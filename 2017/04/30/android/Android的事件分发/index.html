<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="事件分发," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="1. Touch事件和绘制事件的异同之处Touch事件和绘制事件很类似，都是由ViewRoot派发下来的，但是不同之处在绘制事件是由应用中的某个View发起请求，一层一层上传到ViewRoot，再有ViewRoot下发绘制，传递canvas给所有子View让其绘制自身，绘制好后，再通知WMS进行画到屏幕上。而Touch事件是由硬件捕获到触摸后由系统传递给应用的ViewRoot，再由ViewRoot">
<meta name="keywords" content="事件分发">
<meta property="og:type" content="article">
<meta property="og:title" content="Android的事件分发">
<meta property="og:url" content="http://yoursite.com/2017/04/30/android/Android的事件分发/index.html">
<meta property="og:site_name" content="秋过冬漫长">
<meta property="og:description" content="1. Touch事件和绘制事件的异同之处Touch事件和绘制事件很类似，都是由ViewRoot派发下来的，但是不同之处在绘制事件是由应用中的某个View发起请求，一层一层上传到ViewRoot，再有ViewRoot下发绘制，传递canvas给所有子View让其绘制自身，绘制好后，再通知WMS进行画到屏幕上。而Touch事件是由硬件捕获到触摸后由系统传递给应用的ViewRoot，再由ViewRoot">
<meta property="og:image" content="http://img.blog.csdn.net/20170302184158181?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170302184634662?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170302183800394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170302181345556?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170302181357798?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://img.blog.csdn.net/20170302181409595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2017-05-01T07:19:21.394Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android的事件分发">
<meta name="twitter:description" content="1. Touch事件和绘制事件的异同之处Touch事件和绘制事件很类似，都是由ViewRoot派发下来的，但是不同之处在绘制事件是由应用中的某个View发起请求，一层一层上传到ViewRoot，再有ViewRoot下发绘制，传递canvas给所有子View让其绘制自身，绘制好后，再通知WMS进行画到屏幕上。而Touch事件是由硬件捕获到触摸后由系统传递给应用的ViewRoot，再由ViewRoot">
<meta name="twitter:image" content="http://img.blog.csdn.net/20170302184158181?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/30/android/Android的事件分发/"/>





  <title>Android的事件分发 | 秋过冬漫长</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">秋过冬漫长</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">没有比脚更长的路，走过去，前面是个天！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/android/Android的事件分发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋过冬漫长">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android的事件分发
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T23:57:25+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/30/android/Android的事件分发/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/30/android/Android的事件分发/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-Touch事件和绘制事件的异同之处"><a href="#1-Touch事件和绘制事件的异同之处" class="headerlink" title="1. Touch事件和绘制事件的异同之处"></a><strong>1. Touch事件和绘制事件的异同之处</strong></h1><p>Touch事件和绘制事件很类似，都是由ViewRoot派发下来的，但是不同之处在绘制事件是由应用中的某个View发起请求，一层一层上传到ViewRoot，再有ViewRoot下发绘制，传递canvas给所有子View让其绘制自身，绘制好后，再通知WMS进行画到屏幕上。而Touch事件是由硬件捕获到触摸后由系统传递给应用的ViewRoot，再由ViewRoot往下一层一层传递。</p>
<p>他们的处理过程都是自上而下的分发，但是绘制多了一层自下往上的请求。</p>
<p>事件存在消耗，事件的处理方法都会返回一个boolean值，如果该值为true，则本次事件下发将会终止。</p>
<a id="more"></a>
<h1 id="2-MotionEvent"><a href="#2-MotionEvent" class="headerlink" title="2. MotionEvent"></a><strong>2. MotionEvent</strong></h1><h2 id="2-1-MotionEvent对象的产生"><a href="#2-1-MotionEvent对象的产生" class="headerlink" title="2.1 MotionEvent对象的产生"></a><strong>2.1 MotionEvent对象的产生</strong></h2><p>系统有一个线程在循环收集屏幕硬件信息，当用户触摸屏幕时，该线程会把从硬件设备收集到的信息封装成一个MotionEvent对象，然后把该对象存放到一个消息队列中。</p>
<p>系统的另一个线程循环的读取消息队列中的MotionEvent，然后交给WMS去派发，WMS把该事件派发给当前处于活动的Activity，即处于活动栈最顶端的Activity。</p>
<p>这就是一个先进先出的消费者和生产者的模板，一个线程不停的创建MotionEvent对象放入队列中，另一个线程不断的从队列中取出MotionEvent对象进行分发。</p>
<p>当用户的手指从接触屏幕到离开屏幕，是一个完整的触摸事件，在该事件中，系统会不断收集事件信息封装成MotionEvent对象。收集的间隔时间取决于硬件设备，例如屏幕的灵敏度以及cpu的计算能力。目前的手机一般在20毫秒左右。</p>
<p>MotionEventCompat.getActionMasked()</p>
<h2 id="2-2-MotionEvent对象详解"><a href="#2-2-MotionEvent对象详解" class="headerlink" title="2.2 MotionEvent对象详解"></a><strong>2.2 MotionEvent对象详解</strong></h2><p>MotionEvent对象包含了触摸事件的时间、位置、面积、压力、以及本次事件的Dwon发生的时间。</p>
<p>MotionEvent常用的Action分为5种：Down 、Up、Move、Cancel、OutSide</p>
<p>MotionEvent中我们常用的方法就是获取点击的坐标，因为这是与我们操作息息相关的。获取坐标有两种方式：</p>
<ul>
<li>getX和getY用于获取以该View左上角为坐标原点的坐标</li>
<li>getRowX和getRowY用于获取以屏幕左上角为坐标原点的坐标</li>
</ul>
<h2 id="2-3-5种Touch事件"><a href="#2-3-5种Touch事件" class="headerlink" title="2.3 5种Touch事件"></a><strong>2.3 5种Touch事件</strong></h2><ul>
<li>Down：一次触摸事件的第一个MotionEvent对象，即手指初次接触屏幕。</li>
<li>Up：通常为一次触摸事件的最后一个MotionEvent对象，即手指离开屏幕。</li>
<li>Move：通常多次发生在一次触摸事件之中。表示触摸点发生了移动，我们通常把手指放到屏幕上，实际也会触发该事件，因为人手总是在轻微抖动的。</li>
<li>Cancel：常用于取消某个触摸事件，一般是由程序逻辑来指定该事件，用于取消某次触摸事件。</li>
<li>OutSide：当触摸点发生在响应事件的View之外时，传递的事件，通常由程序逻辑来指定。</li>
</ul>
<p>在上面5种事件中，Down为最重要的事件，因为这是一个触摸事件的起始点，程序的很多逻辑判断，都需要根据该事件做处理，例如分发拦截。一次触摸事件必须要有Down事件，这也是MotionEvent对象中都包含了本次触摸事件的Down事件发生的时间点这个属性。其次是Move和Up，通过这3个事件的逻辑处理，就构建出来滑动，点击，长按，双击等多种效果。</p>
<h2 id="2-4-创建一个MotionEvent对象"><a href="#2-4-创建一个MotionEvent对象" class="headerlink" title="2.4 创建一个MotionEvent对象"></a><strong>2.4 创建一个MotionEvent对象</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MotionEvent <span class="title">obtain</span><span class="params">(</span></span></div><div class="line">        <span class="keyword">long</span> downTime,    //当用户最初按下开始一连串的位置事件。这必须得到SystemClock.uptimeMillis()</div><div class="line">        <span class="keyword">long</span> eventTime,   <span class="comment">//当这个特定的事件是生成的。这必须得到SystemClock.uptimeMillis()            </span></div><div class="line">        <span class="keyword">int</span> action,       <span class="comment">//该次事件的Action                       </span></div><div class="line">        <span class="keyword">float</span> x,          <span class="comment">//该次事件的x坐标        </span></div><div class="line">        <span class="keyword">float</span> y,          <span class="comment">//该次事件的y坐标         </span></div><div class="line">        <span class="keyword">float</span> pressure,   <span class="comment">//该次事件的压力，通常感觉标准压力，从0-1取值     </span></div><div class="line">        <span class="keyword">float</span> size,       <span class="comment">//点击的区域大小，通常根据特定标准范围从0-1取值     </span></div><div class="line">        <span class="keyword">int</span> metaState,    <span class="comment">//一个修饰性的状态，好像一直都是0          </span></div><div class="line">        <span class="keyword">float</span> xPrecision, <span class="comment">//x坐标的精确度           </span></div><div class="line">        <span class="keyword">float</span> yPrecision, <span class="comment">//y坐标的精确度                   </span></div><div class="line">        <span class="keyword">int</span> deviceId,     <span class="comment">//触屏设备id，如果是0，说明这个事件不是来自物理设备      </span></div><div class="line">        <span class="keyword">int</span> edgeFlags     <span class="comment">//系统默认都是返回0，程序在传递时，可以通过逻辑判断加入方向位置 </span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>或者一个更简单的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MotionEvent <span class="title">obtain</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">long</span> downTime,</div><div class="line">            <span class="keyword">long</span> eventTime,</div><div class="line">            <span class="keyword">int</span> action,</div><div class="line">            <span class="keyword">float</span> x,</div><div class="line">            <span class="keyword">float</span> y,</div><div class="line">            <span class="keyword">int</span> metaState)</div></pre></td></tr></table></figure>
<p>也可以通过一个MotionEvent来创建一个新的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MotionEvent <span class="title">obtain</span><span class="params">(MotionEvent event)</span></span></div></pre></td></tr></table></figure>
<p>通过以上的方式，我们知道，我们也可以通过代码来构建一个虚假的MotionEvent，并分发下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">view.dispatchTouchEvent(</div><div class="line">            MotionEvent.obtain(SystemClock.uptimeMillis(),</div><div class="line">            SystemClock.uptimeMillis(),</div><div class="line">            MotionEvent.ACTION_DOWN,<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>));</div></pre></td></tr></table></figure>
<p>然后通过延迟以此往下派发Move和Up时间，形成一个完整的触摸操作。</p>
<h1 id="3-dispatchTouchEvent触摸事件分发"><a href="#3-dispatchTouchEvent触摸事件分发" class="headerlink" title="3. dispatchTouchEvent触摸事件分发"></a><strong>3. dispatchTouchEvent触摸事件分发</strong></h1><p><img src="http://img.blog.csdn.net/20170302184158181?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>之前我们知道触摸事件是被包装成MotionEvent进行传递的，而该对象是继承了Parcelable接口，正因为如此，才可以从系统中传递到我们的应用中。系统通过跨进程通知ViewRoot，ViewRoot会调用DecorView的dispatchTouchEvent下发。</p>
<p>这里有一个和其他事件传递不同的地方，DecorView会优先传递给Activity，而不是它的子View。而Activity如果不处理又会回传给DecorView，DecorView才会再将事件传给子View。</p>
<p>dispatchTouchEvent就是触摸事件传递的对外接口，无论是DecorView传给Activity，还是ViewGroup传递给子View，都是直接调用对方的dispatchTouchEvent方法，并传递MotionEvent参数。</p>
<p>我们首先来看看Activity中的dispatchTouchEvent逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        onUserInteraction();</div><div class="line">        <span class="comment">//这是一个空实现的方法，以便子类实现，该方法在Key事件和touch事件的dispatch方法中都被调用，</span></div><div class="line">        <span class="comment">// 就是方便用户在事件被传递之前做一下自己的处理。</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这才是事件真正的分发</span></div><div class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">        <span class="comment">//superDispatchTouchEvent是一个抽象方法，但是getWindow()获取的对象实际是FrameWork层的</span></div><div class="line">        <span class="comment">// PhoneWindow，该对象实现了这个方法，内部是直接调用DecorView的superDispatchTouchEvent</span></div><div class="line">        <span class="comment">// 是直接调用dispatchTouchEvent，这样就传递到子View中了   </span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果上面事件没有被消费掉，那么就调用Activity的onTouchEvent事件。</span></div><div class="line">    <span class="keyword">return</span> onTouchEvent(ev);</div><div class="line">&#125;</div><div class="line"><span class="comment">//PhoneWindow的superDispatchTouchEvent方法直接调用了mDecor的superDispatchTouchEvent</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line">&#125;</div><div class="line"><span class="comment">//mDecor即为Activity真正的根View，我们通过setContentView所添加的内容就是添加在该View上，</span></div><div class="line"><span class="comment">// 它实际上就是一个FrameLayout</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);<span class="comment">//FrameLayout.dispatchTouchEvent</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此我们已经至少明白了以下几点：</p>
<p>1、我们可以重载Activity的onUserInteraction方法，在Down事件触发传递前，实现我们的一些需求，实际上源码中有很多这样的方法，再某个方法体的第一行提供一个空实现的回调方法，在某个方法的最后一行提供一个空实现的回调方法，以便子类去实现自己的逻辑，例如AsyncTask就有类似的方式。这些技巧都能很好的提高我们代码的扩展性。</p>
<p>2、Activity会间接的调用根View的dispatchTouchEvent，并通过if判断返回值，如果为true，即向上层返回true，也就是调用Activity的dispatchTouchEvent的WMS，即操作系统。</p>
<p>3、如果if判断为false，即根View和根View下的所有子View均为消费掉该事件，那么下面的代码就有执行机会，即Activity的onTouchEvent，并把该方法的返回值作为结果返回给上层。</p>
<h2 id="3-1-View的dispatchTouchEvent"><a href="#3-1-View的dispatchTouchEvent" class="headerlink" title="3.1 View的dispatchTouchEvent"></a><strong>3.1 View的dispatchTouchEvent</strong></h2><p><img src="http://img.blog.csdn.net/20170302184634662?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>View中的处理相当简单明了，因为不涉及到子View，所以只在自身内部进行分发。首先判断是否设置了触摸监听，并且可以响应事件，就交由监听的onTouch处理。如果上述条件不成立，或者监听的onTouch事件没有消费掉该事件，则交由onTouchEvent进行处理，并把返回结果交给上层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;</div><div class="line">            mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">        <span class="comment">//判断mOnTouchListener是否存在，并且控件可点的情况下，执行onTouch，如果onTouch返回true，就消耗该事件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果以上条件都不成立，则把事件交给onTouchEvent来处理</span></div><div class="line">    <span class="keyword">return</span> onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-2-ViewGroup的dispatchTouchEvent"><a href="#3-2-ViewGroup的dispatchTouchEvent" class="headerlink" title="3.2 ViewGroup的dispatchTouchEvent"></a><strong>3.2 ViewGroup的dispatchTouchEvent</strong></h2><p><img src="http://img.blog.csdn.net/20170302183800394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="3-3-Down事件"><a href="#3-3-Down事件" class="headerlink" title="3.3 Down事件"></a>3.3 Down事件</h2><ul>
<li>通过onInterceptTouchEvent方法判断是否要拦截事件，默认fasle</li>
<li>根据scroll换算后的坐标找出所接受的子View。有动画的子View将不接受触摸事件。</li>
<li>找到能接受的子View后把event中的坐标转换成子View的坐标</li>
<li>调用子View的dispatchTouchEvent把事件传递给子View。</li>
<li>如果子View消费了该事件，则把target记录为子View，方便后面的Move和Up事件的传递。</li>
<li>如果子View没有消费，则继续寻找下一个子View。</li>
<li>如果没找到，或者找到的子View都不消费，就会调用View的dispatchTouchEvent的逻辑，也就是判断是否有触摸监听，有的话交给监听的onTouch处理，没有的话交给自己的onTouchEvent处理</li>
</ul>
<p>接下来我们来研究ViewGroup的dispatchTouchEvent，这是稍微复杂的分发逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();<span class="comment">//获取事件</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> xf = ev.getX();<span class="comment">//获取触摸坐标</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> yf = ev.getY();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scrolledXFloat = xf + mScrollX;<span class="comment">//获取当前需要偏移的偏移量量</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scrolledYFloat = yf + mScrollY;</div><div class="line">    <span class="keyword">final</span> Rect frame = mTempRect;    <span class="comment">//当前ViewGroup的视图矩阵</span></div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;<span class="comment">//是否禁止拦截</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;<span class="comment">//如果事件是按下事件</span></div><div class="line">        <span class="keyword">if</span> (mMotionTarget != <span class="keyword">null</span>) &#123;    <span class="comment">//判断接受事件的target是否为空</span></div><div class="line">            <span class="comment">//不为空肯定是不正常的，因为一个事件是由DOWN开始的，而DOWN还没有被消费，所以目标也不是不可能被确定，</span></div><div class="line">            <span class="comment">//造成这个的原因可能是在上一次up事件或者cancel事件的时候，没有把目标赋值为空</span></div><div class="line">            mMotionTarget = <span class="keyword">null</span>;    <span class="comment">//在此处挽救</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//不允许拦截，或者onInterceptTouchEvent返回false，也就是不拦截。注意，这个判断都是在DOWN事件中判断</span></div><div class="line">        <span class="keyword">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;</div><div class="line">            <span class="comment">//从新设置一下事件为DOWN事件，其实没有必要，这只是一种保护错误，防止被篡改了</span></div><div class="line">            ev.setAction(MotionEvent.ACTION_DOWN);</div><div class="line">            <span class="comment">//开始寻找能响应该事件的子View</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrolledXInt = (<span class="keyword">int</span>) scrolledXFloat;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrolledYInt = (<span class="keyword">int</span>) scrolledYFloat;</div><div class="line">            <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                <span class="keyword">final</span> View child = children[i];</div><div class="line">                <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE</div><div class="line">                        || child.getAnimation() != <span class="keyword">null</span>) &#123;<span class="comment">//如果child可见，或者有动画，获取该child的矩阵</span></div><div class="line">                    child.getHitRect(frame);</div><div class="line">                    <span class="keyword">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;</div><div class="line">                        <span class="comment">// 设置系统坐标</span></div><div class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - child.mLeft;</div><div class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - child.mTop;</div><div class="line">                        ev.setLocation(xc, yc);</div><div class="line">                        <span class="keyword">if</span> (child.dispatchTouchEvent(ev))  &#123;<span class="comment">//调用child的dispatchTouchEvent</span></div><div class="line">                            <span class="comment">//如果消费了，目标就确定了，以便接下来的事件都传递给child</span></div><div class="line">                            mMotionTarget = child;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//事件消费了，返回true</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//能到这里来，证明所有的子View都没消费掉Down事件，那么留给下面的逻辑进行处理</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断是不是up或者cancel事件</span></div><div class="line">    <span class="keyword">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||</div><div class="line">            (action == MotionEvent.ACTION_CANCEL);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isUpOrCancel) &#123;</div><div class="line">        <span class="comment">//如果是取消，把禁止拦截这个标志位给取消</span></div><div class="line">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">final</span> View target = mMotionTarget;</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//判断该值是否为空，如果为空，则没找到能响应的子View，那么直接调用super的dispatchTouchEvent，也就是View的dispatchTouchEvent</span></div><div class="line">        ev.setLocation(xf, yf);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//能走到这里来，说明已经有target，那也说明，这里不是DOWN事件，因为DOWN事件如果有target，已经在前面返回了，执行不到这里</span></div><div class="line">    <span class="keyword">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;<span class="comment">//如果有目标，又非要拦截，则给目标发送一个cancel事件</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - (<span class="keyword">float</span>) target.mLeft;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - (<span class="keyword">float</span>) target.mTop;</div><div class="line">        ev.setAction(MotionEvent.ACTION_CANCEL);<span class="comment">//该为cancel</span></div><div class="line">        ev.setLocation(xc, yc);</div><div class="line">        <span class="keyword">if</span> (!target.dispatchTouchEvent(ev)) &#123;</div><div class="line">            <span class="comment">//调用子View的dispatchTouchEvent，就算它没有消费这个cancel事件，我们也无能为力了。</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//清除目标</span></div><div class="line">        mMotionTarget = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//有目标，又拦截，自身也享受不了了，因为一个事件应该由一个View去完成</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//直接返回true，以完成这次事件，好让系统开始派发下一次</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isUpOrCancel) &#123;<span class="comment">//取消或者UP的话，把目标赋值为空，以便下一次DOWN能重新找，此处就算不赋值，下一次DOWN也会先把它赋值为空</span></div><div class="line">        mMotionTarget = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//又不拦截，又有目标，那么就直接调用目标的dispatchTouchEvent</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - (<span class="keyword">float</span>) target.mLeft;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - (<span class="keyword">float</span>) target.mTop;</div><div class="line">    ev.setLocation(xc, yc);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> target.dispatchTouchEvent(ev);</div><div class="line">    <span class="comment">//也就是说，如果是DOWN事件，拦截了，那么每次一次MOVE或者UP都不会再判断是否拦截，直接调用super的dispatchTouchEvent</span></div><div class="line">    <span class="comment">//如果DOWN没拦截，就是有其他View处理了DOWN事件，那么接下来的MOVE或者UP事件拦截了，那么给目标View发送一个cancel事件，告诉它touch被取消了，并且自身也不会处理，直接返回true</span></div><div class="line">    <span class="comment">//这是为了不违背一个Touch事件只能由一个View处理的原则。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-4-Move和Up事件"><a href="#3-4-Move和Up事件" class="headerlink" title="3.4 Move和Up事件"></a>3.4 Move和Up事件</h2><p>判断事件是否被取消或者事件是否要拦截住，是的话，给Down事件找到的target发送一个取消事件。如果不取消，也不拦截，并且Down已经找到了target，则直接交给target处理，不再遍历子View寻找合适的View了。这种处理事件是正确的，我们用手机经常可以体会到，当我手指按在一个拖动条上之后，在拖动的时候手指就算移出了拖动条，依然会把事件分发给拖动条控制它的拖动。</p>
<h1 id="4-onInterceptTouchEvent"><a href="#4-onInterceptTouchEvent" class="headerlink" title="4. onInterceptTouchEvent"></a><strong>4. onInterceptTouchEvent</strong></h1><p>ViewGroup的方法，事件拦截，return true表示拦截触摸事件，事件就不往下传递</p>
<p>子View可以调用getParent().requestDisallowInterceptTouchEvent( true ) 请求父控件不拦截touch事件</p>
<h1 id="5-View的onTouchEvent"><a href="#5-View的onTouchEvent" class="headerlink" title="5. View的onTouchEvent"></a><strong>5. View的onTouchEvent</strong></h1><p>从View的dispatchTouchEvent可以看出，事件最终的处理无非是交给TouchListener的onTouch方法或者是交由onTouchEvent处理，由于onTouch默认是空实现，由程序员来编写逻辑，那么我们来看看onTouchEvent事件。View只能响应click和longclick，不具备滑动等特性。</p>
<p>Down时，设置按压状态，发送一个延迟500毫秒的长按事件。<br>Move时，判断是否移出了View，移出后移除按压状态，长按事件。<br>Up时，取消按压，并判断它是否可以通过触摸获取焦点，是的话设置焦点，判断长按事件是否执行了，如果还没执行，就删除，并执行点击事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">    <span class="comment">//先判断标示位是否为disable，也就是无法处理事件。</span></div><div class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">            setPressed(<span class="keyword">false</span>);</div><div class="line">        &#125;<span class="comment">//如果是UP事件，并且状态为按压，取消按压。</span></div><div class="line">        <span class="comment">//系统源码解释：虽然是disable，但是还是可以消费掉触摸事件，只是不触发任何click或者longclick事件。</span></div><div class="line">        <span class="comment">//根据是否可点击,可长按来决定是否消费点击事件。</span></div><div class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//先检查触摸的代理对象是否存在，如果存在，就交由代理对象处理。</span></div><div class="line">        <span class="comment">// 触摸代理对象是可以进行设置的，一般用于当我们手指在某个View上，而让另外一个View响应事件，另外一个View就是该View的事件代理对象。</span></div><div class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;<span class="comment">//如果代理对象消费了，则返回true消费该事件</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class="line">        <span class="comment">//如果是可点击或者长按的标识位执行下面的逻辑，这些标志位可以设置，也可以设置了对应的listener后自动添加</span></div><div class="line">        <span class="comment">//因为作为一个View，它只能单纯的接受处理点击事件，像滑动之类的复杂事件普通View是不具备的。</span></div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:<span class="comment">//处理Up事件</span></div><div class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;<span class="comment">//是否包含临时按压状态</span></div><div class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;<span class="comment">//如果本身处于被按压状态或者临时按压状态</span></div><div class="line">                    <span class="comment">//临时按压状态会在下面的Move事件中说明</span></div><div class="line">                    <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                        <span class="comment">//如果它可以获取焦点，并且可以通过触摸来获取焦点，并且现在不是焦点，则请求获取焦点，因为一个被按压的View理论上应该获取焦点</span></div><div class="line">                        focusTaken = requestFocus();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                        <span class="comment">//如果是临时按压，则设置为按压状态，PFLAG_PREPRESSED是一个非常短暂的状态，用于在某些时候短时间内表示Pressed状态，但不需要绘制</span></div><div class="line">                        setPressed(<span class="keyword">true</span>);<span class="comment">//设置为按压状态，是因为临时按压不会绘制，这个时候强制绘制一次，确保用户能够看见按压状态</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</div><div class="line">                        <span class="comment">//是否执行了长按事件，还没有的话，这个时候可以移除长按的回调了，因为UP都已经触发，说明从按下到UP的时间不足以触发longPress</span></div><div class="line">                        <span class="comment">//至于longPress，会在Down事件中说明</span></div><div class="line">                        removeLongPressCallback();</div><div class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;<span class="comment">//如果是焦点状态，就不会触摸click，这是为什么呢？因为焦点状态一般是交给按键处理的，</span></div><div class="line">                            <span class="comment">//pressed状态才是交给触摸处理，如果它是焦点，那么它的click事件应该由按键来触发</span></div><div class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;    <span class="comment">//封装一个Runnable对象，这个对象中实际就调用了performClick();</span></div><div class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;<span class="comment">//向消息队列发生该runnabel，如果发送不成功，则直接执行该方法。</span></div><div class="line">                                performClick();<span class="comment">//这个方法内部会调用clickListner</span></div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">//为什么不直接执行呢？如果这个时候直接执行，UP事件还没执行完，发送post，可以保障在这个代码块执行完毕之后才执行</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;<span class="comment">//仍旧是创建一个Runnabel对象，执行setPressed(false)</span></div><div class="line">                        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                        <span class="comment">//如果是临时按压状态，之前的Down和move都还未触发按压状态，只在up时设置了，这个状态才刚刚绘制，为了保证用户能看到，发生一个64秒的延迟消息，来取消按压状态。                        postDelayed(mUnsetPressedState,</span></div><div class="line">                        ViewConfiguration.getPressedStateDuration());</div><div class="line">                        <span class="comment">//这是一个64毫秒的短暂时间，这是为了让这个按压状态持续一小段时间，以便手指离开时候，还能看见View的按压状态</span></div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;<span class="comment">//如果不是临时按压，则直接发送，发送失败，则直接执行</span></div><div class="line">                        mUnsetPressedState.run();</div><div class="line">                    &#125;</div><div class="line">                    removeTapCallback();</div><div class="line">                    <span class="comment">//移除这个callBack，这个callBack内部就是把临时按压状态设置成按压状态，因为这个已经没必要了，手指已经up了</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line">                <span class="comment">//按下事件把长按事件执行的变量设置为false，代表还没执行长按，因为才按下，表示新的一个长按事件可以开始计算了</span></div><div class="line">                <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                    <span class="comment">//先把这个事件交由该方法，该方法内部会判断是否为上下文的菜单按钮，或者是否为鼠标右键，如果是就弹出上下文菜单。</span></div><div class="line">                    <span class="comment">//现在有些手机的上下文菜单按钮也是在屏幕触屏上的</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//这个方法会一直往上找父View，判断自身是否在一个可以滚动的容器中</span></div><div class="line">                <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class="line">                <span class="comment">//如果是在一个滚动的容器中，那么按压事件将会被推迟一段时间，如果这段时间内，发生了Move，那么按压状态讲不会被显示，直接滚动父视图</span></div><div class="line">                <span class="keyword">if</span> (isInScrollingContainer) &#123;</div><div class="line">                    mPrivateFlags |= PFLAG_PREPRESSED; <span class="comment">//先添加临时的按压状态，该状态表示按压，但不会绘制</span></div><div class="line">                    <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</div><div class="line">                        mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</div><div class="line">                        <span class="comment">//创建一个runnable对象，这个runnable内部会取消临时按压状态，设置为按压状态，并启动长按的延迟事件</span></div><div class="line">                    &#125;</div><div class="line">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">                    <span class="comment">//向消息机制发生一个64毫秒的延迟时间，该事件会取消临时按压状态，设置为直接按压，并启动长按时间的计时</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//如果不在一个滚动的容器中，则直接设置按压状态，并启动长按计时</span></div><div class="line">                    setPressed(<span class="keyword">true</span>);</div><div class="line">                    checkForLongClick(<span class="number">0</span>);</div><div class="line">                    <span class="comment">//长按事件就是向消息机制发送一个runnable对象，封装的就是我们在lisner中的代码，延迟500毫秒执行，也就是说长按事件在我们按下的时候发送，在up的时候检查一下执行了吗？如果没执行，就取消，并执行click</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: <span class="comment">//如果是取消事件，那就好办了，把我们之前发送的几个延迟runnable对象给取消掉</span></div><div class="line">                setPressed(<span class="keyword">false</span>);      <span class="comment">//设置为非按压状态</span></div><div class="line">                removeTapCallback();    <span class="comment">//取消mPendingCheckForTap，也就是不用再把临时按压设置为按压了</span></div><div class="line">                removeLongPressCallback();    <span class="comment">//取消长按事件的延迟回调</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:    <span class="comment">//move事件</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();    <span class="comment">//取触摸点坐标</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</div><div class="line">                <span class="comment">// 用于判断是否在View中，为什么还要判断呢？</span></div><div class="line">                <span class="comment">//这是因为父View是在Down事件中判断是否在该View中的，如果在，以后的Move和up都会传递过来，不再进行范围判断</span></div><div class="line">                <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                    <span class="comment">//mTouchSlop是一个常量，数值为8,也就是说，就算你的落点超出了View的8像素位置，也算在View中。</span></div><div class="line">                    <span class="comment">//是因为人的手指触摸点比较大，有可能你感觉点在某个控件的边缘，但是实际落点已经超出这个View，所以这里给了8像素的范围</span></div><div class="line">                    removeTapCallback();<span class="comment">//如果在范围外，就移除这些runnable回调</span></div><div class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">//如果是按压状态，就取消长按，设置为非按压状态，为什么这个时候取消呢，因为在Down的时候，我们可以知道，只有是按压状态，才会设置长按</span></div><div class="line">                        removeLongPressCallback();</div><div class="line">                        setPressed(<span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//至此，可以返回true，消费该事件</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;    <span class="comment">//如果不可点击，也不可长按，则返回false，因为View只具备消费点击事件</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码我们总结一下View对触摸事件的处理：</p>
<p>1、是否为diabale，如果是，直接根据是否设置了click和longclick来返回。<br>2、是否设置了触摸代理对象，如果有，把事件传递给触摸代理对象，交由其处理，如果消费了，直接返回<br>3、是否为click或者longclick的，如果是，返回true，不是返回false。</p>
<p>而View对click和longclick的处理如下：</p>
<p>Down：</p>
<ul>
<li>判断是否可以触摸上下文菜单。</li>
<li>是否在可以滑动的容器中，如果是先设置临时按压，再发送一个延迟消息把临时按压改为按压，并发送一个延迟500毫秒的事件去执行长按代码</li>
<li>如果不在滚动容器中，直接设置按压状态，并发送一个延迟500毫秒的事件去执行长按代码。</li>
</ul>
<p>Move：</p>
<ul>
<li>取触摸点坐标判断是否在View中（额外增加了8像素的范围）</li>
<li>如果在，不用做任何事。</li>
<li>如果不在，取消临时按压到按压回调，取消长按延迟回调，设置为非按压状态</li>
</ul>
<p>Up</p>
<ul>
<li>判断是否为按压或者临时按压状态</li>
<li>如果不是，不做任何处理</li>
<li>如果是先判断其是否可以获取焦点，然后请求焦点。</li>
<li>如果是临时按压状态，设置临时按压状态为按压状态。保证界面被绘制成按压状态，让用户可以看见。</li>
<li>如果长按回调还未触发，取消长按回调，如果不是焦点状态，触发click事件。</li>
<li>如果是临时按压状态，发送一个延迟取消按压状态的，保证按压状态持续一段时间，让用户可见。</li>
<li>如果不是临时按压状态，直接发送消息取消按压状态。发送失败，直接取消按压状态。</li>
<li>取消把临时按压设置按压的回调。</li>
</ul>
<p>从中我们知道View的onTouchEvent主要处理了click和longclick事件，当按下时，向消息机制发送一个延迟500毫秒的长按回调事件，当移动时候判断是否移出了View的范围，超出则取消事件。当离开时，判断长按事件是否触发了，如果没触发且不是焦点，就触发click事件。</p>
<p>在这里最绕的就是临时按压和按压状态，临时按压是为了处理滑动容器的，让处于滑动容器中，按下时，我们先设置的是临时按压，持续64毫秒，是为了判断接下来的时间内是否发生了move事件，如果发生了，将不会再出发按压状态，这样不会让用户看到listView滚动时，item还处于按压状态。在离开时，我们再次判断是否处于临时按压，如果是在64毫秒内触发了down和up，说明按压状态还没来得急绘制，则强制设置为按压状态，保证用户能看到，并在取消回调的方法上加上64毫秒的延迟</p>
<h1 id="6-onTouch与onClick"><a href="#6-onTouch与onClick" class="headerlink" title="6. onTouch与onClick"></a><strong>6. onTouch与onClick</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ImageView iv_image = (ImageView) findViewById(R.id.iv_image);</div><div class="line">iv_image.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>点击ImageView的时候只会打印一次，因为onTouch()返回false，只传递down事件，不会传递up事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out: iv_image---onTouch--0</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ImageView天生不能被点击，没有点击事件</span></div><div class="line">ImageView iv_image = (ImageView) findViewById(R.id.iv_image);</div><div class="line">iv_image.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 把返回值改为true </span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>把onTouch()方法返回值改为true，点击ImageView会打印两次（down and up）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out: iv_image---onTouch--0</div><div class="line">System.out: iv_image---onTouch--1</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ImageView iv_image = (ImageView) findViewById(R.id.iv_image);</div><div class="line">iv_image.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//添加click事件</span></div><div class="line">iv_image.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onClick"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>还是打印两次，onTouch()返回true，click事件并不会得到执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ImageView iv_image = (ImageView) findViewById(R.id.iv_image);</div><div class="line">iv_image.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">iv_image.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onClick"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>打印三次，两次touch事件（down and up）和一次click事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"button---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>点击Button会打印两次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"button---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"button---onClick"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>打印两次，因为onTouch()返回true，不会执行onTouchEvent()，而click事件是在onTouchEvent()中执行，所以也不会执行click事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"button---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"button---onClick"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>打印三次<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;</div><div class="line">            mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>a 判断mOnTouchListener是否为null<br>b 判断当前的控件是否可用<br>c 判断view的onTouch。<br>d 如果以上一个返回为false。那么就会调用onTouchEvent</p>
<p>首先判断mOnTouchListener不为null，并且view是enable的状态，然后 mOnTouchListener.onTouch(this, event)返回true，这三个条件如果都满足，直接return true ; 也就是下面的onTouchEvent(event）不会被执行了。如果我们设置了setOnTouchListener，并且return true，那么View自己的onTouchEvent就不会被执行了</p>
<p>onTouch是优先于onClick执行, onClick的调用在onTouchEvent(event)方法中</p>
<p>view的事件分发</p>
<ol>
<li>返回true，说明可以响应down事件和up事件</li>
<li>返回false，只会响应down事件。不会响应up事件。在down事件如果能消费(处理)当前事件。那么在up的时候也会把事件传递给当前的view，在down事件处理不了当前事件。那么在up的时候。也不会把事件传递给当前的view</li>
</ol>
<p>模拟点击事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createClick</span><span class="params">(<span class="keyword">final</span> View v)</span> </span>&#123;</div><div class="line">	<span class="number">08</span>-<span class="number">23</span> <span class="number">03</span>:<span class="number">22</span>:<span class="number">35.028</span>: I/System.out(<span class="number">1652</span>): x轴坐标---<span class="number">151.0</span>--y轴坐标---<span class="number">218.0</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">151</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> y = <span class="number">218</span>;</div><div class="line">	<span class="keyword">long</span> downTime = System.currentTimeMillis();</div><div class="line">	MotionEvent motionEventDown = MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_DOWN, x, y, <span class="number">0</span>);</div><div class="line">	v.dispatchTouchEvent(motionEventDown);</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">long</span> upTime = System.currentTimeMillis();</div><div class="line">			MotionEvent motionEventUp = MotionEvent.obtain(upTime, upTime, MotionEvent.ACTION_UP, x, y, <span class="number">0</span>);</div><div class="line">			v.dispatchTouchEvent(motionEventUp);</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">	&#125;, <span class="number">200</span>);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://blog.csdn.net/axi295309066/article/details/60139074" target="_blank" rel="external">Android的事件分发实例分析</a></p>
<h1 id="7-ScrollView的onTouchEvent"><a href="#7-ScrollView的onTouchEvent" class="headerlink" title="7. ScrollView的onTouchEvent"></a><strong>7. ScrollView的onTouchEvent</strong></h1><p>普通的ViewGroup并没有对onTouchEvent事件做处理，只有可以滚动的才有，我们可以分析一下ScrollView</p>
<ul>
<li><p>Down时，判断落点是否在子View中，不再就不处理，因为ScrollView只有一个子View。</p>
</li>
<li><p>Move时，通过对比本次手指的位置和上一次的位置的距离，计算出Y方向的差值，然后用scorllBy进行滚动视图</p>
</li>
<li><p>Up时，通过速度进行fling，这里利用了两个帮助类，一个是计算速度的帮助类VelocityTracker，一个是滚动的帮助类Scroller</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.getEdgeFlags() != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//如果是down事件，并且触摸到边缘，就不处理EdgeFlags代表是否为边缘，其值是1/2/4/8。代表上下左右</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//这是一个追踪触摸事件，并计算速度的帮助类，实现原理就是用三个数组分别记录每次触摸的x/y和时间</span></div><div class="line">        mVelocityTracker = VelocityTracker.obtain();</div><div class="line">    &#125;</div><div class="line">    mVelocityTracker.addMovement(ev);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</div><div class="line">    <span class="keyword">switch</span> (action &amp; MotionEvent.ACTION_MASK) &#123;<span class="comment">//与上ff，去掉高位有关多点的信息</span></div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;<span class="comment">//如果是down</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();<span class="comment">//获取y坐标</span></div><div class="line">            <span class="keyword">if</span> (!(mIsBeingDragged = inChild((<span class="keyword">int</span>) ev.getX(), (<span class="keyword">int</span>) y))) &#123;<span class="comment">//判断是否开始拖动</span></div><div class="line">                <span class="comment">//原理就是判断落点是否在child中，ScrollView只能由一个child，如果在，返回true，反之false</span></div><div class="line">                <span class="comment">//也就是说落点在child中，就是准备开始拖动，不在，就直接返回，这可能是因为设置了padding之类的缘故造成的</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!mScroller.isFinished()) &#123;<span class="comment">//判断滚动是否完成</span></div><div class="line">                mScroller.abortAnimation();<span class="comment">//如果没完成，停止滚动</span></div><div class="line">                <span class="comment">//对应上一次用户手指离开时候处理fling状态，这次按下手指，直接停止滚动</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//记录y坐标，以便下次事件来对比</span></div><div class="line">            mLastMotionY = y;</div><div class="line">            mActivePointerId = ev.getPointerId(<span class="number">0</span>);<span class="comment">//记住多点的id，下次取值时只取该点的</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">            <span class="keyword">if</span> (mIsBeingDragged) &#123;<span class="comment">//可以看出，如果down的时候落点在child外，则以后就算滑进了child也不处理</span></div><div class="line">                <span class="comment">//根据上次记录的多点id，找到对应的点，取y值</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> activePointerIndex = ev.findPointerIndex(mActivePointerId);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(activePointerIndex);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> deltaY = (<span class="keyword">int</span>) (mLastMotionY - y);<span class="comment">//计算位移</span></div><div class="line">                mLastMotionY = y;<span class="comment">//重新记录y值</span></div><div class="line">                scrollBy(<span class="number">0</span>, deltaY);<span class="comment">//滚动指定的距离，这也说明了ScrollView只具备纵向滑动</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">            <span class="keyword">if</span> (mIsBeingDragged) &#123;<span class="comment">//如果是离开事件</span></div><div class="line">                <span class="keyword">final</span> VelocityTracker velocityTracker = mVelocityTracker;</div><div class="line">                velocityTracker.computeCurrentVelocity(<span class="number">1000</span>, mMaximumVelocity);<span class="comment">//计算最后1秒钟内的速度，并给定一个最大速度进行限制</span></div><div class="line">                <span class="comment">//这个最大速度是根据屏幕密度不同而不同的，所以大家也没事别使劲滑动屏幕，因为有这个最大速度限制</span></div><div class="line">                <span class="comment">//获取y方向的速度</span></div><div class="line">                <span class="keyword">int</span> initialVelocity = (<span class="keyword">int</span>) velocityTracker.getYVelocity(mActivePointerId);</div><div class="line">                <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span> &amp;&amp; Math.abs(initialVelocity) &gt; mMinimumVelocity) &#123;</div><div class="line">                    <span class="comment">//如果有子View，并且计算出来的y的速度比最小速度要大，执行fling状态</span></div><div class="line">                    <span class="comment">//手指滑动的方向和屏幕移动的方向是相反的，所以这里加-</span></div><div class="line">                    fling(-initialVelocity);</div><div class="line">                &#125;</div><div class="line">                mActivePointerId = INVALID_POINTER;<span class="comment">//给mActivePointerId重新赋值为-1，防止下次事件找到了错误的点</span></div><div class="line">                mIsBeingDragged = <span class="keyword">false</span>;<span class="comment">//恢复默认值</span></div><div class="line">                <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;<span class="comment">//清空速度计算帮助类</span></div><div class="line">                    mVelocityTracker.recycle();</div><div class="line">                    mVelocityTracker = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">            <span class="keyword">if</span> (mIsBeingDragged &amp;&amp; getChildCount() &gt; <span class="number">0</span>) &#123;<span class="comment">//判断条件，只有这2个条件成立，才会发生滚动事件，下面的值才会被改变，才需要恢复默认</span></div><div class="line">                mActivePointerId = INVALID_POINTER;</div><div class="line">                mIsBeingDragged = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;</div><div class="line">                    mVelocityTracker.recycle();</div><div class="line">                    mVelocityTracker = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_UP:<span class="comment">//多点触摸时，不是最后一个点离开</span></div><div class="line">            onSecondaryPointerUp(ev);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//用于应对先按下1点，然后按下2点，1点离开后，2点仍能继续滑动的逻辑</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onSecondaryPointerUp</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;</div><div class="line">            MotionEvent.ACTION_POINTER_INDEX_SHIFT;<span class="comment">//首先对高位进行与操作，然后右移8位，获取其高位代表index的值</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(pointerIndex);<span class="comment">//取出该点的id</span></div><div class="line">    <span class="keyword">if</span> (pointerId == mActivePointerId) &#123;<span class="comment">//如果这个id对应的就是第一个按下的点</span></div><div class="line">        <span class="comment">//理论上pointerIndex应该是0，所以用第二个按下的点，即1index的点代替</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newPointerIndex = pointerIndex == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">        mLastMotionY = ev.getY(newPointerIndex);<span class="comment">//取出新点的y坐标</span></div><div class="line">        mActivePointerId = ev.getPointerId(newPointerIndex);<span class="comment">//记录新点的id</span></div><div class="line">        <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;<span class="comment">//清空之前存入的MotionEvent，也就是说最后的速度只计算该点产生的</span></div><div class="line">            mVelocityTracker.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过以上分析，我们得出以下知识：</p>
<ul>
<li>在down事件的时候先判断触摸是否处于边缘，如果是，则不处理</li>
<li>在down事件中判断落点是否在子View中，如果不在，不处理</li>
<li>在down事件中判断是否仍在滑动，如果是，先停止</li>
<li>记录第一个按下点的索引值</li>
<li>每次事件都记录住当前的y值</li>
<li>在move事件中通过记录的索引值找到对应的点，获取y坐标</li>
<li>与上一次y坐标进行比对，scrollBy两次的差值</li>
<li>在up事件的时候计算最后一秒钟的速度，并且有最大速度进行限制，当计算的速度大于系统默认的最小速度时，只想fling</li>
<li>up和cancel事件还原变量为默认值</li>
<li>如果为多点离开，进行多点离开的处理</li>
<li>该处理方式时：如果离开的是第一个按下的点，那么由第二个按下的点代替其进行y值偏移计算的基点，并清空速度计算的帮助类，重新记录MotionEvnet</li>
</ul>
<h1 id="8-Layout和Scroll的区别"><a href="#8-Layout和Scroll的区别" class="headerlink" title="8. Layout和Scroll的区别"></a><strong>8. Layout和Scroll的区别</strong></h1><ul>
<li>Layout中设置的是自身在父View中的显示区域</li>
<li>Scroll是调整自己的显示区域</li>
<li>当父View滚动或者layout变化后，自身在屏幕上的位置会发生变化。<br>当自身Scroll滚动后，在屏幕上的显示位置是不变的，变的只是自身的显示内容。</li>
<li>Scroll滚动不会影响Layout，只是在draw的时候影响画布偏移和触摸时的坐标计算。</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170302181345556?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><img src="http://img.blog.csdn.net/20170302181357798?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><img src="http://img.blog.csdn.net/20170302181409595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a><a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a><a href="#" class="bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a></div></p>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{},"image":{"viewList":["fbook","twi","linkedin","qzone","tsina","douban","weixin","evernotecn"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?'];</script>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat-reward-image.png" alt="JackChan WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay-reward-image.jpg" alt="JackChan Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/事件分发/" rel="tag"># 事件分发</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/30/android/Android的消息机制/" rel="next" title="Android的消息机制">
                <i class="fa fa-chevron-left"></i> Android的消息机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/30/javaweb/HTTP协议详解/" rel="prev" title="Http协议详解">
                Http协议详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/ai.jpg"
               alt="JackChan" />
          <p class="site-author-name" itemprop="name">JackChan</p>
           
              <p class="site-description motion-element" itemprop="description">生活不止眼前的苟且，还有诗和远方！</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">76</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">47</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/JackChan1999" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.gitbook.com/@alleniverson" target="_blank" title="GitBook">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  GitBook
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1848214604?topnav=1&wvr=6&topsug=1&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/axi295309066" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/guolin_blog" title="郭霖" target="_blank">郭霖</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/lmj623565791" title="鸿洋" target="_blank">鸿洋</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://stormzhang.com/" title="张帅" target="_blank">张帅</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jikedaohang.com/" title="极客导航" target="_blank">极客导航</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Touch事件和绘制事件的异同之处"><span class="nav-number">1.</span> <span class="nav-text">1. Touch事件和绘制事件的异同之处</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-MotionEvent"><span class="nav-number">2.</span> <span class="nav-text">2. MotionEvent</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-MotionEvent对象的产生"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 MotionEvent对象的产生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-MotionEvent对象详解"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 MotionEvent对象详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-5种Touch事件"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 5种Touch事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-创建一个MotionEvent对象"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 创建一个MotionEvent对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-dispatchTouchEvent触摸事件分发"><span class="nav-number">3.</span> <span class="nav-text">3. dispatchTouchEvent触摸事件分发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-View的dispatchTouchEvent"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 View的dispatchTouchEvent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-ViewGroup的dispatchTouchEvent"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 ViewGroup的dispatchTouchEvent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Down事件"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 Down事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Move和Up事件"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 Move和Up事件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-onInterceptTouchEvent"><span class="nav-number">4.</span> <span class="nav-text">4. onInterceptTouchEvent</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-View的onTouchEvent"><span class="nav-number">5.</span> <span class="nav-text">5. View的onTouchEvent</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-onTouch与onClick"><span class="nav-number">6.</span> <span class="nav-text">6. onTouch与onClick</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-ScrollView的onTouchEvent"><span class="nav-number">7.</span> <span class="nav-text">7. ScrollView的onTouchEvent</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-Layout和Scroll的区别"><span class="nav-number">8.</span> <span class="nav-text">8. Layout和Scroll的区别</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JackChan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2017/04/30/android/Android的事件分发/';
          this.page.identifier = '2017/04/30/android/Android的事件分发/';
          this.page.title = 'Android的事件分发';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
