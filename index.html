<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="生活不止眼前的苟且，还有诗和远方！">
<meta property="og:type" content="website">
<meta property="og:title" content="秋过冬漫长">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="秋过冬漫长">
<meta property="og:description" content="生活不止眼前的苟且，还有诗和远方！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="秋过冬漫长">
<meta name="twitter:description" content="生活不止眼前的苟且，还有诗和远方！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>秋过冬漫长</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">秋过冬漫长</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">没有比脚更长的路，走过去，前面是个天！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/HTTP协议详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋过冬漫长">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/HTTP协议详解/" itemprop="url">
                  Http协议详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T23:58:11+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/30/HTTP协议详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/30/HTTP协议详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当今web程序的开发技术真是百家争鸣，ASP.NET, PHP, JSP，Perl, AJAX 等等。 无论Web技术在未来如何发展，理解Web程序之间通信的基本协议相当重要, 因为它让我们理解了Web应用程序的内部工作. 本文将对HTTP协议进行详细的实例讲解，内容较多，希望大家耐心看。也希望对大家的开发工作或者测试工作有所帮助。使用Fiddler工具非常方便地捕获HTTP Request和HTTP Response,  关于Fiddler工具的用法，请看我另一篇博客[<a href="http://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html" target="_blank" rel="external">Fiddler 教程</a>]</p>
<h1 id="1-什么是HTTP协议"><a href="#1-什么是HTTP协议" class="headerlink" title="1. 什么是HTTP协议"></a>1. 什么是HTTP协议</h1><p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器</p>
<p>目前我们使用的是HTTP/1.1 版本</p>
<h1 id="2-Web服务器，浏览器-代理服务器"><a href="#2-Web服务器，浏览器-代理服务器" class="headerlink" title="2. Web服务器，浏览器,代理服务器"></a>2. Web服务器，浏览器,代理服务器</h1><p>当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？</p>
<p>实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页，过程如下图所示</p>
<p><img src="http://images2015.cnblogs.com/blog/263119/201702/263119-20170226084020460-1834612400.png" alt="img"></p>
<p>我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。过程如下图所示</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012020910491417.png" alt="img"></p>
<p>代理服务器就是网络信息的中转站，有什么功能呢？</p>
<ol>
<li>提高访问速度， 大多数的代理服务器都有缓存功能</li>
<li>突破限制， 也就是翻墙了</li>
<li>隐藏身份</li>
</ol>
<h1 id="3-URL详解"><a href="#3-URL详解" class="headerlink" title="3. URL详解"></a>3. URL详解</h1><p> URL(Uniform Resource Locator) 地址用于描述一个网络上的资源,  基本格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">schema://host[:port#]/path/.../[?query-string][#anchor]</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">scheme</td>
<td style="text-align:left">指定低层使用的协议(例如：http, https, ftp)</td>
</tr>
<tr>
<td style="text-align:left">host</td>
<td style="text-align:left">HTTP服务器的IP地址或者域名</td>
</tr>
<tr>
<td style="text-align:left">port#</td>
<td style="text-align:left">HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.cnblogs.com:8080/" target="_blank" rel="external">http://www.cnblogs.com:8080/</a></td>
</tr>
<tr>
<td style="text-align:left">path</td>
<td style="text-align:left">访问资源的路径</td>
</tr>
<tr>
<td style="text-align:left">query-string</td>
<td style="text-align:left">发送给http服务器的数据</td>
</tr>
<tr>
<td style="text-align:left">anchor</td>
<td style="text-align:left">锚</td>
</tr>
</tbody>
</table>
<p>URL 的一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff</div><div class="line"></div><div class="line">Schema:                 http</div><div class="line">host:                   www.mywebsite.com</div><div class="line">path:                   /sj/test/test.aspx</div><div class="line">Query String:           name=sviergn&amp;x=true</div><div class="line">Anchor:                 stuff</div></pre></td></tr></table></figure>
<h1 id="4-HTTP协议是无状态的"><a href="#4-HTTP协议是无状态的" class="headerlink" title="4. HTTP协议是无状态的"></a>4. HTTP协议是无状态的</h1><p>http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态.</p>
<h1 id="5-打开一个网页需要浏览器发送很多次Request"><a href="#5-打开一个网页需要浏览器发送很多次Request" class="headerlink" title="5. 打开一个网页需要浏览器发送很多次Request"></a>5. 打开一个网页需要浏览器发送很多次Request</h1><ol>
<li><p>当你在浏览器输入URL <a href="http://www.cnblogs.com" target="_blank" rel="external">http://www.cnblogs.com</a> 的时候，浏览器发送一个Request去获取 <a href="http://www.cnblogs.com" target="_blank" rel="external">http://www.cnblogs.com</a> 的html.  服务器把Response发送回给浏览器</p>
</li>
<li><p>浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件</p>
</li>
<li><p>浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件</p>
</li>
<li><p>等所有的文件都下载成功后。 网页就被显示出来了</p>
</li>
</ol>
<h1 id="6-HTTP消息的结构"><a href="#6-HTTP消息的结构" class="headerlink" title="6. HTTP消息的结构"></a>6. HTTP消息的结构</h1><p>先看Request 消息的结构,   Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行， 结构如下图</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012020914293943.png" alt="img"></p>
<p>第一行中的Method表示请求方法,比如”POST”,”GET”,  Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号</p>
<p>当使用的是”GET” 方法的时候， body是为空的，比如我们打开博客园首页的request 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GET http://www.cnblogs.com/ HTTP/1.1</div><div class="line">Host: www.cnblogs.com</div></pre></td></tr></table></figure>
<p>抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们今天用Fiddler，实际的看看Request和Response</p>
<p>下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息，   如下图</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012022009421183.png" alt="img"></p>
<p>我们再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行,  结构如下图</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012021309365350.png" alt="img"></p>
<p>HTTP/version-number表示HTTP协议的版本号，  status-code 和message 请看下节[<a href="http://www.cnblogs.com/TankXiao/archive/2012/02/13/2342672.html#statecode" target="_blank" rel="external">状态代码</a>]的详细解释.</p>
<p>我们用Fiddler 捕捉一个博客园首页的Response然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Response的消息，   如下图</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012022009373182.png" alt="img"></p>
<h1 id="7-Get和Post方法的区别"><a href="#7-Get和Post方法的区别" class="headerlink" title="7. Get和Post方法的区别"></a>7. Get和Post方法的区别</h1><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</p>
<p>我们看看GET和POST的区别</p>
<ol>
<li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456.  POST方法是把提交的数据放在HTTP包的Body中.</p>
</li>
<li><p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p>
</li>
<li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p>
</li>
<li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p>
</li>
</ol>
<h1 id="8-状态码"><a href="#8-状态码" class="headerlink" title="8. 状态码"></a>8. 状态码</h1><p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>
<p>状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.</p>
<p>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p>
<ul>
<li><p>1XX  提示信息 - 表示请求已被成功接收，继续处理</p>
</li>
<li><p>2XX  成功 - 表示请求已被成功接收，理解，接受</p>
</li>
<li><p>3XX  重定向 - 要完成请求必须进行更进一步的处理</p>
</li>
<li><p>4XX  客户端错误 -  请求有语法错误或请求无法实现</p>
</li>
<li><p>5XX  服务器端错误 -   服务器未能实现合法的请求</p>
</li>
</ul>
<p>看看一些常见的状态码</p>
<ul>
<li>200 OK</li>
</ul>
<p>最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端</p>
<p>如下图， 打开博客园首页</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012021114423456.png" alt="img"></p>
<ul>
<li>302 Found</li>
</ul>
<p>重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request</p>
<p>例如在IE中输入， <a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a>. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request.</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012021115280744.png" alt="img"></p>
<ul>
<li>304 Not Modified</li>
</ul>
<p>代表上次的文档已经被缓存了， 还可以继续使用，例如打开博客园首页, 发现很多Response 的status code 都是304</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012021115064471.png" alt="img"></p>
<p>提示：　如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面</p>
<ul>
<li><p>400 Bad Request  客户端请求与语法错误，不能被服务器所理解</p>
</li>
<li><p>403 Forbidden 服务器收到请求，但是拒绝提供服务</p>
</li>
<li><p>404 Not Found</p>
</li>
</ul>
<p>请求资源不存在（输错了URL），比如在IE中输入一个错误的URL， <a href="http://www.cnblogs.com/tesdf.aspx" target="_blank" rel="external">http://www.cnblogs.com/tesdf.aspx</a></p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012021114534541.png" alt="img"></p>
<ul>
<li><p>500 Internal Server Error 服务器发生了不可预期的错误</p>
</li>
<li><p>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
</li>
</ul>
<h1 id="9-HTTP-Request-header"><a href="#9-HTTP-Request-header" class="headerlink" title="9. HTTP Request header"></a>9. HTTP Request header</h1><p>使用Fiddler 能很方便的查看Reques header, 点击Inspectors tab -&gt;Request tab-&gt; headers  如下图所示.</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012021116181545.png" alt="img"></p>
<p>header 有很多，比较难以记忆，我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p>
<h2 id="9-1-Cache-头域"><a href="#9-1-Cache-头域" class="headerlink" title="9.1 Cache 头域"></a>9.1 Cache 头域</h2><ul>
<li>If-Modified-Since</li>
</ul>
<p>作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</p>
<p>例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT，实例如下图</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012021322503738.png" alt="img"></p>
<ul>
<li>If-None-Match</li>
</ul>
<p>作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能</p>
<p>例如: If-None-Match: “03f2b33c0bfcc1:0”，实例如下图</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012021117041918.png" alt="img"></p>
<ul>
<li>Pragma</li>
</ul>
<p>作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样</p>
<p>Pargma只有一个用法， 例如： Pragma: no-cache</p>
<p>注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</p>
<ul>
<li>Cache-Control</li>
</ul>
<p>作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下</p>
<ul>
<li><p>Cache-Control:Public   可以被任何缓存所缓存（）</p>
</li>
<li><p>Cache-Control:Private     内容只缓存到私有缓存中</p>
</li>
<li><p>Cache-Control:no-cache  所有内容都不会被缓存</p>
</li>
</ul>
<p>还有其他的一些用法， 我没搞懂其中的意思， 请大家参考其他的资料</p>
<h2 id="9-2-Client-头域"><a href="#9-2-Client-头域" class="headerlink" title="9.2 Client 头域"></a>9.2 Client 头域</h2><ul>
<li>Accept</li>
</ul>
<p>作用： 浏览器端可以接受的媒体类型,</p>
<p>例如：  Accept: text/html  代表浏览器可以接受服务器回发的类型为 text/html  也就是我们常说的html文档,</p>
<p>如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable)</p>
<p>通配符 * 代表任意类型</p>
<p>例如  Accept: <em>/</em>  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)</p>
<ul>
<li>Accept-Encoding：</li>
</ul>
<p>作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）;</p>
<p>例如： Accept-Encoding: gzip, deflate</p>
<ul>
<li>Accept-Language</li>
</ul>
<p>作用： 浏览器申明自己接收的语言。</p>
<p>语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；</p>
<p>例如： Accept-Language: en-us</p>
<ul>
<li>User-Agent</li>
</ul>
<p>作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.</p>
<p>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。</p>
<p>例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)</p>
<ul>
<li>Accept-Charset</li>
</ul>
<p>作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）</p>
<h2 id="9-3-Cookie-Login-头域"><a href="#9-3-Cookie-Login-头域" class="headerlink" title="9.3 Cookie/Login 头域"></a>9.3 Cookie/Login 头域</h2><p>Cookie，作用： 最重要的header, 将cookie的值发送给HTTP 服务器</p>
<h2 id="9-4-Entity头域"><a href="#9-4-Entity头域" class="headerlink" title="9.4 Entity头域"></a>9.4 Entity头域</h2><ul>
<li>Content-Length，作用：发送给HTTP服务器数据的长度。例如： Content-Length: 38</li>
</ul>
<ul>
<li>Content-Type，作用：发送给HTTP服务器数据的类型，例如：Content-Type: application/x-www-form-urlencoded</li>
</ul>
<h2 id="9-5-Miscellaneous-头域"><a href="#9-5-Miscellaneous-头域" class="headerlink" title="9.5 Miscellaneous 头域"></a>9.5 Miscellaneous 头域</h2><ul>
<li>Referer:</li>
</ul>
<p>作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p>
<p>例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT" target="_blank" rel="external">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></p>
<h2 id="9-6-Transport-头域"><a href="#9-6-Transport-头域" class="headerlink" title="9.6 Transport 头域"></a>9.6 Transport 头域</h2><ul>
<li>Connection</li>
</ul>
<p>例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>
<ul>
<li>Host（发送请求时，该报头域是必需的）</li>
</ul>
<p>作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的</p>
<p>例如: 我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html" target="_blank" rel="external">http://www.guet.edu.cn/index.html</a></p>
<p>浏览器发送的请求消息中，就会包含Host请求报头域，例如，Host：<a href="http://www.guet.edu.cn" target="_blank" rel="external">http://www.guet.edu.cn</a></p>
<p>此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</p>
<h1 id="10-HTTP-Response-header"><a href="#10-HTTP-Response-header" class="headerlink" title="10. HTTP Response header"></a>10. HTTP Response header</h1><p>同样使用Fiddler 查看Response header, 点击Inspectors tab -&gt;Response tab-&gt; headers  如下图所示</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012021116212815.png" alt="img"></p>
<p> 我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。</p>
<h2 id="10-1-Cache头域"><a href="#10-1-Cache头域" class="headerlink" title="10.1 Cache头域"></a>10.1 Cache头域</h2><ul>
<li>Date，作用:  生成消息的具体时间和日期，例如：Date: Sat, 11 Feb 2012 11:35:14 GMT</li>
<li>Expires，作用: 浏览器会在指定过期时间内使用本地缓存，例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT</li>
<li>Vary，作用：例如: Vary: Accept-Encoding</li>
</ul>
<h2 id="10-2-Cookie-Login-头域"><a href="#10-2-Cookie-Login-头域" class="headerlink" title="10.2 Cookie/Login 头域"></a>10.2 Cookie/Login 头域</h2><ul>
<li>P3P，作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题</li>
</ul>
<p>例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR</p>
<ul>
<li>Set-Cookie</li>
</ul>
<p>作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.</p>
<p>例如: Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com</p>
<p><img src="http://pic002.cnblogs.com/images/2012/263119/2012021119563476.png" alt="img"></p>
<h2 id="10-3-Entity头域"><a href="#10-3-Entity头域" class="headerlink" title="10.3 Entity头域"></a>10.3 Entity头域</h2><ul>
<li>ETag</li>
</ul>
<p>作用:  和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例）</p>
<p>例如: ETag: “03f2b33c0bfcc1:0”</p>
<ul>
<li>Last-Modified:</li>
</ul>
<p>作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）</p>
<p>例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT</p>
<ul>
<li>Content-Type</li>
</ul>
<p>作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集，例如:</p>
<p>Content-Type: text/html; charset=utf-8<br>Content-Type:text/html;charset=GB2312<br>Content-Type: image/jpeg</p>
<ul>
<li>Content-Length</li>
</ul>
<p>指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。例如: Content-Length: 19847</p>
<ul>
<li>Content-Encoding</li>
</ul>
<p>WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip</p>
<ul>
<li>Content-Language</li>
</ul>
<p>作用： WEB服务器告诉浏览器自己响应的对象的语言者，例如： Content-Language:da</p>
<h2 id="10-4-Miscellaneous-头域"><a href="#10-4-Miscellaneous-头域" class="headerlink" title="10.4 Miscellaneous 头域"></a>10.4 Miscellaneous 头域</h2><ul>
<li>Server，作用：指明HTTP服务器的软件信息，例如:Server: Microsoft-IIS/7.5</li>
<li>X-AspNet-Version:</li>
</ul>
<p>作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本，例如: X-AspNet-Version: 4.0.30319</p>
<ul>
<li>X-Powered-By，作用：表示网站是用什么技术开发的，例如： X-Powered-By: ASP.NET</li>
</ul>
<h2 id="10-5-Transport头域"><a href="#10-5-Transport头域" class="headerlink" title="10.5 Transport头域"></a>10.5 Transport头域</h2><ul>
<li>Connection</li>
</ul>
<p>例如：　Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p>例如：  Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>
<h2 id="10-6-Location头域"><a href="#10-6-Location头域" class="headerlink" title="10.6 Location头域"></a>10.6 Location头域</h2><p>Location，作用： 用于重定向一个新的位置, 包含新的URL地址，实例请看304状态实例</p>
<h1 id="11-HTTP协议是无状态的和Connection-keep-alive的区别"><a href="#11-HTTP协议是无状态的和Connection-keep-alive的区别" class="headerlink" title="11. HTTP协议是无状态的和Connection: keep-alive的区别"></a>11. HTTP协议是无状态的和Connection: keep-alive的区别</h1><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系</p>
<p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</p>
<p>从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p> Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/Http协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋过冬漫长">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/Http协议/" itemprop="url">
                  Http协议
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T23:58:11+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/30/Http协议/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/30/Http协议/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><ul>
<li><a href="http://blog.csdn.net/axi295309066/article/details/52854772" target="_blank" rel="external">Java基础：网络编程</a></li>
<li><a href="http://blog.csdn.net/axi295309066/article/details/60129690" target="_blank" rel="external">Uri、URL、UriMatcher、ContentUris详解</a></li>
<li><a href="http://blog.csdn.net/axi295309066/article/details/50315017" target="_blank" rel="external">Android应用开发：网络编程1</a></li>
<li><a href="http://blog.csdn.net/axi295309066/article/details/50330375" target="_blank" rel="external">Android应用开发：网络编程2</a></li>
</ul>
<p><img src="http://img.blog.csdn.net/20161108115713048" alt="Http协议"></p>
<h1 id="1-什么是HTTP协议"><a href="#1-什么是HTTP协议" class="headerlink" title="1. 什么是HTTP协议"></a><strong>1. 什么是HTTP协议</strong></h1><p>客户端连上web服务器后，若想获得web服务器中的某个web资源，需遵守一定的通讯格式，HTTP协议用于定义客户端与web服务器通迅的格式。</p>
<p>HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程。这个协议详细规定了浏览器和万维网服务器之间互相通信的规则。</p>
<p>HTTP就是一个通信规则，通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。其实我们要学习的就是这个两个格式！客户端发送给服务器的格式叫“请求协议”；服务器发送给客户端的格式叫“响应协议”。</p>
<p>HTTP协议是学习JavaWEB开发的基石，不深入了解HTTP协议，就不能说掌握了WEB开发，更无法管理和维护一些复杂的WEB站点。</p>
<h2 id="OSI网络七层协议"><a href="#OSI网络七层协议" class="headerlink" title="OSI网络七层协议"></a>OSI网络七层协议</h2><ul>
<li>应用层（HTTP、FTP、SMTP、POP3、TELNET）</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层（TCP、UDP）</li>
<li>网络层（IP）</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<p><img src="img/网络协议.jpg" alt=""></p>
<p><img src="img/网络模型.jpg" alt=""></p>
<h1 id="2-HTTP协议简介"><a href="#2-HTTP协议简介" class="headerlink" title="2. HTTP协议简介"></a><strong>2. HTTP协议简介</strong></h1><p>HTTP使用请求-响应的方式进行传输，一个请求对应一个响应，并且请求只能是由客户端发起的。</p>
<p>利用Telnet演示请求与响应的过程</p>
<p>安装IE浏览器插件HttpWatch，查看IE浏览器通过HTTP协议获取某个页面。</p>
<p>HTTP协议的版本：HTTP/1.0、HTTP/1.1</p>
<h1 id="3-HTTP1-0和HTTP1-1的区别"><a href="#3-HTTP1-0和HTTP1-1的区别" class="headerlink" title="3. HTTP1.0和HTTP1.1的区别"></a><strong>3. HTTP1.0和HTTP1.1的区别</strong></h1><p>在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。</p>
<p>HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。</p>
<p>利用telnet演示HTTP1.0和HTTP1.1的区别</p>
<p>一个好多同学搞不清楚的问题：</p>
<p>一个web页面中，使用img标签引用了三幅图片，当客户端访问服务器中的这个web页面时，客户端总共会访问几次服务器，即向服务器发送了几次HTTP请求。</p>
<h1 id="4-协议"><a href="#4-协议" class="headerlink" title="4. 协议"></a><strong>4. 协议</strong></h1><p>协议：协议的甲乙双方，就是客户端（浏览器）和服务器！</p>
<p>理解成双方通信的格式！</p>
<ul>
<li>请求协议</li>
<li>响应协议</li>
</ul>
<h1 id="5-HttpWatch和FireBug"><a href="#5-HttpWatch和FireBug" class="headerlink" title="5. HttpWatch和FireBug"></a><strong>5. HttpWatch和FireBug</strong></h1><p>HttpWatch是专门为IE浏览器提供的，用来查看HTTP请求和响应内容的工具。而FireFox上需要安装FireBug软件。如果你使用的是Chrome，那么就不用自行安装什么工具了，因为它自身就有查看请求和响应内容的功能！</p>
<p>HttpWatch和FireBug这些工具对浏览器而言不是必须的，但对我们开发者是很有帮助的，通过查看HTTP请求响应内容，可以使我们更好的学习HTTP协议。</p>
<h1 id="6-请求协议"><a href="#6-请求协议" class="headerlink" title="6. 请求协议"></a><strong>6. 请求协议</strong></h1><p>请求协议的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">请求首行；</div><div class="line">请求头信息；</div><div class="line">空行；</div><div class="line">请求体。</div></pre></td></tr></table></figure>
<p>浏览器发送给服务器的内容就这个格式的，如果不是这个格式服务器将无法解读！在HTTP协议中，请求有很多请求方法，其中最为常用的就是GET和POST。不同的请求方法之间的区别，后面会一点一点的介绍。</p>
<h2 id="6-1-GET请求"><a href="#6-1-GET请求" class="headerlink" title="6.1 GET请求"></a><strong>6.1 GET请求</strong></h2><p>打开IE，在访问hello项目的index.jsp之间打开HttpWatch，并点击“Record”按钮。然后访问index.jsp页面。查看请求内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">GET /hello/index.jsp HTTP/1.1</div><div class="line">Host: localhost</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Language: zh-cn,zh;q=0.5</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Accept-Charset: GB2312,utf-8;q=0.7,*;q=0.7</div><div class="line">Connection: keep-alive</div><div class="line">Cookie: JSESSIONID=369766FDF6220F7803433C0B2DE36D98</div></pre></td></tr></table></figure>
<ul>
<li><p>GET /hello/index.jsp HTTP/1.1：GET请求，请求服务器路径为/hello/index.jsp，协议为1.1</p>
</li>
<li><p>Host:localhost：请求的主机名为localhost</p>
</li>
<li><p>User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0：<br>与浏览器和OS相关的信息。有些网站会显示用户的系统版本和浏览器版本信息，这都是通过获取User-Agent头信息而来的</p>
</li>
<li><p>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8：<br>告诉服务器，当前客户端可以接收的文档类型，其实这里包含了<em>/</em>，就表示什么都可以接收</p>
</li>
<li><p>Accept-Language: zh-cn,zh;q=0.5<br>当前客户端支持的语言，可以在浏览器的工具选项中找到语言相关信息</p>
</li>
<li><p>Accept-Encoding: gzip, deflate：支持的压缩格式。数据在网络上传递时，可能服务器会把数据压缩后再发送</p>
</li>
<li><p>Accept-Charset: GB2312,utf-8;q=0.7,*;q=0.7：客户端支持的编码</p>
</li>
<li><p>Connection: keep-alive：客户端支持的链接方式，保持一段时间链接，默认为3000ms</p>
</li>
<li><p>Cookie: JSESSIONID=369766FDF6220F7803433C0B2DE36D98<br>因为不是第一次访问这个地址，所以会在请求中把上一次服务器响应中发送过来的Cookie在请求中一并发送去过；这个Cookie的名字为JSESSIONID，然后在讲会话是讲究它！</p>
</li>
</ul>
<h2 id="6-2-POST请求"><a href="#6-2-POST请求" class="headerlink" title="6.2 POST请求"></a><strong>6.2 POST请求</strong></h2><p>为了演示POST请求，我们需要修改index.jsp页面，即添加一个表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></div><div class="line">  关键字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"keyword"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://img.blog.csdn.net/20161028111125470" alt="http"></p>
<p>打开HttpWatch，输入hello后点击提交，查看请求内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">POST /hello/index.jsp HTTP/1.1</div><div class="line">Accept: image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/msword, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/x-ms-application, application/x-ms-xbap, application/vnd.ms-xpsdocument, application/xaml+xml, */*</div><div class="line">Referer: http://localhost:8080/hello/index.jsp</div><div class="line">Accept-Language: zh-cn,en-US;q=0.5</div><div class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; InfoPath.2; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Host: localhost:8080</div><div class="line">Content-Length: 13</div><div class="line">Connection: Keep-Alive</div><div class="line">Cache-Control: no-cache</div><div class="line">Cookie: JSESSIONID=E365D980343B9307023A1D271CC48E7D</div><div class="line"></div><div class="line">keyword=hello</div></pre></td></tr></table></figure>
<p>POST请求是可以有体的，而GET请求不能有请求体。</p>
<ul>
<li><p>Referer: <a href="http://localhost:8080/hello/index.jsp" target="_blank" rel="external">http://localhost:8080/hello/index.jsp</a><br>请求来自哪个页面，例如你在百度上点击链接到了这里，那么Referer:<a href="http://www.baidu.com；如果你是在浏览器的地址栏中直接输入的地址，那么就没有Referer这个请求头了" target="_blank" rel="external">http://www.baidu.com；如果你是在浏览器的地址栏中直接输入的地址，那么就没有Referer这个请求头了</a></p>
</li>
<li><p>Content-Type: application/x-www-form-urlencoded<br>表单的数据类型，说明会使用url格式编码数据；url编码的数据都是以“%”为前缀，后面跟随两位的16进制，例如“传智”这两个字使用UTF-8的url编码用为“%E4%BC%A0%E6%99%BA”</p>
</li>
<li><p>Content-Length:13：请求体的长度，这里表示13个字节</p>
</li>
<li>keyword=hello：请求体内容！hello是在表单中输入的数据，keyword是表单字段的名字。</li>
</ul>
<p>Referer请求头是比较有用的一个请求头，它可以用来做统计工作，也可以用来做防盗链。</p>
<h2 id="6-3-统计工作"><a href="#6-3-统计工作" class="headerlink" title="6.3 统计工作"></a><strong>6.3 统计工作</strong></h2><p>我公司网站在百度上做了广告，但不知道在百度上做广告对我们网站的访问量是否有影响，那么可以对每个请求中的Referer进行分析，如果Referer为百度的很多，那么说明用户都是通过百度找到我们公司网站的。</p>
<h2 id="6-4-防盗链"><a href="#6-4-防盗链" class="headerlink" title="6.4 防盗链"></a><strong>6.4 防盗链</strong></h2><p>我公司网站上有一个下载链接，而其他网站盗链了这个地址，例如在我网站上的index.html页面中有一个链接，点击即可下载JDK7.0，但有某个人的微博中盗链了这个资源，它也有一个链接指向我们网站的JDK7.0，也就是说登录它的微博，点击链接就可以从我网站上下载JDK7.0，这导致我们网站的广告没有看，但下载的却是我网站的资源。这时可以使用Referer进行防盗链，在资源被下载之前，我们对Referer进行判断，如果请求来自本网站，那么允许下载，如果非本网站，先跳转到本网站看广告，然后再允许下载</p>
<h1 id="7-响应协议"><a href="#7-响应协议" class="headerlink" title="7. 响应协议"></a><strong>7. 响应协议</strong></h1><h2 id="7-1-响应内容"><a href="#7-1-响应内容" class="headerlink" title="7.1 响应内容"></a><strong>7.1 响应内容</strong></h2><p>响应协议的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">响应首行；</div><div class="line">响应头信息；</div><div class="line">空行；</div><div class="line">响应体。</div></pre></td></tr></table></figure></p>
<p>响应内容是由服务器发送给浏览器的内容，浏览器会根据响应内容来显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: Apache-Coyote/1.1</div><div class="line">Content-Type: text/html;charset=UTF-8</div><div class="line">Content-Length: 724</div><div class="line">Set-Cookie: JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/hello</div><div class="line">Date: Wed, 25 Sep 2012 04:15:03 GMT</div></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"http://localhost:8080/hello/"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My JSP 'index.jsp' starting page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"cache-control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"expires"</span> <span class="attr">content</span>=<span class="string">"0"</span>&gt;</span>    </div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"keyword1,keyword2,keyword3"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"This is my page"</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!--</span></div><div class="line">	&lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;</div><div class="line">	--&gt;</div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></div><div class="line">  关键字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"keyword"</span>/&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>HTTP/1.1 200 OK：响应协议为HTTP1.1，状态码为200，表示请求成功，OK是对状态码的解释</li>
<li>Server: Apache-Coyote/1.1：服务器的版本信息</li>
<li>Content-Type: text/html;charset=UTF-8：响应体使用的编码为UTF-8</li>
<li>Content-Length: 724：响应体为724字节</li>
<li>Set-Cookie: JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/hello：响应给客户端的Cookie；</li>
<li>Date: Wed, 25 Sep 2012 04:15:03 GMT：响应的时间，这可能会有8小时的时区差</li>
</ul>
<h2 id="7-2-若干响应头"><a href="#7-2-若干响应头" class="headerlink" title="7.2 若干响应头"></a><strong>7.2 若干响应头</strong></h2><table>
<thead>
<tr>
<th style="text-align:left">响应头</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Content-Encoding: gzip</td>
<td style="text-align:left">服务器发送数据时使用的压缩格式</td>
</tr>
<tr>
<td style="text-align:left">Server:apache tomcat</td>
<td style="text-align:left">服务器的基本信息</td>
</tr>
<tr>
<td style="text-align:left">Content-Length: 80</td>
<td style="text-align:left">发送数据的大小</td>
</tr>
<tr>
<td style="text-align:left">Content-Language: zh-cn</td>
<td style="text-align:left">发送的数据使用的语言环境</td>
</tr>
<tr>
<td style="text-align:left">Content-Disposition: attachment;filename=aaa.zip</td>
<td style="text-align:left">与下载相关的头</td>
</tr>
<tr>
<td style="text-align:left">Expires: -1</td>
<td style="text-align:left">指定资源缓存的时间，如果取值为0或-1浏览就不缓存资源</td>
</tr>
<tr>
<td style="text-align:left">Cache-Control: no-cache</td>
<td style="text-align:left">缓存相关的头，如果为no-cache则通知浏览器不缓存</td>
</tr>
<tr>
<td style="text-align:left">Pragma: no-cache</td>
<td style="text-align:left">缓存相关的头，如果为no-cache则不缓存</td>
</tr>
<tr>
<td style="text-align:left">Connection: close/Keep-Alive</td>
<td style="text-align:left">是否保持连接</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">配合302实现请求重定向</td>
</tr>
<tr>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">发送数据的类型和编码</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">最后修改时间</td>
</tr>
<tr>
<td style="text-align:left">Refresh</td>
<td style="text-align:left">自动刷新，n秒后跳转到另一个页面</td>
</tr>
<tr>
<td style="text-align:left">Set-Cookie</td>
<td style="text-align:left">发送Cookie信息</td>
</tr>
</tbody>
</table>
<p>Location: <a href="http://www.it315.org/index.jsp" target="_blank" rel="external">http://www.it315.org/index.jsp</a>  配合302实现请求重定向</p>
<p><img src="http://img.blog.csdn.net/20161030185328767" alt="http"></p>
<p>Content-Type: text/html; charset=GB2312 当前所发送的数据的基本信息，（数据的类型，所使用的编码）</p>
<p>Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT 缓存相关的头</p>
<p>Refresh: 1;url=<a href="http://www.it315.org" target="_blank" rel="external">http://www.it315.org</a> 通知浏览器进行定时刷新，此值可以是一个数字指定多长时间以后刷新当前页面，这个数字之后也可以接一个分号后跟一个URL地址指定多长时间后刷新到哪个URL</p>
<p>Transfer-Encoding: chunked 传输类型，如果是此值是一个chunked说明当前的数据是一块一块传输的</p>
<p>Set-Cookie:SS=Q0=5Lb_nQ; path=/search 和cookie相关的头，后面课程单讲</p>
<p>ETag: W/“83794-1208174400000” 和缓存机制相关的头<br>​<br>Date: Tue, 11 Jul 2000 18:23:51 GMT 当前时间</p>
<h2 id="7-3-响应码"><a href="#7-3-响应码" class="headerlink" title="7.3 响应码"></a><strong>7.3 响应码</strong></h2><p>响应头对浏览器来说很重要，它说明了响应的真正含义。例如200表示响应成功了，302表示重定向，这说明浏览器需要再发一个新的请求。</p>
<table>
<thead>
<tr>
<th style="text-align:left">响应码</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">请求部分资源，和请求头Range使用</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，<br>服务器会发送一个响应头Location，它指定了新请求的URL地址</td>
</tr>
<tr>
<td style="text-align:left">304</td>
<td style="text-align:left">服务器通知浏览器使用缓存</td>
</tr>
<tr>
<td style="text-align:left">307</td>
<td style="text-align:left">服务器通知浏览器使用缓存</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">请求的资源没有找到，说明客户端错误的请求了不存在的资源</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">请求资源找到了，但服务器内部出现了错误</td>
</tr>
</tbody>
</table>
<p>304：当用户第一次请求index.html时，服务器会添加一个名为Last-Modified响应头，这个头说明了index.html的最后修改时间，浏览器会把index.html内容，以及最后响应时间缓存下来。当用户第二次请求index.html时，在请求中包含一个名为If-Modified-Since请求头，它的值就是第一次请求时服务器通过Last-Modified响应头发送给浏览器的值，即index.html最后的修改时间，If-Modified-Since请求头就是在告诉服务器，我这里浏览器缓存的index.html最后修改时间是这个，您看看现在的index.html最后修改时间是不是这个，如果还是，那么您就不用再响应这个index.html内容了，我会把缓存的内容直接显示出来。而服务器端会获取If-Modified-Since值，与index.html的当前最后修改时间比对，如果相同，服务器会发响应码304，表示index.html与浏览器上次缓存的相同，无需再次发送，浏览器可以显示自己的缓存页面，如果比对不同，那么说明index.html已经做了修改，服务器会响应200</p>
<p><img src="http://img.blog.csdn.net/20161028111022578" alt="http"></p>
<p>响应头：</p>
<ul>
<li>Last-Modified：最后的修改时间</li>
</ul>
<p>请求头</p>
<ul>
<li>If-Modified-Since：把上次请求的index.html的最后修改时间还给服务器；状态码：304，比较If-Modified-Since的时间与文件真实的时间一样时，服务器会响应304，而且不会有响正文，表示浏览器缓存的就是最新版本</li>
</ul>
<h2 id="7-4-其他响应头"><a href="#7-4-其他响应头" class="headerlink" title="7.4 其他响应头"></a><strong>7.4 其他响应头</strong></h2><p>1、告诉浏览器不要缓存的响应头</p>
<ul>
<li>Expires: -1</li>
<li>Cache-Control: no-cache</li>
<li>Pragma: no-cache</li>
</ul>
<p>以上三个头都是用来控制缓存的，是因为历史原因造成的，不同的浏览器认识不同的头，我们通常三个一起使用保证通用性</p>
<p>2、自动刷新响应头，浏览器会在3秒之后请求<a href="http://www.itcast.cn：" target="_blank" rel="external">http://www.itcast.cn：</a></p>
<ul>
<li>Refresh: 3;url=<a href="http://www.itcast.cn" target="_blank" rel="external">http://www.itcast.cn</a></li>
</ul>
<h2 id="7-5-HTML中指定响应头"><a href="#7-5-HTML中指定响应头" class="headerlink" title="7.5 HTML中指定响应头"></a><strong>7.5 HTML中指定响应头</strong></h2><p>在HTMl页面中可以使用<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">来指定响应头，例如在index.html页面中给出<meta http-equiv="Refresh" content="3;url=http://www.itcast.cn">，表示浏览器只会显示index.html页面3秒，然后自动跳转到<a href="http://www.itcast.cn。" target="_blank" rel="external">http://www.itcast.cn。</a></p>
<h1 id="8-模拟网络请求"><a href="#8-模拟网络请求" class="headerlink" title="8. 模拟网络请求"></a>8. 模拟网络请求</h1><p>restClient，这个是firefox上的一个插件，对应chrome浏览器叫做postman，这个插件主要用作和服务器开发人员联调协议</p>
<h2 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h2><p><img src="http://upload-images.jianshu.io/upload_images/3981391-02e99251afe0bdb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="postman"></p>
<h2 id="restClient"><a href="#restClient" class="headerlink" title="restClient"></a>restClient</h2><p><img src="http://upload-images.jianshu.io/upload_images/3981391-a0c088ae331915b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="9-测试请求的地址"><a href="#9-测试请求的地址" class="headerlink" title="9. 测试请求的地址"></a>9. 测试请求的地址</h1><p><a href="http://httpbin.org" target="_blank" rel="external">http://httpbin.org</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3981391-96524f3229518fc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="httpbin"></p>
<h1 id="10-gzip压缩"><a href="#10-gzip压缩" class="headerlink" title="10. gzip压缩"></a>10. gzip压缩</h1><p>一种压缩格式，一种压缩方式，可以对网络传输的数据进行压缩。减少网络传输的大小</p>
<p>为什么需要压缩?因为经过压缩，可以减少体积，提高传输速度,提高用户体验</p>
<h2 id="10-1-浏览器发送器请求的过程"><a href="#10-1-浏览器发送器请求的过程" class="headerlink" title="10.1 浏览器发送器请求的过程"></a>10.1 浏览器发送器请求的过程</h2><ul>
<li>1.发送请求头:Accept-Encoding:gzip</li>
<li>2.服务器压缩数据,返回数据,在响应头里面添加Content-Encoding:gzip</li>
<li>3.客户端,根据Content-Encoding这个响应头,对应解压<ul>
<li>有Content-Encoding:gzip–&gt;gzip解压</li>
<li>没有Content-Encoding:gzip–&gt;标准解压</li>
</ul>
</li>
</ul>
<p>app使用gzip压缩：返回的json/xml(文本信息)其实就是个特殊的网页,其实也是可以进行gzip压缩</p>
<h2 id="10-2-gzip压缩效果"><a href="#10-2-gzip压缩效果" class="headerlink" title="10.2 gzip压缩效果"></a>10.2 gzip压缩效果</h2><p><img src="http://upload-images.jianshu.io/upload_images/3981391-318969a8bc5b1c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gzip压缩效果"></p>
<p>通过数据，我们得知，文本的压缩率，大概可以达到70%左右。压缩率很高</p>
<h2 id="10-3-gzip压缩的实现"><a href="#10-3-gzip压缩的实现" class="headerlink" title="10.3 gzip压缩的实现"></a>10.3 gzip压缩的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	<span class="keyword">boolean</span> isGzip = <span class="keyword">false</span>;</div><div class="line">	<span class="comment">//1.创建httpclient</span></div><div class="line">	DefaultHttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</div><div class="line">	<span class="comment">//2.创建get请求</span></div><div class="line">	HttpGet get = <span class="keyword">new</span> HttpGet(<span class="string">"http://httpbin.org/gzip"</span>);</div><div class="line">	<span class="comment">//① 添加请求头 Accept-Encoding:"gzip, deflate"</span></div><div class="line">	get.addHeader(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</div><div class="line">	<span class="comment">//3.执行请求</span></div><div class="line">	HttpResponse response = httpClient.execute(get);</div><div class="line">	<span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</div><div class="line">		<span class="comment">//② 得到响应头,Content-Encoding:"gzip"</span></div><div class="line">		Header[] headers = response.getHeaders(<span class="string">"Content-Encoding"</span>);</div><div class="line">		<span class="keyword">for</span> (Header header : headers) &#123;</div><div class="line">			<span class="keyword">if</span> (header.getValue().equals(<span class="string">"gzip"</span>)) &#123;<span class="comment">//后台server把数据进行了gzip压缩</span></div><div class="line">				isGzip = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		String result = <span class="string">""</span>;</div><div class="line">		HttpEntity entity = response.getEntity();</div><div class="line">		<span class="comment">//③根据是否使用gzip压缩.采取不同的解压方式</span></div><div class="line">		<span class="keyword">if</span> (isGzip) &#123;</div><div class="line">			<span class="comment">//④进行gzip的解压</span></div><div class="line">			GZIPInputStream in = <span class="keyword">new</span> GZIPInputStream(response.getEntity().getContent());</div><div class="line">			<span class="comment">//in--&gt;string</span></div><div class="line">			result = convertStreamToString(in);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">//4.打印结果</span></div><div class="line">			result = EntityUtils.toString(entity);</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">"result:"</span> + result);</div><div class="line">	&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">	e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="11-抓包"><a href="#11-抓包" class="headerlink" title="11. 抓包"></a>11. 抓包</h1><h2 id="11-1-Fiddler"><a href="#11-1-Fiddler" class="headerlink" title="11.1 Fiddler"></a><a href="http://www.telerik.com/fiddler" target="_blank" rel="external">11.1 Fiddler</a></h2><p>只能抓浏览器返回的包，即只可以抓PC上的包，无法抓手机上的包<br><img src="http://upload-images.jianshu.io/upload_images/3981391-a253c69288b70c37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fiddler"></p>
<h2 id="11-2-Wireshark"><a href="#11-2-Wireshark" class="headerlink" title="11.2 Wireshark"></a><a href="https://www.wireshark.org/" target="_blank" rel="external">11.2 Wireshark</a></h2><p>世界上最流行的网络协议分析器，<a href="http://blog.csdn.net/axi295309066/article/details/62141352" target="_blank" rel="external">抓包工具Wireshark基本介绍和学习TCP三次握手</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3981391-ddb7479bc322b078.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Wireshark"></p>
<p>通过ping命令拿到网址的IP<br><img src="http://upload-images.jianshu.io/upload_images/3981391-67e132b813b85c7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Wireshark"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/Android的事件分发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋过冬漫长">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/Android的事件分发/" itemprop="url">
                  Android的事件分发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T23:57:25+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/30/Android的事件分发/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/30/Android的事件分发/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Touch事件和绘制事件的异同之处"><a href="#1-Touch事件和绘制事件的异同之处" class="headerlink" title="1. Touch事件和绘制事件的异同之处"></a><strong>1. Touch事件和绘制事件的异同之处</strong></h1><p>Touch事件和绘制事件很类似，都是由ViewRoot派发下来的，但是不同之处在绘制事件是由应用中的某个View发起请求，一层一层上传到ViewRoot，再有ViewRoot下发绘制，传递canvas给所有子View让其绘制自身，绘制好后，再通知WMS进行画到屏幕上。而Touch事件是由硬件捕获到触摸后由系统传递给应用的ViewRoot，再由ViewRoot往下一层一层传递。</p>
<p>他们的处理过程都是自上而下的分发，但是绘制多了一层自下往上的请求。</p>
<p>事件存在消耗，事件的处理方法都会返回一个boolean值，如果该值为true，则本次事件下发将会终止。</p>
<h1 id="2-MotionEvent"><a href="#2-MotionEvent" class="headerlink" title="2. MotionEvent"></a><strong>2. MotionEvent</strong></h1><h2 id="2-1-MotionEvent对象的产生"><a href="#2-1-MotionEvent对象的产生" class="headerlink" title="2.1 MotionEvent对象的产生"></a><strong>2.1 MotionEvent对象的产生</strong></h2><p>系统有一个线程在循环收集屏幕硬件信息，当用户触摸屏幕时，该线程会把从硬件设备收集到的信息封装成一个MotionEvent对象，然后把该对象存放到一个消息队列中。</p>
<p>系统的另一个线程循环的读取消息队列中的MotionEvent，然后交给WMS去派发，WMS把该事件派发给当前处于活动的Activity，即处于活动栈最顶端的Activity。</p>
<p>这就是一个先进先出的消费者和生产者的模板，一个线程不停的创建MotionEvent对象放入队列中，另一个线程不断的从队列中取出MotionEvent对象进行分发。</p>
<p>当用户的手指从接触屏幕到离开屏幕，是一个完整的触摸事件，在该事件中，系统会不断收集事件信息封装成MotionEvent对象。收集的间隔时间取决于硬件设备，例如屏幕的灵敏度以及cpu的计算能力。目前的手机一般在20毫秒左右。</p>
<p>MotionEventCompat.getActionMasked()</p>
<h2 id="2-2-MotionEvent对象详解"><a href="#2-2-MotionEvent对象详解" class="headerlink" title="2.2 MotionEvent对象详解"></a><strong>2.2 MotionEvent对象详解</strong></h2><p>MotionEvent对象包含了触摸事件的时间、位置、面积、压力、以及本次事件的Dwon发生的时间。</p>
<p>MotionEvent常用的Action分为5种：Down 、Up、Move、Cancel、OutSide</p>
<p>MotionEvent中我们常用的方法就是获取点击的坐标，因为这是与我们操作息息相关的。获取坐标有两种方式：</p>
<ul>
<li>getX和getY用于获取以该View左上角为坐标原点的坐标</li>
<li>getRowX和getRowY用于获取以屏幕左上角为坐标原点的坐标</li>
</ul>
<h2 id="2-3-5种Touch事件"><a href="#2-3-5种Touch事件" class="headerlink" title="2.3 5种Touch事件"></a><strong>2.3 5种Touch事件</strong></h2><ul>
<li>Down：一次触摸事件的第一个MotionEvent对象，即手指初次接触屏幕。</li>
<li>Up：通常为一次触摸事件的最后一个MotionEvent对象，即手指离开屏幕。</li>
<li>Move：通常多次发生在一次触摸事件之中。表示触摸点发生了移动，我们通常把手指放到屏幕上，实际也会触发该事件，因为人手总是在轻微抖动的。</li>
<li>Cancel：常用于取消某个触摸事件，一般是由程序逻辑来指定该事件，用于取消某次触摸事件。</li>
<li>OutSide：当触摸点发生在响应事件的View之外时，传递的事件，通常由程序逻辑来指定。</li>
</ul>
<p>在上面5种事件中，Down为最重要的事件，因为这是一个触摸事件的起始点，程序的很多逻辑判断，都需要根据该事件做处理，例如分发拦截。一次触摸事件必须要有Down事件，这也是MotionEvent对象中都包含了本次触摸事件的Down事件发生的时间点这个属性。其次是Move和Up，通过这3个事件的逻辑处理，就构建出来滑动，点击，长按，双击等多种效果。</p>
<h2 id="2-4-创建一个MotionEvent对象"><a href="#2-4-创建一个MotionEvent对象" class="headerlink" title="2.4 创建一个MotionEvent对象"></a><strong>2.4 创建一个MotionEvent对象</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MotionEvent <span class="title">obtain</span><span class="params">(</span></span></div><div class="line">        <span class="keyword">long</span> downTime,    //当用户最初按下开始一连串的位置事件。这必须得到SystemClock.uptimeMillis()</div><div class="line">        <span class="keyword">long</span> eventTime,   <span class="comment">//当这个特定的事件是生成的。这必须得到SystemClock.uptimeMillis()            </span></div><div class="line">        <span class="keyword">int</span> action,       <span class="comment">//该次事件的Action                       </span></div><div class="line">        <span class="keyword">float</span> x,          <span class="comment">//该次事件的x坐标        </span></div><div class="line">        <span class="keyword">float</span> y,          <span class="comment">//该次事件的y坐标         </span></div><div class="line">        <span class="keyword">float</span> pressure,   <span class="comment">//该次事件的压力，通常感觉标准压力，从0-1取值     </span></div><div class="line">        <span class="keyword">float</span> size,       <span class="comment">//点击的区域大小，通常根据特定标准范围从0-1取值     </span></div><div class="line">        <span class="keyword">int</span> metaState,    <span class="comment">//一个修饰性的状态，好像一直都是0          </span></div><div class="line">        <span class="keyword">float</span> xPrecision, <span class="comment">//x坐标的精确度           </span></div><div class="line">        <span class="keyword">float</span> yPrecision, <span class="comment">//y坐标的精确度                   </span></div><div class="line">        <span class="keyword">int</span> deviceId,     <span class="comment">//触屏设备id，如果是0，说明这个事件不是来自物理设备      </span></div><div class="line">        <span class="keyword">int</span> edgeFlags     <span class="comment">//系统默认都是返回0，程序在传递时，可以通过逻辑判断加入方向位置 </span></div><div class="line">)</div></pre></td></tr></table></figure>
<p>或者一个更简单的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MotionEvent <span class="title">obtain</span><span class="params">(</span></span></div><div class="line">            <span class="keyword">long</span> downTime,</div><div class="line">            <span class="keyword">long</span> eventTime,</div><div class="line">            <span class="keyword">int</span> action,</div><div class="line">            <span class="keyword">float</span> x,</div><div class="line">            <span class="keyword">float</span> y,</div><div class="line">            <span class="keyword">int</span> metaState)</div></pre></td></tr></table></figure>
<p>也可以通过一个MotionEvent来创建一个新的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MotionEvent <span class="title">obtain</span><span class="params">(MotionEvent event)</span></span></div></pre></td></tr></table></figure>
<p>通过以上的方式，我们知道，我们也可以通过代码来构建一个虚假的MotionEvent，并分发下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">view.dispatchTouchEvent(</div><div class="line">            MotionEvent.obtain(SystemClock.uptimeMillis(),</div><div class="line">            SystemClock.uptimeMillis(),</div><div class="line">            MotionEvent.ACTION_DOWN,<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>));</div></pre></td></tr></table></figure>
<p>然后通过延迟以此往下派发Move和Up时间，形成一个完整的触摸操作。</p>
<h1 id="3-dispatchTouchEvent触摸事件分发"><a href="#3-dispatchTouchEvent触摸事件分发" class="headerlink" title="3. dispatchTouchEvent触摸事件分发"></a><strong>3. dispatchTouchEvent触摸事件分发</strong></h1><p><img src="http://img.blog.csdn.net/20170302184158181?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>之前我们知道触摸事件是被包装成MotionEvent进行传递的，而该对象是继承了Parcelable接口，正因为如此，才可以从系统中传递到我们的应用中。系统通过跨进程通知ViewRoot，ViewRoot会调用DecorView的dispatchTouchEvent下发。</p>
<p>这里有一个和其他事件传递不同的地方，DecorView会优先传递给Activity，而不是它的子View。而Activity如果不处理又会回传给DecorView，DecorView才会再将事件传给子View。</p>
<p>dispatchTouchEvent就是触摸事件传递的对外接口，无论是DecorView传给Activity，还是ViewGroup传递给子View，都是直接调用对方的dispatchTouchEvent方法，并传递MotionEvent参数。</p>
<p>我们首先来看看Activity中的dispatchTouchEvent逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        onUserInteraction();</div><div class="line">        <span class="comment">//这是一个空实现的方法，以便子类实现，该方法在Key事件和touch事件的dispatch方法中都被调用，</span></div><div class="line">        <span class="comment">// 就是方便用户在事件被传递之前做一下自己的处理。</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这才是事件真正的分发</span></div><div class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">        <span class="comment">//superDispatchTouchEvent是一个抽象方法，但是getWindow()获取的对象实际是FrameWork层的</span></div><div class="line">        <span class="comment">// PhoneWindow，该对象实现了这个方法，内部是直接调用DecorView的superDispatchTouchEvent</span></div><div class="line">        <span class="comment">// 是直接调用dispatchTouchEvent，这样就传递到子View中了   </span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果上面事件没有被消费掉，那么就调用Activity的onTouchEvent事件。</span></div><div class="line">    <span class="keyword">return</span> onTouchEvent(ev);</div><div class="line">&#125;</div><div class="line"><span class="comment">//PhoneWindow的superDispatchTouchEvent方法直接调用了mDecor的superDispatchTouchEvent</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line">&#125;</div><div class="line"><span class="comment">//mDecor即为Activity真正的根View，我们通过setContentView所添加的内容就是添加在该View上，</span></div><div class="line"><span class="comment">// 它实际上就是一个FrameLayout</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);<span class="comment">//FrameLayout.dispatchTouchEvent</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此我们已经至少明白了以下几点：</p>
<p>1、我们可以重载Activity的onUserInteraction方法，在Down事件触发传递前，实现我们的一些需求，实际上源码中有很多这样的方法，再某个方法体的第一行提供一个空实现的回调方法，在某个方法的最后一行提供一个空实现的回调方法，以便子类去实现自己的逻辑，例如AsyncTask就有类似的方式。这些技巧都能很好的提高我们代码的扩展性。</p>
<p>2、Activity会间接的调用根View的dispatchTouchEvent，并通过if判断返回值，如果为true，即向上层返回true，也就是调用Activity的dispatchTouchEvent的WMS，即操作系统。</p>
<p>3、如果if判断为false，即根View和根View下的所有子View均为消费掉该事件，那么下面的代码就有执行机会，即Activity的onTouchEvent，并把该方法的返回值作为结果返回给上层。</p>
<h2 id="3-1-View的dispatchTouchEvent"><a href="#3-1-View的dispatchTouchEvent" class="headerlink" title="3.1 View的dispatchTouchEvent"></a><strong>3.1 View的dispatchTouchEvent</strong></h2><p><img src="http://img.blog.csdn.net/20170302184634662?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>View中的处理相当简单明了，因为不涉及到子View，所以只在自身内部进行分发。首先判断是否设置了触摸监听，并且可以响应事件，就交由监听的onTouch处理。如果上述条件不成立，或者监听的onTouch事件没有消费掉该事件，则交由onTouchEvent进行处理，并把返回结果交给上层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;</div><div class="line">            mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">        <span class="comment">//判断mOnTouchListener是否存在，并且控件可点的情况下，执行onTouch，如果onTouch返回true，就消耗该事件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果以上条件都不成立，则把事件交给onTouchEvent来处理</span></div><div class="line">    <span class="keyword">return</span> onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-2-ViewGroup的dispatchTouchEvent"><a href="#3-2-ViewGroup的dispatchTouchEvent" class="headerlink" title="3.2 ViewGroup的dispatchTouchEvent"></a><strong>3.2 ViewGroup的dispatchTouchEvent</strong></h2><p><img src="http://img.blog.csdn.net/20170302183800394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="3-3-Down事件"><a href="#3-3-Down事件" class="headerlink" title="3.3 Down事件"></a>3.3 Down事件</h2><ul>
<li>通过onInterceptTouchEvent方法判断是否要拦截事件，默认fasle</li>
<li>根据scroll换算后的坐标找出所接受的子View。有动画的子View将不接受触摸事件。</li>
<li>找到能接受的子View后把event中的坐标转换成子View的坐标</li>
<li>调用子View的dispatchTouchEvent把事件传递给子View。</li>
<li>如果子View消费了该事件，则把target记录为子View，方便后面的Move和Up事件的传递。</li>
<li>如果子View没有消费，则继续寻找下一个子View。</li>
<li>如果没找到，或者找到的子View都不消费，就会调用View的dispatchTouchEvent的逻辑，也就是判断是否有触摸监听，有的话交给监听的onTouch处理，没有的话交给自己的onTouchEvent处理</li>
</ul>
<p>接下来我们来研究ViewGroup的dispatchTouchEvent，这是稍微复杂的分发逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();<span class="comment">//获取事件</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> xf = ev.getX();<span class="comment">//获取触摸坐标</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> yf = ev.getY();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scrolledXFloat = xf + mScrollX;<span class="comment">//获取当前需要偏移的偏移量量</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scrolledYFloat = yf + mScrollY;</div><div class="line">    <span class="keyword">final</span> Rect frame = mTempRect;    <span class="comment">//当前ViewGroup的视图矩阵</span></div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;<span class="comment">//是否禁止拦截</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;<span class="comment">//如果事件是按下事件</span></div><div class="line">        <span class="keyword">if</span> (mMotionTarget != <span class="keyword">null</span>) &#123;    <span class="comment">//判断接受事件的target是否为空</span></div><div class="line">            <span class="comment">//不为空肯定是不正常的，因为一个事件是由DOWN开始的，而DOWN还没有被消费，所以目标也不是不可能被确定，</span></div><div class="line">            <span class="comment">//造成这个的原因可能是在上一次up事件或者cancel事件的时候，没有把目标赋值为空</span></div><div class="line">            mMotionTarget = <span class="keyword">null</span>;    <span class="comment">//在此处挽救</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//不允许拦截，或者onInterceptTouchEvent返回false，也就是不拦截。注意，这个判断都是在DOWN事件中判断</span></div><div class="line">        <span class="keyword">if</span> (disallowIntercept || !onInterceptTouchEvent(ev)) &#123;</div><div class="line">            <span class="comment">//从新设置一下事件为DOWN事件，其实没有必要，这只是一种保护错误，防止被篡改了</span></div><div class="line">            ev.setAction(MotionEvent.ACTION_DOWN);</div><div class="line">            <span class="comment">//开始寻找能响应该事件的子View</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrolledXInt = (<span class="keyword">int</span>) scrolledXFloat;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> scrolledYInt = (<span class="keyword">int</span>) scrolledYFloat;</div><div class="line">            <span class="keyword">final</span> View[] children = mChildren;</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                <span class="keyword">final</span> View child = children[i];</div><div class="line">                <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE</div><div class="line">                        || child.getAnimation() != <span class="keyword">null</span>) &#123;<span class="comment">//如果child可见，或者有动画，获取该child的矩阵</span></div><div class="line">                    child.getHitRect(frame);</div><div class="line">                    <span class="keyword">if</span> (frame.contains(scrolledXInt, scrolledYInt)) &#123;</div><div class="line">                        <span class="comment">// 设置系统坐标</span></div><div class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - child.mLeft;</div><div class="line">                        <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - child.mTop;</div><div class="line">                        ev.setLocation(xc, yc);</div><div class="line">                        <span class="keyword">if</span> (child.dispatchTouchEvent(ev))  &#123;<span class="comment">//调用child的dispatchTouchEvent</span></div><div class="line">                            <span class="comment">//如果消费了，目标就确定了，以便接下来的事件都传递给child</span></div><div class="line">                            mMotionTarget = child;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//事件消费了，返回true</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//能到这里来，证明所有的子View都没消费掉Down事件，那么留给下面的逻辑进行处理</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断是不是up或者cancel事件</span></div><div class="line">    <span class="keyword">boolean</span> isUpOrCancel = (action == MotionEvent.ACTION_UP) ||</div><div class="line">            (action == MotionEvent.ACTION_CANCEL);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isUpOrCancel) &#123;</div><div class="line">        <span class="comment">//如果是取消，把禁止拦截这个标志位给取消</span></div><div class="line">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">final</span> View target = mMotionTarget;</div><div class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//判断该值是否为空，如果为空，则没找到能响应的子View，那么直接调用super的dispatchTouchEvent，也就是View的dispatchTouchEvent</span></div><div class="line">        ev.setLocation(xf, yf);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//能走到这里来，说明已经有target，那也说明，这里不是DOWN事件，因为DOWN事件如果有target，已经在前面返回了，执行不到这里</span></div><div class="line">    <span class="keyword">if</span> (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;<span class="comment">//如果有目标，又非要拦截，则给目标发送一个cancel事件</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - (<span class="keyword">float</span>) target.mLeft;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - (<span class="keyword">float</span>) target.mTop;</div><div class="line">        ev.setAction(MotionEvent.ACTION_CANCEL);<span class="comment">//该为cancel</span></div><div class="line">        ev.setLocation(xc, yc);</div><div class="line">        <span class="keyword">if</span> (!target.dispatchTouchEvent(ev)) &#123;</div><div class="line">            <span class="comment">//调用子View的dispatchTouchEvent，就算它没有消费这个cancel事件，我们也无能为力了。</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//清除目标</span></div><div class="line">        mMotionTarget = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">//有目标，又拦截，自身也享受不了了，因为一个事件应该由一个View去完成</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//直接返回true，以完成这次事件，好让系统开始派发下一次</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isUpOrCancel) &#123;<span class="comment">//取消或者UP的话，把目标赋值为空，以便下一次DOWN能重新找，此处就算不赋值，下一次DOWN也会先把它赋值为空</span></div><div class="line">        mMotionTarget = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//又不拦截，又有目标，那么就直接调用目标的dispatchTouchEvent</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> xc = scrolledXFloat - (<span class="keyword">float</span>) target.mLeft;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span> yc = scrolledYFloat - (<span class="keyword">float</span>) target.mTop;</div><div class="line">    ev.setLocation(xc, yc);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> target.dispatchTouchEvent(ev);</div><div class="line">    <span class="comment">//也就是说，如果是DOWN事件，拦截了，那么每次一次MOVE或者UP都不会再判断是否拦截，直接调用super的dispatchTouchEvent</span></div><div class="line">    <span class="comment">//如果DOWN没拦截，就是有其他View处理了DOWN事件，那么接下来的MOVE或者UP事件拦截了，那么给目标View发送一个cancel事件，告诉它touch被取消了，并且自身也不会处理，直接返回true</span></div><div class="line">    <span class="comment">//这是为了不违背一个Touch事件只能由一个View处理的原则。</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-4-Move和Up事件"><a href="#3-4-Move和Up事件" class="headerlink" title="3.4 Move和Up事件"></a>3.4 Move和Up事件</h2><p>判断事件是否被取消或者事件是否要拦截住，是的话，给Down事件找到的target发送一个取消事件。如果不取消，也不拦截，并且Down已经找到了target，则直接交给target处理，不再遍历子View寻找合适的View了。这种处理事件是正确的，我们用手机经常可以体会到，当我手指按在一个拖动条上之后，在拖动的时候手指就算移出了拖动条，依然会把事件分发给拖动条控制它的拖动。</p>
<h1 id="4-onInterceptTouchEvent"><a href="#4-onInterceptTouchEvent" class="headerlink" title="4. onInterceptTouchEvent"></a><strong>4. onInterceptTouchEvent</strong></h1><p>ViewGroup的方法，事件拦截，return true表示拦截触摸事件，事件就不往下传递</p>
<p>子View可以调用getParent().requestDisallowInterceptTouchEvent( true ) 请求父控件不拦截touch事件</p>
<h1 id="5-View的onTouchEvent"><a href="#5-View的onTouchEvent" class="headerlink" title="5. View的onTouchEvent"></a><strong>5. View的onTouchEvent</strong></h1><p>从View的dispatchTouchEvent可以看出，事件最终的处理无非是交给TouchListener的onTouch方法或者是交由onTouchEvent处理，由于onTouch默认是空实现，由程序员来编写逻辑，那么我们来看看onTouchEvent事件。View只能响应click和longclick，不具备滑动等特性。</p>
<p>Down时，设置按压状态，发送一个延迟500毫秒的长按事件。<br>Move时，判断是否移出了View，移出后移除按压状态，长按事件。<br>Up时，取消按压，并判断它是否可以通过触摸获取焦点，是的话设置焦点，判断长按事件是否执行了，如果还没执行，就删除，并执行点击事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</div><div class="line">    <span class="comment">//先判断标示位是否为disable，也就是无法处理事件。</span></div><div class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">            setPressed(<span class="keyword">false</span>);</div><div class="line">        &#125;<span class="comment">//如果是UP事件，并且状态为按压，取消按压。</span></div><div class="line">        <span class="comment">//系统源码解释：虽然是disable，但是还是可以消费掉触摸事件，只是不触发任何click或者longclick事件。</span></div><div class="line">        <span class="comment">//根据是否可点击,可长按来决定是否消费点击事件。</span></div><div class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//先检查触摸的代理对象是否存在，如果存在，就交由代理对象处理。</span></div><div class="line">        <span class="comment">// 触摸代理对象是可以进行设置的，一般用于当我们手指在某个View上，而让另外一个View响应事件，另外一个View就是该View的事件代理对象。</span></div><div class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;<span class="comment">//如果代理对象消费了，则返回true消费该事件</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class="line">        <span class="comment">//如果是可点击或者长按的标识位执行下面的逻辑，这些标志位可以设置，也可以设置了对应的listener后自动添加</span></div><div class="line">        <span class="comment">//因为作为一个View，它只能单纯的接受处理点击事件，像滑动之类的复杂事件普通View是不具备的。</span></div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:<span class="comment">//处理Up事件</span></div><div class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;<span class="comment">//是否包含临时按压状态</span></div><div class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;<span class="comment">//如果本身处于被按压状态或者临时按压状态</span></div><div class="line">                    <span class="comment">//临时按压状态会在下面的Move事件中说明</span></div><div class="line">                    <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                        <span class="comment">//如果它可以获取焦点，并且可以通过触摸来获取焦点，并且现在不是焦点，则请求获取焦点，因为一个被按压的View理论上应该获取焦点</span></div><div class="line">                        focusTaken = requestFocus();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                        <span class="comment">//如果是临时按压，则设置为按压状态，PFLAG_PREPRESSED是一个非常短暂的状态，用于在某些时候短时间内表示Pressed状态，但不需要绘制</span></div><div class="line">                        setPressed(<span class="keyword">true</span>);<span class="comment">//设置为按压状态，是因为临时按压不会绘制，这个时候强制绘制一次，确保用户能够看见按压状态</span></div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</div><div class="line">                        <span class="comment">//是否执行了长按事件，还没有的话，这个时候可以移除长按的回调了，因为UP都已经触发，说明从按下到UP的时间不足以触发longPress</span></div><div class="line">                        <span class="comment">//至于longPress，会在Down事件中说明</span></div><div class="line">                        removeLongPressCallback();</div><div class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;<span class="comment">//如果是焦点状态，就不会触摸click，这是为什么呢？因为焦点状态一般是交给按键处理的，</span></div><div class="line">                            <span class="comment">//pressed状态才是交给触摸处理，如果它是焦点，那么它的click事件应该由按键来触发</span></div><div class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;    <span class="comment">//封装一个Runnable对象，这个对象中实际就调用了performClick();</span></div><div class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;<span class="comment">//向消息队列发生该runnabel，如果发送不成功，则直接执行该方法。</span></div><div class="line">                                performClick();<span class="comment">//这个方法内部会调用clickListner</span></div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">//为什么不直接执行呢？如果这个时候直接执行，UP事件还没执行完，发送post，可以保障在这个代码块执行完毕之后才执行</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;<span class="comment">//仍旧是创建一个Runnabel对象，执行setPressed(false)</span></div><div class="line">                        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                        <span class="comment">//如果是临时按压状态，之前的Down和move都还未触发按压状态，只在up时设置了，这个状态才刚刚绘制，为了保证用户能看到，发生一个64秒的延迟消息，来取消按压状态。                        postDelayed(mUnsetPressedState,</span></div><div class="line">                        ViewConfiguration.getPressedStateDuration());</div><div class="line">                        <span class="comment">//这是一个64毫秒的短暂时间，这是为了让这个按压状态持续一小段时间，以便手指离开时候，还能看见View的按压状态</span></div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;<span class="comment">//如果不是临时按压，则直接发送，发送失败，则直接执行</span></div><div class="line">                        mUnsetPressedState.run();</div><div class="line">                    &#125;</div><div class="line">                    removeTapCallback();</div><div class="line">                    <span class="comment">//移除这个callBack，这个callBack内部就是把临时按压状态设置成按压状态，因为这个已经没必要了，手指已经up了</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line">                <span class="comment">//按下事件把长按事件执行的变量设置为false，代表还没执行长按，因为才按下，表示新的一个长按事件可以开始计算了</span></div><div class="line">                <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                    <span class="comment">//先把这个事件交由该方法，该方法内部会判断是否为上下文的菜单按钮，或者是否为鼠标右键，如果是就弹出上下文菜单。</span></div><div class="line">                    <span class="comment">//现在有些手机的上下文菜单按钮也是在屏幕触屏上的</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//这个方法会一直往上找父View，判断自身是否在一个可以滚动的容器中</span></div><div class="line">                <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class="line">                <span class="comment">//如果是在一个滚动的容器中，那么按压事件将会被推迟一段时间，如果这段时间内，发生了Move，那么按压状态讲不会被显示，直接滚动父视图</span></div><div class="line">                <span class="keyword">if</span> (isInScrollingContainer) &#123;</div><div class="line">                    mPrivateFlags |= PFLAG_PREPRESSED; <span class="comment">//先添加临时的按压状态，该状态表示按压，但不会绘制</span></div><div class="line">                    <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</div><div class="line">                        mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</div><div class="line">                        <span class="comment">//创建一个runnable对象，这个runnable内部会取消临时按压状态，设置为按压状态，并启动长按的延迟事件</span></div><div class="line">                    &#125;</div><div class="line">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">                    <span class="comment">//向消息机制发生一个64毫秒的延迟时间，该事件会取消临时按压状态，设置为直接按压，并启动长按时间的计时</span></div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//如果不在一个滚动的容器中，则直接设置按压状态，并启动长按计时</span></div><div class="line">                    setPressed(<span class="keyword">true</span>);</div><div class="line">                    checkForLongClick(<span class="number">0</span>);</div><div class="line">                    <span class="comment">//长按事件就是向消息机制发送一个runnable对象，封装的就是我们在lisner中的代码，延迟500毫秒执行，也就是说长按事件在我们按下的时候发送，在up的时候检查一下执行了吗？如果没执行，就取消，并执行click</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: <span class="comment">//如果是取消事件，那就好办了，把我们之前发送的几个延迟runnable对象给取消掉</span></div><div class="line">                setPressed(<span class="keyword">false</span>);      <span class="comment">//设置为非按压状态</span></div><div class="line">                removeTapCallback();    <span class="comment">//取消mPendingCheckForTap，也就是不用再把临时按压设置为按压了</span></div><div class="line">                removeLongPressCallback();    <span class="comment">//取消长按事件的延迟回调</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:    <span class="comment">//move事件</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();    <span class="comment">//取触摸点坐标</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</div><div class="line">                <span class="comment">// 用于判断是否在View中，为什么还要判断呢？</span></div><div class="line">                <span class="comment">//这是因为父View是在Down事件中判断是否在该View中的，如果在，以后的Move和up都会传递过来，不再进行范围判断</span></div><div class="line">                <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                    <span class="comment">//mTouchSlop是一个常量，数值为8,也就是说，就算你的落点超出了View的8像素位置，也算在View中。</span></div><div class="line">                    <span class="comment">//是因为人的手指触摸点比较大，有可能你感觉点在某个控件的边缘，但是实际落点已经超出这个View，所以这里给了8像素的范围</span></div><div class="line">                    removeTapCallback();<span class="comment">//如果在范围外，就移除这些runnable回调</span></div><div class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">                        <span class="comment">//如果是按压状态，就取消长按，设置为非按压状态，为什么这个时候取消呢，因为在Down的时候，我们可以知道，只有是按压状态，才会设置长按</span></div><div class="line">                        removeLongPressCallback();</div><div class="line">                        setPressed(<span class="keyword">false</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//至此，可以返回true，消费该事件</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;    <span class="comment">//如果不可点击，也不可长按，则返回false，因为View只具备消费点击事件</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码我们总结一下View对触摸事件的处理：</p>
<p>1、是否为diabale，如果是，直接根据是否设置了click和longclick来返回。<br>2、是否设置了触摸代理对象，如果有，把事件传递给触摸代理对象，交由其处理，如果消费了，直接返回<br>3、是否为click或者longclick的，如果是，返回true，不是返回false。</p>
<p>而View对click和longclick的处理如下：</p>
<p>Down：</p>
<ul>
<li>判断是否可以触摸上下文菜单。</li>
<li>是否在可以滑动的容器中，如果是先设置临时按压，再发送一个延迟消息把临时按压改为按压，并发送一个延迟500毫秒的事件去执行长按代码</li>
<li>如果不在滚动容器中，直接设置按压状态，并发送一个延迟500毫秒的事件去执行长按代码。</li>
</ul>
<p>Move：</p>
<ul>
<li>取触摸点坐标判断是否在View中（额外增加了8像素的范围）</li>
<li>如果在，不用做任何事。</li>
<li>如果不在，取消临时按压到按压回调，取消长按延迟回调，设置为非按压状态</li>
</ul>
<p>Up</p>
<ul>
<li>判断是否为按压或者临时按压状态</li>
<li>如果不是，不做任何处理</li>
<li>如果是先判断其是否可以获取焦点，然后请求焦点。</li>
<li>如果是临时按压状态，设置临时按压状态为按压状态。保证界面被绘制成按压状态，让用户可以看见。</li>
<li>如果长按回调还未触发，取消长按回调，如果不是焦点状态，触发click事件。</li>
<li>如果是临时按压状态，发送一个延迟取消按压状态的，保证按压状态持续一段时间，让用户可见。</li>
<li>如果不是临时按压状态，直接发送消息取消按压状态。发送失败，直接取消按压状态。</li>
<li>取消把临时按压设置按压的回调。</li>
</ul>
<p>从中我们知道View的onTouchEvent主要处理了click和longclick事件，当按下时，向消息机制发送一个延迟500毫秒的长按回调事件，当移动时候判断是否移出了View的范围，超出则取消事件。当离开时，判断长按事件是否触发了，如果没触发且不是焦点，就触发click事件。</p>
<p>在这里最绕的就是临时按压和按压状态，临时按压是为了处理滑动容器的，让处于滑动容器中，按下时，我们先设置的是临时按压，持续64毫秒，是为了判断接下来的时间内是否发生了move事件，如果发生了，将不会再出发按压状态，这样不会让用户看到listView滚动时，item还处于按压状态。在离开时，我们再次判断是否处于临时按压，如果是在64毫秒内触发了down和up，说明按压状态还没来得急绘制，则强制设置为按压状态，保证用户能看到，并在取消回调的方法上加上64毫秒的延迟</p>
<h1 id="6-onTouch与onClick"><a href="#6-onTouch与onClick" class="headerlink" title="6. onTouch与onClick"></a><strong>6. onTouch与onClick</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ImageView iv_image = (ImageView) findViewById(R.id.iv_image);</div><div class="line">iv_image.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>点击ImageView的时候只会打印一次，因为onTouch()返回false，只传递down事件，不会传递up事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out: iv_image---onTouch--0</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ImageView天生不能被点击，没有点击事件</span></div><div class="line">ImageView iv_image = (ImageView) findViewById(R.id.iv_image);</div><div class="line">iv_image.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 把返回值改为true </span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>把onTouch()方法返回值改为true，点击ImageView会打印两次（down and up）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out: iv_image---onTouch--0</div><div class="line">System.out: iv_image---onTouch--1</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ImageView iv_image = (ImageView) findViewById(R.id.iv_image);</div><div class="line">iv_image.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//添加click事件</span></div><div class="line">iv_image.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onClick"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>还是打印两次，onTouch()返回true，click事件并不会得到执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ImageView iv_image = (ImageView) findViewById(R.id.iv_image);</div><div class="line">iv_image.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">iv_image.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"iv_image---onClick"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>打印三次，两次touch事件（down and up）和一次click事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"button---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>点击Button会打印两次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"button---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"button---onClick"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>打印两次，因为onTouch()返回true，不会执行onTouchEvent()，而click事件是在onTouchEvent()中执行，所以也不会执行click事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Button button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"button---onTouch--"</span> + event.getAction());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"button---onClick"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>打印三次<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mOnTouchListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;</div><div class="line">            mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>a 判断mOnTouchListener是否为null<br>b 判断当前的控件是否可用<br>c 判断view的onTouch。<br>d 如果以上一个返回为false。那么就会调用onTouchEvent</p>
<p>首先判断mOnTouchListener不为null，并且view是enable的状态，然后 mOnTouchListener.onTouch(this, event)返回true，这三个条件如果都满足，直接return true ; 也就是下面的onTouchEvent(event）不会被执行了。如果我们设置了setOnTouchListener，并且return true，那么View自己的onTouchEvent就不会被执行了</p>
<p>onTouch是优先于onClick执行, onClick的调用在onTouchEvent(event)方法中</p>
<p>view的事件分发</p>
<ol>
<li>返回true，说明可以响应down事件和up事件</li>
<li>返回false，只会响应down事件。不会响应up事件。在down事件如果能消费(处理)当前事件。那么在up的时候也会把事件传递给当前的view，在down事件处理不了当前事件。那么在up的时候。也不会把事件传递给当前的view</li>
</ol>
<p>模拟点击事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createClick</span><span class="params">(<span class="keyword">final</span> View v)</span> </span>&#123;</div><div class="line">	<span class="number">08</span>-<span class="number">23</span> <span class="number">03</span>:<span class="number">22</span>:<span class="number">35.028</span>: I/System.out(<span class="number">1652</span>): x轴坐标---<span class="number">151.0</span>--y轴坐标---<span class="number">218.0</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="number">151</span>;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> y = <span class="number">218</span>;</div><div class="line">	<span class="keyword">long</span> downTime = System.currentTimeMillis();</div><div class="line">	MotionEvent motionEventDown = MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_DOWN, x, y, <span class="number">0</span>);</div><div class="line">	v.dispatchTouchEvent(motionEventDown);</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">long</span> upTime = System.currentTimeMillis();</div><div class="line">			MotionEvent motionEventUp = MotionEvent.obtain(upTime, upTime, MotionEvent.ACTION_UP, x, y, <span class="number">0</span>);</div><div class="line">			v.dispatchTouchEvent(motionEventUp);</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">	&#125;, <span class="number">200</span>);</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://blog.csdn.net/axi295309066/article/details/60139074" target="_blank" rel="external">Android的事件分发实例分析</a></p>
<h1 id="7-ScrollView的onTouchEvent"><a href="#7-ScrollView的onTouchEvent" class="headerlink" title="7. ScrollView的onTouchEvent"></a><strong>7. ScrollView的onTouchEvent</strong></h1><p>普通的ViewGroup并没有对onTouchEvent事件做处理，只有可以滚动的才有，我们可以分析一下ScrollView</p>
<ul>
<li><p>Down时，判断落点是否在子View中，不再就不处理，因为ScrollView只有一个子View。</p>
</li>
<li><p>Move时，通过对比本次手指的位置和上一次的位置的距离，计算出Y方向的差值，然后用scorllBy进行滚动视图</p>
</li>
<li><p>Up时，通过速度进行fling，这里利用了两个帮助类，一个是计算速度的帮助类VelocityTracker，一个是滚动的帮助类Scroller</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.getEdgeFlags() != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//如果是down事件，并且触摸到边缘，就不处理EdgeFlags代表是否为边缘，其值是1/2/4/8。代表上下左右</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">//这是一个追踪触摸事件，并计算速度的帮助类，实现原理就是用三个数组分别记录每次触摸的x/y和时间</span></div><div class="line">        mVelocityTracker = VelocityTracker.obtain();</div><div class="line">    &#125;</div><div class="line">    mVelocityTracker.addMovement(ev);</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</div><div class="line">    <span class="keyword">switch</span> (action &amp; MotionEvent.ACTION_MASK) &#123;<span class="comment">//与上ff，去掉高位有关多点的信息</span></div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;<span class="comment">//如果是down</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY();<span class="comment">//获取y坐标</span></div><div class="line">            <span class="keyword">if</span> (!(mIsBeingDragged = inChild((<span class="keyword">int</span>) ev.getX(), (<span class="keyword">int</span>) y))) &#123;<span class="comment">//判断是否开始拖动</span></div><div class="line">                <span class="comment">//原理就是判断落点是否在child中，ScrollView只能由一个child，如果在，返回true，反之false</span></div><div class="line">                <span class="comment">//也就是说落点在child中，就是准备开始拖动，不在，就直接返回，这可能是因为设置了padding之类的缘故造成的</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!mScroller.isFinished()) &#123;<span class="comment">//判断滚动是否完成</span></div><div class="line">                mScroller.abortAnimation();<span class="comment">//如果没完成，停止滚动</span></div><div class="line">                <span class="comment">//对应上一次用户手指离开时候处理fling状态，这次按下手指，直接停止滚动</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//记录y坐标，以便下次事件来对比</span></div><div class="line">            mLastMotionY = y;</div><div class="line">            mActivePointerId = ev.getPointerId(<span class="number">0</span>);<span class="comment">//记住多点的id，下次取值时只取该点的</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">            <span class="keyword">if</span> (mIsBeingDragged) &#123;<span class="comment">//可以看出，如果down的时候落点在child外，则以后就算滑进了child也不处理</span></div><div class="line">                <span class="comment">//根据上次记录的多点id，找到对应的点，取y值</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> activePointerIndex = ev.findPointerIndex(mActivePointerId);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(activePointerIndex);</div><div class="line">                <span class="keyword">final</span> <span class="keyword">int</span> deltaY = (<span class="keyword">int</span>) (mLastMotionY - y);<span class="comment">//计算位移</span></div><div class="line">                mLastMotionY = y;<span class="comment">//重新记录y值</span></div><div class="line">                scrollBy(<span class="number">0</span>, deltaY);<span class="comment">//滚动指定的距离，这也说明了ScrollView只具备纵向滑动</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">            <span class="keyword">if</span> (mIsBeingDragged) &#123;<span class="comment">//如果是离开事件</span></div><div class="line">                <span class="keyword">final</span> VelocityTracker velocityTracker = mVelocityTracker;</div><div class="line">                velocityTracker.computeCurrentVelocity(<span class="number">1000</span>, mMaximumVelocity);<span class="comment">//计算最后1秒钟内的速度，并给定一个最大速度进行限制</span></div><div class="line">                <span class="comment">//这个最大速度是根据屏幕密度不同而不同的，所以大家也没事别使劲滑动屏幕，因为有这个最大速度限制</span></div><div class="line">                <span class="comment">//获取y方向的速度</span></div><div class="line">                <span class="keyword">int</span> initialVelocity = (<span class="keyword">int</span>) velocityTracker.getYVelocity(mActivePointerId);</div><div class="line">                <span class="keyword">if</span> (getChildCount() &gt; <span class="number">0</span> &amp;&amp; Math.abs(initialVelocity) &gt; mMinimumVelocity) &#123;</div><div class="line">                    <span class="comment">//如果有子View，并且计算出来的y的速度比最小速度要大，执行fling状态</span></div><div class="line">                    <span class="comment">//手指滑动的方向和屏幕移动的方向是相反的，所以这里加-</span></div><div class="line">                    fling(-initialVelocity);</div><div class="line">                &#125;</div><div class="line">                mActivePointerId = INVALID_POINTER;<span class="comment">//给mActivePointerId重新赋值为-1，防止下次事件找到了错误的点</span></div><div class="line">                mIsBeingDragged = <span class="keyword">false</span>;<span class="comment">//恢复默认值</span></div><div class="line">                <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;<span class="comment">//清空速度计算帮助类</span></div><div class="line">                    mVelocityTracker.recycle();</div><div class="line">                    mVelocityTracker = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">            <span class="keyword">if</span> (mIsBeingDragged &amp;&amp; getChildCount() &gt; <span class="number">0</span>) &#123;<span class="comment">//判断条件，只有这2个条件成立，才会发生滚动事件，下面的值才会被改变，才需要恢复默认</span></div><div class="line">                mActivePointerId = INVALID_POINTER;</div><div class="line">                mIsBeingDragged = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;</div><div class="line">                    mVelocityTracker.recycle();</div><div class="line">                    mVelocityTracker = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_UP:<span class="comment">//多点触摸时，不是最后一个点离开</span></div><div class="line">            onSecondaryPointerUp(ev);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//用于应对先按下1点，然后按下2点，1点离开后，2点仍能继续滑动的逻辑</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onSecondaryPointerUp</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt;</div><div class="line">            MotionEvent.ACTION_POINTER_INDEX_SHIFT;<span class="comment">//首先对高位进行与操作，然后右移8位，获取其高位代表index的值</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pointerId = ev.getPointerId(pointerIndex);<span class="comment">//取出该点的id</span></div><div class="line">    <span class="keyword">if</span> (pointerId == mActivePointerId) &#123;<span class="comment">//如果这个id对应的就是第一个按下的点</span></div><div class="line">        <span class="comment">//理论上pointerIndex应该是0，所以用第二个按下的点，即1index的点代替</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> newPointerIndex = pointerIndex == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">        mLastMotionY = ev.getY(newPointerIndex);<span class="comment">//取出新点的y坐标</span></div><div class="line">        mActivePointerId = ev.getPointerId(newPointerIndex);<span class="comment">//记录新点的id</span></div><div class="line">        <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;<span class="comment">//清空之前存入的MotionEvent，也就是说最后的速度只计算该点产生的</span></div><div class="line">            mVelocityTracker.clear();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过以上分析，我们得出以下知识：</p>
<ul>
<li>在down事件的时候先判断触摸是否处于边缘，如果是，则不处理</li>
<li>在down事件中判断落点是否在子View中，如果不在，不处理</li>
<li>在down事件中判断是否仍在滑动，如果是，先停止</li>
<li>记录第一个按下点的索引值</li>
<li>每次事件都记录住当前的y值</li>
<li>在move事件中通过记录的索引值找到对应的点，获取y坐标</li>
<li>与上一次y坐标进行比对，scrollBy两次的差值</li>
<li>在up事件的时候计算最后一秒钟的速度，并且有最大速度进行限制，当计算的速度大于系统默认的最小速度时，只想fling</li>
<li>up和cancel事件还原变量为默认值</li>
<li>如果为多点离开，进行多点离开的处理</li>
<li>该处理方式时：如果离开的是第一个按下的点，那么由第二个按下的点代替其进行y值偏移计算的基点，并清空速度计算的帮助类，重新记录MotionEvnet</li>
</ul>
<h1 id="8-Layout和Scroll的区别"><a href="#8-Layout和Scroll的区别" class="headerlink" title="8. Layout和Scroll的区别"></a><strong>8. Layout和Scroll的区别</strong></h1><ul>
<li>Layout中设置的是自身在父View中的显示区域</li>
<li>Scroll是调整自己的显示区域</li>
<li>当父View滚动或者layout变化后，自身在屏幕上的位置会发生变化。<br>当自身Scroll滚动后，在屏幕上的显示位置是不变的，变的只是自身的显示内容。</li>
<li>Scroll滚动不会影响Layout，只是在draw的时候影响画布偏移和触摸时的坐标计算。</li>
</ul>
<p><img src="http://img.blog.csdn.net/20170302181345556?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><img src="http://img.blog.csdn.net/20170302181357798?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><img src="http://img.blog.csdn.net/20170302181409595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/Android的消息机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋过冬漫长">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/Android的消息机制/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T23:57:10+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/30/Android的消息机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/30/Android的消息机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>title: Android的消息机制<br>categories: android<br>tags: 消息机制</p>
<h1 id="1-ANR异常"><a href="#1-ANR异常" class="headerlink" title="1. ANR异常"></a><strong>1. ANR异常</strong></h1><p>Application No Response：应用程序无响应。在主线程中，是不允许执行耗时的操作的，如果主线程阻塞的时间大于6秒，就很有可能出现anr异常。主线程，要完成界面的更新，事件的处理，窗体显示的回调，所以如果主线程阻塞时间较长，就不能很好的处理以上比较重要的事情，那么Android有一个机制，就是如果他发现消息队列中有很多消息，主线程没办法响应的话，他就会抛出anr异常。所以，比较耗时的操作都必须要交给子线程。</p>
<p>解决办法：可以通过Handler来解决这个问题，将比较耗时的操作交给子线程，然后子线程通过Handler，发送消息给主线程，让主线程去更新界面。什么样的操作时比较耗时的？</p>
<p>1、访问网络，2、大文件的拷贝，3、阻塞式的请求，socket</p>
<h1 id="2-Handler、Looper、Message、MessageQueue"><a href="#2-Handler、Looper、Message、MessageQueue" class="headerlink" title="2. Handler、Looper、Message、MessageQueue"></a><strong>2. Handler、Looper、Message、MessageQueue</strong></h1><p>Android 的Handler 机制（也有人叫消息机制）目的是为了跨线程通信，也就是多线程通信。之所以需要跨线程通信是因为在Android 中主线程通常只负责UI 的创建和修改，子线程负责网络访问和耗时操作，因此，主线程和子线程需要经常配合使用才能完成整个Android 功能。</p>
<p>在Android中，线程内部或者线程之间进行信息交互时经常会使用消息，这些基础的东西如果我们熟悉其内部的原理，将会使我们容易、更好地架构系统，避免一些低级的错误。在学习Android中消息机制之前，我们先了解与消息有关的几个类：</p>
<ul>
<li>Handler：消息处理器，发送消息和处理消息。你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里，或者接收Looper(从Message Queue取出)所送来的消息。</li>
<li>Looper：轮询器，从messagequeue取消息，分发给handler处理。一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)</li>
<li>Message 消息，数据的载体</li>
<li>MessageQueue 消息队列，存储消息</li>
</ul>
<p>当我们的Android应用程序的进程一创建的时候，系统就给这个进程提供了一个Looper，Looper是一个死循环，它内部维护这个一个消息队列。Looper不停地从消息队列中取消息（Message），取到消息就发送给了Handler，最后Handler根据接收到的消息去修改UI。Handler的sendMessage方法就是将消息添加到消息队列中。</p>
<h1 id="3-UI线程"><a href="#3-UI线程" class="headerlink" title="3. UI线程"></a><strong>3. UI线程</strong></h1><p>线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。</p>
<p>每一个线程里可含有一个Looper对象以及一个MessageQueue数据结构。在你的应用程序里，可以定义Handler的子类别来接收Looper所送出的消息。在你的Android程序里，新诞生一个线程，或执行 (Thread)时并不会自动建立其Message Looper。</p>
<p>Android里并没有Global的Message Queue数据结构，例如，不同APK里的对象不能透过Massage Queue来交换讯息(Message)。</p>
<p>例如：线程A的Handler对象可以传递消息给别的线程，让别的线程B或C等能送消息来给线程A(存于A的Message Queue里)。线程A的Message Queue里的消息，只有线程A所属的对象可以处理。使用Looper.myLooper()可以取得当前线程的Looper对象。可以自定义Handler类，只要继承Handler即可。使用new EventHandler(Looper.myLooper()); 可用来构造当前线程的Handler对象（其中EventHandler是自定义的Handler类）。</p>
<h1 id="4-Activity-runOnUiThread"><a href="#4-Activity-runOnUiThread" class="headerlink" title="4. Activity.runOnUiThread()"></a><strong>4. Activity.runOnUiThread()</strong></h1><p>Activity中提供了一个runOnUiThread方法，用于进行消息处理。此方法是通过线程合并join来实现消息处理的。<br>线程合并：主线程将子线程的任务拿到自己这里来执行并终止子线程。实例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Runs the specified action on the UI thread. If thecurrent thread is</div><div class="line"> * the UI thread, then the action is executedimmediately. If the</div><div class="line"> * current thread is not the UI thread, the action is posted to the</div><div class="line"> * event queue of the UI thread.</div><div class="line"> *</div><div class="line"> * 上面的意思为：在UI线程中运行我们的任务，如果当前线程是UI线程，则立即执行，如果</div><div class="line"> * 不是则该任务发送到UI线程的事件队列。 </div><div class="line"> */</div><div class="line">runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//自定义我们的业务代码</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="5-View-post-、View-postDelayed"><a href="#5-View-post-、View-postDelayed" class="headerlink" title="5. View.post()、View.postDelayed()"></a><strong>5. View.post()、View.postDelayed()</strong></h1><h1 id="6-Message消息"><a href="#6-Message消息" class="headerlink" title="6. Message消息"></a><strong>6. Message消息</strong></h1><p>消息对象，顾名思义就是记录消息信息的类。这个类有几个比较重要的字段：</p>
<ul>
<li>arg1和arg2：我们可以使用两个字段用来存放我们需要传递的整型值，在Service中，我们可以用来存放Service的ID。</li>
<li>obj：该字段是Object类型，我们可以让该字段传递某个多项到消息的接受者中。</li>
<li>what：这个字段可以说是消息的标志，在消息处理中，我们可以根据这个字段的不同的值进行不同的处理，类似于我们在处理Button事件时，通过switch(v.getId())判断是点击了哪个按钮。</li>
</ul>
<p>在使用Message时，我们可以通过new Message()创建一个Message实例，但是Android更推荐我们通过Message.obtain()或者Handler.obtainMessage()获取Message对象。这并不一定是直接创建一个新的实例，而是先从消息池中看有没有可用的Message实例，存在则直接取出并返回这个实例。反之如果消息池中没有可用的Message实例，则根据给定的参数new一个新Message对象。通过分析源码可得知，Android系统默认情况下在消息池中实例化10个Message对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建或获取消息的几种方式</span></div><div class="line">Message msg = <span class="keyword">new</span> Message();<span class="comment">// 创建一个新的消息对象</span></div><div class="line">Message msg = handler.obtainMessage();<span class="comment">// 获取一个消息，如果消息池存在消息，则复用消息池中的消息，否则新创建一个消息对象</span></div><div class="line">Message msg = Message.obtain();</div><div class="line">Message.obtain(handler, what, obj).sendToTarget();</div></pre></td></tr></table></figure>
<h1 id="7-MessageQueue消息队列"><a href="#7-MessageQueue消息队列" class="headerlink" title="7. MessageQueue消息队列"></a><strong>7. MessageQueue消息队列</strong></h1><p>消息队列，用来存放Message对象的数据结构，按照“先进先出”的原则存放消息。存放并非实际意义的保存，而是将Message对象以链表的方式串联起来的。MessageQueue对象不需要我们自己创建，而是有Looper对象对其进行管理，一个线程最多只可以拥有一个MessageQueue。我们可以通过Looper.myQueue()获取当前线程中的MessageQueue。</p>
<p>MessageQueue的管理者，在一个线程中，如果存在Looper对象，则必定存在MessageQueue对象，并且只存在一个Looper对象和一个MessageQueue对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</div><div class="line">	MessageQueue mQueue;<span class="comment">//Looper身上维持着一个消息队列</span></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Android系统中，除了主线程有默认的Looper对象，其它线程默认是没有Looper对象。如果想让我们新创建的线程拥有Looper对象时，我们首先应调用Looper.prepare()方法，然后再调用Looper.loop()方法。典型的用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> Handler mHandler;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        Looper.prepare();</div><div class="line">        <span class="comment">//其它需要处理的操作</span></div><div class="line">        Looper.loop();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>倘若我们的线程中存在Looper对象，则我们可以通过Looper.myLooper()获取，此外我们还可以通过Looper.getMainLooper()获取当前应用系统中主线程的Looper对象。在这个地方有一点需要注意，假如Looper对象位于应用程序主线程中，则Looper.myLooper()和Looper.getMainLooper()获取的是同一个对象。</p>
<h1 id="8-Handler消息处理器"><a href="#8-Handler消息处理器" class="headerlink" title="8. Handler消息处理器"></a><strong>8. Handler消息处理器</strong></h1><p>消息的处理者。通过Handler对象我们可以封装Message对象，然后通过sendMessage(msg)把Message对象添加到MessageQueue中；当MessageQueue循环到该Message时，就会调用该Message对象对应的handler对象的handleMessage()方法对其进行处理。由于是在handleMessage()方法中处理消息，因此我们应该编写一个类继承自Handler，然后在handleMessage()处理我们需要的操作。</p>
<p>下面我们通过跟踪代码分析在Android中是如何处理消息。首先贴上测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageService</span> <span class="keyword">extends</span> <span class="title">Service</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MessageService"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KUKA = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> Looper looper;</div><div class="line">    <span class="keyword">private</span> ServiceHandler handler;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 由于处理消息是在Handler的handleMessage()方法中，因此我们需要自己编写类</div><div class="line">     * 继承自Handler类，然后在handleMessage()中编写我们所需要的功能代码</div><div class="line">     * <span class="doctag">@author</span> coolszy</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span></span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">super</span>(looper);</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 根据what字段判断是哪个消息</span></div><div class="line">            <span class="keyword">switch</span> (msg.what)</div><div class="line">            &#123;</div><div class="line">            <span class="keyword">case</span> KUKA:</div><div class="line">                <span class="comment">//获取msg的obj字段。我们可在此编写我们所需要的功能代码</span></div><div class="line">                Log.i(TAG, <span class="string">"The obj field of msg:"</span> + msg.obj);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="comment">// other cases</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果我们Service已完成任务，则停止Service</span></div><div class="line">            stopSelf(msg.arg1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        Log.i(TAG, <span class="string">"MessageService--&gt;onCreate()"</span>);</div><div class="line">        <span class="comment">// 默认情况下Service是运行在主线程中，而服务一般又十分耗费时间，如果</span></div><div class="line">        <span class="comment">// 放在主线程中，将会影响程序与用户的交互，因此把Service</span></div><div class="line">        <span class="comment">// 放在一个单独的线程中执行</span></div><div class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"MessageDemoThread"</span>, Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">        thread.start();</div><div class="line">        <span class="comment">// 获取当前线程中的looper对象</span></div><div class="line">        looper = thread.getLooper();</div><div class="line">        <span class="comment">//创建Handler对象，把looper传递过来使得handler、</span></div><div class="line">        <span class="comment">//looper和messageQueue三者建立联系</span></div><div class="line">        handler = <span class="keyword">new</span> ServiceHandler(looper);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span></span></div><div class="line">    &#123;</div><div class="line">        Log.i(TAG, <span class="string">"MessageService--&gt;onStartCommand()"</span>);</div><div class="line">        <span class="comment">//从消息池中获取一个Message实例</span></div><div class="line">        Message msg = handler.obtainMessage();</div><div class="line">        <span class="comment">// arg1保存线程的ID，在handleMessage()方法中</span></div><div class="line">        <span class="comment">// 我们可以通过stopSelf(startId)方法，停止服务</span></div><div class="line">        msg.arg1 = startId;</div><div class="line">        <span class="comment">// msg的标志</span></div><div class="line">        msg.what = KUKA;</div><div class="line">        <span class="comment">// 在这里我创建一个date对象，赋值给obj字段</span></div><div class="line">        <span class="comment">// 在实际中我们可以通过obj传递我们需要处理的对象</span></div><div class="line">        Date date = <span class="keyword">new</span> Date();</div><div class="line">        msg.obj = date;</div><div class="line">        <span class="comment">// 把msg添加到MessageQueue中</span></div><div class="line">        handler.sendMessage(msg);</div><div class="line">        <span class="keyword">return</span> START_STICKY;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        Log.i(TAG, <span class="string">"MessageService--&gt;onDestroy()"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://img.blog.csdn.net/20170303152457864?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="消息机制"></p>
<p>注：在测试代码中我们使用了HandlerThread类，该类是Thread的子类，该类运行时将会创建looper对象，使用该类省去了我们自己编写Thread子类并且创建Looper的麻烦。下面我们分析下程序的运行过程：</p>
<h2 id="8-1-onCreate"><a href="#8-1-onCreate" class="headerlink" title="8.1 onCreate()"></a><strong>8.1 onCreate()</strong></h2><p>首先启动服务时将会调用onCreate()方法，在该方法中我们new了一个HandlerThread对象，提供了线程的名字和优先级。紧接着我们调用了start()方法，执行该方法将会调用HandlerThread对象的run()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    mTid = Process.myTid();</div><div class="line">    Looper.prepare();</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    Process.setThreadPriority(mPriority);</div><div class="line">    onLooperPrepared();</div><div class="line">    Looper.loop();</div><div class="line">    mTid = -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在run()方法中，系统给线程添加的Looper，同时调用了Looper的loop()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    Looper me = myLooper();</div><div class="line">    MessageQueue queue = me.mQueue;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">        <span class="comment">//if (!me.mRun) &#123;</span></div><div class="line">        <span class="comment">//    break;</span></div><div class="line">        <span class="comment">//&#125;</span></div><div class="line">        <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// No target is a magic identifier for the quit message.</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (me.mLogging!= <span class="keyword">null</span>) me.mLogging.println(</div><div class="line">                    <span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span></div><div class="line">                    + msg.callback + <span class="string">": "</span> + msg.what</div><div class="line">                    );</div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line">            <span class="keyword">if</span> (me.mLogging!= <span class="keyword">null</span>) me.mLogging.println(</div><div class="line">                    <span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to    "</span> + msg.target + <span class="string">" "</span></div><div class="line">                    + msg.callback);</div><div class="line">            msg.recycle();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过源码我们可以看到loop()方法是个死循环，将会不停的从MessageQueue对象中获取Message对象，如果MessageQueue 对象中不存在Message对象，则结束本次循环，然后继续循环；如果存在Message对象，则执行 msg.target.dispatchMessage(msg)，但是这个msg的.target字段的值是什么呢？我们先暂时停止跟踪源码，返回到onCreate()方法中。线程执行完start()方法后，我们可以获取线程的Looper对象，然后new一个ServiceHandler对象，我们把Looper对象传到ServiceHandler构造函数中将使handler、looper和messageQueue三者建立联系。</p>
<h2 id="8-2-onStartCommand"><a href="#8-2-onStartCommand" class="headerlink" title="8.2 onStartCommand()"></a><strong>8.2 onStartCommand()</strong></h2><p>执行完onStart()方法后，将执行onStartCommand()方法。首先我们从消息池中获取一个Message实例，然后给Message对象的arg1、what、obj三个字段赋值。紧接着调用sendMessage(msg)方法，我们跟踪源代码，该方法将会调用sendMessageDelayed(msg, 0)方法，而sendMessageDelayed()方法又会调用sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)方法，在该方法中我们要注意该句代码msg.target = this，msg的target指向了this，而this就是ServiceHandler对象，因此msg的target字段指向了ServiceHandler对象，同时该方法又调用MessageQueue 的enqueueMessage(msg, uptimeMillis)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.when != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(msg</div><div class="line">                + <span class="string">" This message is already in use."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span> &amp;&amp; !mQuitAllowed) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread not allowed to quit"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mQuiting) &#123;</div><div class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">            Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">            mQuiting = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        msg.when = when;</div><div class="line">        <span class="comment">//Log.d("MessageQueue", "Enqueing: " + msg);</span></div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            <span class="keyword">this</span>.notify();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Message prev = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">            &#125;</div><div class="line">            msg.next = prev.next;</div><div class="line">            prev.next = msg;</div><div class="line">            <span class="keyword">this</span>.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法主要的任务就是把Message对象的添加到MessageQueue中（数据结构最基础的东西，自己画图理解下）。</p>
<p>handler.sendMessage()–&gt;handler.sendMessageDelayed()–&gt;handler.sendMessageAtTime()–&gt;msg.target = this;queue.enqueueMessage==&gt;把msg添加到消息队列中</p>
<p><img src="http://img.blog.csdn.net/20170303151844350?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="handler"></p>
<h2 id="8-3-handleMessage-msg"><a href="#8-3-handleMessage-msg" class="headerlink" title="8.3 handleMessage(msg)"></a><strong>8.3 handleMessage(msg)</strong></h2><p>onStartCommand()执行完毕后我们的Service中的方法就执行完毕了，那么handleMessage()是怎么调用的呢？在前面分析的loop()方法中，我们当时不知道msg的target字段代码什么，通过上面分析现在我们知道它代表ServiceHandler对象，msg.target.dispatchMessage(msg);则表示执行ServiceHandler对象中的dispatchMessage()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法首先判断callback是否为空，我们跟踪的过程中未见给其赋值，因此callback字段为空，所以最终将会执行handleMessage()方法，也就是我们ServiceHandler类中复写的方法。在该方法将根据what字段的值判断执行哪段代码。</p>
<p>至此，我们看到，一个Message经由Handler的发送，MessageQueue的入队，Looper的抽取，又再一次地回到Handler的怀抱中。而绕的这一圈，也正好帮助我们将同步操作变成了异步操作。</p>
<h1 id="9-Handler的源码分析"><a href="#9-Handler的源码分析" class="headerlink" title="9. Handler的源码分析"></a><strong>9. Handler的源码分析</strong></h1><p>先看构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Looper       mLooper;</div><div class="line">    <span class="keyword">private</span> MessageQueue mQueue;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">        &#125;</div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Handler的构造方法中，调用Looper.myLooper()方法获取一个Looper对象，如果Looper对象为空，则会抛异常，没有Looper对象不能创建Handler对象。但是我们在主线程new Handler的时候，并没有调用Looper.prepare()和Looper.loop()方法初始化Looper，也不会出现异常，这是因为Android系统在主线程创建的时候帮我们把Looper初始化了</p>
<h2 id="9-1-主线程设置Looper，在ActivityThread类里面"><a href="#9-1-主线程设置Looper，在ActivityThread类里面" class="headerlink" title="9.1 主线程设置Looper，在ActivityThread类里面"></a><strong>9.1 主线程设置Looper，在ActivityThread类里面</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ....</div><div class="line">    <span class="comment">// 1.主线程创建Looper </span></div><div class="line">    Looper.prepareMainLooper();</div><div class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">        sMainThreadHandler = <span class="keyword">new</span> Handler();</div><div class="line">    &#125;</div><div class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">    thread.attach(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span> LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">    &#125;</div><div class="line">    Looper.loop();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MainThread 是Android 系统创建并维护的，创建的时候系统执行了Looper.prepare();方法，该方法内部创建了MessageQueue 消息队列（也叫消息池），该消息队列是Message 消息的容器，用于存储通过handler发送过来的Message。MessageQueue 是Looper 对象的成员变量，Looper 对象通过ThreadLocal 绑定在MainThread 中。因此我们可以简单的这么认为：MainThread 拥有唯一的一个Looper 对象，该Looper 对象有用唯一的MessageQueue 对象，MessageQueue 对象可以存储多个Message。</p>
<p>MainThread 中需要程序员手动创建Handler 对象，并覆写Handler 中的handleMessage(Message msg)方法，该方法将来会在主线程中被调用，在该方法里一般会写与UI 修改相关的代码。</p>
<p>MainThread 创建好之后，系统自动执行了Looper.loop();方法，该方法内部开启了一个“死循环”不断的去之前创建好的MessageQueue 中取Message。如果一有消息进入MessageQueue，那么马上会被Looper.loop();取出来，取出来之后就会调用之前创建好的handler 对象的handleMessage（Message）方法。</p>
<p>newThread 线程是我们程序员自定new 出来的子线程。在该子线程中处理完我们的“耗时”或者网络访问任务后，调用主线程中的handler 对象的sendMessage（msg）方法，该方法一被执行，内部将就msg添加到了主线程中的MessageQueue 队列中，这样就成为了Looper.loop()的盘中餐了，等待着被消费。</p>
<p>上面的过程有点类似生产者和消费者的过程。newThread 属于生产者，负责生产Message，MainThread 属于消费者。这是一个很复杂的过程，但是Android 显然已经将这种模式给封装起来了，就叫Handler 机制。我们使用时只需要在主线程中创建Handler，并覆写handler 中的handleMessage 方法，然后在子线程中调用handler 的sendMessage（msg）方法即可。</p>
<p>获取Looper对象后，接着获取Looper身上的MessageQueue对象，Handler就是把消息发送到该消息队列</p>
<p>Handler对象创建后，就可以通过handler.sendXxx()发送消息，可以发送一个普通的消息，也可以发送一个空消息，可以发送一个延时消息，也可以发送一个定时消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">	...</div><div class="line">	<span class="comment">// 发送一个普通消息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 发送一个空消息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 发送一个空的延时消息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = what;</div><div class="line">        <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 发送一个延时消息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (delayTime &lt; <span class="number">0</span>)</div><div class="line">            delayTime = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayTime);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 发送一个定时消息</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">        MessageQueue queue = mQueue;</div><div class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//发送消息几个方法sendXxx()，最终都是调用enqueueMessage()方法，消息入队</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">	    <span class="comment">// 把Message的target置为当前发送的Handler，以便Looper取到message后根据target把message分发给正确的Handler</span></div><div class="line">        msg.target = <span class="keyword">this</span>;</div><div class="line">        <span class="comment">// 往队列里面添加消息Message</span></div><div class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发送消息几个方法sendXxx()，最终都是调用enqueueMessage()方法，在该方法内部调用的是消息队列MessageQueue的enqueueMessage()方法，把消息发送到消息队列</p>
<p>把this，也就是当前handler对象赋值给Message 的target属性，当多个Handler发送消息到消息队列的时候，可以通过该属性判断消息是哪个Handler发送的</p>
<h2 id="9-2-MessageQueue-enqueueMessage"><a href="#9-2-MessageQueue-enqueueMessage" class="headerlink" title="9.2 MessageQueue.enqueueMessage"></a><strong>9.2 MessageQueue.enqueueMessage</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            ...</div><div class="line">            msg.markInUse();</div><div class="line">            msg.when = when;</div><div class="line">            Message p = mMessages;</div><div class="line">            <span class="keyword">boolean</span> needWake;</div><div class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">                <span class="comment">// 当前发送的message需要马上被处理调，needWake唤醒状态置true</span></div><div class="line">                msg.next = p;</div><div class="line">                mMessages = msg;</div><div class="line">                needWake = mBlocked;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 当前发送的message被排队到其他message的后面，needWake唤醒状态置false</span></div><div class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">                Message prev;</div><div class="line">                <span class="keyword">for</span> (; ; ) &#123;</div><div class="line">                    prev = p;</div><div class="line">                    p = p.next;</div><div class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                        needWake = <span class="keyword">false</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">                prev.next = msg;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (needWake) &#123; <span class="comment">// 是否唤醒主线程</span></div><div class="line">                nativeWake(mPtr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="9-3-Handler的post-、postAtTime-、postDelayed"><a href="#9-3-Handler的post-、postAtTime-、postDelayed" class="headerlink" title="9.3 Handler的post()、postAtTime()、postDelayed()"></a><strong>9.3 Handler的post()、postAtTime()、postDelayed()</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 把Runnable包装成一个消息Message</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">    Message m = Message.obtain();<span class="comment">// 获取消息对象</span></div><div class="line">    m.callback = r;<span class="comment">// 把消息赋值给Message的callback属性</span></div><div class="line">    <span class="keyword">return</span> m;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以调用Handler的post()、postAtTime()、postDelayed()分别发送一个普通的、定时、延时的Runnable任务，Runnable会赋值给Message的callback属性，最终封装成一个消息发送出去</p>
<h2 id="9-4-删除Callback和Message"><a href="#9-4-删除Callback和Message" class="headerlink" title="9.4 删除Callback和Message"></a><strong>9.4 删除Callback和Message</strong></h2><ul>
<li>Handler.removeCallbacks() 从消息队列中删除所有回调</li>
<li>Handler.removeMessages() 从消息队列删除所有消息</li>
<li>Handler.removeCallbacksAndMessages() 从消息队列中删除所有Message和Callback</li>
</ul>
<p>一般在Activity销毁的时候调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</div><div class="line">	handler.removeCallbacks();</div><div class="line">	handler.removeMessages();</div><div class="line">	handler.removeCallbacksAndMessages();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="10-Looper"><a href="#10-Looper" class="headerlink" title="10. Looper "></a><strong>10. Looper </strong></h1><p>轮询器，从messagequeue取消息，分发给handler处理。创建Handler对象，必须有Looper对象，而Looper对象的初始化需要调用Looper.prepare()和Looper.loop()方法</p>
<h2 id="10-1-Looper-prepare"><a href="#10-1-Looper-prepare" class="headerlink" title="10.1 Looper.prepare()"></a><strong>10.1 Looper.prepare()</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ThreadLocal&lt;Looper&gt; sThreadLocal;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 3、在主线程中设置Looper， new Looper()里面创建了一个MessageQueue</span></div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 2、调用prepare</span></div><div class="line">    prepare();</div><div class="line">    setMainLooper(myLooper());</div><div class="line">    <span class="keyword">if</span> (Process.supportsProcesses()) &#123;</div><div class="line">        myLooper().mQueue.mQuitAllowed = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先从ThreadLocal中获取一个Looper对象，如果该Looper对象不为空，则抛异常，这是因为一个线程仅能够绑定一个Looper对象。ThreadLocal是一个用于线程范围内共享数据的底层是一个map结构的类，key是当前线程，value是Looper。如果当前线程没有绑定Looper对象，则new Looper()创建一个Looper对象，并把该Looper对象设置sThreadLocal</p>
<h2 id="10-2-Looper-loop"><a href="#10-2-Looper-loop" class="headerlink" title="10.2 Looper.loop()"></a><strong>10.2 Looper.loop()</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    Looper me = myLooper(); <span class="comment">// 获取当前线程的Looper对象，为空则抛异常</span></div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    MessageQueue queue = me.mQueue; <span class="comment">// 获取Looper对象维持的消息队列</span></div><div class="line">    <span class="keyword">for</span> (; ; ) &#123; <span class="comment">// 开启死循环从消息队列获取消息</span></div><div class="line">        <span class="comment">// 调用MessageQueue的next()取消息，如果没有消息，就阻塞</span></div><div class="line">        Message msg = queue.next();</div><div class="line">        <span class="comment">// msg.target即Handler，获取消息后调用Handler的dispatchMessage()处理消息</span></div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主线程调用Looper.loop()方法,主线程就会阻塞，是一个死循环，使用管道（Pipe），是Linux中的一种进程间通信方式，使用了特殊的文件，有两个文件描述符（一个是读取，一个是写入）</p>
<p>应用场景；主进程拿着读取描述符等待读取，没有内容时就阻塞，另一个进程拿写入描述符去写内容，唤醒主进程，主进程拿着读取描述符读取到内容，继续执行。</p>
<p>Handler应用场景：Handler在主线程中创建，Looper会在死循环里等待取消息，1、没取到，就阻塞，2、一旦被子线程唤醒，取到消息，就把Message交给Handler处理。子线程用Handler去发送消息，拿写入描述符去写消息，唤醒主线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Looper.getMainLooper() == Looper.myLooper(); <span class="comment">// 判断是否在主线程</span></div><div class="line">Handler mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div></pre></td></tr></table></figure>
<h1 id="11-Handler-dispatchMessage"><a href="#11-Handler-dispatchMessage" class="headerlink" title="11. Handler.dispatchMessage"></a><strong>11. Handler.dispatchMessage</strong></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 把Message交给Handler处理</span></div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用Looper.loop()会开启一个死循环，从消息队列MessageQueue取消息，取到消息后调用msg.target.dispatchMessage(msg);即调用Handler的dispatchMessage()方法，在该方法内部调用的是handleMessage()，对，就是我们new Handler的时候实现的handleMessage()方法</p>
<p>所以Android的消息机制大概流程是：Handler把消息Message发送到消息队列MessageQueue，Looper从消息队列取消息，取到消息后回调Handler的handleMessage()方法</p>
<p><img src="http://img.blog.csdn.net/20170303172217572?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXhpMjk1MzA5MDY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="handler"></p>
<h2 id="11-1-消息处理的优先级"><a href="#11-1-消息处理的优先级" class="headerlink" title="11.1 消息处理的优先级"></a><strong>11.1 消息处理的优先级</strong></h2><p>在dispatchMessage()方法中，如果msg.callback（一个Runnable）不为空，则先处理Message的Runnable；然后判断mCallback（通过Handler的构造方法传进来的Callback）是否为空，不为空，则执行Callback的handleMessage()方法，最后才是执行Handler的handleMessage()</p>
<p>所有消息处理的优先级是Message的callback –&gt; Handler的mCallback –&gt; Handler的handleMessage()</p>
<h1 id="12-Handler机制的应用"><a href="#12-Handler机制的应用" class="headerlink" title="12. Handler机制的应用"></a><strong>12. Handler机制的应用</strong></h1><h2 id="12-1-在主线程中给子线程发送消息"><a href="#12-1-在主线程中给子线程发送消息" class="headerlink" title="12.1 在主线程中给子线程发送消息"></a>12.1 在主线程中给子线程发送消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Handler subHandler;<span class="comment">//是在子线程中创建的Handler对象</span></div><div class="line">	<span class="keyword">private</span> Looper  myLooper;<span class="comment">//子线程中的Looper对象</span></div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(android.os.Message msg)</span> </span>&#123;</div><div class="line">			<span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">			<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">				Toast.makeText(MainActivity.<span class="keyword">this</span>, msg.obj.toString(), Toast.LENGTH_SHORT).show();</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * 匿名内部类对象对外部类有一个隐式的强引用</div><div class="line">		 */</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// 1. 创建了Looper对象，然后Looper对象中创建了MessageQueue</span></div><div class="line">				<span class="comment">// 2. 并将当前的Looper对象跟当前的线程（子线程）绑定ThreadLocal</span></div><div class="line">				Looper.prepare();</div><div class="line"></div><div class="line">				<span class="comment">// 1. 创建了handler对象，然后从当前线程中获取Looper对象，然后获取到MessageQueue对象</span></div><div class="line">				subHandler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">						Toast.makeText(MainActivity.<span class="keyword">this</span>, msg.obj.toString(), Toast.LENGTH_SHORT).show();</div><div class="line">					&#125;</div><div class="line">				&#125;;</div><div class="line">				</div><div class="line">				myLooper = Looper.myLooper();<span class="comment">//获取当前线程中的Looper对象</span></div><div class="line">				</div><div class="line">				<span class="comment">/*</span></div><div class="line">				 * 1. 从当前线程中找到之前创建的Looper对象，然后找到 MessageQueue</div><div class="line">				 * 2. 开启死循环，遍历消息池中的消息</div><div class="line">				 * 3. 当获取到msg的时候，调用这个msg的handler的disPatchMsg方法，让msg执行起来</div><div class="line">				 */</div><div class="line">				Looper.loop();</div><div class="line">				Log.d(<span class="string">"tag"</span>, <span class="string">"loop()方法执行完了"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onDestroy();</div><div class="line">		<span class="keyword">if</span> (myLooper!=<span class="keyword">null</span>) &#123;</div><div class="line">			myLooper.quit();</div><div class="line">			myLooper = <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(View view)</span></span>&#123;</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				SystemClock.sleep(<span class="number">2000</span>);<span class="comment">//模拟一个耗时操作</span></div><div class="line">				Message msg = <span class="keyword">new</span> Message();</div><div class="line">				msg.what = <span class="number">1</span>;<span class="comment">//区分发送的消息</span></div><div class="line">				msg.obj = <span class="string">"来自子线程的问候"</span>;</div><div class="line">				handler.sendMessage(msg);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg2</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">		<span class="comment">//从消息池中获取一个旧的msg，如果没有重新创建消息</span></div><div class="line">		subHandler.obtainMessage(<span class="number">2</span>, <span class="string">"我是主线程发送来的祝福"</span>).sendToTarget();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="12-2-同线程内不同组件间的消息传递"><a href="#12-2-同线程内不同组件间的消息传递" class="headerlink" title="12.2 同线程内不同组件间的消息传递"></a>12.2 同线程内不同组件间的消息传递</h2><p>Looper类用来管理特定线程内对象之间的消息交换(MessageExchange)。你的应用程序可以产生许多个线程。而一个线程可以有许多个组件，这些组件之间常常需要互相交换讯息。如果有这种需要，您可以替线程构造一个Looper对象，来担任讯息交换的管理工作。Looper对象会建立一个MessageQueue数据结构来存放各对象传来的消息(包括UI事件或System事件等)。每一个线程里可含有一个Looper对象以及一个MessageQueue数据结构。在你的应用程序里，可以定义Handler的子类别来接收Looper所送出的消息。</p>
<p>同线程不同组件之间的消息传递代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * ============================================================</div><div class="line"> * Copyright：$&#123;TODO&#125;有限公司版权所有 (c) 2017</div><div class="line"> * Author：   AllenIverson</div><div class="line"> * Email：    815712739@qq.com</div><div class="line"> * GitHub：   https://github.com/JackChen1999</div><div class="line"> * 博客：     http://blog.csdn.net/axi295309066</div><div class="line"> * 微博：     AndroidDeveloper</div><div class="line"> * GitBook： https://www.gitbook.com/<span class="doctag">@alleniverson</span></div><div class="line"> * &lt;p&gt;</div><div class="line"> * Project_Name：HandlerDemo</div><div class="line"> * Package_Name：com.github.handlerdemo.activity</div><div class="line"> * Version：1.0</div><div class="line"> * time：2017/3/1 16:23</div><div class="line"> * des ：</div><div class="line"> * gitVersion：2.12.0.windows.1</div><div class="line"> * updateAuthor：$Author$</div><div class="line"> * updateDate：$Date$</div><div class="line"> * updateDes：$&#123;TODO&#125;</div><div class="line"> * ============================================================</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> classHandlerActivity extends Activity</div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> Button sendBtn;</div><div class="line">    <span class="keyword">private</span> TextView tv;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.main);</div><div class="line">        sendBtn=(Button)findViewById(R.id.send);</div><div class="line">        tv=(TextView)findViewById(R.id.textview);</div><div class="line">        sendBtn.setOnClickListener(newMyOnClickListener());</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyOnClickListener</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            <span class="keyword">switch</span> (v.getId()) &#123;</div><div class="line">                <span class="keyword">case</span> R.id.send:</div><div class="line">                    <span class="comment">// 取得当前线程的Looper，此时的线程为主线程（UI线程）</span></div><div class="line">                    Looper looper = Looper.myLooper();</div><div class="line">                    <span class="comment">// 构造一个Handler对象使之与Looper通信</span></div><div class="line">                    MyHandler mHandler = newMyHandler(looper);</div><div class="line">                    <span class="comment">// 产生一个消息通过Handler传递给Looper</span></div><div class="line">                    String msgStr = <span class="string">"main"</span>;</div><div class="line">                    <span class="comment">// 构造一个消息，这里what参数设为1，obj参数设为msgStr变量。</span></div><div class="line">                    Message msg = mHandler.obtainMessage(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, msgStr);</div><div class="line">                    <span class="comment">// 发送消息，调用Handler对象的handleMessage方法</span></div><div class="line">                    mHandler.sendMessage(msg);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 自定义Handler类</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="comment">// 指定Looper对象来构造Handler对象，而我们平时直接使用的Handler无参构造方法实际上默认是本线程的looper，可通过查看SDk源代码了解。</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(looper);</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                    tv.setText(String.valueOf(msg.obj));</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说明：此程序启动时，当前线程(即主线程, mainthread)已诞生了一个Looper对象，并且有了一个MessageQueue数据结构。</p>
<ul>
<li><p>调用Looper类别的静态myLooper()函数，以取得目前线程里的Looper对象。looper = Looper.myLooper (); </p>
</li>
<li><p>构造一个MyHandler对象来与Looper沟通。Activity等对象可以藉由MyHandler对象来将消息传给Looper，然后放入MessageQueue里；MyHandler对象也扮演Listener的角色，可接收Looper对象所送来的消息。mHandler = new MyHandler (looper);</p>
</li>
<li><p>先构造一个Message对象，并将数据存入对象里。<br>Message msg = mHandler.obtainMessage(1, 1, 1, msgStr);<br>这里也可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Message msg = <span class="keyword">new</span> Message();</div><div class="line">msg.what = <span class="number">1</span>;</div><div class="line">msg.obj = msgStr;</div></pre></td></tr></table></figure>
</li>
<li><p>通过mHandler对象将消息m传给Looper，然后放入MessageQueue里。mHandler.sendMessage(msg);</p>
</li>
</ul>
<p>此时，Looper对象看到MessageQueue里有消息m，就将它广播出去，mHandler对象接到此讯息时，会调用其handleMessage()函数来处理，于是让msgStr显示于TextView上（更新UI）。</p>
<h2 id="12-3-子线程传递消息给主线程"><a href="#12-3-子线程传递消息给主线程" class="headerlink" title="12.3 子线程传递消息给主线程"></a>12.3 子线程传递消息给主线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * ============================================================</div><div class="line"> * Copyright：$&#123;TODO&#125;有限公司版权所有 (c) 2017</div><div class="line"> * Author：   AllenIverson</div><div class="line"> * Email：    815712739@qq.com</div><div class="line"> * GitHub：   https://github.com/JackChen1999</div><div class="line"> * 博客：     http://blog.csdn.net/axi295309066</div><div class="line"> * 微博：     AndroidDeveloper</div><div class="line"> * GitBook： https://www.gitbook.com/<span class="doctag">@alleniverson</span></div><div class="line"> * &lt;p&gt;</div><div class="line"> * Project_Name：HandlerDemo</div><div class="line"> * Package_Name：com.github.handlerdemo.activity</div><div class="line"> * Version：1.0</div><div class="line"> * time：2017/3/1 16:23</div><div class="line"> * des ：</div><div class="line"> * gitVersion：2.12.0.windows.1</div><div class="line"> * updateAuthor：$Author$</div><div class="line"> * updateDate：$Date$</div><div class="line"> * updateDes：$&#123;TODO&#125;</div><div class="line"> * ============================================================</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> classHandlerActivity extends Activity</div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span> Button sendBtn;</div><div class="line">    <span class="keyword">private</span> TextView tv;</div><div class="line">    <span class="keyword">private</span> MyHandler mHandler = <span class="keyword">null</span>;</div><div class="line">    Thread thread;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.main);</div><div class="line">        sendBtn = (Button)findViewById(R.id.send);</div><div class="line">        tv = (TextView)findViewById(R.id.textview);</div><div class="line">        sendBtn.setOnClickListener(newMyOnClickListener());</div><div class="line">    &#125;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyOnClickListener</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">            <span class="keyword">switch</span> (v.getId()) &#123;</div><div class="line">                <span class="keyword">case</span> R.id.send:</div><div class="line">                    thread = <span class="keyword">new</span> MyThread();</div><div class="line">                    thread.start();</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 自定义Handler类</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="comment">// 指定Looper对象来构造Handler对象，而我们平时直接使用的Handler无参构造方法实际上默认是本线程的looper，可通过查看SDk源代码了解。  </span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(looper);</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">                    tv.setText(String.valueOf(msg.obj));</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 获得当前线程的Looper对象  </span></div><div class="line">            Looper curLooper =Looper.myLooper();</div><div class="line">            <span class="comment">// 获得主线程（UI线程）的Looper对象  </span></div><div class="line">            Looper mainLooper =Looper.getMainLooper();</div><div class="line">            String msgStr;</div><div class="line">            <span class="keyword">if</span> (curLooper == <span class="keyword">null</span>) &#123;</div><div class="line">                mHandler = newMyHandler(mainLooper);</div><div class="line">                msgStr = <span class="string">"curLooper isnull"</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                mHandler = newMyHandler(curLooper);</div><div class="line">                msgStr = <span class="string">"This iscurLooper"</span>;</div><div class="line">            &#125;</div><div class="line">            Message msg =mHandler.obtainMessage(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, msgStr);</div><div class="line">            mHandler.sendMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Android会自动替主线程建立MessageQueue。在这个子线程里并没有建立Message Queue。所以curLooper值为null，而mainLooper则指向主线程里的Looper。于是执行mHandler= new MyHandler (mainLooper);此mHandler属于主线程</p>
<p>mHandler.sendMessage(msg);就将msg消息存入到主线程的MessageQueue里</p>
<p>mainLooper看到Message Queue里有讯息，就会作出处理，于是由主线程执行到mHandler的handleMessage()来处理消息。</p>
<h2 id="12-4-在子线程中直接更新View不抛异常的问题"><a href="#12-4-在子线程中直接更新View不抛异常的问题" class="headerlink" title="12.4 在子线程中直接更新View不抛异常的问题"></a>12.4 在子线程中直接更新View不抛异常的问题</h2><p>下面代码，我们在子线程中直接操作View，但是并不会抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.main);</div><div class="line">    tv = (TextView) findViewById(R.id.tv);</div><div class="line">    iv = (ImageView) findViewById(R.id.iv);</div><div class="line">    <span class="comment">//搞不懂为什么在子线程里可以修改ui</span></div><div class="line">    <span class="keyword">new</span> Thread()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        tv.setText(<span class="string">"wwwwwwwww"</span>);</div><div class="line">        iv.setImageResource(R.drawable.ic_launcher);</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原因：</p>
<p>在更新ui界面时View会把要界面传给ViewRoot </p>
<p>自定义Handler它是Activity和WindowMangerImpl之间的桥梁，要修改界面上的数据的经过它，它把数据传递给WindowManagerImple或DecorView之前，会调用checkThread方法，判断当前线程是否是主线程，不是的话跑异常。</p>
<p>而上面的代码是在onCreate里面修改的view，那时候view还没有被真正的被放在ContentView里面，ViewRoot还没有被创建，mParent为null。mparent（放ContentView的容器类型ViewParent）为null时不调用checkThread方法，当执行到ActivityThread的handlerResumeActivity方法时ViewRoot方法才会被创建，该方法在Activity的onResume方法执行完以后的200到300毫秒以后得到执行，并且把界面传递给WidowManagerImpl进行显示，由于在viewRoot被创建前已经修改了控件的值，所以显示的是已经修改的值。</p>
<p>所以在onResume方法被执行完的200毫秒之前那是还没有ViewRoot和mparent是可以修改主线程UI界面的   只有当viewRoot被创建了以后</p>
<p>在子线程view被添加到了contentView上时，或已添加到ContentView上在修改显示内容时会调用View的requestLayout方法，requestLayout会调用ViewRoot的checkThread方法，才会抛异常。</p>
<p>如果修改一个view的内容不调用requestLayout方法时是可以子线程中修改的并且不抛异常。如给一个view设置监听事件，虽然设置监听是在子线程里设置的但是调用执行监听事件的代码是在主线程里调用的从而执行也将在主线程执行。又如post方法，它只是给主线程所在的handler发送消息，handler分发消息时执行具体任务，并没有执行checkThread。又如创建一个VIew，为VIEW设置内容，添加view到该view等等，因为还没被添加到ContentView上所以不会执行checkThread。</p>
<h1 id="13-Handler的核心代码"><a href="#13-Handler的核心代码" class="headerlink" title="13. Handler的核心代码"></a>13. Handler的核心代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Looper mLooper;</div><div class="line">    <span class="keyword">private</span> MessageQueue mQueue;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span></span>&#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">        &#125;</div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">()</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">        handleMessage();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> sendMessageDelayed(msg,<span class="number">0</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> sendEmptyMessageDelayed(what,<span class="number">0</span>);   </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span></span>&#123;</div><div class="line">        Message msg = Message.obtain();</div><div class="line">        msg.what = what;</div><div class="line">        <span class="keyword">return</span> sendMessageDelayed(msg,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayTime)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (delayTime &lt; <span class="number">0</span>) delayTime = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> sendMessageAtTime(msg,SystemClock.uptimeMillis()+delayTime);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span></span>&#123;</div><div class="line">        MessageQueue queue = mQueue;</div><div class="line">        <span class="keyword">return</span> enqueueMessage(queue,msg,uptimeMillis);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span></span>&#123;</div><div class="line">        msg.target = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</div><div class="line">        sendMessageDelayed(getPostMessage(r),<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span></span>&#123;</div><div class="line">        Message m = Message.obtain();</div><div class="line">        m.callback = r;</div><div class="line">        <span class="keyword">return</span> m;</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="14-Looper的核心代码"><a href="#14-Looper的核心代码" class="headerlink" title="14. Looper的核心代码"></a>14. Looper的核心代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; mThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</div><div class="line">    MessageQueue mQueue;</div><div class="line">    Thread mCurrentThread;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">()</span> </span>&#123;</div><div class="line">        mQueue = <span class="keyword">new</span> MessageQueue();</div><div class="line">        mCurrentThread = Thread.currentThread();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">        &#125;</div><div class="line">        mThreadLocal.set(<span class="keyword">new</span> Looper());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span></span>&#123;</div><div class="line">        prepare();</div><div class="line">        sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">        Looper me = myLooper();</div><div class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);&#125;</div><div class="line">		MessageQueue queue = me.mQueue;</div><div class="line">        <span class="keyword">for</span>(;;)&#123;</div><div class="line">            Message msg = queue.next();<span class="comment">//block</span></div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mThreadLocal.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/使用JDK5中同步技术的3个面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋过冬漫长">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/使用JDK5中同步技术的3个面试题/" itemprop="url">
                  使用JDK5中同步技术的3个面试题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T23:56:42+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/30/使用JDK5中同步技术的3个面试题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/04/30/使用JDK5中同步技术的3个面试题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p>现有的程序代码模拟产生了16个日志对象，并且需要运行16秒才能打印完这些日志，请在程序中增加4个线程去调用parseLog()方法来分头打印这16个日志对象，程序只需要运行4秒即可打印完这些日志对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">          </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">              </div><div class="line">            System.out.println(<span class="string">"begin:"</span>+(System.currentTimeMillis()/<span class="number">1000</span>));  </div><div class="line">            <span class="comment">/*模拟处理16行日志，下面的代码产生了16个日志对象，当前代码需要运行16秒才能打印完这些日志。 </span></div><div class="line">            修改程序代码，开四个线程让这16个对象在4秒钟打完。 </div><div class="line">            */  </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;  <span class="comment">//这行代码不能改动  </span></div><div class="line">                <span class="keyword">final</span> String log = <span class="string">""</span>+(i+<span class="number">1</span>);   <span class="comment">//这行代码不能改动  </span></div><div class="line">                &#123;  </div><div class="line">                        Test.parseLog(log);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        <span class="comment">//parseLog方法内部的代码不能改动  </span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseLog</span><span class="params">(String log)</span></span>&#123;  </div><div class="line">            System.out.println(log+<span class="string">":"</span>+(System.currentTimeMillis()/<span class="number">1000</span>));  </div><div class="line">              </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;         </div><div class="line">        &#125;     </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>实现：通过阻塞队列实现线程间的通信</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;  </div><div class="line">  </div><div class="line"><span class="comment">//BlockingQueue  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">          </div><div class="line">        <span class="comment">//创建一个空间大小为16的阻塞队列，空间大小可以任意，因为每次打印都要1秒，在此期间，  </span></div><div class="line">        <span class="comment">//4个线程足以不断去从队列中取数据，然后打印,即在1秒内打印4条日志信息  </span></div><div class="line">        <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">16</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">//开启4个线程打印  </span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;  </div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;  </div><div class="line">                <span class="meta">@Override</span>  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </div><div class="line">                        <span class="keyword">try</span> &#123;  </div><div class="line">                            <span class="comment">//开始没有数据，阻塞，一旦有其中一个线程就去取数据，即不再阻塞，就开始打印</span></div><div class="line">                            String log = queue.take();    </div><div class="line">                            parseLog(log);  </div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                            e.printStackTrace();  </div><div class="line">                        &#125;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">                  </div><div class="line">            &#125;).start();  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        <span class="comment">//打印秒数  </span></div><div class="line">        System.out.println(<span class="string">"begin:"</span>+(System.currentTimeMillis()/<span class="number">1000</span>));  </div><div class="line">          </div><div class="line">          </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;  <span class="comment">// 这行代码不能改动  </span></div><div class="line">            <span class="keyword">final</span> String log = <span class="string">""</span>+(i+<span class="number">1</span>); <span class="comment">// 这行代码不能改动  </span></div><div class="line">            &#123;  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        queue.put(log);  <span class="comment">// 向队列中存储数据  </span></div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125;  </div><div class="line">                    <span class="comment">//Test.parseLog(log);  </span></div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">//parseLog方法内部的代码不能改动  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parseLog</span><span class="params">(String log)</span></span>&#123;  </div><div class="line">        System.out.println(log+<span class="string">":"</span>+(System.currentTimeMillis()/<span class="number">1000</span>));  </div><div class="line">          </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            Thread.sleep(<span class="number">1000</span>);     <span class="comment">// 模拟每条日志打印需要1秒  </span></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;         </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p>现成程序中的Test类中的代码在不断地产生数据，然后交给TestDo.doSome()方法去处理，就好像生产者在不断地产生数据，消费者在不断消费数据。</p>
<p>请将程序改造成有10个线程来消费生成者产生的数据，这些消费者都调用TestDo.doSome()方法去进行处理，故每个消费者都需要一秒才能处理完，程序应保证这些消费者线程依次有序地消费数据，只有上一个消费者消费完后，下一个消费者才能消费数据，下一个消费者是谁都可以，但要保证这些消费者线程拿到的数据是有顺序的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">      </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">              </div><div class="line">            System.out.println(<span class="string">"begin:"</span>+(System.currentTimeMillis()/<span class="number">1000</span>));  </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  <span class="comment">//这行不能改动  </span></div><div class="line">                String input = i+<span class="string">""</span>;  <span class="comment">//这行不能改动  </span></div><div class="line">                String output = TestDo.doSome(input);  </div><div class="line">                System.out.println(Thread.currentThread().getName()+ <span class="string">":"</span> + output);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">//不能改动此TestDo类  </span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestDo</span> </span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doSome</span><span class="params">(String input)</span></span>&#123;  </div><div class="line">              </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">            String output = input + <span class="string">":"</span>+ (System.currentTimeMillis() / <span class="number">1000</span>);  </div><div class="line">            <span class="keyword">return</span> output;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在实现之前先介绍一个阻塞队列：SynchronousQuene，一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。</p>
<p>应用：它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;  </div><div class="line">  </div><div class="line"><span class="comment">/*Semaphore与SynchronousQueue的混合使用。 </span></div><div class="line">    由于Semaphore只有1个许可权，所以谁先拿到谁执行，然后释放，保证依次执行, </div><div class="line">    用锁也行，只要保证一个线程执行即可 </div><div class="line">    SynchronousQueue是必须有其他线程取的动作，这样一一对应 </div><div class="line">*/  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          </div><div class="line">        <span class="comment">//定义一个许可权为1的信号灯  </span></div><div class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">//产生的结果无序  </span></div><div class="line">        <span class="keyword">final</span> SynchronousQueue&lt;String&gt; queue = <span class="keyword">new</span> SynchronousQueue&lt;String&gt;();  </div><div class="line">          </div><div class="line">        <span class="comment">//产生10个线程  </span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;  </div><div class="line">                <span class="meta">@Override</span>  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;   </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        semaphore.acquire();    <span class="comment">//获取许可  </span></div><div class="line">                        String input = queue.take();    <span class="comment">//获取并移除此队列的头  </span></div><div class="line">                        String output = TestDo.doSome(input);  </div><div class="line">                        System.out.println(Thread.currentThread().getName()+ <span class="string">":"</span> + output);  </div><div class="line">                        semaphore.release();    <span class="comment">//释放许可  </span></div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                        <span class="comment">// TODO Auto-generated catch block  </span></div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125;     </div><div class="line">                &#125;  </div><div class="line">            &#125;).start();  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        System.out.println(<span class="string">"begin:"</span>+(System.currentTimeMillis()/<span class="number">1000</span>));  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  <span class="comment">//这行不能改动  </span></div><div class="line">            String input = i+<span class="string">""</span>;  <span class="comment">//这行不能改动  </span></div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                queue.put(input); <span class="comment">//将指定元素添加到此队列  </span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">//不能改动此TestDo类  </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDo</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">doSome</span><span class="params">(String input)</span></span>&#123;  </div><div class="line">          </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            Thread.sleep(<span class="number">1000</span>);  </div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        String output = input + <span class="string">":"</span>+ (System.currentTimeMillis() / <span class="number">1000</span>);  </div><div class="line">        <span class="keyword">return</span> output;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><p>现有程序同时启动了4个线程去调用TestDo.doSome(key, value)方法，由于TestDo.doSome(key, value)方法内的代码是先暂停1秒，然后再输出以秒为单位的当前时间值，所以，会打印出4个相同的时间值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">4:4:1258199615</div><div class="line">1:1:1258199615</div><div class="line">3:3:1258199615</div><div class="line">1:2:1258199615</div></pre></td></tr></table></figure>
<p>请修改代码，如果有几个线程调用TestDo.doSome(key, value)方法时，传递进去的key相等（equals比较为true），则这几个线程应互斥排队输出结果，即当有两个线程的key都是”1”时，它们中的一个要比另外其他线程晚1秒输出结果，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">4:4:1258199615</div><div class="line">1:1:1258199615</div><div class="line">3:3:1258199615</div><div class="line">1:2:1258199616</div></pre></td></tr></table></figure>
<p>总之，当每个线程中指定的key相等时，这些相等key的线程应每隔一秒依次输出时间值（要用互斥），如果key不同，则并行执行（相互之间不互斥）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不能改动此Test类      </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> TestDo testDo;  </div><div class="line">    <span class="keyword">private</span> String key;  </div><div class="line">    <span class="keyword">private</span> String value;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String key,String key2,String value)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.testDo = TestDo.getInstance();  </div><div class="line">        <span class="comment">/*常量"1"和"1"是同一个对象，下面这行代码就是要用"1"+""的方式产生新的对象， </span></div><div class="line">        以实现内容没有改变，仍然相等（都还为"1"），但对象却不再是同一个的效果*/  </div><div class="line">        <span class="keyword">this</span>.key = key+key2;   </div><div class="line">        <span class="keyword">this</span>.value = value;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;  </div><div class="line">        Test a = <span class="keyword">new</span> Test(<span class="string">"1"</span>,<span class="string">""</span>,<span class="string">"1"</span>);  </div><div class="line">        Test b = <span class="keyword">new</span> Test(<span class="string">"1"</span>,<span class="string">""</span>,<span class="string">"2"</span>);  </div><div class="line">        Test c = <span class="keyword">new</span> Test(<span class="string">"3"</span>,<span class="string">""</span>,<span class="string">"3"</span>);  </div><div class="line">        Test d = <span class="keyword">new</span> Test(<span class="string">"4"</span>,<span class="string">""</span>,<span class="string">"4"</span>);  </div><div class="line">        System.out.println(<span class="string">"begin:"</span>+(System.currentTimeMillis()/<span class="number">1000</span>));  </div><div class="line">        a.start();  </div><div class="line">        b.start();  </div><div class="line">        c.start();  </div><div class="line">        d.start();  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </div><div class="line">        testDo.doSome(key, value);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDo</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestDo</span><span class="params">()</span> </span>&#123;&#125;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestDo _instance = <span class="keyword">new</span> TestDo();   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestDo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> _instance;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">(Object key, String value)</span> </span>&#123;  </div><div class="line">  </div><div class="line">        <span class="comment">// 以大括号内的是需要局部同步的代码，不能改动!  </span></div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep(<span class="number">1000</span>);  </div><div class="line">                System.out.println(key+<span class="string">":"</span>+value + <span class="string">":"</span>  </div><div class="line">                        + (System.currentTimeMillis() / <span class="number">1000</span>));  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于源代码中关于实现值相同而对象不同的效果进行解释：<br>对于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = <span class="string">"1"</span>+<span class="string">""</span>;</div><div class="line">b = <span class="string">"1"</span>+<span class="string">""</span>;</div></pre></td></tr></table></figure></p>
<p>编译器自动优化，所以a和b是同一个对象</p>
<p>而对于：key = key+key2;  由于是变量，编译器无法识别，这时a和b把“1”和“”赋值给key和key2时会得到两个不同的对象</p>
<p>思想：将集合中的对象作为同步代码块的锁，即this锁，每次将对象存入集合中的时候，就判断是否原集合中已经存在一个与将要存入集合的对象值相同的对象，即用equals比较，如果有，那么就获取原来的这个对象，把这个对象作为将要存入对象的锁，这样它们持有的就是同一把锁，即可实现互斥，这样就可以实现值相同的对象在不同的时刻打印的效果</p>
<p>代码中出现的问题：在遍历ArrayList集合查找与要存入值相同元素的时候，进行了添加的动作，所以会出现并发修改异常，因此使用并发的CopyOnWriteArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;  </div><div class="line"><span class="keyword">import</span> java.util.Iterator;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;  </div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment">//不能改动此Test类      </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> TestDo testDo;  </div><div class="line">    <span class="keyword">private</span> String key;  </div><div class="line">    <span class="keyword">private</span> String value;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String key,String key2,String value)</span></span>&#123;  </div><div class="line">        <span class="keyword">this</span>.testDo = TestDo.getInstance();  </div><div class="line">        <span class="comment">/*常量"1"和"1"是同一个对象，下面这行代码就是要用"1"+""的方式产生新的对象， </span></div><div class="line">        以实现内容没有改变，仍然相等（都还为"1"），但对象却不再是同一个的效果*/  </div><div class="line">          </div><div class="line">        <span class="keyword">this</span>.key = key+key2;    <span class="comment">//这里是变量，所以不会优化  </span></div><div class="line"><span class="comment">/*      a = "1"+""; </span></div><div class="line">        b = "1"+""   </div><div class="line">        编译器自动优化，所以a和b是同一个对象 </div><div class="line">*/  </div><div class="line">        <span class="keyword">this</span>.value = value;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;  </div><div class="line">        Test a = <span class="keyword">new</span> Test(<span class="string">"1"</span>,<span class="string">""</span>,<span class="string">"1"</span>);  </div><div class="line">        Test b = <span class="keyword">new</span> Test(<span class="string">"1"</span>,<span class="string">""</span>,<span class="string">"2"</span>);  </div><div class="line">        Test c = <span class="keyword">new</span> Test(<span class="string">"3"</span>,<span class="string">""</span>,<span class="string">"3"</span>);  </div><div class="line">        Test d = <span class="keyword">new</span> Test(<span class="string">"4"</span>,<span class="string">""</span>,<span class="string">"4"</span>);  </div><div class="line">        System.out.println(<span class="string">"begin:"</span>+(System.currentTimeMillis()/<span class="number">1000</span>));  </div><div class="line">        a.start();  </div><div class="line">        b.start();  </div><div class="line">        c.start();  </div><div class="line">        d.start();  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </div><div class="line">        testDo.doSome(key, value);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDo</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestDo</span><span class="params">()</span> </span>&#123;&#125;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestDo _instance = <span class="keyword">new</span> TestDo();   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestDo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> _instance;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">//private ArrayList keys = new ArrayList();  </span></div><div class="line">    <span class="comment">//迭代的时候不能修改数据，所以使用同步的ArrayList  </span></div><div class="line">    <span class="keyword">private</span> CopyOnWriteArrayList keys = <span class="keyword">new</span> CopyOnWriteArrayList();  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">(Object key, String value)</span> </span>&#123;  </div><div class="line">        Object o = key;  </div><div class="line">        <span class="keyword">if</span>(!keys.contains(o))&#123;  <span class="comment">//比较是否已经存入了一个相同值的对象  </span></div><div class="line">            keys.add(o);  </div><div class="line">        &#125;<span class="keyword">else</span>&#123;  </div><div class="line">              </div><div class="line">            <span class="comment">//迭代，找出原集合里和传进来的值相同的对象  </span></div><div class="line">            <span class="keyword">for</span>(Iterator iter=keys.iterator();iter.hasNext();)&#123;  </div><div class="line">                <span class="keyword">try</span> &#123;  </div><div class="line">                    Thread.sleep(<span class="number">20</span>);   <span class="comment">// 迭代的时候休息一会，在ArrayList下演示并发修改异常  </span></div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                    e.printStackTrace();  </div><div class="line">                &#125;  </div><div class="line">                Object oo = iter.next();  </div><div class="line">                <span class="keyword">if</span>(oo.equals(o))&#123;   <span class="comment">//如果两个对象的值相同  </span></div><div class="line">                    <span class="comment">//就让原集合中的那个相等值的对象作为锁对象，由于原对象之前做的就是锁</span></div><div class="line">                    <span class="comment">//这样两个锁就相同了，就可以实现互斥</span></div><div class="line">                  	o = oo;    </div><div class="line">                    <span class="keyword">break</span>;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">synchronized</span>(o)  </div><div class="line">        <span class="comment">// 以大括号内的是需要局部同步的代码，不能改动!  </span></div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep(<span class="number">1000</span>);  </div><div class="line">                System.out.println(key+<span class="string">":"</span>+value + <span class="string">":"</span>  </div><div class="line">                        + (System.currentTimeMillis() / <span class="number">1000</span>));  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/ai.jpg"
               alt="JackChan" />
          <p class="site-author-name" itemprop="name">JackChan</p>
           
              <p class="site-description motion-element" itemprop="description">生活不止眼前的苟且，还有诗和远方！</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/JackChan1999" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.gitbook.com/@alleniverson" target="_blank" title="GitBook">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  GitBook
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1848214604?topnav=1&wvr=6&topsug=1&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/axi295309066" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JackChan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://评论.disqus.com/count.js" async></script>
    

    

  




	





  





  








  





  

  

  

  

  

</body>
</html>
