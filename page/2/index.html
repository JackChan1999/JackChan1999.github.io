<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="生活不止眼前的苟且，还有诗和远方！">
<meta property="og:type" content="website">
<meta property="og:title" content="秋过冬漫长">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="秋过冬漫长">
<meta property="og:description" content="生活不止眼前的苟且，还有诗和远方！">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="秋过冬漫长">
<meta name="twitter:description" content="生活不止眼前的苟且，还有诗和远方！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>秋过冬漫长</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">秋过冬漫长</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">没有比脚更长的路，走过去，前面是个天！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/线程范围内共享数据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋过冬漫长">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/线程范围内共享数据/" itemprop="url">
                  线程范围内共享数据
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T23:56:42+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="笔记摘要"><a href="#笔记摘要" class="headerlink" title="笔记摘要"></a><strong>笔记摘要</strong></h2><p>所谓线程范围内共享数据，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据，API中为我们提供了一个操作线程范围内共享数据的类ThreadLocal，对于线程范围内共享数据的应用，在ThreadLocal的应用场景中进行了介绍，然后主要对它的使用进行讲解，演示了由单一数据的共享到将多个数据封装到一个对象中，然后进行共享。在开始先用一个Map集合简单实现线程范围内数据的共享</p>
<h2 id="1-使用Map实现线程范围内数据的共享"><a href="#1-使用Map实现线程范围内数据的共享" class="headerlink" title="1. 使用Map实现线程范围内数据的共享"></a><strong>1. 使用Map实现线程范围内数据的共享</strong></h2><p>原理：将线程对象作为map的键存入，这样就保证了map对象的唯一，也就保证了线程内数据的唯一</p>
<p>关键:  明确一点，把当前线程对象作为map集合的键存进去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;  </div><div class="line"><span class="keyword">import</span> java.util.Map;  </div><div class="line"><span class="keyword">import</span> java.util.Random;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeShareData</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;    <span class="comment">//定义一个全局的成员变量  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Thread, Integer&gt; threadData = <span class="keyword">new</span> HashMap&lt;Thread, Integer&gt;();  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">//启动两个线程  </span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;  </div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;  </div><div class="line">                <span class="meta">@Override</span>  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();  <span class="comment">//准备一个数据  </span></div><div class="line">                    System.out.println(Thread.currentThread().getName()   </div><div class="line">                            + <span class="string">" has put data :"</span> + data);  </div><div class="line">                    <span class="comment">//把当前线程对象作为键，就可以保证map对象的唯一，即保证线程内的数据唯一  </span></div><div class="line">                    threadData.put(Thread.currentThread(), data);  </div><div class="line">                    <span class="keyword">new</span> A().get();  </div><div class="line">                    <span class="keyword">new</span> B().get();  </div><div class="line">                &#125;  </div><div class="line">            &#125;).start();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//定义一个类模拟获取数据  </span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">int</span> data = threadData.get(Thread.currentThread());  </div><div class="line">            System.out.println(<span class="string">"A from "</span> + Thread.currentThread().getName()   </div><div class="line">                    + <span class="string">" get data :"</span> + data);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">int</span> data = threadData.get(Thread.currentThread());            </div><div class="line">            System.out.println(<span class="string">"B from "</span> + Thread.currentThread().getName()   </div><div class="line">                    + <span class="string">" get data :"</span> + data);  </div><div class="line">        &#125;         </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Thread-0 has put data:-49248136</div><div class="line">Thread-1 has put data:311124475</div><div class="line">A from Thread-0 get data:-49248136</div><div class="line">A from Thread-1 get data:311124475</div><div class="line">B from Thread-0 get data:-49248136</div><div class="line">B from Thread-1 get data:311124475</div></pre></td></tr></table></figure>
<h2 id="2-ThreadLocal类"><a href="#2-ThreadLocal类" class="headerlink" title="2. ThreadLocal类"></a><strong>2. ThreadLocal类</strong></h2><p>ThreadLocal的作用和目的：</p>
<p>用于实现线程内的数据共享，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。</p>
<p>每个线程调用全局ThreadLocal对象的set方法，就相当于往其内部的map中增加一条记录，key分别是各自的线程，value是各自的set方法传进去的值。在线程结束时可以调用ThreadLocal.clear()方法，这样会更快释放内存，不调用也可以，因为线程结束后也可以自动释放相关的ThreadLocal变量。</p>
<h2 id="3-ThreadLocal的应用场景"><a href="#3-ThreadLocal的应用场景" class="headerlink" title="3. ThreadLocal的应用场景"></a><strong>3. ThreadLocal的应用场景</strong></h2><p>1、订单处理包含一系列操作：减少库存量、增加一条流水台账、修改总账，这几个操作要在同一个事务中完成，通常也即同一个线程中进行处理，如果累加公司应收款的操作失败了，则应该把前面的操作回滚，否则，提交所有操作，这要求这些操作使用相同的数据库连接对象，而这些操作的代码分别位于不同的模块类中。</p>
<p>2、 银行转账包含一系列操作：把转出帐户的余额减少，把转入帐户的余额增加，这两个操作要在同一个事务中完成，它们必须使用相同的数据库连接对象，转入和转出操作的代码分别是两个不同的帐户对象的方法。</p>
<p>3、例如Strut2的ActionContext，同一段代码被不同的线程调用运行时，该代码操作的数据是每个线程各自的状态和数据，对于不同的线程来说，getContext方法拿到的对象都不相同，对同一个线程来说，不管调用getContext方法多少次和在哪个模块中getContext方法，拿到的都是同一个。</p>
<p>线程范围内共享数据示意图</p>
<p> <img src="img/threadlocal.png" alt="threadlocal"></p>
<p>实现对ThreadLocal变量的封装， 让外界不要直接操作ThreadLocal变量由于对基本类型的数据的封装，这种应用相对很少见。而对对象类型的数据的封装，比较常见，即让某个类针对不同线程分别创建一个独立的实例对象。所以我们要对数据进行封装。</p>
<h3 id="实现方式一"><a href="#实现方式一" class="headerlink" title="实现方式一"></a><strong>实现方式一</strong></h3><p>示例说明：</p>
<p>1、 该示例包含了对基本类型数据的共享和对象类型数据的共享</p>
<p>2、定义一个全局共享的ThreadLocal变量，然后启动多个线程向该ThreadLocal变量中存储一个随机值，接着各个线程调用另外其他多个类的方法，这多个类的方法中读取这个ThreadLocal变量的值，就可以看到多个类在同一个线程中共享同一份数据。</p>
<p>3、但这里每次存储数据时，都是使用同一个ThreadLocal对象，只是重新赋值而已</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.HashMap;  </div><div class="line"><span class="keyword">import</span> java.util.Map;  </div><div class="line"><span class="keyword">import</span> java.util.Random;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; x = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();  </div><div class="line">    <span class="comment">//创建一个存储封装类对象的ThreadLocal  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; myThreadScopeData = <span class="keyword">new</span>  ThreadLocal&lt;MyThreadScopeData&gt;();  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> data = <span class="number">0</span>;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">      </div><div class="line">        <span class="comment">//产生两个线程  </span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;  </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;  </div><div class="line">  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">            <span class="comment">//共享单一的数据  </span></div><div class="line">            <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();  </div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"has put data : "</span>+data);  </div><div class="line">            x.set(data);      </div><div class="line">              </div><div class="line">            <span class="comment">//共享多个数据  </span></div><div class="line">            <span class="comment">//将数据封装在myData对象中，并将myData作为myThreadScopeData的键  </span></div><div class="line">            MyThreadScopeData myData = <span class="keyword">new</span> MyThreadScopeData();  </div><div class="line">            myData.setName(<span class="string">"name "</span>+data);  </div><div class="line">            myData.setAge(data);  </div><div class="line">            myThreadScopeData.set(myData);  </div><div class="line">              </div><div class="line">            <span class="keyword">new</span> A().get();  </div><div class="line">            <span class="keyword">new</span> B().get();  </div><div class="line">            &#125;  </div><div class="line">         &#125;).start();  </div><div class="line">      &#125;  </div><div class="line">   &#125;  </div><div class="line">      </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">int</span> data = x.get();  </div><div class="line">            System.out.println(<span class="string">"A from "</span>+Thread.currentThread().getName()+<span class="string">" get data :"</span>+data);  </div><div class="line">          </div><div class="line">            <span class="comment">//从myData中取出数据，并获取当前线程名，数据  </span></div><div class="line">            MyThreadScopeData myData = myThreadScopeData.get();  </div><div class="line">            System.out.println(<span class="string">"A from "</span>+Thread.currentThread().getName()+<span class="string">" getMyData: "</span> +   </div><div class="line">                    myData.getName() + <span class="string">","</span> +myData.getAge());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">          </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">int</span> data = x.get();  </div><div class="line">            System.out.println(<span class="string">"B from "</span>+Thread.currentThread().getName()+<span class="string">" get data :"</span>+data);  </div><div class="line">            MyThreadScopeData myData = myThreadScopeData.get();  </div><div class="line">            System.out.println(<span class="string">"B from "</span>+Thread.currentThread().getName()+<span class="string">" getMyData: "</span> +   </div><div class="line">                    myData.getName() + <span class="string">","</span> +myData.getAge());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">//封装数据的类  </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadScopeData</span></span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> String name;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> age;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.age = age;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Thread-0has put data : 1317043235</div><div class="line">Thread-1has put data : -969579752</div><div class="line">A from Thread-0 get data :1317043235</div><div class="line">A from Thread-1 get data :-969579752</div><div class="line">A from Thread-0 getMyData: name 1317043235,1317043235</div><div class="line">A from Thread-1 getMyData: name -969579752,-969579752</div><div class="line">B from Thread-0 get data :1317043235</div><div class="line">B from Thread-1 get data :-969579752</div><div class="line">B from Thread-0 getMyData: name 1317043235,1317043235</div><div class="line">B from Thread-1 getMyData: name -969579752,-969579752</div></pre></td></tr></table></figure>
<h3 id="实现方式二"><a href="#实现方式二" class="headerlink" title="实现方式二"></a><strong>实现方式二</strong></h3><p> 示例说明：</p>
<p>这里模拟原始的单例模式，它们的区别是：单例模式中只有唯一的一个实例，而这里是每个线程拥有自己唯一的实例，只要是已经创建，就直接返回，保证每个线程拥有自己的唯一一份实例</p>
<p>优点：</p>
<p>这里可以返回每个线程自己唯一的实例对象，所以不必在外面定义，当在代码中的任意地方想获取到一个可以存储自己数据的线程实例的时候直接去调用getThreadInstance方法即可，直接定义在数据对象的内部，和数据关系更紧密，而方式一，则每次想存入数据的时候都需要在外面创建一个ThreadLocal对象用于存储数据。所以方式二更具封装性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.itcast.heima2;  </div><div class="line">  </div><div class="line"><span class="keyword">import</span> java.util.HashMap;  </div><div class="line"><span class="keyword">import</span> java.util.Map;  </div><div class="line"><span class="keyword">import</span> java.util.Random;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="comment">//创建一个ThreadLocal对象  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; x = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;  </div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;  </div><div class="line">                <span class="meta">@Override</span>  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();  </div><div class="line">                    System.out.println(Thread.currentThread().getName()   </div><div class="line">                            + <span class="string">" has put data :"</span> + data);  </div><div class="line">                    x.set(data);    <span class="comment">//往当前线程存入一条数据  </span></div><div class="line">                      </div><div class="line">                    <span class="comment">//获取与当前线程绑定的实例并设置值  </span></div><div class="line">                    MyThreadScopeData.getThreadInstance().setName(<span class="string">"name："</span> + data);  </div><div class="line">                    MyThreadScopeData.getThreadInstance().setAge(data);  </div><div class="line">                    <span class="keyword">new</span> A().get();  </div><div class="line">                    <span class="keyword">new</span> B().get();  </div><div class="line">                &#125;  </div><div class="line">            &#125;).start();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">int</span> data = x.get();     <span class="comment">//获取当前线程中的数据  </span></div><div class="line">            System.out.println(<span class="string">"A from "</span> + Thread.currentThread().getName()   </div><div class="line">                    + <span class="string">" get data :"</span> + data);  </div><div class="line">              </div><div class="line">            <span class="comment">//获取与当前线程绑定的实例  </span></div><div class="line">            MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();  </div><div class="line">            System.out.println(<span class="string">"A from "</span> + Thread.currentThread().getName()   </div><div class="line">                    + <span class="string">" getMyData: "</span> + myData.getName() + <span class="string">","</span> +  </div><div class="line">                    myData.getAge());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;  </div><div class="line">            <span class="keyword">int</span> data = x.get();           </div><div class="line">            System.out.println(<span class="string">"B from "</span> + Thread.currentThread().getName()   </div><div class="line">                    + <span class="string">" get data :"</span> + data);  </div><div class="line">            MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();  </div><div class="line">            System.out.println(<span class="string">"B from "</span> + Thread.currentThread().getName()   </div><div class="line">                    + <span class="string">" getMyData: "</span> + myData.getName() + <span class="string">",age: "</span> +  </div><div class="line">                    myData.getAge());             </div><div class="line">        &#125;         </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">//一个绑定当前线程的类  </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadScopeData</span></span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyThreadScopeData</span><span class="params">()</span></span>&#123;&#125;   <span class="comment">//构造方法私有化  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;MyThreadScopeData&gt; map = <span class="keyword">new</span> ThreadLocal&lt;MyThreadScopeData&gt;();  </div><div class="line">      </div><div class="line">    <span class="comment">//定义一个静态方法，返回各线程自己的实例   </span></div><div class="line">    <span class="comment">//这里不必用同步，因为每个线程都要创建自己的实例，所以没有线程安全问题。  </span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="comment">/*synchronized*/</span> <span class="function">MyThreadScopeData <span class="title">getThreadInstance</span><span class="params">()</span></span>&#123;  </div><div class="line">        MyThreadScopeData instance = map.get();     <span class="comment">//获取当前线程绑定的实例  </span></div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;         </div><div class="line">            instance = <span class="keyword">new</span> MyThreadScopeData();  </div><div class="line">            map.set(instance);  <span class="comment">//创建完之后，将实例对象存进去  </span></div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> String name;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> age;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.age = age;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Thread-0 has put data :2105117242</div><div class="line">Thread-1 has put data :-368218341</div><div class="line">A from Thread-1 get data :-368218341</div><div class="line">A from Thread-1 getMyData: name：-368218341,-368218341</div><div class="line">A from Thread-0 get data :2105117242</div><div class="line">A from Thread-0 getMyData: name：2105117242,2105117242</div><div class="line">B from Thread-0 get data :2105117242</div><div class="line">B from Thread-1 get data :-368218341</div><div class="line">B from Thread-0 getMyData: name：2105117242,age: 2105117242</div><div class="line">B from Thread-1 getMyData: name：-368218341,age: -368218341</div></pre></td></tr></table></figure>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h2><p>一个ThreadLocal代表一个变量，故其中只能放一个数据，有两个变量都要线程范围内共享，则要定义两个ThreadLocal对象，如果数据更多就很麻烦，可以先定义一个对象封装变量，然后在ThreadLocal中存储这一个对象，而这些操作都在提供线程数据类中完成</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋过冬漫长">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/线程池/" itemprop="url">
                  线程池
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T23:56:42+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里首先介绍了java5中的并发的小工具包：java.util.concurrent.atomic，然后介绍了线程池的概念，对使用java5的方式创建不同形式的线程进行了演示，之后介绍了两个 对象：Callable和Future，用于获取线程执行后的结果，对于<a href="线程锁技术.md">线程锁技术</a>则在另外一篇文章中介绍。</p>
<p>Java5中的线程并发库都在java.util.concurrent包及子包中</p>
<h1 id="1-Executor类的继承结构"><a href="#1-Executor类的继承结构" class="headerlink" title="1. Executor类的继承结构"></a><strong>1. Executor类的继承结构</strong></h1><p><img src="http://img.blog.csdn.net/20161024205013699" alt="ThreadPoolExecutor"></p>
<p>Executor是线程池的顶级接口，只有一个执行任务的方法execute()</p>
<p>ExecutorService是Executor的子接口，该接口中包含了线程池常用的一些方法</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">execute()</td>
<td style="text-align:left">执行任务</td>
</tr>
<tr>
<td style="text-align:left">shutdown()</td>
<td style="text-align:left">调用后不再接收新任务，如果里面有任务，就执行完</td>
</tr>
<tr>
<td style="text-align:left">shutdownNow()</td>
<td style="text-align:left">调用后不再接受新任务，如果有等待任务，移出队列；有正在执行的，尝试停止之</td>
</tr>
<tr>
<td style="text-align:left">isShutdown()</td>
<td style="text-align:left">判断线程池是否关闭</td>
</tr>
<tr>
<td style="text-align:left">isTerminated()</td>
<td style="text-align:left">判断线程池中任务是否执行完成</td>
</tr>
<tr>
<td style="text-align:left">submit()</td>
<td style="text-align:left">提交任务</td>
</tr>
<tr>
<td style="text-align:left">invokeAll()</td>
<td style="text-align:left">执行一组任务</td>
</tr>
</tbody>
</table>
<h1 id="2-ThreadPoolExecutor"><a href="#2-ThreadPoolExecutor" class="headerlink" title="2. ThreadPoolExecutor"></a><strong>2. ThreadPoolExecutor</strong></h1><p>ExecutorService的默认实现，同时也是Executors的底层实现</p>
<h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a><strong>2.1 构造方法</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></div><div class="line">    <span class="keyword">int</span> corePoolSize, //核心线程数</div><div class="line">    <span class="keyword">int</span> maximumPoolSize, //最大线程数</div><div class="line">    <span class="keyword">long</span> keepAliveTime, //保持时间</div><div class="line">    TimeUnit unit, //时间单位</div><div class="line">    BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列</div><div class="line">    ThreadFactory threadFactory, //线程工厂</div><div class="line">    RejectedExecutionHandler handler //异常捕获器</div><div class="line">)</div></pre></td></tr></table></figure>
<h3 id="2-1-1-int-corePoolSize"><a href="#2-1-1-int-corePoolSize" class="headerlink" title="2.1.1 int corePoolSize"></a><strong>2.1.1 int corePoolSize</strong></h3><p>核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中</p>
<h3 id="2-1-2-int-maximumPoolSize"><a href="#2-1-2-int-maximumPoolSize" class="headerlink" title="2.1.2 int maximumPoolSize"></a><strong>2.1.2 int maximumPoolSize</strong></h3><p>线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程</p>
<h3 id="2-1-3-long-keepAliveTime"><a href="#2-1-3-long-keepAliveTime" class="headerlink" title="2.1.3 long keepAliveTime"></a><strong>2.1.3 long keepAliveTime</strong></h3><p>表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0</p>
<h3 id="2-1-4-TimeUnit-unit"><a href="#2-1-4-TimeUnit-unit" class="headerlink" title="2.1.4 TimeUnit unit"></a><strong>2.1.4 TimeUnit unit</strong></h3><p>参数keepAliveTime的时间单位，有7种取值</p>
<ul>
<li>TimeUnit.DAYS                        //天</li>
<li>TimeUnit.HOURS                    //小时</li>
<li>TimeUnit.MINUTES                 //分钟</li>
<li>TimeUnit.SECONDS               //秒</li>
<li>TimeUnit.MILLISECONDS      //毫秒</li>
<li>TimeUnit.MICROSECONDS      //微妙</li>
<li>TimeUnit.NANOSECONDS       //纳秒</li>
</ul>
<h3 id="2-1-5-RejectedExecutionHandler"><a href="#2-1-5-RejectedExecutionHandler" class="headerlink" title="2.1.5 RejectedExecutionHandler"></a><strong>2.1.5 RejectedExecutionHandler</strong></h3><ul>
<li><p>ThreadPoolExecutor.AbortPolicy<br>当添加任务出错时的策略捕获器，丢弃任务并抛出RejectedExecutionException异常</p>
</li>
<li><p>ThreadPoolExecutor.DiscardPolicy<br>也是丢弃任务，但是不抛出异常</p>
</li>
<li><p>ThreadPoolExecutor.DiscardOldestPolicy<br>丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</p>
</li>
<li><p>ThreadPoolExecutor.CallerRunsPolicy<br>由调用线程处理该任务</p>
</li>
</ul>
<h1 id="3-任务提交给线程池之后的处理策略"><a href="#3-任务提交给线程池之后的处理策略" class="headerlink" title="3. 任务提交给线程池之后的处理策略"></a><strong>3. 任务提交给线程池之后的处理策略</strong></h1><p>3.1 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建执行这个任务</p>
<p><img src="http://img.blog.csdn.net/20161025001312662" alt="ThreadPoolExecutor"></p>
<p>3.2 如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中</p>
<p>3.2.1 若添加成功，则该任务会等待空闲线程将其取出去执行</p>
<p><img src="http://img.blog.csdn.net/20161025001328454" alt="ThreadPoolExecutor"></p>
<p>3.2.2 若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务</p>
<p><img src="http://img.blog.csdn.net/20161025001336913" alt="ThreadPoolExecutor"></p>
<p>3.3 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理</p>
<p><img src="http://img.blog.csdn.net/20161025001349032" alt="ThreadPoolExecutor"></p>
<p>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止</p>
<h1 id="4-阻塞队列的介绍"><a href="#4-阻塞队列的介绍" class="headerlink" title="4. 阻塞队列的介绍"></a><strong>4. 阻塞队列的介绍</strong></h1><h2 id="4-1-BlockingQueue"><a href="#4-1-BlockingQueue" class="headerlink" title="4.1 BlockingQueue"></a>4.1 BlockingQueue</h2><table>
<thead>
<tr>
<th style="text-align:left">阻塞队列</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">BlockingQueue</td>
<td style="text-align:left">阻塞队列的顶级接口，主要用于实现生产者消费者队列</td>
</tr>
<tr>
<td style="text-align:left">BlockingDeque</td>
<td style="text-align:left">双端队列</td>
</tr>
<tr>
<td style="text-align:left">SynchronousQueue</td>
<td style="text-align:left">同步队列，无界队列，直接提交策略，交替队列，在某次添加元素后必须等待其他线程取走后才能继续添加</td>
</tr>
<tr>
<td style="text-align:left">LinkedBlockingQueue</td>
<td style="text-align:left">无界队列，基于链表的阻塞队列，可以并发运行，FIFO</td>
</tr>
<tr>
<td style="text-align:left">ArrayBlockingQueue</td>
<td style="text-align:left">基于数组的有界(固定大小的数组)阻塞队列，只有put方法和take方法才具有阻塞功能，公平性  fairness</td>
</tr>
<tr>
<td style="text-align:left">PriorityBlockingQueue</td>
<td style="text-align:left">基于优先级的阻塞队列，依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序</td>
</tr>
<tr>
<td style="text-align:left">DelayQueue</td>
<td style="text-align:left">延时队列</td>
</tr>
</tbody>
</table>
<h2 id="4-2-排队策略"><a href="#4-2-排队策略" class="headerlink" title="4.2 排队策略"></a>4.2 排队策略</h2><h3 id="直接提交"><a href="#直接提交" class="headerlink" title="直接提交"></a>直接提交</h3><p>工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p>
<h3 id="无界队列"><a href="#无界队列" class="headerlink" title="无界队列"></a>无界队列</h3><p>使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）使用无界队列将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列。例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性</p>
<h3 id="有界队列"><a href="#有界队列" class="headerlink" title="有界队列"></a>有界队列</h3><p>当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。</p>
<h2 id="4-3-BlockingQueue"><a href="#4-3-BlockingQueue" class="headerlink" title="4.3 BlockingQueue"></a>4.3 BlockingQueue</h2><table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">Throw exception  抛出异常</th>
<th style="text-align:left">Special value  特殊值</th>
<th style="text-align:left">Blocks   阻塞</th>
<th style="text-align:left">Time out  超时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Insert</td>
<td style="text-align:left">add()</td>
<td style="text-align:left">offer()</td>
<td style="text-align:left">put()</td>
<td style="text-align:left">offer(e，time，unit)</td>
</tr>
<tr>
<td style="text-align:left">Remove</td>
<td style="text-align:left">remove()</td>
<td style="text-align:left">poll()</td>
<td style="text-align:left">take()</td>
<td style="text-align:left">poll(time，unit)</td>
</tr>
<tr>
<td style="text-align:left">Examine检查</td>
<td style="text-align:left">element()</td>
<td style="text-align:left">peek()</td>
<td style="text-align:left">不可用</td>
<td style="text-align:left">不可用</td>
</tr>
</tbody>
</table>
<p><code>BlockingQueue</code> 不接受 <code>null</code> 元素。试图 <code>add</code>、<code>put</code> 或 <code>offer</code> 一个 <code>null</code> 元素时，某些实现会抛出 <code>NullPointerException</code>。<code>null</code> 被用作指示 <code>poll</code> 操作失败的警戒值。 </p>
<p><code>BlockingQueue</code> 可以是限定容量的。它在任意给定时间都可以有一个 <code>remainingCapacity</code>，超出此容量，便无法无阻塞地 <code>put</code> 附加元素。没有任何内部容量约束的 <code>BlockingQueue</code> 总是报告 <code>Integer.MAX_VALUE</code> 的剩余容量。 </p>
<p><code>BlockingQueue</code> 实现主要用于生产者-使用者队列，但它另外还支持 <a href="../../../java/util/Collection.html"><code>Collection</code></a> 接口。因此，举例来说，使用 <code>remove(x)</code> 从队列中移除任意一个元素是有可能的。然而，这种操作通常<em>不</em> 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。 </p>
<p><code>BlockingQueue</code> 实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的 Collection 操作（<code>addAll</code>、<code>containsAll</code>、<code>retainAll</code> 和 <code>removeAll</code>）没有必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了 <code>c</code> 中的一些元素后，<code>addAll(c)</code> 有可能失败（抛出一个异常）。 </p>
<p><code>BlockingQueue</code> 实质上不支持使用任何一种“close”或“shutdown”操作来指示不再添加任何项。这种功能的需求和使用有依赖于实现的倾向。例如，一种常用的策略是：对于生产者，插入特殊的end-of-stream或poison对象，并根据使用者获取这些对象的时间来对它们进行解释。 </p>
<h2 id="4-4-BlockingDeque"><a href="#4-4-BlockingDeque" class="headerlink" title="4.4 BlockingDeque"></a>4.4 BlockingDeque</h2><p>双端队列</p>
<h2 id="4-5-ArrayBlockingQueue"><a href="#4-5-ArrayBlockingQueue" class="headerlink" title="4.5 ArrayBlockingQueue"></a>4.5 ArrayBlockingQueue</h2><p>一个由数组支持的有界<a href="../../../java/util/concurrent/BlockingQueue.html">阻塞队列</a>。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象必须明确大小，像数组一样。其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。</p>
<p>实现互斥，你一下我一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueCondition</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</div><div class="line">        <span class="keyword">final</span> Business3 business = <span class="keyword">new</span> Business3();</div><div class="line">        service.execute(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</div><div class="line">                    business.sub();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</div><div class="line">            business.main();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Business3</span></span>&#123;</div><div class="line">    BlockingQueue subQueue  = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1</span>);</div><div class="line">    BlockingQueue mainQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1</span>);</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            mainQueue.put(<span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line">            mainQueue.take();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</div><div class="line">            &#125;</div><div class="line">            subQueue.put(<span class="number">1</span>);</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span></div><div class="line">        &#123;</div><div class="line">            subQueue.take();</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</div><div class="line">            &#125;</div><div class="line">            mainQueue.put(<span class="number">1</span>);</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">pool-1-thread-1 : 0</div><div class="line">pool-1-thread-1 : 1</div><div class="line">pool-1-thread-1 : 2</div><div class="line">pool-1-thread-1 : 3</div><div class="line">pool-1-thread-1 : 4</div><div class="line">pool-1-thread-1 : 5</div><div class="line">pool-1-thread-1 : 6</div><div class="line">pool-1-thread-1 : 7</div><div class="line">pool-1-thread-1 : 8</div><div class="line">pool-1-thread-1 : 9</div><div class="line">main : 0</div><div class="line">main : 1</div><div class="line">main : 2</div><div class="line">main : 3</div><div class="line">main : 4</div><div class="line">pool-1-thread-1 : 0</div><div class="line">pool-1-thread-1 : 1</div><div class="line">pool-1-thread-1 : 2</div><div class="line">pool-1-thread-1 : 3</div><div class="line">pool-1-thread-1 : 4</div><div class="line">pool-1-thread-1 : 5</div><div class="line">pool-1-thread-1 : 6</div><div class="line">pool-1-thread-1 : 7</div><div class="line">pool-1-thread-1 : 8</div><div class="line">pool-1-thread-1 : 9</div><div class="line">main : 0</div><div class="line">main : 1</div><div class="line">main : 2</div><div class="line">main : 3</div><div class="line">main : 4</div><div class="line">pool-1-thread-1 : 0</div><div class="line">pool-1-thread-1 : 1</div><div class="line">pool-1-thread-1 : 2</div><div class="line">pool-1-thread-1 : 3</div><div class="line">pool-1-thread-1 : 4</div><div class="line">pool-1-thread-1 : 5</div><div class="line">pool-1-thread-1 : 6</div><div class="line">pool-1-thread-1 : 7</div><div class="line">pool-1-thread-1 : 8</div><div class="line">pool-1-thread-1 : 9</div><div class="line">...</div></pre></td></tr></table></figure>
<h2 id="4-6-LinkedBlockingQueue"><a href="#4-6-LinkedBlockingQueue" class="headerlink" title="4.6 LinkedBlockingQueue"></a>4.6 LinkedBlockingQueue</h2><p>一个可改变大小的阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象如果没有明确大小，默认值是Integer.MAX_VALUE。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 </p>
<h2 id="4-7-SynchronousQueue"><a href="#4-7-SynchronousQueue" class="headerlink" title="4.7 SynchronousQueue"></a>4.7 SynchronousQueue</h2><p>同步队列。同步队列没有任何容量，每个插入必须等待另一个线程移除，反之亦然。是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</p>
<h2 id="4-8-DelayQueue"><a href="#4-8-DelayQueue" class="headerlink" title="4.8 DelayQueue"></a>4.8 DelayQueue</h2><p>延时队列，对元素进行持有直到一个特定的延迟到期，只有在延迟期满时才能从中提取元素。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。</p>
<h2 id="4-9-PriorityBlockingQueue"><a href="#4-9-PriorityBlockingQueue" class="headerlink" title="4.9 PriorityBlockingQueue"></a>4.9 PriorityBlockingQueue</h2><p>基于优先级的阻塞队列，依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序，应用：Volley</p>
<h2 id="4-10-生产者消费者"><a href="#4-10-生产者消费者" class="headerlink" title="4.10 生产者消费者"></a>4.10 生产者消费者</h2><p>生产者生产任务，消费者消费任务，那么这时就需要一个任务队列，生产者向队列里插入任务，消费者从队列里提取任务执行</p>
<h1 id="5-线程池工具类Executors"><a href="#5-线程池工具类Executors" class="headerlink" title="5. 线程池工具类Executors"></a><strong>5. 线程池工具类Executors</strong></h1><p>jdk1.5之后的一个新类，提供了一些静态工厂，生成一些常用的线程池，ThreadPoolExecutor是Executors类的底层实现</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">newCachedThreadPool()</td>
<td style="text-align:left">创建一个可缓存的线程池</td>
</tr>
<tr>
<td style="text-align:left">newFixedThreadPool()</td>
<td style="text-align:left">创建一个固定大小的线程池</td>
</tr>
<tr>
<td style="text-align:left">newScheduledThreadPool()</td>
<td style="text-align:left">创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求</td>
</tr>
<tr>
<td style="text-align:left">newSingleThreadExecutor()</td>
<td style="text-align:left">创建单个线程的线程池，始终保证线程池中会有一个线程在。当某线程死去，会找继任者</td>
</tr>
<tr>
<td style="text-align:left">defaultThreadFactory()</td>
<td style="text-align:left">创建一个默认线程池工厂</td>
</tr>
</tbody>
</table>
<h1 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6. 线程池"></a><strong>6. 线程池</strong></h1><p>在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程，这就是封装</p>
<p>记住：任务是提交给整个线程池，一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。</p>
<p>示例：</p>
<ul>
<li>创建固定大小的线程池</li>
<li>创建缓存线程池  </li>
<li>用线程池创建定时器</li>
<li>创建单一线程池（始终保证线程池中会有一个线程在。当某线程死去，会找继任者）</li>
</ul>
<p>注意：</p>
<p>定时器中总是相对时间，我们要想指定具体时间的方法：比如明天早上10点钟执行，则可以使用明天早上10点的时间减去当前的时间，得到时间间隔</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">          </div><div class="line">        <span class="comment">//创建固定大小的线程池，这里只能完成3个任务  </span></div><div class="line">        <span class="comment">//ExecutorService threadPool = Executors.newFixedThreadPool(3);  </span></div><div class="line">          </div><div class="line">        <span class="comment">//创建缓存线程池，根据任务来自动创建线程的数量，可以完成创建的所有任务  </span></div><div class="line">        <span class="comment">//ExecutorService threadPool = Executors.newCachedThreadPool();  </span></div><div class="line">          </div><div class="line">        <span class="comment">//创建单一线程池（始终保持线程池中有一个线程存活。当唯一线程死去，会创建新的继任者、  </span></div><div class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();  </div><div class="line">          </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;  </div><div class="line">　　<span class="comment">//内部类不能访问外部类的局部变量，所以i要定义为final，又由于i++.  </span></div><div class="line">　　<span class="comment">//所以在循环内部定义一个变量接收i  </span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> task = i;  </div><div class="line">        threadPool.execute(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">              </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)&#123;  </div><div class="line">                    System.out.println(Thread.currentThread().getName()  </div><div class="line">                            +<span class="string">" is looping of "</span>+ j+<span class="string">"  for task of "</span> +task);  </div><div class="line">                &#125;  </div><div class="line">                  </div><div class="line">            &#125;  </div><div class="line">        &#125;);  </div><div class="line">        &#125;  </div><div class="line">        <span class="comment">//验证10个任务都提交给了线程池  </span></div><div class="line">        System.out.println(<span class="string">"all of 10 tasks have committed! "</span>);  </div><div class="line">        <span class="comment">//threadPool.shutdown();        //等任务完成后，杀死线程、  </span></div><div class="line">        <span class="comment">//threadPool.shutdownNow();     //立即停止线程  </span></div><div class="line">      </div><div class="line">        <span class="comment">//用线程池启动定时器  </span></div><div class="line">          </div><div class="line">        Executors.newScheduledThreadPool(<span class="number">3</span>).schedule(  </div><div class="line">                <span class="keyword">new</span> Runnable() &#123;  <span class="comment">//任务  </span></div><div class="line">                <span class="meta">@Override</span>  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                    System.out.println(<span class="string">"bombing!"</span>);  </div><div class="line">                &#125;  </div><div class="line">            &#125;,   </div><div class="line">                    <span class="number">5</span>,  <span class="comment">//5秒以后执行  </span></div><div class="line">                    TimeUnit.SECONDS);  <span class="comment">//单位  </span></div><div class="line">              </div><div class="line">    <span class="comment">//在某个时间执行一次后，再指定后续的执行间隔时间  </span></div><div class="line">        Executors.newScheduledThreadPool(<span class="number">3</span>).scheduleAtFixedRate(<span class="keyword">new</span> Runnable()&#123;  </div><div class="line">  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;           </div><div class="line">                System.out.println(<span class="string">"bombing!"</span>);  </div><div class="line">            &#125;  </div><div class="line">              </div><div class="line">        &#125;, <span class="number">10</span>,   <span class="comment">//第一次在10秒时爆炸  </span></div><div class="line">            <span class="number">3</span>,          <span class="comment">//以后每隔3秒爆炸一次。  </span></div><div class="line">        TimeUnit.SECONDS);   </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="7-线程池的简单使用"><a href="#7-线程池的简单使用" class="headerlink" title="7. 线程池的简单使用"></a>7. 线程池的简单使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一个简易的线程池管理类，提供三个线程池</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadManager</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SINGLE_POOL_NAME = <span class="string">"DEFAULT_SINGLE_POOL_NAME"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolProxy mLongPool = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object mLongLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolProxy mShortPool = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object mShortLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolProxy mDownloadPool = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object mDownloadLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ThreadPoolProxy&gt; mMap = <span class="keyword">new</span> HashMap&lt;String, ThreadPoolProxy&gt;();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object mSingleLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">	<span class="comment">/** 获取下载线程 */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolProxy <span class="title">getDownloadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (mDownloadLock) &#123;</div><div class="line">			<span class="keyword">if</span> (mDownloadPool == <span class="keyword">null</span>) &#123;</div><div class="line">				mDownloadPool = <span class="keyword">new</span> ThreadPoolProxy(<span class="number">3</span>, <span class="number">3</span>, <span class="number">5L</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> mDownloadPool;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/** 获取一个用于执行长耗时任务的线程池，避免和短耗时任务处在同一个队列而阻塞了重要的短耗时任务，通常用来联网操作 */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolProxy <span class="title">getLongPool</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (mLongLock) &#123;</div><div class="line">			<span class="keyword">if</span> (mLongPool == <span class="keyword">null</span>) &#123;</div><div class="line">				mLongPool = <span class="keyword">new</span> ThreadPoolProxy(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5L</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> mLongPool;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/** 获取一个用于执行短耗时任务的线程池，避免因为和耗时长的任务处在同一个队列而长时间得不到执行，通常用来执行本地的IO/SQL */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolProxy <span class="title">getShortPool</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (mShortLock) &#123;</div><div class="line">			<span class="keyword">if</span> (mShortPool == <span class="keyword">null</span>) &#123;</div><div class="line">				mShortPool = <span class="keyword">new</span> ThreadPoolProxy(<span class="number">2</span>, <span class="number">2</span>, <span class="number">5L</span>);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> mShortPool;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/** 获取一个单线程池，所有任务将会被按照加入的顺序执行，免除了同步开销的问题 */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolProxy <span class="title">getSinglePool</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> getSinglePool(DEFAULT_SINGLE_POOL_NAME);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/** 获取一个单线程池，所有任务将会被按照加入的顺序执行，免除了同步开销的问题 */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadPoolProxy <span class="title">getSinglePool</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">synchronized</span> (mSingleLock) &#123;</div><div class="line">			ThreadPoolProxy singlePool = mMap.get(name);</div><div class="line">			<span class="keyword">if</span> (singlePool == <span class="keyword">null</span>) &#123;</div><div class="line">				singlePool = <span class="keyword">new</span> ThreadPoolProxy(<span class="number">1</span>, <span class="number">1</span>, <span class="number">5L</span>);</div><div class="line">				mMap.put(name, singlePool);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> singlePool;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolProxy</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> ThreadPoolExecutor mPool;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">int</span> mCorePoolSize;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">int</span> mMaximumPoolSize;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">long</span> mKeepAliveTime;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="title">ThreadPoolProxy</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime)</span> </span>&#123;</div><div class="line">			mCorePoolSize = corePoolSize;</div><div class="line">			mMaximumPoolSize = maximumPoolSize;</div><div class="line">			mKeepAliveTime = keepAliveTime;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/** 执行任务，当线程池处于关闭，将会重新创建新的线程池 */</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable run)</span> </span>&#123;</div><div class="line">			<span class="keyword">if</span> (run == <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (mPool == <span class="keyword">null</span> || mPool.isShutdown()) &#123;</div><div class="line">				<span class="comment">//参数说明</span></div><div class="line">				<span class="comment">//当线程池中的线程小于mCorePoolSize，直接创建新的线程加入线程池执行任务</span></div><div class="line">				<span class="comment">//当线程池中的线程数目等于mCorePoolSize，将会把任务放入任务队列BlockingQueue中</span></div><div class="line">				<span class="comment">//当BlockingQueue中的任务放满了，将会创建新的线程去执行，</span></div><div class="line">				<span class="comment">//但是当总线程数大于mMaximumPoolSize时，将会抛出异常，交给RejectedExecutionHandler处理</span></div><div class="line">				<span class="comment">//mKeepAliveTime是线程执行完任务后，且队列中没有可以执行的任务，存活的时间，后面的参数是时间单位</span></div><div class="line">				<span class="comment">//ThreadFactory是每次创建新的线程工厂</span></div><div class="line">				mPool = <span class="keyword">new</span> ThreadPoolExecutor(mCorePoolSize, mMaximumPoolSize, mKeepAliveTime, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(), Executors.defaultThreadFactory(), <span class="keyword">new</span> AbortPolicy());</div><div class="line">			&#125;</div><div class="line">			mPool.execute(run);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/** 取消线程池中某个还未执行的任务 */</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">(Runnable run)</span> </span>&#123;</div><div class="line">			<span class="keyword">if</span> (mPool != <span class="keyword">null</span> &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123;</div><div class="line">				mPool.getQueue().remove(run);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/** 取消线程池中某个还未执行的任务 */</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Runnable run)</span> </span>&#123;</div><div class="line">			<span class="keyword">if</span> (mPool != <span class="keyword">null</span> &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123;</div><div class="line">				<span class="keyword">return</span> mPool.getQueue().contains(run);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/** 立刻关闭线程池，并且正在执行的任务也将会被中断 */</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">if</span> (mPool != <span class="keyword">null</span> &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123;</div><div class="line">				mPool.shutdownNow();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/** 平缓关闭单任务线程池，但是会确保所有已经加入的任务都将会被执行完毕才关闭 */</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">if</span> (mPool != <span class="keyword">null</span> &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123;</div><div class="line">				mPool.shutdownNow();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/同步工具类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋过冬漫长">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/同步工具类/" itemprop="url">
                  同步工具类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T23:56:42+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内容摘要"><a href="#内容摘要" class="headerlink" title="内容摘要"></a><strong>内容摘要</strong></h1><p>这里主要介绍了java5中线程锁技术以外的其他同步工具，首先介绍Semaphore：一个计数信号量。用于控制同时访问资源的线程个数，CyclicBarrier同步辅助类：从字面意思看是路障，这里用于线程之间的相互等待，到达某点后，继续向下执行。CountDownLatch同步辅助类：在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。犹如倒计时计数器，然后是Exchanger：实现两个对象之间数据交换，可阻塞队列：ArrayBlockingQueue，通过阻塞队列间的通信来演示其作用，最后介绍了几个同步集合。</p>
<h1 id="1-Semaphore实现信号灯"><a href="#1-Semaphore实现信号灯" class="headerlink" title="1. Semaphore实现信号灯"></a><strong>1. Semaphore实现信号灯</strong></h1><p>Semaphore可以维护当前访问自身的线程个数，并提供了同步机制，使用Semaphore可以控制同时访问资源的线程个数，例如，实现一个文件允许的并发访问数。Semaphore 只对可用许可的号码进行计数，并采取相应的行动。 </p>
<p>Semaphore实现的功能就像：银行办理业务，一共有5个窗口，但一共有10个客户，一次性最多有5个客户可以进行办理，其他的人必须等候，当5个客户中的任何一个离开后，在等待的客户中有一个人可以进行业务办理。</p>
<p>Semaphore提供了两种规则：</p>
<ul>
<li>一种是公平的：获得资源的先后，按照排队的先后。在构造函数中设置true实现</li>
<li>一种是野蛮的：谁有本事抢到资源，谁就可以获得资源的使用权。</li>
</ul>
<p>与传统的互斥锁的异同：</p>
<p>单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁“，再由另外一个线程释放”锁“，这可以应用于死锁恢复的一些场合。</p>
<p>应用场景：共享资源的争夺，例如游戏中选手进入房间的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          </div><div class="line">　　<span class="comment">//创建一个可根据需要创建新线程的线程池  </span></div><div class="line">　　ExecutorService service = Executors.newCachedThreadPool();  </div><div class="line">        <span class="keyword">final</span>  Semaphore sp = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);  </div><div class="line">          </div><div class="line">　　<span class="comment">//创建10个线程  </span></div><div class="line">　　<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </div><div class="line">            Runnable runnable = <span class="keyword">new</span> Runnable()&#123;  </div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        sp.acquire();   <span class="comment">//获取灯，即许可权  </span></div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;  </div><div class="line">                        e1.printStackTrace();  </div><div class="line">                    &#125;  </div><div class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +   </div><div class="line">                            <span class="string">"进入，当前已有"</span> + (<span class="number">3</span>-sp.availablePermits()) + <span class="string">"个并发"</span>);  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">10000</span>));  </div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125;  </div><div class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +   </div><div class="line">                            <span class="string">"即将离开"</span>);                      </div><div class="line">                    sp.release();   <span class="comment">// 释放一个许可，将其返回给信号量  </span></div><div class="line">  </div><div class="line">                    <span class="comment">//下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元  </span></div><div class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +   </div><div class="line">                            <span class="string">"已离开，当前已有"</span> + (<span class="number">3</span>-sp.availablePermits()) + <span class="string">"个并发"</span>);                      </div><div class="line">                &#125;  </div><div class="line">            &#125;;  </div><div class="line">            service.execute(runnable);            </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">线程pool-1-thread-3进入，当前已有3个并发</div><div class="line">线程pool-1-thread-2进入，当前已有3个并发</div><div class="line">线程pool-1-thread-1进入，当前已有3个并发</div><div class="line">线程pool-1-thread-2即将离开</div><div class="line">线程pool-1-thread-2已离开，当前已有2个并发</div><div class="line">线程pool-1-thread-5进入，当前已有3个并发</div><div class="line">线程pool-1-thread-1即将离开</div><div class="line">线程pool-1-thread-1已离开，当前已有2个并发</div><div class="line">线程pool-1-thread-4进入，当前已有3个并发</div><div class="line">线程pool-1-thread-4即将离开</div><div class="line">线程pool-1-thread-4已离开，当前已有2个并发</div><div class="line">线程pool-1-thread-8进入，当前已有3个并发</div><div class="line">线程pool-1-thread-3即将离开</div><div class="line">线程pool-1-thread-7进入，当前已有3个并发</div><div class="line">线程pool-1-thread-3已离开，当前已有3个并发</div><div class="line">线程pool-1-thread-8即将离开</div><div class="line">线程pool-1-thread-8已离开，当前已有2个并发</div><div class="line">线程pool-1-thread-9进入，当前已有3个并发</div><div class="line">线程pool-1-thread-7即将离开</div><div class="line">线程pool-1-thread-7已离开，当前已有2个并发</div><div class="line">线程pool-1-thread-6进入，当前已有3个并发</div><div class="line">线程pool-1-thread-9即将离开</div><div class="line">线程pool-1-thread-9已离开，当前已有2个并发</div><div class="line">线程pool-1-thread-10进入，当前已有3个并发</div><div class="line">线程pool-1-thread-5即将离开</div><div class="line">线程pool-1-thread-5已离开，当前已有2个并发</div><div class="line">线程pool-1-thread-6即将离开</div><div class="line">线程pool-1-thread-6已离开，当前已有1个并发</div><div class="line">线程pool-1-thread-10即将离开</div><div class="line">线程pool-1-thread-10已离开，当前已有0个并发</div></pre></td></tr></table></figure>
<p>控制一个方法的并发量，比如同时只能有3个线程进来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</div><div class="line">    <span class="comment">//信号量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);<span class="comment">//允许个数，相当于放了3把锁</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line"></div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        method();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//同时最多只允许3个线程过来</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">        semaphore.acquire();<span class="comment">//获取一把锁</span></div><div class="line">        System.out.println(<span class="string">"ThreadName="</span>+Thread.currentThread().getName()+<span class="string">"过来了"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"ThreadName="</span>+Thread.currentThread().getName()+<span class="string">"出去了"</span>);</div><div class="line">        semaphore.release();<span class="comment">//释放一把锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ThreadName=Thread-1过来了</div><div class="line">ThreadName=Thread-4过来了</div><div class="line">ThreadName=Thread-0过来了</div><div class="line">ThreadName=Thread-1出去了</div><div class="line">ThreadName=Thread-4出去了</div><div class="line">ThreadName=Thread-2过来了</div><div class="line">ThreadName=Thread-3过来了</div><div class="line">ThreadName=Thread-0出去了</div><div class="line">ThreadName=Thread-5过来了</div><div class="line">ThreadName=Thread-3出去了</div><div class="line">ThreadName=Thread-2出去了</div><div class="line">ThreadName=Thread-6过来了</div><div class="line">ThreadName=Thread-7过来了</div><div class="line">ThreadName=Thread-5出去了</div><div class="line">ThreadName=Thread-9过来了</div><div class="line">ThreadName=Thread-7出去了</div><div class="line">ThreadName=Thread-6出去了</div><div class="line">ThreadName=Thread-8过来了</div><div class="line">ThreadName=Thread-9出去了</div><div class="line">ThreadName=Thread-8出去了</div></pre></td></tr></table></figure>
<p>三个线程a、b、c 并发运行，b，c 需要a 线程的数据怎么实现</p>
<p>根据问题的描述，我将问题用以下代码演示，ThreadA、ThreadB、ThreadC，ThreadA 用于初始化数据num，<br>只有当num 初始化完成之后再让ThreadB 和ThreadC 获取到初始化后的变量num。</p>
<p>分析过程如下：</p>
<p>考虑到多线程的不确定性，因此我们不能确保ThreadA 就一定先于ThreadB 和ThreadC 前执行，就算ThreadA先执行了，我们也无法保证ThreadA 什么时候才能将变量num 给初始化完成。因此我们必须让ThreadB 和ThreadC去等待ThreadA 完成任何后发出的消息。</p>
<p>现在需要解决两个难题，一是让ThreadB 和ThreadC 等待ThreadA 先执行完，二是ThreadA 执行完之后给<br>ThreadB 和ThreadC 发送消息。</p>
<p>解决上面的难题我能想到的两种方案，一是使用纯Java API 的Semaphore 类来控制线程的等待和释放，二是使用Android 提供的Handler 消息机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunication</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;<span class="comment">//定义一个变量作为数据</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//模拟耗时操作之后初始化变量num</span></div><div class="line">                    Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    num = <span class="number">1</span>;</div><div class="line"></div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName()</div><div class="line">                        +<span class="string">"获取到num 的值为："</span>+num);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(Thread.currentThread().getName()</div><div class="line">                        +<span class="string">"获取到num 的值为："</span>+num);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//同时开启3 个线程</span></div><div class="line">        threadA.start();</div><div class="line">        threadB.start();</div><div class="line">        threadC.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunication</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 定义一个信号量，该类内部维持了多个线程锁，可以阻塞多个线程，释放多个线程，</div><div class="line">     * 线程的阻塞和释放是通过permit 概念来实现的线程通过semaphore.acquire()方法获取permit，</div><div class="line">     * 如果当前semaphore 有permit 则分配给该线程，如果没有则阻塞该线程直到semaphore</div><div class="line">     * 调用release（）方法释放permit。构造函数中参数：permit（允许） 个数</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//模拟耗时操作之后初始化变量num</span></div><div class="line">                    Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    num = <span class="number">1</span>;</div><div class="line">                    <span class="comment">//初始化完参数后释放两个permit</span></div><div class="line">                    semaphore.release(<span class="number">2</span>);</div><div class="line"></div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//获取permit，如果semaphore 没有可用的permit 则等待</span></div><div class="line">                    <span class="comment">// 如果有则消耗一个</span></div><div class="line">                    semaphore.acquire();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName()</div><div class="line">                        +<span class="string">"获取到num 的值为："</span>+num);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//获取permit，如果semaphore 没有可用的permit 则等待</span></div><div class="line">                    <span class="comment">// 如果有则消耗一个</span></div><div class="line">                    semaphore.acquire();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"></div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                System.out.println(Thread.currentThread().getName()</div><div class="line">                        +<span class="string">"获取到num 的值为："</span>+num);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//同时开启3 个线程</span></div><div class="line">        threadA.start();</div><div class="line">        threadB.start();</div><div class="line">        threadC.start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2. CyclicBarrier"></a>2. CyclicBarrier</h1><p>一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 </p>
<p>CyclicBarrier 支持一个可选的 Runnable 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作 很有用。 </p>
<p>3个线程到达某个集合点后再向下执行,使用await方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        ExecutorService service = Executors.newCachedThreadPool();  </div><div class="line">        <span class="keyword">final</span>  CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>);  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;  </div><div class="line">            Runnable runnable = <span class="keyword">new</span> Runnable()&#123;  </div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">10000</span>));    </div><div class="line">                        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +   </div><div class="line">                                <span class="string">"即将到达集合地点1，当前已有"</span> + (cb.getNumberWaiting()+<span class="number">1</span>) + <span class="string">"个已经到达，"</span> + (cb.getNumberWaiting()==<span class="number">2</span>?<span class="string">"都到齐了，继续走啊"</span>:<span class="string">"正在等候"</span>));                         </div><div class="line">                        cb.await();<span class="comment">//在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。  </span></div><div class="line">                          </div><div class="line">                        Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">10000</span>));    </div><div class="line">                        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +   </div><div class="line">                                <span class="string">"即将到达集合地点2，当前已有"</span> + (cb.getNumberWaiting()+<span class="number">1</span>) + <span class="string">"个已经到达，"</span> + (cb.getNumberWaiting()==<span class="number">2</span>?<span class="string">"都到齐了，继续走啊"</span>:<span class="string">"正在等候"</span>));  </div><div class="line">                        cb.await();   </div><div class="line">                        Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">10000</span>));    </div><div class="line">                        System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +   </div><div class="line">                                <span class="string">"即将到达集合地点3，当前已有"</span> + (cb.getNumberWaiting() + <span class="number">1</span>) + <span class="string">"个已经到达，"</span> + (cb.getNumberWaiting()==<span class="number">2</span>?<span class="string">"都到齐了，继续走啊"</span>:<span class="string">"正在等候"</span>));                       </div><div class="line">                        cb.await();                       </div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125;                 </div><div class="line">                &#125;  </div><div class="line">            &#125;;  </div><div class="line">            service.execute(runnable);  </div><div class="line">        &#125;  </div><div class="line">        service.shutdown();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">线程pool-1-thread-3即将到达集合地点1，当前已有1个已经到达，正在等候</div><div class="line">线程pool-1-thread-1即将到达集合地点1，当前已有2个已经到达，正在等候</div><div class="line">线程pool-1-thread-2即将到达集合地点1，当前已有3个已经到达，都到齐了，继续走啊</div><div class="line">线程pool-1-thread-1即将到达集合地点2，当前已有1个已经到达，正在等候</div><div class="line">线程pool-1-thread-2即将到达集合地点2，当前已有2个已经到达，正在等候</div><div class="line">线程pool-1-thread-3即将到达集合地点2，当前已有3个已经到达，都到齐了，继续走啊</div><div class="line">线程pool-1-thread-3即将到达集合地点3，当前已有1个已经到达，正在等候</div><div class="line">线程pool-1-thread-1即将到达集合地点3，当前已有2个已经到达，正在等候</div><div class="line">线程pool-1-thread-2即将到达集合地点3，当前已有3个已经到达，都到齐了，继续走啊</div></pre></td></tr></table></figure>
<h1 id="3-CountDownLatch"><a href="#3-CountDownLatch" class="headerlink" title="3. CountDownLatch"></a>3. CountDownLatch</h1><p>一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。犹如倒计时计数器，调用CountDownLatch对象的countDown方法就将计数器减1，当计数到达0时，则所有等待者或单个等待者开始执行。</p>
<p>可以实现一个人（也可以是多个人）等待其他所有人都来通知他，也可以实现一个人通知多个人的效果，类似裁判一声口令，运动员开始奔跑（一对多），或者所有运送员都跑到终点后裁判才可以公布结果（多对一）。</p>
<p>用指定的计数 初始化 CountDownLatch。在调用 countDown() 方法之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。 </p>
<p>实现运动员比赛的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchTest</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          </div><div class="line">　　ExecutorService service = Executors.newCachedThreadPool();  </div><div class="line">　　  </div><div class="line">　　<span class="comment">//构造一个用给定计数初始化的 CountDownLatch,相当于裁判的口哨  </span></div><div class="line">　　<span class="keyword">final</span> CountDownLatch cdOrder = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);  </div><div class="line">　　  </div><div class="line">　　    <span class="comment">//相当于定义3个运行员  </span></div><div class="line">        <span class="keyword">final</span> CountDownLatch cdAnswer = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;  </div><div class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() &#123;  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        System.out.println(<span class="string">"线程"</span>  </div><div class="line">                                + Thread.currentThread().getName() + <span class="string">"正准备接受命令"</span>);  </div><div class="line">  </div><div class="line">                        <span class="comment">// 等待发令枪  </span></div><div class="line">                        cdOrder.await();<span class="comment">//使当前线程在锁存器倒计数至零之前一直等待  </span></div><div class="line">  </div><div class="line">                        System.out.println(<span class="string">"线程"</span>  </div><div class="line">                                + Thread.currentThread().getName() + <span class="string">"已接受命令"</span>);  </div><div class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));  </div><div class="line">                        System.out  </div><div class="line">                                .println(<span class="string">"线程"</span>  </div><div class="line">                                        + Thread.currentThread().getName()  </div><div class="line">                                        + <span class="string">"回应命令处理结果"</span>);  </div><div class="line">  </div><div class="line">                        <span class="comment">// 各个运动员完报告成绩之后，通知裁判  </span></div><div class="line">                        cdAnswer.countDown();<span class="comment">//递减锁存器的计数，如果计数到达零，则释放所有等待的线程  </span></div><div class="line">  </div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;;  </div><div class="line">            service.execute(runnable);  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));  </div><div class="line">  </div><div class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()  </div><div class="line">                    + <span class="string">"即将发布命令"</span>);  </div><div class="line">            <span class="comment">// 发令枪打响，比赛开始  </span></div><div class="line">            cdOrder.countDown();  </div><div class="line">  </div><div class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()  </div><div class="line">                    + <span class="string">"已发送命令，正在等待结果"</span>);  </div><div class="line">  </div><div class="line">            <span class="comment">// 裁判等待各个运动员的结果  </span></div><div class="line">            cdAnswer.await();  </div><div class="line">  </div><div class="line">            <span class="comment">// 裁判公布获得所有运动员的成绩  </span></div><div class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName()  </div><div class="line">                    + <span class="string">"已收到所有响应结果"</span>);  </div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">        service.shutdown();  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">线程pool-1-thread-2正准备接受命令</div><div class="line">线程pool-1-thread-3正准备接受命令</div><div class="line">线程pool-1-thread-1正准备接受命令</div><div class="line">线程main即将发布命令</div><div class="line">线程main已发送命令，正在等待结果</div><div class="line">线程pool-1-thread-1已接受命令</div><div class="line">线程pool-1-thread-2已接受命令</div><div class="line">线程pool-1-thread-3已接受命令</div><div class="line">线程pool-1-thread-1回应命令处理结果</div><div class="line">线程pool-1-thread-3回应命令处理结果</div><div class="line">线程pool-1-thread-2回应命令处理结果</div><div class="line">线程main已收到所有响应结果</div></pre></td></tr></table></figure>
<h1 id="4-Exchanger"><a href="#4-Exchanger" class="headerlink" title="4. Exchanger"></a>4. Exchanger</h1><p>用于实现两个对象之间的数据交换，每个对象在完成一定的事务后想与对方交换数据，第一个先拿出数据的对象将一直等待第二个对象拿着数据到来时，彼此才能交换数据。</p>
<p>方法：exchange（V x）</p>
<p>等待另一个线程到达此交换点（除非当前线程被中断），然后将给定的对象传送给该线程，并接收该线程的对象。</p>
<p>应用：使用 Exchanger 在线程间交换缓冲区</p>
<p>示例：模拟毒品交易情景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        ExecutorService service = Executors.newCachedThreadPool();  </div><div class="line">        <span class="keyword">final</span> Exchanger exchanger = <span class="keyword">new</span> Exchanger();  </div><div class="line">        service.execute(<span class="keyword">new</span> Runnable()&#123;  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                <span class="keyword">try</span> &#123;                 </div><div class="line">  </div><div class="line">                    String data1 = <span class="string">"毒品"</span>;  </div><div class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +   </div><div class="line">                    <span class="string">"正在把: "</span> + data1 +<span class="string">"   交易出去"</span>);  </div><div class="line">                    Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">10000</span>));  </div><div class="line">                    String data2 = (String)exchanger.exchange(data1);  </div><div class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +   </div><div class="line">                    <span class="string">"换得了: "</span> + data2);  </div><div class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;  </div><div class="line">                      </div><div class="line">                &#125;  </div><div class="line">            &#125;     </div><div class="line">        &#125;);  </div><div class="line">        service.execute(<span class="keyword">new</span> Runnable()&#123;  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                <span class="keyword">try</span> &#123;                 </div><div class="line">  </div><div class="line">                    String data1 = <span class="string">"美金"</span>;  </div><div class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +   </div><div class="line">                    <span class="string">"正在把: "</span> + data1 +<span class="string">"   交易出去"</span>);  </div><div class="line">                    Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">10000</span>));                    </div><div class="line">                    String data2 = (String)exchanger.exchange(data1);  </div><div class="line">                    System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +   </div><div class="line">                    <span class="string">"换得了: "</span> + data2);  </div><div class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;  </div><div class="line">                      </div><div class="line">                &#125;                 </div><div class="line">            &#125;     </div><div class="line">        &#125;);       </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">线程pool-1-thread-1正在把: 毒品   交易出去</div><div class="line">线程pool-1-thread-2正在把: 美金   交易出去</div><div class="line">线程pool-1-thread-1换得了: 美金</div><div class="line">线程pool-1-thread-2换得了: 毒品</div></pre></td></tr></table></figure>
<h1 id="5-ArrayBlockingQueue"><a href="#5-ArrayBlockingQueue" class="headerlink" title="5. ArrayBlockingQueue"></a>5. ArrayBlockingQueue</h1><p>一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列包含固定长度的队列和不固定长度的队列。</p>
<p>这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。</p>
<p>通俗的讲：当指定队列大小，如果已经放满，其他存入数据的线程就阻塞，等着该队列中有空位，才能放进去。当取的比较快，队列中没有数据，取数据的线程阻塞，等队列中放入了数据，才可以取。</p>
<p>ArrayBlockingQueue中只有put和take方法才具有阻塞功能。方法类型如下</p>
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left">抛出异常</th>
<th style="text-align:left">特殊值</th>
<th style="text-align:left">阻塞</th>
<th style="text-align:left">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">插入</td>
<td style="text-align:left">add(e)</td>
<td style="text-align:left">offer(e)</td>
<td style="text-align:left">put(e)</td>
<td style="text-align:left">offer(e, time, unit)</td>
</tr>
<tr>
<td style="text-align:left">移除</td>
<td style="text-align:left">remove()</td>
<td style="text-align:left">poll()</td>
<td style="text-align:left">take()</td>
<td style="text-align:left">poll(time, unit)</td>
</tr>
<tr>
<td style="text-align:left">检查</td>
<td style="text-align:left">element()</td>
<td style="text-align:left">peek()</td>
<td style="text-align:left">不可用</td>
<td style="text-align:left">不可用</td>
</tr>
</tbody>
</table>
<p>示例：用3个空间的队列来演示向阻塞队列中存取数据的效果。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> cn.xushuai.thread;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">final</span> BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>);  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;  </div><div class="line">            <span class="keyword">new</span> Thread()&#123;  </div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </div><div class="line">                    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </div><div class="line">                        <span class="keyword">try</span> &#123;  </div><div class="line">                            Thread.sleep((<span class="keyword">long</span>)(Math.random()*<span class="number">1000</span>));  </div><div class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"准备放数据!"</span>);</div><div class="line">                            queue.put(<span class="number">1</span>);   <span class="comment">//放进去后，可能立即执行“准备取数据”  </span></div><div class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"已经放了数据，"</span> + <span class="string">"队列目前有"</span> + queue.size() + <span class="string">"个数据"</span>);  </div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                            e.printStackTrace();  </div><div class="line">                        &#125;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">                  </div><div class="line">            &#125;.start();  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        <span class="keyword">new</span> Thread()&#123;  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        <span class="comment">//将此处的睡眠时间分别改为100和1000，观察运行结果  </span></div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"准备取数据!"</span>);  </div><div class="line">                        queue.take(); <span class="comment">//取出后可能來不及执行下面的打印语句，就跑到了“准备放数据”，  </span></div><div class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"已经取走数据，"</span> + <span class="string">"队列目前有"</span> + queue.size() + <span class="string">"个数据"</span>);                      </div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;.start();            </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Thread-0准备放数据!</div><div class="line">Thread-0已经放了数据，队列目前有1个数据</div><div class="line">Thread-0准备放数据!</div><div class="line">Thread-0已经放了数据，队列目前有2个数据</div><div class="line">Thread-1准备放数据!</div><div class="line">Thread-1已经放了数据，队列目前有3个数据</div><div class="line">Thread-2准备取数据!</div><div class="line">Thread-2已经取走数据，队列目前有2个数据</div><div class="line">Thread-0准备放数据!</div><div class="line">Thread-0已经放了数据，队列目前有3个数据</div><div class="line">Thread-0准备放数据!</div><div class="line">Thread-1准备放数据!</div><div class="line">Thread-2准备取数据!</div><div class="line">Thread-2已经取走数据，队列目前有2个数据</div><div class="line">Thread-0已经放了数据，队列目前有3个数据</div><div class="line">Thread-0准备放数据!</div><div class="line">Thread-2准备取数据!</div><div class="line">Thread-2已经取走数据，队列目前有2个数据</div><div class="line">Thread-1已经放了数据，队列目前有3个数据</div><div class="line">Thread-1准备放数据!</div><div class="line">Thread-2准备取数据!</div><div class="line">Thread-2已经取走数据，队列目前有2个数据</div><div class="line">Thread-0已经放了数据，队列目前有3个数据</div><div class="line">Thread-0准备放数据!</div><div class="line">Thread-2准备取数据!</div><div class="line">...</div></pre></td></tr></table></figure></p>
<h1 id="6-阻塞队列间的通信"><a href="#6-阻塞队列间的通信" class="headerlink" title="6. 阻塞队列间的通信"></a>6. 阻塞队列间的通信</h1><p>A队列向空间中存数据，B从空间里取数据，A存入后，通知B去取，B取过之后，通知A去放，依次循环</p>
<p><strong>示例</strong>：子线程先循环10次，接着主线程循环100次，接着又回到子线程，循环10次，再回到主线程又循环100，如此循环50次。</p>
<p><strong>说明</strong>：这里通过使 用两个具有1个空间的队列来实现同步通知的功能（实现了锁和condition的功能），以便实现队列间的通信，其中使用到了构造代码块为主队列先存入一个数据，以使其先阻塞，子队列先执行。</p>
<p>使用构造代码块的原因：</p>
<p>成员变量在创建类的实例对象时，才分配空间，才能有值，所以创建一个构造方法来给main_quene赋值，这里不可以使用静态代码块，因为静态在还没创建对象就存在， 而sub_quene和main_quene是对象创建以后的成员变量，所以这里用匿名构造方法，它的运行时期在任何构造方法之前，创建几个对象就执行几次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueCommunication</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">          </div><div class="line">        <span class="keyword">final</span> Business business = <span class="keyword">new</span> Business();  </div><div class="line">          </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;  </div><div class="line">                    business.sub(i);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;).start();  </div><div class="line">  </div><div class="line">            <span class="comment">//主线程外部循环  </span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;  </div><div class="line">                business.main(i);  </div><div class="line">          &#125;  </div><div class="line">       &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">//业务类  </span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span></span>&#123;  </div><div class="line">          </div><div class="line">        BlockingQueue&lt;Integer&gt; sub_quene = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">1</span>);  </div><div class="line">        BlockingQueue&lt;Integer&gt; main_quene = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">1</span>);  </div><div class="line">                  </div><div class="line">        &#123;  </div><div class="line">　　        <span class="comment">//为了让子队列先走，所以在一开始就往主队列中存入一个对象，使其阻塞。  </span></div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                main_quene.put(<span class="number">1</span>);    </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;         </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        <span class="comment">//子队列先走       </span></div><div class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;  </div><div class="line">              </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                sub_quene.put(<span class="number">1</span>);   <span class="comment">//子队列第一次存入，可以执行，但由于只有1个空间，已经存满，所以只有在执行后要等到take之后才能继续下次执行  </span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">            <span class="comment">//子队列循环执行  </span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)&#123;  </div><div class="line">                System.out.println(<span class="string">"sub thread sequence of"</span>+i+<span class="string">",loop of "</span>+j);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                main_quene.take();  <span class="comment">//让主队列从已经填满的队列中取出数据，使其开始第一次执行  </span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;  </div><div class="line">              </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                main_quene.put(<span class="number">1</span>);  <span class="comment">//主队列先前放过1个空间，现在处于阻塞状态，等待子队列通知，即子线程中的main_quene.take();   </span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">              </div><div class="line">　　<span class="comment">//主队列循环执行  </span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">100</span>;j++)&#123;  </div><div class="line">                System.out.println(<span class="string">"main thread sequence of"</span>+i+<span class="string">", loop of "</span>+j);  </div><div class="line">            &#125;     </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                sub_quene.take(); <span class="comment">//让子队列从已经填满的队列中取出数据，使其执行  </span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;     </div><div class="line">    &#125;  </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="7-同步集合类"><a href="#7-同步集合类" class="headerlink" title="7. 同步集合类"></a><strong>7. 同步集合类</strong></h1><h2 id="7-1-同步Map集合"><a href="#7-1-同步Map集合" class="headerlink" title="7.1 同步Map集合"></a>7.1 同步Map集合</h2><ul>
<li>java.util.concurrent.ConcurrentMap</li>
<li>ConcurrentHashMap</li>
<li>ConcurrentNavigableMap</li>
<li>ConcurrentSkipListMap</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><strong>ConcurrentHashMap</strong></h3><p>同步的HashMap，支持获取的完全并发和更新的所期望可调整并发的哈希表。此类遵守与 Hashtable 相同的功能规范，并且包括对应于 Hashtable 的每个方法的方法版本。</p>
<p>不过，尽管所有操作都是线程安全的，但获取操作不 必锁定，并且不 支持以某种防止所有访问的方式锁定整个表。此类可以通过程序完全与 Hashtable 进行互操作，这取决于其线程安全，而与其同步细节无关。</p>
<p>内部原理：</p>
<p>其实内部使用了代理模式，你给我一个HashMap，我就给你一个同步的HashMap。同步的HashMap在调用方法时，是去分配给原始的HashMap只是在去调用方法的同时加上了Synchronized，以此实现同步效果</p>
<p>ConcurrentHashMap是线程安全的HashMap的实现，默认构造同样有initialCapacity和loadFactor属性，不过还多了一个concurrencyLevel属性，三属性默认值分别为16、0.75及16。其内部使用锁分段技术，维持这锁Segment的数组，在Segment数组中又存放着Entity[]数组，内部hash算法将数据较均匀分布在不同锁中。</p>
<ul>
<li>put(key , value)</li>
</ul>
<p>并没有在此方法上加上synchronized，首先对key.hashcode进行hash操作，得到key的hash值。hash操作的算法和map也不同，根据此hash值计算并获取其对应的数组中的Segment对象(继承自ReentrantLock)，接着调用此Segment对象的put方法来完成当前操作。</p>
<p>ConcurrentHashMap基于concurrencyLevel划分出了多个Segment来对key-value进行存储，从而避免每次put操作都得锁住整个数组。在默认的情况下，最佳情况下可允许16个线程并发无阻塞的操作集合对象，尽可能地减少并发时的阻塞现象。</p>
<ul>
<li>get(key)</li>
</ul>
<p>首先对key.hashCode进行hash操作，基于其值找到对应的Segment对象，调用其get方法完成当前操作。而Segment的get操作首先通过hash值和对象数组大小减1的值进行按位与操作来获取数组上对应位置的HashEntry。在这个步骤中，可能会因为对象数组大小的改变，以及数组上对应位置的HashEntry产生不一致性，那么ConcurrentHashMap是如何保证的？</p>
<p>对象数组大小的改变只有在put操作时有可能发生，由于HashEntry对象数组对应的变量是volatile类型的，因此可以保证如HashEntry对象数组大小发生改变，读操作可看到最新的对象数组大小。</p>
<p>在获取到了HashEntry对象后，怎么能保证它及其next属性构成的链表上的对象不会改变呢？这点ConcurrentHashMap采用了一个简单的方式，即HashEntry对象中的hash、key、next属性都是final的，这也就意味着没办法插入一个HashEntry对象到基于next属性构成的链表中间或末尾。这样就可以保证当获取到HashEntry对象后，其基于next属性构建的链表是不会发生变化的。</p>
<p>ConcurrentHashMap默认情况下采用将数据分为16个段进行存储，并且16个段分别持有各自不同的锁Segment，锁仅用于put和remove等改变集合对象的操作，基于volatile及HashEntry链表的不变性实现了读取的不加锁。这些方式使得ConcurrentHashMap能够保持极好的并发支持，尤其是对于读远比插入和删除频繁的Map而言，而它采用的这些方法也可谓是对于Java内存模型、并发机制深刻掌握的体现。</p>
<h3 id="ConcurrentNavigableMap"><a href="#ConcurrentNavigableMap" class="headerlink" title="ConcurrentNavigableMap"></a>ConcurrentNavigableMap</h3><p>java.util.concurrent.ConcurrentNavigableMap 是一个支持并发访问的 java.util.NavigableMap，它还能让它的子 map 具备并发访问的能力。所谓的 “子 map” 指的是诸如 headMap()，subMap()，tailMap() 之类的方法返回的 map。</p>
<p>NavigableMap 中的方法不再赘述，本小节我们来看一下 ConcurrentNavigableMap 添加的方法。</p>
<h4 id="headMap"><a href="#headMap" class="headerlink" title="headMap()"></a>headMap()</h4><p>headMap(T toKey) 方法返回一个包含了小于给定 toKey 的 key 的子 map。<br>如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素(译者注：map 集合持有的其实只是对象的引用)。</p>
<p>以下示例演示了对 headMap() 方法的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ConcurrentNavigableMap map = <span class="keyword">new</span> ConcurrentSkipListMap();  </div><div class="line"></div><div class="line">map.put(<span class="string">"1"</span>, <span class="string">"one"</span>);  </div><div class="line">map.put(<span class="string">"2"</span>, <span class="string">"two"</span>);  </div><div class="line">map.put(<span class="string">"3"</span>, <span class="string">"three"</span>);  </div><div class="line"></div><div class="line">ConcurrentNavigableMap headMap = map.headMap(<span class="string">"2"</span>);</div></pre></td></tr></table></figure>
<p>headMap 将指向一个只含有键 “1” 的 ConcurrentNavigableMap，因为只有这一个键小于 “2”。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。</p>
<h4 id="tailMap"><a href="#tailMap" class="headerlink" title="tailMap()"></a>tailMap()</h4><p>tailMap(T fromKey) 方法返回一个包含了不小于给定 fromKey 的 key 的子 map。<br>如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素(译者注：map 集合持有的其实只是对象的引用)。</p>
<p>以下示例演示了对 tailMap() 方法的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ConcurrentNavigableMap map = <span class="keyword">new</span> ConcurrentSkipListMap();  </div><div class="line"></div><div class="line">map.put(<span class="string">"1"</span>, <span class="string">"one"</span>);  </div><div class="line">map.put(<span class="string">"2"</span>, <span class="string">"two"</span>);  </div><div class="line">map.put(<span class="string">"3"</span>, <span class="string">"three"</span>);  </div><div class="line"></div><div class="line">ConcurrentNavigableMap tailMap = map.tailMap(<span class="string">"2"</span>);</div></pre></td></tr></table></figure>
<p>tailMap 将拥有键 “2” 和 “3”，因为它们不小于给定键 “2”。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。</p>
<h4 id="subMap"><a href="#subMap" class="headerlink" title="subMap()"></a>subMap()</h4><p>subMap() 方法返回原始 map 中，键介于 from(包含) 和 to (不包含) 之间的子 map。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ConcurrentNavigableMap map = <span class="keyword">new</span> ConcurrentSkipListMap();  </div><div class="line"></div><div class="line">map.put(<span class="string">"1"</span>, <span class="string">"one"</span>);  </div><div class="line">map.put(<span class="string">"2"</span>, <span class="string">"two"</span>);  </div><div class="line">map.put(<span class="string">"3"</span>, <span class="string">"three"</span>);  </div><div class="line"></div><div class="line">ConcurrentNavigableMap subMap = map.subMap(<span class="string">"2"</span>, <span class="string">"3"</span>);</div></pre></td></tr></table></figure>
<p>返回的 submap 只包含键 “2”，因为只有它满足不小于 “2”，比 “3” 小。</p>
<h4 id="更多方法"><a href="#更多方法" class="headerlink" title="更多方法"></a>更多方法</h4><p>ConcurrentNavigableMap 接口还有其他一些方法可供使用，比如：</p>
<ul>
<li>descendingKeySet()</li>
<li>descendingMap()</li>
<li>navigableKeySet()</li>
</ul>
<p>关于这些方法更多信息参考官方 Java 文档。</p>
<h2 id="7-2-同步List集合"><a href="#7-2-同步List集合" class="headerlink" title="7.2 同步List集合"></a>7.2 同步List集合</h2><ul>
<li>ConcurrentSkipListSet</li>
<li>CopyOnWriteArraySet</li>
<li>CopyOnWriteArrayList</li>
</ul>
<h3 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a><strong>ConcurrentSkipListSet</strong></h3><p>一个基于 ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现。类似于TreeSet，set 的元素可以根据它们的自然顺序进行排序，也可以根据创建 set 时所提供的Comparator 进行排序，具体取决于使用的构造方法。</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><strong>CopyOnWriteArrayList</strong></h3><p>ArrayList 的一个线程安全的变体，可解决线程安全问题，在遍历的时候，同时进行添加操作。其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。</p>
<p>CopyOnWriteArrayList是一个线程安全、并且在读操作时无锁的ArrayList，其具体实现方法如下。</p>
<ul>
<li>CopyOnWriteArrayList()</li>
</ul>
<p>和ArrayList不同，此步的做法为创建一个大小为0的数组。</p>
<ul>
<li>add(E)</li>
</ul>
<p>add方法并没有加上synchronized关键字，它通过使用ReentrantLock来保证线程安全。此处和ArrayList的不同是每次都会创建一个新的Object数组，此数组的大小为当前数组大小加1，将之前数组中的内容复制到新的数组中，并将新增加的对象放入数组末尾，最后做引用切换将新创建的数组对象赋值给全局的数组对象。</p>
<ul>
<li>remove(E)</li>
</ul>
<p>和add方法一样，此方法也通过ReentrantLock来保证其线程安全，但它和ArrayList删除元素采用的方式并不一样。</p>
<p>首先创建一个比当前数组小1的数组，遍历新数组，如找到equals或均为null的元素，则将之后的元素全部赋值给新的数组对象，并做引用切换，返回true；如未找到，则将当前的元素赋值给新的数组对象，最后特殊处理数组中的最后一个元素，如最后一个元素等于要删除的元素，即将当前数组对象赋值为新创建的数组对象，完成删除操作，如最后一个元素也不等于要删除的元素，那么返回false。</p>
<p>此方法和ArrayList除了锁不同外，最大的不同在于其复制过程并没有调用System的arrayCopy来完成，理论上来说会导致性能有一定下降。</p>
<ul>
<li>get(int)    </li>
</ul>
<p>此方法非常简单，直接获取当前数组对应位置的元素，这种方法是没有加锁保护的，因此可能会出现读到脏数据的现象。但相对而言，性能会非常高，对于写少读多且脏数据影响不大的场景而言是不错的选择。</p>
<ul>
<li>iterator()</li>
</ul>
<p>调用iterator方法后创建一个新的COWIterator对象实例，并保存了一个当前数组的快照，在调用next遍历时则仅对此快照数组进行遍历，因此遍历此list时不会抛出ConcurrentModificatiedException。</p>
<p>与ArrayList的性能对比，在读多写少的并发场景中，较之ArrayList是更好的选择，单线程以及多线程下增加元素及删除元素的性能不比ArrayList好</p>
<h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a><strong>CopyOnWriteArraySet</strong></h3><p>对其所有操作使用内部 CopyOnWriteArrayList 的 Set。因此，它共享以下相同的基本属性：</p>
<ul>
<li>它最适合于 set 大小通常保持很小、只读操作远多于可变操作以及需要在遍历期间防止线程间冲突的应用程序。</li>
<li>它是线程安全的。</li>
<li>因为通常需要复制整个基础数组，所以可变操作（添加、设置、移除，等等）的开销巨大。</li>
<li>迭代器不支持可变移除操作。</li>
<li>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</li>
</ul>
<p>CopyOnWriteArraySet基于CopyOnWriteArrayList实现，其唯一的不同是在add时调用的是CopyOnWriteArrayList的addIfAbsent方法。保证了无重复元素，但在add时每次都要进行数组的遍历，因此性能会略低于上个。</p>
<h2 id="7-3-ConcurrentLinkedQueue"><a href="#7-3-ConcurrentLinkedQueue" class="headerlink" title="7.3 ConcurrentLinkedQueue"></a>7.3 ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue是一个基于链接节点的、无界的、线程安全的队列。此队列按照 FIFO（先进先出）原则对元素进行排序，队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列检索操作从队列头部获得元素。当许多线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择，此队列不允许 null 元素。</p>
<h2 id="7-4-ConcurrentLinkedDeque"><a href="#7-4-ConcurrentLinkedDeque" class="headerlink" title="7.4 ConcurrentLinkedDeque"></a>7.4 ConcurrentLinkedDeque</h2><p>一个基于链接节点的、无界的、线程安全的双端队列</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/volatile关键字解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋过冬漫长">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/volatile关键字解析/" itemprop="url">
                  volatile关键字解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T23:56:42+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文链接：<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
</blockquote>
<p>volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p>
<p>volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p>
<h1 id="目录大纲"><a href="#目录大纲" class="headerlink" title="目录大纲"></a>目录大纲</h1><ul>
<li>内存模型的相关概念</li>
<li>并发编程中的三个概念</li>
<li>Java内存模型</li>
<li>深入剖析volatile关键字</li>
<li>使用volatile关键字的场景</li>
</ul>
<h1 id="1-内存模型的相关概念"><a href="#1-内存模型的相关概念" class="headerlink" title="1. 内存模型的相关概念"></a>1. 内存模型的相关概念</h1><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = i + <span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p>为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>
<ul>
<li>通过在总线加LOCK锁的方式</li>
<li>通过缓存一致性协议</li>
</ul>
<p>这2种方式都是硬件层面上提供的方式。</p>
<p>在早期的CPU当中，是通过在总线上加LOCK锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p><img src="http://images.cnitblog.com/blog/288799/201408/212219343783699.jpg" alt="内存模型"></p>
<h1 id="2-并发编程中的三个概念"><a href="#2-并发编程中的三个概念" class="headerlink" title="2. 并发编程中的三个概念"></a>2. 并发编程中的三个概念</h1><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>
<h2 id="2-1-原子性"><a href="#2-1-原子性" class="headerlink" title="2.1 原子性"></a>2.1 原子性</h2><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>一个很经典的例子就是银行账户转账问题：</p>
<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>同样地反映到并发编程中会出现什么结果呢？</p>
<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">9</span>;</div></pre></td></tr></table></figure>
<p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>
<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<h2 id="2-2-可见性"><a href="#2-2-可见性" class="headerlink" title="2.2 可见性"></a>2.2 可见性</h2><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1执行的代码</span></div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">i = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="comment">//线程2执行的代码</span></div><div class="line">j = i;</div></pre></td></tr></table></figure>
<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h2 id="2-3-有序性"><a href="#2-3-有序性" class="headerlink" title="2.3 有序性"></a>2.3 有序性</h2><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </div><div class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></div><div class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></div></pre></td></tr></table></figure>
<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></div><div class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></div><div class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></div><div class="line">r = a*a;     <span class="comment">//语句4</span></div></pre></td></tr></table></figure>
<p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p><img src="http://images.cnitblog.com/blog/288799/201408/212305263939989.jpg" alt="img"></p>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p>
<p>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();   <span class="comment">//语句1</span></div><div class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h1 id="3-Java内存模型"><a href="#3-Java内存模型" class="headerlink" title="3. Java内存模型"></a>3. Java内存模型</h1><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>举个简单的例子：在java中，执行下面这个语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">10</span>;</div></pre></td></tr></table></figure>
<p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<h1 id="4-原子性"><a href="#4-原子性" class="headerlink" title="4. 原子性"></a>4. 原子性</h1><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">10</span>;         <span class="comment">//语句1</span></div><div class="line">y = x;         <span class="comment">//语句2</span></div><div class="line">x++;           <span class="comment">//语句3</span></div><div class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></div></pre></td></tr></table></figure>
<p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h1 id="5-可见性"><a href="#5-可见性" class="headerlink" title="5. 可见性"></a>5. 可见性</h1><p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h1 id="6-有序性"><a href="#6-有序性" class="headerlink" title="6. 有序性"></a>6. 有序性</h1><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>下面就来具体介绍下happens-before原则（先行发生原则）：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>
<p>这8条原则摘自《深入理解Java虚拟机》。这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。下面我们来解释一下前4条规则：</p>
<p>对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h1 id="7-深入剖析volatile关键字"><a href="#7-深入剖析volatile关键字" class="headerlink" title="7. 深入剖析volatile关键字"></a>7. 深入剖析volatile关键字</h1><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<h2 id="7-1-volatile关键字的两层语义"><a href="#7-1-volatile关键字的两层语义" class="headerlink" title="7.1 volatile关键字的两层语义"></a>7.1 volatile关键字的两层语义</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ul>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
</ul>
<p>先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1</span></div><div class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">while</span>(!stop)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//线程2</span></div><div class="line">stop = <span class="keyword">true</span>;</div></pre></td></tr></table></figure>
<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>但是用volatile修饰之后就变得不一样了：</p>
<p>第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>那么线程1读取到的就是最新的正确的值。</p>
<h2 id="7-2-volatile保证原子性吗？"><a href="#7-2-volatile保证原子性吗？" class="headerlink" title="7.2 volatile保证原子性吗？"></a>7.2 volatile保证原子性吗？</h2><p>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>
<p>下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，</p>
<p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>把上面的代码改成以下任何一种都可以达到效果：</p>
<p>采用synchronized：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用Lock：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            inc++;</div><div class="line">        &#125; <span class="keyword">finally</span>&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>采用AtomicInteger：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span>  AtomicInteger inc = <span class="keyword">new</span> AtomicInteger();</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc.getAndIncrement();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<h2 id="7-3-volatile能保证有序性吗？"><a href="#7-3-volatile能保证有序性吗？" class="headerlink" title="7.3 volatile能保证有序性吗？"></a>7.3 volatile能保证有序性吗？</h2><p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>volatile关键字禁止指令重排序有两层意思：</p>
<ul>
<li><p>当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
</li>
<li><p>在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
</li>
</ul>
<p>可能上面说的比较绕，举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//x、y为非volatile变量</span></div><div class="line"><span class="comment">//flag为volatile变量</span></div><div class="line"> </div><div class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></div><div class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></div><div class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></div><div class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></div><div class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></div></pre></td></tr></table></figure>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>那么我们回到前面举的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();   <span class="comment">//语句1</span></div><div class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<h2 id="7-4-volatile的原理和实现机制"><a href="#7-4-volatile的原理和实现机制" class="headerlink" title="7.4 volatile的原理和实现机制"></a>7.4 volatile的原理和实现机制</h2><p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。下面这段话摘自《深入理解Java虚拟机》：</p>
<blockquote>
<p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
</blockquote>
<p>lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>
</ul>
<h2 id="7-5-使用volatile关键字的场景"><a href="#7-5-使用volatile关键字的场景" class="headerlink" title="7.5 使用volatile关键字的场景"></a>7.5 使用volatile关键字的场景</h2><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<ul>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
</ul>
<p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>下面列举几个Java中使用volatile的几个场景。</p>
<p>状态标记量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"> </div><div class="line"><span class="keyword">while</span>(!flag)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</div><div class="line">    flag = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</div><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();  </div><div class="line">inited = <span class="keyword">true</span>;            </div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<p>double check</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 至于为何需要这么写请参考：</p>
<p><a href="http://blog.csdn.net/dl88250/article/details/5439024" target="_blank" rel="external">Java 中的双重检查（Double-Check）</a></p>
<p><a href="http://www.iteye.com/topic/652440" target="_blank" rel="external">单例模式与双重检测</a></p>
<h1 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8. 参考资料"></a>8. 参考资料</h1><p>《Java编程思想》</p>
<p>《深入理解Java虚拟机》</p>
<p><a href="http://jiangzhengjun.iteye.com/blog/652532" target="_blank" rel="external">http://jiangzhengjun.iteye.com/blog/652532</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html</a></p>
<p><a href="http://ifeve.com/volatile/" target="_blank" rel="external">http://ifeve.com/volatile/</a></p>
<p><a href="http://blog.csdn.net/ccit0519/article/details/11241403" target="_blank" rel="external">http://blog.csdn.net/ccit0519/article/details/11241403</a></p>
<p><a href="http://blog.csdn.net/ns_code/article/details/17101369" target="_blank" rel="external">http://blog.csdn.net/ns_code/article/details/17101369</a></p>
<p><a href="http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html" target="_blank" rel="external">http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html</a></p>
<p><a href="http://www.cppblog.com/elva/archive/2011/01/21/139019.html" target="_blank" rel="external">http://www.cppblog.com/elva/archive/2011/01/21/139019.html</a></p>
<p><a href="http://ifeve.com/volatile-array-visiblity/" target="_blank" rel="external">http://ifeve.com/volatile-array-visiblity/</a></p>
<p><a href="http://www.bdqn.cn/news/201312/12579.shtml" target="_blank" rel="external">http://www.bdqn.cn/news/201312/12579.shtml</a></p>
<p><a href="http://exploer.blog.51cto.com/7123589/1193399" target="_blank" rel="external">http://exploer.blog.51cto.com/7123589/1193399</a></p>
<p><a href="http://www.cnblogs.com/Mainz/p/3556430.html" target="_blank" rel="external">http://www.cnblogs.com/Mainz/p/3556430.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/30/定时器、互斥、同步通信技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JackChan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ai.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="秋过冬漫长">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/30/定时器、互斥、同步通信技术/" itemprop="url">
                  定时器、互斥、同步通信技术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-30T23:56:42+08:00">
                2017-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="笔记摘要"><a href="#笔记摘要" class="headerlink" title="笔记摘要"></a><strong>笔记摘要</strong></h1><p>这里分析了多线程的一些细节问题，并介绍了传统定时器的创建，同时实现了根据自己的调度计划的自定义定时器，对于传统互斥技术中发现的内部类问题，进行了分析，最后对于同步通信技术，是重点，分析了如何处理类似的问题，如何设计能够更加清晰简单，体现了高内聚和程序的健壮性</p>
<h1 id="1-多线程的几个知识点"><a href="#1-多线程的几个知识点" class="headerlink" title="1. 多线程的几个知识点"></a><strong>1. 多线程的几个知识点</strong></h1><h2 id="1-1-为何使用实现Runnable的方式创建线程更普遍？"><a href="#1-1-为何使用实现Runnable的方式创建线程更普遍？" class="headerlink" title="1.1 为何使用实现Runnable的方式创建线程更普遍？"></a><strong>1.1 为何使用实现Runnable的方式创建线程更普遍？</strong></h2><p>new Runnable()的方式，更加体现面向对象的思想</p>
<p>通过 new Thread()创建一个线程，代码封装在runnable对象中，代码和线程独立分开来，但最终将它们组合在一起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">  </div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// code</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="1-2-获取线程名的时候，应使用currentThread-getName-方式"><a href="#1-2-获取线程名的时候，应使用currentThread-getName-方式" class="headerlink" title="1.2 获取线程名的时候，应使用currentThread().getName()方式"></a><strong>1.2 获取线程名的时候，应使用currentThread().getName()方式</strong></h2><p>因为this.getName()方式，只有在当前对象是Thread的时候可以，当我们使用runnable方式时，this代表的是runnable对象，它仅是要运行代码的宿主，而不是线程，当然编译也无法通过（没有此方法）。</p>
<h2 id="1-3-创建线程的两种传统方式的run方法执行问题"><a href="#1-3-创建线程的两种传统方式的run方法执行问题" class="headerlink" title="1.3 创建线程的两种传统方式的run方法执行问题"></a><strong>1.3 创建线程的两种传统方式的run方法执行问题</strong></h2><p>查看Thread类的run()方法的源代码，可以看到其实这两种方式都是在调用Thread对象的run()方法，如果Thread类的run()方法没有被覆盖，并且为该Thread对象设置了一个Runnable对象，该run方法会调用Runnable对象的run()方法。</p>
<p>下面是Thread类的run()方法的源码，可以看到runnable对象也是调用了Thread的run()方法。</p>
<p>当runnable对象不为null，并且有自己的run()方法，则执行自己的，如果target为null，则Thread类的run()方法什么也不执行，所以我们在创建线程的时候不直接创建Thread对象，而是创建其子类对象，目的是为了复写run方法，把要执行的代码放进去，否则该线程没有意义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Private Runnable target;  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;  </div><div class="line">            target.run();  </div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1-4-多线程的运行"><a href="#1-4-多线程的运行" class="headerlink" title="1.4 多线程的运行"></a><strong>1.4 多线程的运行</strong></h2><p>问题1：如果在Thread子类覆盖的run()方法中编写了运行代码，也为Thread子类对象传递了一个Runnable对象，那么，线程运行时的执行代码？</p>
<p>是子类的run方法的代码？还是Runnable对象的run()方法的代码？如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 匿名内部类的方式实现的一个子类，并在构造方法中传入了一个Runnable对象</span></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// code</span></div><div class="line">  &#125;</div><div class="line">&#125;) &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.run();</div><div class="line">    <span class="comment">// code</span></div><div class="line">  &#125;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure>
<p>会运行子类的run方法。因为当某个对象调用start方法之后，就会去找自己对象的run方法，如果没有就会找父类的run方法，父类的run方法会找runnable运行。</p>
<p>其实就是多态的一种体现，覆盖了父类的就执行自己的，没有覆盖就去找父类的执行</p>
<p>问题2：多线程机制是否会提高程序的运行效率？</p>
<p>多线程机制并不会提高程序的运行效率，反而性能更低，因为CPU需要在不同线程之间频繁切换。</p>
<h2 id="1-5-多线程下载的误解？"><a href="#1-5-多线程下载的误解？" class="headerlink" title="1.5 多线程下载的误解？"></a><strong>1.5 多线程下载的误解？</strong></h2><p>多线程下载其实是抢了服务器的带宽，一个线程代表一个用户，每个线程分配的带宽是相等的，开启的线程多，就会分配更多的带宽，是在抢资源，而不是自己更快。</p>
<h1 id="2-传统定时器：Timer类"><a href="#2-传统定时器：Timer类" class="headerlink" title="2. 传统定时器：Timer类"></a><strong>2. 传统定时器：Timer类</strong></h1><p>定时器有两种：一种在指定时间只执行一次，另一种先在指定时间执行一次，之后每隔指定时间循环执行。</p>
<p>该示例说明了定时器的创建方式，并通过自定义定时器的方式，在一个定时器内部通过不同切换秒数，来实现在不同的间隔时间实现循环爆炸，另外还通过两个类之间的互相实现相同的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Date;  </div><div class="line"><span class="keyword">import</span> java.util.Timer;  </div><div class="line"><span class="keyword">import</span> java.util.TimerTask;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraditionalTimerTest</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          </div><div class="line">        <span class="comment">//创建一个定时器并调度任务  </span></div><div class="line">    <span class="comment">/*  new Timer().schedule(new TimerTask() &#123; </span></div><div class="line">             </div><div class="line">            @Override </div><div class="line">            public void run() &#123; </div><div class="line">                System.out.println("bombing!"); </div><div class="line">                 </div><div class="line">            &#125; </div><div class="line">        &#125;, 3000);//3秒以后爆炸 </div><div class="line">*/      <span class="comment">//&#125;, 10000,3000);       //10秒以后爆炸，以后每隔3秒炸一次  </span></div><div class="line">          </div><div class="line">          </div><div class="line">        <span class="comment">//自定义一个定时器  </span></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span></span>&#123;  </div><div class="line">              </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                count = (count+<span class="number">1</span>)%<span class="number">2</span>;    <span class="comment">//在0和1之间切换  </span></div><div class="line">                System.out.println(<span class="string">"bombing!"</span>);  </div><div class="line">                <span class="keyword">new</span> Timer().schedule(<span class="comment">/*new TimerTask() &#123; </span></div><div class="line">                     </div><div class="line">                    @Override </div><div class="line">                    public void run() &#123; </div><div class="line">                        System.out.println("bombing!"); </div><div class="line">                    &#125; </div><div class="line">                &#125;*/<span class="keyword">new</span> MyTimerTask(),<span class="number">2000</span>+<span class="number">2000</span>*count);  </div><div class="line">                <span class="comment">//实现循环，不能用this，因为是匿名，所以只能执行一次，  </span></div><div class="line">                <span class="comment">//就像炸弹一样，炸完后就没有了，必须布置新的炸弹  </span></div><div class="line">                <span class="comment">//所以创建一个类，每次在最后new一个新的炸弹  </span></div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        <span class="comment">//开启定时器，每隔2秒调用一次MyTimerTask  </span></div><div class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> MyTimerTask(), <span class="number">2000</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">//为了观察定时器任务的执行：每隔1秒打印一次当前秒数  </span></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </div><div class="line">            System.out.println(<span class="keyword">new</span> Date().getSeconds());  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                <span class="comment">// TODO Auto-generated catch block  </span></div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用互相调用的方式实现间隔2秒和4秒的连环爆炸<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Date;  </div><div class="line"><span class="keyword">import</span> java.util.Timer;  </div><div class="line"><span class="keyword">import</span> java.util.TimerTask;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTraditionalTimer</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">          </div><div class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> MyTimerTask(), <span class="number">4000</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">//打印当前秒数  </span></div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </div><div class="line">            System.out.println(<span class="keyword">new</span> Date().getSeconds());  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                <span class="comment">// TODO Auto-generated catch block  </span></div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//每隔2秒调用MyTimerTask2  </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span></span>&#123;  </div><div class="line">      </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="comment">// TODO Auto-generated method stub  </span></div><div class="line">        System.out.println(<span class="string">"boomping!!!"</span>);  </div><div class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> MyTimerTask2(),<span class="number">2000</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">//每隔4秒调用MyTimerTask2  </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask2</span> <span class="keyword">extends</span> <span class="title">TimerTask</span></span>&#123;  </div><div class="line">      </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="comment">// TODO Auto-generated method stub  </span></div><div class="line">        System.out.println(<span class="string">"boomping!!!"</span>);  </div><div class="line">        <span class="keyword">new</span> Timer().schedule(<span class="keyword">new</span> MyTimerTask(), <span class="number">4000</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="3-调度框架：quarts"><a href="#3-调度框架：quarts" class="headerlink" title="3. 调度框架：quarts"></a><strong>3. 调度框架：quarts</strong></h1><p>Quartz是一个开源的作业调度框架，它完全由Java写成，并设计用于J2SE和J2EE应用中。它提供了巨大的灵活性而不牺牲简单性。你能够用它来为执行一个作业而创建简单的或复杂的调度。它有很多特征，如：数据库支持，集群，插件，EJB作业预构建，JavaMail及其它，支持cron-like表达式等等。</p>
<p>对于定时器中不能很好实现的需求，我们可以想到quarts,这里并没有介绍其使用方式，以后开发用到，能够记起，去查资料</p>
<h1 id="4-传统线程互斥技术"><a href="#4-传统线程互斥技术" class="headerlink" title="4. 传统线程互斥技术"></a><strong>4. 传统线程互斥技术</strong></h1><p>发现的问题：在主函数内部不能创建内部类的实例对象</p>
<p>内部类的一个重要特点就是可以访问外部类的成员变量，成员变量是对象身上的，对象创建完后，成员变量才分配空间，所以内部类访问外部类的成员变量需要外部类的实例对象。而静态方法先存在，所以不可以。</p>
<p>解决方式：</p>
<p>可以将内部类定义为静态的，或者将创建内部类的实例对象的语句封装在一个外部类的成员方法中，这里定义了一个init方法，因为方法调用需要对象，这个对象就是将来调用该方法的对象</p>
<p>示例说明：</p>
<p>本示例主要是对上面的问题进行了展示，另外对过去的互斥技术中的锁所使用的对象进行了分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraditionalThreadSychronized</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">          </div><div class="line">        <span class="comment">//无法创建，必须关联一个外部类的实例对象，可以定义一个方法，  </span></div><div class="line">        <span class="comment">//或者将外部类定义为静态  </span></div><div class="line">        <span class="comment">//final Outputer outputer = new Outputer(); //编译错误  </span></div><div class="line">        <span class="keyword">new</span> TraditionalThreadSychronized().init();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">//方法需要对象调用，所以就关联了一个外部类的对象  </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">final</span> Outputer outputer = <span class="keyword">new</span> Outputer();  </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        Thread.sleep(<span class="number">10</span>);  </div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125;  </div><div class="line">                    outputer.output(<span class="string">"11111"</span>);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">        &#125;).start();  </div><div class="line">  </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </div><div class="line">  </div><div class="line">                    <span class="keyword">try</span> &#123;  </div><div class="line">                        Thread.sleep(<span class="number">10</span>);  </div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                        e.printStackTrace();  </div><div class="line">                    &#125;  </div><div class="line">                    <span class="comment">// outputer.output("are you happy?");  </span></div><div class="line">                    outputer.output2(<span class="string">"22222"</span>);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;).start();  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outputer</span> </span>&#123;  </div><div class="line">         <span class="comment">//  </span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">            <span class="comment">// String lock = "";  </span></div><div class="line">            <span class="keyword">int</span> len = name.length();  </div><div class="line">  </div><div class="line">            <span class="comment">// synchronized(lock)&#123; 使用同一把锁，任意对象都可以  </span></div><div class="line">            <span class="comment">// synchronized(this)&#123; 同步函数使用的是锁是this，即outputer对象  </span></div><div class="line">            <span class="keyword">synchronized</span> (Outputer.class) &#123; <span class="comment">// 静态方法的锁只能是class字节码对象  </span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  </div><div class="line">                    System.out.print(name.charAt(i));  </div><div class="line">                &#125;  </div><div class="line">                System.out.println();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// 同步函数使用的是锁是this  </span></div><div class="line">        <span class="comment">/* </span></div><div class="line">          public synchronized void output2(String name)&#123;  </div><div class="line">            int len = name.length(); </div><div class="line">            for(int i=0;i&lt;len;i++)&#123;  </div><div class="line">                System.out.print(name.charAt(i)); &#125; </div><div class="line">                System.out.println();  </div><div class="line">              &#125; </div><div class="line">          &#125; </div><div class="line">         */  </div><div class="line">          </div><div class="line">        <span class="comment">//定义同步的静态方法  </span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">output2</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">            <span class="keyword">int</span> len = name.length();  </div><div class="line">  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;  </div><div class="line">                System.out.print(name.charAt(i));  </div><div class="line">            &#125;  </div><div class="line">            System.out.println();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5-传统线程同步通信技术"><a href="#5-传统线程同步通信技术" class="headerlink" title="5. 传统线程同步通信技术"></a><strong>5. 传统线程同步通信技术</strong></h1><p>这里通过一道面试题进行讲解</p>
<p>需求：子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程又循环100次，如此循环50次</p>
<p>1、思路：</p>
<p> 使用面向对象的方式思考，子线程的任务是循环10次，子线程的任务是循环100次，所以可以将它们各自的任务封装起来，在封装内部实现各自的同步（锁是放在代表要操作的资源的类的内部方法中），最后别的对象来调用，循环50次即可</p>
<p>2、Eclipse小技巧：</p>
<p>这里打印结果过长，我们可以使用eclipse将打印结果输出到文件中：<br>Run As → Run Configurations → Common → File前打勾 → 指定路径</p>
<p>3、锁对象的定义</p>
<p>两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个锁对象，锁是放在代表要操作的资源的类的内部方法中，而不是在线程代码中。</p>
<p>4、实现按指定的顺序执行</p>
<p>需要用到wait，Notify，当轮到自己要执行的时候，让对象去唤醒自己，可以定义一个标识，来决定谁可以执行</p>
<p>5、wait方法必须放在synchronized的里面，而且调用它的对象必须和synchronized的对象是同一个。</p>
<p>6、While比if更严谨，因为会循环判断执行条件，所以可以防止伪唤醒，（并不是期望的对象来唤醒自己）。</p>
<p>经验：要用到共同数据（包括同步锁）或共同算法的若干个方法应该归于同一个类上，在这个类的内部去管理各个方法的状态，这种设计正好体现了高类聚和程序的健壮性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraditionalThreadCommunication</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </div><div class="line">          </div><div class="line">        <span class="comment">//获取一个业务对象  </span></div><div class="line">        <span class="keyword">final</span> Business business = <span class="keyword">new</span> Business();  </div><div class="line">          </div><div class="line">        <span class="comment">//子线程  </span></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;  </div><div class="line">  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;  </div><div class="line">                    <span class="comment">/*for(int j=0;j&lt;10;j++)&#123; </span></div><div class="line">                        System.out.println("sub thread sequence of"+i+",loop of "+j); </div><div class="line">                    &#125;*/  </div><div class="line">                    business.sub(i);  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;).start();  </div><div class="line">              </div><div class="line">            <span class="comment">//主线程  </span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;  </div><div class="line">                  </div><div class="line">            <span class="comment">/*  for(int j=0;j&lt;100;j++)&#123; </span></div><div class="line">                System.out.println("main thread sequence of"+i+", loop of "+j); </div><div class="line">                &#125;   */        </div><div class="line">                business.main(i);  </div><div class="line">          &#125;  </div><div class="line">       &#125;  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line"><span class="comment">//定义一个业务类  </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Business</span></span>&#123;  </div><div class="line">      </div><div class="line">    <span class="comment">//定义一个boolean型变量来决定子线程和主线程的执行权  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> bShouldSub = <span class="keyword">true</span>;  </div><div class="line">      </div><div class="line">    <span class="comment">//子线程  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//把同步的鎖放在资源身上  </span></div><div class="line">        <span class="comment">//不该子线程执行，等待  </span></div><div class="line">        <span class="keyword">if</span>(!bShouldSub)&#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                <span class="keyword">this</span>.wait();  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                <span class="comment">// TODO Auto-generated catch block  </span></div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)&#123;  </div><div class="line">            System.out.println(<span class="string">"sub thread sequence of"</span>+i+<span class="string">",loop of "</span>+j);  </div><div class="line">        &#125;  </div><div class="line">        bShouldSub = <span class="keyword">false</span>;  </div><div class="line">        <span class="keyword">this</span>.notify();      <span class="comment">//唤醒主线程  </span></div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">//主线程  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;  </div><div class="line">          </div><div class="line">        <span class="comment">//若是子线程执行，主线程等待  </span></div><div class="line">        <span class="keyword">if</span>(bShouldSub)&#123;  </div><div class="line">            <span class="keyword">try</span> &#123;  </div><div class="line">                <span class="keyword">this</span>.wait();  </div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">                <span class="comment">// TODO Auto-generated catch block  </span></div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">100</span>;j++)&#123;  </div><div class="line">            System.out.println(<span class="string">"main thread sequence of"</span>+i+<span class="string">", loop of "</span>+j);  </div><div class="line">        &#125;     </div><div class="line">        bShouldSub = <span class="keyword">true</span>;  </div><div class="line">        <span class="keyword">this</span>.notify();      <span class="comment">//唤醒子线程  </span></div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/ai.jpg"
               alt="JackChan" />
          <p class="site-author-name" itemprop="name">JackChan</p>
           
              <p class="site-description motion-element" itemprop="description">生活不止眼前的苟且，还有诗和远方！</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/JackChan1999" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.gitbook.com/@alleniverson" target="_blank" title="GitBook">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  GitBook
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1848214604?topnav=1&wvr=6&topsug=1&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/axi295309066" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JackChan</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
