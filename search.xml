<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Http协议]]></title>
    <url>%2F2017%2F04%2F30%2FHttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[网络编程 Java基础：网络编程 Uri、URL、UriMatcher、ContentUris详解 Android应用开发：网络编程1 Android应用开发：网络编程2 1. 什么是HTTP协议客户端连上web服务器后，若想获得web服务器中的某个web资源，需遵守一定的通讯格式，HTTP协议用于定义客户端与web服务器通迅的格式。 HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程。这个协议详细规定了浏览器和万维网服务器之间互相通信的规则。 HTTP就是一个通信规则，通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。其实我们要学习的就是这个两个格式！客户端发送给服务器的格式叫“请求协议”；服务器发送给客户端的格式叫“响应协议”。 HTTP协议是学习JavaWEB开发的基石，不深入了解HTTP协议，就不能说掌握了WEB开发，更无法管理和维护一些复杂的WEB站点。 OSI网络七层协议 应用层（HTTP、FTP、SMTP、POP3、TELNET） 表示层 会话层 传输层（TCP、UDP） 网络层（IP） 数据链路层 物理层 2. HTTP协议简介HTTP使用请求-响应的方式进行传输，一个请求对应一个响应，并且请求只能是由客户端发起的。 利用Telnet演示请求与响应的过程 安装IE浏览器插件HttpWatch，查看IE浏览器通过HTTP协议获取某个页面。 HTTP协议的版本：HTTP/1.0、HTTP/1.1 3. HTTP1.0和HTTP1.1的区别在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。 HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。 利用telnet演示HTTP1.0和HTTP1.1的区别 一个好多同学搞不清楚的问题： 一个web页面中，使用img标签引用了三幅图片，当客户端访问服务器中的这个web页面时，客户端总共会访问几次服务器，即向服务器发送了几次HTTP请求。 4. 协议协议：协议的甲乙双方，就是客户端（浏览器）和服务器！ 理解成双方通信的格式！ 请求协议 响应协议 5. HttpWatch和FireBugHttpWatch是专门为IE浏览器提供的，用来查看HTTP请求和响应内容的工具。而FireFox上需要安装FireBug软件。如果你使用的是Chrome，那么就不用自行安装什么工具了，因为它自身就有查看请求和响应内容的功能！ HttpWatch和FireBug这些工具对浏览器而言不是必须的，但对我们开发者是很有帮助的，通过查看HTTP请求响应内容，可以使我们更好的学习HTTP协议。 6. 请求协议请求协议的格式如下： 1234请求首行；请求头信息；空行；请求体。 浏览器发送给服务器的内容就这个格式的，如果不是这个格式服务器将无法解读！在HTTP协议中，请求有很多请求方法，其中最为常用的就是GET和POST。不同的请求方法之间的区别，后面会一点一点的介绍。 6.1 GET请求打开IE，在访问hello项目的index.jsp之间打开HttpWatch，并点击“Record”按钮。然后访问index.jsp页面。查看请求内容如下： 123456789GET /hello/index.jsp HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,zh;q=0.5Accept-Encoding: gzip, deflateAccept-Charset: GB2312,utf-8;q=0.7,*;q=0.7Connection: keep-aliveCookie: JSESSIONID=369766FDF6220F7803433C0B2DE36D98 GET /hello/index.jsp HTTP/1.1：GET请求，请求服务器路径为/hello/index.jsp，协议为1.1 Host:localhost：请求的主机名为localhost User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0：与浏览器和OS相关的信息。有些网站会显示用户的系统版本和浏览器版本信息，这都是通过获取User-Agent头信息而来的 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8：告诉服务器，当前客户端可以接收的文档类型，其实这里包含了/，就表示什么都可以接收 Accept-Language: zh-cn,zh;q=0.5当前客户端支持的语言，可以在浏览器的工具选项中找到语言相关信息 Accept-Encoding: gzip, deflate：支持的压缩格式。数据在网络上传递时，可能服务器会把数据压缩后再发送 Accept-Charset: GB2312,utf-8;q=0.7,*;q=0.7：客户端支持的编码 Connection: keep-alive：客户端支持的链接方式，保持一段时间链接，默认为3000ms Cookie: JSESSIONID=369766FDF6220F7803433C0B2DE36D98因为不是第一次访问这个地址，所以会在请求中把上一次服务器响应中发送过来的Cookie在请求中一并发送去过；这个Cookie的名字为JSESSIONID，然后在讲会话是讲究它！ 6.2 POST请求为了演示POST请求，我们需要修改index.jsp页面，即添加一个表单： 1234&lt;form action="" method="post"&gt; 关键字：&lt;input type="text" name="keyword"/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 打开HttpWatch，输入hello后点击提交，查看请求内容如下： 1234567891011121314POST /hello/index.jsp HTTP/1.1Accept: image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/msword, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/x-ms-application, application/x-ms-xbap, application/vnd.ms-xpsdocument, application/xaml+xml, */*Referer: http://localhost:8080/hello/index.jspAccept-Language: zh-cn,en-US;q=0.5User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; InfoPath.2; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)Content-Type: application/x-www-form-urlencodedAccept-Encoding: gzip, deflateHost: localhost:8080Content-Length: 13Connection: Keep-AliveCache-Control: no-cacheCookie: JSESSIONID=E365D980343B9307023A1D271CC48E7Dkeyword=hello POST请求是可以有体的，而GET请求不能有请求体。 Referer: http://localhost:8080/hello/index.jsp请求来自哪个页面，例如你在百度上点击链接到了这里，那么Referer:http://www.baidu.com；如果你是在浏览器的地址栏中直接输入的地址，那么就没有Referer这个请求头了 Content-Type: application/x-www-form-urlencoded表单的数据类型，说明会使用url格式编码数据；url编码的数据都是以“%”为前缀，后面跟随两位的16进制，例如“传智”这两个字使用UTF-8的url编码用为“%E4%BC%A0%E6%99%BA” Content-Length:13：请求体的长度，这里表示13个字节 keyword=hello：请求体内容！hello是在表单中输入的数据，keyword是表单字段的名字。 Referer请求头是比较有用的一个请求头，它可以用来做统计工作，也可以用来做防盗链。 6.3 统计工作我公司网站在百度上做了广告，但不知道在百度上做广告对我们网站的访问量是否有影响，那么可以对每个请求中的Referer进行分析，如果Referer为百度的很多，那么说明用户都是通过百度找到我们公司网站的。 6.4 防盗链我公司网站上有一个下载链接，而其他网站盗链了这个地址，例如在我网站上的index.html页面中有一个链接，点击即可下载JDK7.0，但有某个人的微博中盗链了这个资源，它也有一个链接指向我们网站的JDK7.0，也就是说登录它的微博，点击链接就可以从我网站上下载JDK7.0，这导致我们网站的广告没有看，但下载的却是我网站的资源。这时可以使用Referer进行防盗链，在资源被下载之前，我们对Referer进行判断，如果请求来自本网站，那么允许下载，如果非本网站，先跳转到本网站看广告，然后再允许下载 7. 响应协议7.1 响应内容响应协议的格式如下：1234响应首行；响应头信息；空行；响应体。 响应内容是由服务器发送给浏览器的内容，浏览器会根据响应内容来显示。123456HTTP/1.1 200 OKServer: Apache-Coyote/1.1Content-Type: text/html;charset=UTF-8Content-Length: 724Set-Cookie: JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/helloDate: Wed, 25 Sep 2012 04:15:03 GMT 1234567891011121314151617181920212223&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="http://localhost:8080/hello/"&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;!-- &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; --&gt; &lt;/head&gt; &lt;body&gt;&lt;form action="" method="post"&gt; 关键字：&lt;input type="text" name="keyword"/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; HTTP/1.1 200 OK：响应协议为HTTP1.1，状态码为200，表示请求成功，OK是对状态码的解释 Server: Apache-Coyote/1.1：服务器的版本信息 Content-Type: text/html;charset=UTF-8：响应体使用的编码为UTF-8 Content-Length: 724：响应体为724字节 Set-Cookie: JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/hello：响应给客户端的Cookie； Date: Wed, 25 Sep 2012 04:15:03 GMT：响应的时间，这可能会有8小时的时区差 7.2 若干响应头 响应头 功能描述 Content-Encoding: gzip 服务器发送数据时使用的压缩格式 Server:apache tomcat 服务器的基本信息 Content-Length: 80 发送数据的大小 Content-Language: zh-cn 发送的数据使用的语言环境 Content-Disposition: attachment;filename=aaa.zip 与下载相关的头 Expires: -1 指定资源缓存的时间，如果取值为0或-1浏览就不缓存资源 Cache-Control: no-cache 缓存相关的头，如果为no-cache则通知浏览器不缓存 Pragma: no-cache 缓存相关的头，如果为no-cache则不缓存 Connection: close/Keep-Alive 是否保持连接 Location 配合302实现请求重定向 Content-Type 发送数据的类型和编码 Last-Modified 最后修改时间 Refresh 自动刷新，n秒后跳转到另一个页面 Set-Cookie 发送Cookie信息 Location: http://www.it315.org/index.jsp 配合302实现请求重定向 Content-Type: text/html; charset=GB2312 当前所发送的数据的基本信息，（数据的类型，所使用的编码） Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT 缓存相关的头 Refresh: 1;url=http://www.it315.org 通知浏览器进行定时刷新，此值可以是一个数字指定多长时间以后刷新当前页面，这个数字之后也可以接一个分号后跟一个URL地址指定多长时间后刷新到哪个URL Transfer-Encoding: chunked 传输类型，如果是此值是一个chunked说明当前的数据是一块一块传输的 Set-Cookie:SS=Q0=5Lb_nQ; path=/search 和cookie相关的头，后面课程单讲 ETag: W/“83794-1208174400000” 和缓存机制相关的头​Date: Tue, 11 Jul 2000 18:23:51 GMT 当前时间 7.3 响应码响应头对浏览器来说很重要，它说明了响应的真正含义。例如200表示响应成功了，302表示重定向，这说明浏览器需要再发一个新的请求。 响应码 描述 200 请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中 206 请求部分资源，和请求头Range使用 302 重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location，它指定了新请求的URL地址 304 服务器通知浏览器使用缓存 307 服务器通知浏览器使用缓存 404 请求的资源没有找到，说明客户端错误的请求了不存在的资源 500 请求资源找到了，但服务器内部出现了错误 304：当用户第一次请求index.html时，服务器会添加一个名为Last-Modified响应头，这个头说明了index.html的最后修改时间，浏览器会把index.html内容，以及最后响应时间缓存下来。当用户第二次请求index.html时，在请求中包含一个名为If-Modified-Since请求头，它的值就是第一次请求时服务器通过Last-Modified响应头发送给浏览器的值，即index.html最后的修改时间，If-Modified-Since请求头就是在告诉服务器，我这里浏览器缓存的index.html最后修改时间是这个，您看看现在的index.html最后修改时间是不是这个，如果还是，那么您就不用再响应这个index.html内容了，我会把缓存的内容直接显示出来。而服务器端会获取If-Modified-Since值，与index.html的当前最后修改时间比对，如果相同，服务器会发响应码304，表示index.html与浏览器上次缓存的相同，无需再次发送，浏览器可以显示自己的缓存页面，如果比对不同，那么说明index.html已经做了修改，服务器会响应200 响应头： Last-Modified：最后的修改时间 请求头 If-Modified-Since：把上次请求的index.html的最后修改时间还给服务器；状态码：304，比较If-Modified-Since的时间与文件真实的时间一样时，服务器会响应304，而且不会有响正文，表示浏览器缓存的就是最新版本 7.4 其他响应头1、告诉浏览器不要缓存的响应头 Expires: -1 Cache-Control: no-cache Pragma: no-cache 以上三个头都是用来控制缓存的，是因为历史原因造成的，不同的浏览器认识不同的头，我们通常三个一起使用保证通用性 2、自动刷新响应头，浏览器会在3秒之后请求http://www.itcast.cn： Refresh: 3;url=http://www.itcast.cn 7.5 HTML中指定响应头在HTMl页面中可以使用&lt;meta http-equiv=”Content-Type” content=”text/html; charset=UTF-8”&gt;来指定响应头，例如在index.html页面中给出&lt;meta http-equiv=”Refresh” content=”3;url=http://www.itcast.cn&quot;&gt;，表示浏览器只会显示index.html页面3秒，然后自动跳转到http://www.itcast.cn。 8. 模拟网络请求restClient，这个是firefox上的一个插件，对应chrome浏览器叫做postman，这个插件主要用作和服务器开发人员联调协议 postman restClient 9. 测试请求的地址http://httpbin.org 10. gzip压缩一种压缩格式，一种压缩方式，可以对网络传输的数据进行压缩。减少网络传输的大小 为什么需要压缩?因为经过压缩，可以减少体积，提高传输速度,提高用户体验 10.1 浏览器发送器请求的过程 1.发送请求头:Accept-Encoding:gzip 2.服务器压缩数据,返回数据,在响应头里面添加Content-Encoding:gzip 3.客户端,根据Content-Encoding这个响应头,对应解压 有Content-Encoding:gzip–&gt;gzip解压 没有Content-Encoding:gzip–&gt;标准解压 app使用gzip压缩：返回的json/xml(文本信息)其实就是个特殊的网页,其实也是可以进行gzip压缩 10.2 gzip压缩效果 通过数据，我们得知，文本的压缩率，大概可以达到70%左右。压缩率很高 10.3 gzip压缩的实现1234567891011121314151617181920212223242526272829303132333435try &#123; boolean isGzip = false; //1.创建httpclient DefaultHttpClient httpClient = new DefaultHttpClient(); //2.创建get请求 HttpGet get = new HttpGet("http://httpbin.org/gzip"); //① 添加请求头 Accept-Encoding:"gzip, deflate" get.addHeader("Accept-Encoding", "gzip"); //3.执行请求 HttpResponse response = httpClient.execute(get); if (response.getStatusLine().getStatusCode() == 200) &#123; //② 得到响应头,Content-Encoding:"gzip" Header[] headers = response.getHeaders("Content-Encoding"); for (Header header : headers) &#123; if (header.getValue().equals("gzip")) &#123;//后台server把数据进行了gzip压缩 isGzip = true; &#125; &#125; String result = ""; HttpEntity entity = response.getEntity(); //③根据是否使用gzip压缩.采取不同的解压方式 if (isGzip) &#123; //④进行gzip的解压 GZIPInputStream in = new GZIPInputStream(response.getEntity().getContent()); //in--&gt;string result = convertStreamToString(in); &#125; else &#123; //4.打印结果 result = EntityUtils.toString(entity); &#125; System.out.println("result:" + result); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 11. 抓包11.1 Fiddler只能抓浏览器返回的包，即只可以抓PC上的包，无法抓手机上的包 11.2 Wireshark世界上最流行的网络协议分析器，抓包工具Wireshark基本介绍和学习TCP三次握手 通过ping命令拿到网址的IP]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http协议详解]]></title>
    <url>%2F2017%2F04%2F30%2FHTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[当今web程序的开发技术真是百家争鸣，ASP.NET, PHP, JSP，Perl, AJAX 等等。 无论Web技术在未来如何发展，理解Web程序之间通信的基本协议相当重要, 因为它让我们理解了Web应用程序的内部工作. 本文将对HTTP协议进行详细的实例讲解，内容较多，希望大家耐心看。也希望对大家的开发工作或者测试工作有所帮助。使用Fiddler工具非常方便地捕获HTTP Request和HTTP Response, 关于Fiddler工具的用法，请看我另一篇博客[Fiddler 教程] 1. 什么是HTTP协议协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器 目前我们使用的是HTTP/1.1 版本 2. Web服务器，浏览器,代理服务器当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？ 实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页，过程如下图所示 我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。过程如下图所示 代理服务器就是网络信息的中转站，有什么功能呢？ 提高访问速度， 大多数的代理服务器都有缓存功能 突破限制， 也就是翻墙了 隐藏身份 3. URL详解 URL(Uniform Resource Locator) 地址用于描述一个网络上的资源, 基本格式如下 1schema://host[:port#]/path/.../[?query-string][#anchor] URL 说明 scheme 指定低层使用的协议(例如：http, https, ftp) host HTTP服务器的IP地址或者域名 port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/ path 访问资源的路径 query-string 发送给http服务器的数据 anchor 锚 URL 的一个例子 1234567http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/test/test.aspxQuery String: name=sviergn&amp;x=trueAnchor: stuff 4. HTTP协议是无状态的http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态. 5. 打开一个网页需要浏览器发送很多次Request 当你在浏览器输入URL http://www.cnblogs.com 的时候，浏览器发送一个Request去获取 http://www.cnblogs.com 的html. 服务器把Response发送回给浏览器 浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件 等所有的文件都下载成功后。 网页就被显示出来了 6. HTTP消息的结构先看Request 消息的结构, Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行， 结构如下图 第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号 当使用的是”GET” 方法的时候， body是为空的，比如我们打开博客园首页的request 如下 12GET http://www.cnblogs.com/ HTTP/1.1Host: www.cnblogs.com 抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们今天用Fiddler，实际的看看Request和Response 下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息， 如下图 我们再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行, 结构如下图 HTTP/version-number表示HTTP协议的版本号， status-code 和message 请看下节[状态代码]的详细解释. 我们用Fiddler 捕捉一个博客园首页的Response然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Response的消息， 如下图 7. Get和Post方法的区别Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. 我们看看GET和POST的区别 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码. 8. 状态码Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response. HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别 1XX 提示信息 - 表示请求已被成功接收，继续处理 2XX 成功 - 表示请求已被成功接收，理解，接受 3XX 重定向 - 要完成请求必须进行更进一步的处理 4XX 客户端错误 - 请求有语法错误或请求无法实现 5XX 服务器端错误 - 服务器未能实现合法的请求 看看一些常见的状态码 200 OK 最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端 如下图， 打开博客园首页 302 Found 重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request 例如在IE中输入， http://www.google.com. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request. 304 Not Modified 代表上次的文档已经被缓存了， 还可以继续使用，例如打开博客园首页, 发现很多Response 的status code 都是304 提示： 如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面 400 Bad Request 客户端请求与语法错误，不能被服务器所理解 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在（输错了URL），比如在IE中输入一个错误的URL， http://www.cnblogs.com/tesdf.aspx 500 Internal Server Error 服务器发生了不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 9. HTTP Request header使用Fiddler 能很方便的查看Reques header, 点击Inspectors tab -&gt;Request tab-&gt; headers 如下图所示. header 有很多，比较难以记忆，我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。 9.1 Cache 头域 If-Modified-Since 作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中. 例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT，实例如下图 If-None-Match 作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能 例如: If-None-Match: “03f2b33c0bfcc1:0”，实例如下图 Pragma 作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样 Pargma只有一个用法， 例如： Pragma: no-cache 注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control Cache-Control 作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下 Cache-Control:Public 可以被任何缓存所缓存（） Cache-Control:Private 内容只缓存到私有缓存中 Cache-Control:no-cache 所有内容都不会被缓存 还有其他的一些用法， 我没搞懂其中的意思， 请大家参考其他的资料 9.2 Client 头域 Accept 作用： 浏览器端可以接受的媒体类型, 例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档, 如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable) 通配符 * 代表任意类型 例如 Accept: / 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个) Accept-Encoding： 作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）; 例如： Accept-Encoding: gzip, deflate Accept-Language 作用： 浏览器申明自己接收的语言。 语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等； 例如： Accept-Language: en-us User-Agent 作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本. 我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。 例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E) Accept-Charset 作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案） 9.3 Cookie/Login 头域Cookie，作用： 最重要的header, 将cookie的值发送给HTTP 服务器 9.4 Entity头域 Content-Length，作用：发送给HTTP服务器数据的长度。例如： Content-Length: 38 Content-Type，作用：发送给HTTP服务器数据的类型，例如：Content-Type: application/x-www-form-urlencoded 9.5 Miscellaneous 头域 Referer: 作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。 例如: Referer:http://translate.google.cn/?hl=zh-cn&amp;tab=wT 9.6 Transport 头域 Connection 例如： Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 Host（发送请求时，该报头域是必需的） 作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的 例如: 我们在浏览器中输入：http://www.guet.edu.cn/index.html 浏览器发送的请求消息中，就会包含Host请求报头域，例如，Host：http://www.guet.edu.cn 此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号 10. HTTP Response header同样使用Fiddler 查看Response header, 点击Inspectors tab -&gt;Response tab-&gt; headers 如下图所示 我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。 10.1 Cache头域 Date，作用: 生成消息的具体时间和日期，例如：Date: Sat, 11 Feb 2012 11:35:14 GMT Expires，作用: 浏览器会在指定过期时间内使用本地缓存，例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT Vary，作用：例如: Vary: Accept-Encoding 10.2 Cookie/Login 头域 P3P，作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题 例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR Set-Cookie 作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie. 例如: Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com 10.3 Entity头域 ETag 作用: 和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例） 例如: ETag: “03f2b33c0bfcc1:0” Last-Modified: 作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例） 例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT Content-Type 作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集，例如: Content-Type: text/html; charset=utf-8Content-Type:text/html;charset=GB2312Content-Type: image/jpeg Content-Length 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。例如: Content-Length: 19847 Content-Encoding WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip Content-Language 作用： WEB服务器告诉浏览器自己响应的对象的语言者，例如： Content-Language:da 10.4 Miscellaneous 头域 Server，作用：指明HTTP服务器的软件信息，例如:Server: Microsoft-IIS/7.5 X-AspNet-Version: 作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本，例如: X-AspNet-Version: 4.0.30319 X-Powered-By，作用：表示网站是用什么技术开发的，例如： X-Powered-By: ASP.NET 10.5 Transport头域 Connection 例如： Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 10.6 Location头域Location，作用： 用于重定向一个新的位置, 包含新的URL地址，实例请看304状态实例 11. HTTP协议是无状态的和Connection: keep-alive的区别无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系 HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接） 从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的事件分发]]></title>
    <url>%2F2017%2F04%2F30%2FAndroid%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[1. Touch事件和绘制事件的异同之处Touch事件和绘制事件很类似，都是由ViewRoot派发下来的，但是不同之处在绘制事件是由应用中的某个View发起请求，一层一层上传到ViewRoot，再有ViewRoot下发绘制，传递canvas给所有子View让其绘制自身，绘制好后，再通知WMS进行画到屏幕上。而Touch事件是由硬件捕获到触摸后由系统传递给应用的ViewRoot，再由ViewRoot往下一层一层传递。 他们的处理过程都是自上而下的分发，但是绘制多了一层自下往上的请求。 事件存在消耗，事件的处理方法都会返回一个boolean值，如果该值为true，则本次事件下发将会终止。 2. MotionEvent2.1 MotionEvent对象的产生系统有一个线程在循环收集屏幕硬件信息，当用户触摸屏幕时，该线程会把从硬件设备收集到的信息封装成一个MotionEvent对象，然后把该对象存放到一个消息队列中。 系统的另一个线程循环的读取消息队列中的MotionEvent，然后交给WMS去派发，WMS把该事件派发给当前处于活动的Activity，即处于活动栈最顶端的Activity。 这就是一个先进先出的消费者和生产者的模板，一个线程不停的创建MotionEvent对象放入队列中，另一个线程不断的从队列中取出MotionEvent对象进行分发。 当用户的手指从接触屏幕到离开屏幕，是一个完整的触摸事件，在该事件中，系统会不断收集事件信息封装成MotionEvent对象。收集的间隔时间取决于硬件设备，例如屏幕的灵敏度以及cpu的计算能力。目前的手机一般在20毫秒左右。 MotionEventCompat.getActionMasked() 2.2 MotionEvent对象详解MotionEvent对象包含了触摸事件的时间、位置、面积、压力、以及本次事件的Dwon发生的时间。 MotionEvent常用的Action分为5种：Down 、Up、Move、Cancel、OutSide MotionEvent中我们常用的方法就是获取点击的坐标，因为这是与我们操作息息相关的。获取坐标有两种方式： getX和getY用于获取以该View左上角为坐标原点的坐标 getRowX和getRowY用于获取以屏幕左上角为坐标原点的坐标 2.3 5种Touch事件 Down：一次触摸事件的第一个MotionEvent对象，即手指初次接触屏幕。 Up：通常为一次触摸事件的最后一个MotionEvent对象，即手指离开屏幕。 Move：通常多次发生在一次触摸事件之中。表示触摸点发生了移动，我们通常把手指放到屏幕上，实际也会触发该事件，因为人手总是在轻微抖动的。 Cancel：常用于取消某个触摸事件，一般是由程序逻辑来指定该事件，用于取消某次触摸事件。 OutSide：当触摸点发生在响应事件的View之外时，传递的事件，通常由程序逻辑来指定。 在上面5种事件中，Down为最重要的事件，因为这是一个触摸事件的起始点，程序的很多逻辑判断，都需要根据该事件做处理，例如分发拦截。一次触摸事件必须要有Down事件，这也是MotionEvent对象中都包含了本次触摸事件的Down事件发生的时间点这个属性。其次是Move和Up，通过这3个事件的逻辑处理，就构建出来滑动，点击，长按，双击等多种效果。 2.4 创建一个MotionEvent对象1234567891011121314public static MotionEvent obtain( long downTime, //当用户最初按下开始一连串的位置事件。这必须得到SystemClock.uptimeMillis() long eventTime, //当这个特定的事件是生成的。这必须得到SystemClock.uptimeMillis() int action, //该次事件的Action float x, //该次事件的x坐标 float y, //该次事件的y坐标 float pressure, //该次事件的压力，通常感觉标准压力，从0-1取值 float size, //点击的区域大小，通常根据特定标准范围从0-1取值 int metaState, //一个修饰性的状态，好像一直都是0 float xPrecision, //x坐标的精确度 float yPrecision, //y坐标的精确度 int deviceId, //触屏设备id，如果是0，说明这个事件不是来自物理设备 int edgeFlags //系统默认都是返回0，程序在传递时，可以通过逻辑判断加入方向位置 ) 或者一个更简单的方式： 1234567public static MotionEvent obtain( long downTime, long eventTime, int action, float x, float y, int metaState) 也可以通过一个MotionEvent来创建一个新的 1public static MotionEvent obtain(MotionEvent event) 通过以上的方式，我们知道，我们也可以通过代码来构建一个虚假的MotionEvent，并分发下去。 1234view.dispatchTouchEvent( MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN,100,100,0)); 然后通过延迟以此往下派发Move和Up时间，形成一个完整的触摸操作。 3. dispatchTouchEvent触摸事件分发 之前我们知道触摸事件是被包装成MotionEvent进行传递的，而该对象是继承了Parcelable接口，正因为如此，才可以从系统中传递到我们的应用中。系统通过跨进程通知ViewRoot，ViewRoot会调用DecorView的dispatchTouchEvent下发。 这里有一个和其他事件传递不同的地方，DecorView会优先传递给Activity，而不是它的子View。而Activity如果不处理又会回传给DecorView，DecorView才会再将事件传给子View。 dispatchTouchEvent就是触摸事件传递的对外接口，无论是DecorView传给Activity，还是ViewGroup传递给子View，都是直接调用对方的dispatchTouchEvent方法，并传递MotionEvent参数。 我们首先来看看Activity中的dispatchTouchEvent逻辑： 12345678910111213141516171819202122232425public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); //这是一个空实现的方法，以便子类实现，该方法在Key事件和touch事件的dispatch方法中都被调用， // 就是方便用户在事件被传递之前做一下自己的处理。 &#125; //这才是事件真正的分发 if (getWindow().superDispatchTouchEvent(ev)) &#123; //superDispatchTouchEvent是一个抽象方法，但是getWindow()获取的对象实际是FrameWork层的 // PhoneWindow，该对象实现了这个方法，内部是直接调用DecorView的superDispatchTouchEvent // 是直接调用dispatchTouchEvent，这样就传递到子View中了 return true; &#125; //如果上面事件没有被消费掉，那么就调用Activity的onTouchEvent事件。 return onTouchEvent(ev);&#125;//PhoneWindow的superDispatchTouchEvent方法直接调用了mDecor的superDispatchTouchEventpublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125;//mDecor即为Activity真正的根View，我们通过setContentView所添加的内容就是添加在该View上，// 它实际上就是一个FrameLayoutpublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);//FrameLayout.dispatchTouchEvent&#125; 至此我们已经至少明白了以下几点： 1、我们可以重载Activity的onUserInteraction方法，在Down事件触发传递前，实现我们的一些需求，实际上源码中有很多这样的方法，再某个方法体的第一行提供一个空实现的回调方法，在某个方法的最后一行提供一个空实现的回调方法，以便子类去实现自己的逻辑，例如AsyncTask就有类似的方式。这些技巧都能很好的提高我们代码的扩展性。 2、Activity会间接的调用根View的dispatchTouchEvent，并通过if判断返回值，如果为true，即向上层返回true，也就是调用Activity的dispatchTouchEvent的WMS，即操作系统。 3、如果if判断为false，即根View和根View下的所有子View均为消费掉该事件，那么下面的代码就有执行机会，即Activity的onTouchEvent，并把该方法的返回值作为结果返回给上层。 3.1 View的dispatchTouchEvent View中的处理相当简单明了，因为不涉及到子View，所以只在自身内部进行分发。首先判断是否设置了触摸监听，并且可以响应事件，就交由监听的onTouch处理。如果上述条件不成立，或者监听的onTouch事件没有消费掉该事件，则交由onTouchEvent进行处理，并把返回结果交给上层。 123456789public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; //判断mOnTouchListener是否存在，并且控件可点的情况下，执行onTouch，如果onTouch返回true，就消耗该事件 return true; &#125; //如果以上条件都不成立，则把事件交给onTouchEvent来处理 return onTouchEvent(event);&#125; 3.2 ViewGroup的dispatchTouchEvent 3.3 Down事件 通过onInterceptTouchEvent方法判断是否要拦截事件，默认fasle 根据scroll换算后的坐标找出所接受的子View。有动画的子View将不接受触摸事件。 找到能接受的子View后把event中的坐标转换成子View的坐标 调用子View的dispatchTouchEvent把事件传递给子View。 如果子View消费了该事件，则把target记录为子View，方便后面的Move和Up事件的传递。 如果子View没有消费，则继续寻找下一个子View。 如果没找到，或者找到的子View都不消费，就会调用View的dispatchTouchEvent的逻辑，也就是判断是否有触摸监听，有的话交给监听的onTouch处理，没有的话交给自己的onTouchEvent处理 接下来我们来研究ViewGroup的dispatchTouchEvent，这是稍微复杂的分发逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public boolean dispatchTouchEvent(MotionEvent ev) &#123; final int action = ev.getAction();//获取事件 final float xf = ev.getX();//获取触摸坐标 final float yf = ev.getY(); final float scrolledXFloat = xf + mScrollX;//获取当前需要偏移的偏移量量 final float scrolledYFloat = yf + mScrollY; final Rect frame = mTempRect; //当前ViewGroup的视图矩阵 boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;//是否禁止拦截 if (action == MotionEvent.ACTION_DOWN) &#123;//如果事件是按下事件 if (mMotionTarget != null) &#123; //判断接受事件的target是否为空 //不为空肯定是不正常的，因为一个事件是由DOWN开始的，而DOWN还没有被消费，所以目标也不是不可能被确定， //造成这个的原因可能是在上一次up事件或者cancel事件的时候，没有把目标赋值为空 mMotionTarget = null; //在此处挽救 &#125; //不允许拦截，或者onInterceptTouchEvent返回false，也就是不拦截。注意，这个判断都是在DOWN事件中判断 if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123; //从新设置一下事件为DOWN事件，其实没有必要，这只是一种保护错误，防止被篡改了 ev.setAction(MotionEvent.ACTION_DOWN); //开始寻找能响应该事件的子View final int scrolledXInt = (int) scrolledXFloat; final int scrolledYInt = (int) scrolledYFloat; final View[] children = mChildren; final int count = mChildrenCount; for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123;//如果child可见，或者有动画，获取该child的矩阵 child.getHitRect(frame); if (frame.contains(scrolledXInt, scrolledYInt)) &#123; // 设置系统坐标 final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); if (child.dispatchTouchEvent(ev)) &#123;//调用child的dispatchTouchEvent //如果消费了，目标就确定了，以便接下来的事件都传递给child mMotionTarget = child; return true; //事件消费了，返回true &#125; &#125; &#125; &#125; //能到这里来，证明所有的子View都没消费掉Down事件，那么留给下面的逻辑进行处理 &#125; &#125; //判断是不是up或者cancel事件 boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL); if (isUpOrCancel) &#123; //如果是取消，把禁止拦截这个标志位给取消 mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; final View target = mMotionTarget; if (target == null) &#123; //判断该值是否为空，如果为空，则没找到能响应的子View，那么直接调用super的dispatchTouchEvent，也就是View的dispatchTouchEvent ev.setLocation(xf, yf); return super.dispatchTouchEvent(ev); &#125; //能走到这里来，说明已经有target，那也说明，这里不是DOWN事件，因为DOWN事件如果有target，已经在前面返回了，执行不到这里 if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;//如果有目标，又非要拦截，则给目标发送一个cancel事件 final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; ev.setAction(MotionEvent.ACTION_CANCEL);//该为cancel ev.setLocation(xc, yc); if (!target.dispatchTouchEvent(ev)) &#123; //调用子View的dispatchTouchEvent，就算它没有消费这个cancel事件，我们也无能为力了。 &#125; //清除目标 mMotionTarget = null; //有目标，又拦截，自身也享受不了了，因为一个事件应该由一个View去完成 return true;//直接返回true，以完成这次事件，好让系统开始派发下一次 &#125; if (isUpOrCancel) &#123;//取消或者UP的话，把目标赋值为空，以便下一次DOWN能重新找，此处就算不赋值，下一次DOWN也会先把它赋值为空 mMotionTarget = null; &#125; //又不拦截，又有目标，那么就直接调用目标的dispatchTouchEvent final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; ev.setLocation(xc, yc); return target.dispatchTouchEvent(ev); //也就是说，如果是DOWN事件，拦截了，那么每次一次MOVE或者UP都不会再判断是否拦截，直接调用super的dispatchTouchEvent //如果DOWN没拦截，就是有其他View处理了DOWN事件，那么接下来的MOVE或者UP事件拦截了，那么给目标View发送一个cancel事件，告诉它touch被取消了，并且自身也不会处理，直接返回true //这是为了不违背一个Touch事件只能由一个View处理的原则。&#125; 3.4 Move和Up事件判断事件是否被取消或者事件是否要拦截住，是的话，给Down事件找到的target发送一个取消事件。如果不取消，也不拦截，并且Down已经找到了target，则直接交给target处理，不再遍历子View寻找合适的View了。这种处理事件是正确的，我们用手机经常可以体会到，当我手指按在一个拖动条上之后，在拖动的时候手指就算移出了拖动条，依然会把事件分发给拖动条控制它的拖动。 4. onInterceptTouchEventViewGroup的方法，事件拦截，return true表示拦截触摸事件，事件就不往下传递 子View可以调用getParent().requestDisallowInterceptTouchEvent( true ) 请求父控件不拦截touch事件 5. View的onTouchEvent从View的dispatchTouchEvent可以看出，事件最终的处理无非是交给TouchListener的onTouch方法或者是交由onTouchEvent处理，由于onTouch默认是空实现，由程序员来编写逻辑，那么我们来看看onTouchEvent事件。View只能响应click和longclick，不具备滑动等特性。 Down时，设置按压状态，发送一个延迟500毫秒的长按事件。Move时，判断是否移出了View，移出后移除按压状态，长按事件。Up时，取消按压，并判断它是否可以通过触摸获取焦点，是的话设置焦点，判断长按事件是否执行了，如果还没执行，就删除，并执行点击事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; //先判断标示位是否为disable，也就是无法处理事件。 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125;//如果是UP事件，并且状态为按压，取消按压。 //系统源码解释：虽然是disable，但是还是可以消费掉触摸事件，只是不触发任何click或者longclick事件。 //根据是否可点击,可长按来决定是否消费点击事件。 return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; //先检查触摸的代理对象是否存在，如果存在，就交由代理对象处理。 // 触摸代理对象是可以进行设置的，一般用于当我们手指在某个View上，而让另外一个View响应事件，另外一个View就是该View的事件代理对象。 if (mTouchDelegate.onTouchEvent(event)) &#123;//如果代理对象消费了，则返回true消费该事件 return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; //如果是可点击或者长按的标识位执行下面的逻辑，这些标志位可以设置，也可以设置了对应的listener后自动添加 //因为作为一个View，它只能单纯的接受处理点击事件，像滑动之类的复杂事件普通View是不具备的。 switch (event.getAction()) &#123; case MotionEvent.ACTION_UP://处理Up事件 boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;//是否包含临时按压状态 if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;//如果本身处于被按压状态或者临时按压状态 //临时按压状态会在下面的Move事件中说明 boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; //如果它可以获取焦点，并且可以通过触摸来获取焦点，并且现在不是焦点，则请求获取焦点，因为一个被按压的View理论上应该获取焦点 focusTaken = requestFocus(); &#125; if (prepressed) &#123; //如果是临时按压，则设置为按压状态，PFLAG_PREPRESSED是一个非常短暂的状态，用于在某些时候短时间内表示Pressed状态，但不需要绘制 setPressed(true);//设置为按压状态，是因为临时按压不会绘制，这个时候强制绘制一次，确保用户能够看见按压状态 &#125; if (!mHasPerformedLongPress) &#123; //是否执行了长按事件，还没有的话，这个时候可以移除长按的回调了，因为UP都已经触发，说明从按下到UP的时间不足以触发longPress //至于longPress，会在Down事件中说明 removeLongPressCallback(); if (!focusTaken) &#123;//如果是焦点状态，就不会触摸click，这是为什么呢？因为焦点状态一般是交给按键处理的， //pressed状态才是交给触摸处理，如果它是焦点，那么它的click事件应该由按键来触发 if (mPerformClick == null) &#123; //封装一个Runnable对象，这个对象中实际就调用了performClick(); mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123;//向消息队列发生该runnabel，如果发送不成功，则直接执行该方法。 performClick();//这个方法内部会调用clickListner &#125; //为什么不直接执行呢？如果这个时候直接执行，UP事件还没执行完，发送post，可以保障在这个代码块执行完毕之后才执行 &#125; &#125; if (mUnsetPressedState == null) &#123;//仍旧是创建一个Runnabel对象，执行setPressed(false) mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; //如果是临时按压状态，之前的Down和move都还未触发按压状态，只在up时设置了，这个状态才刚刚绘制，为了保证用户能看到，发生一个64秒的延迟消息，来取消按压状态。 postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); //这是一个64毫秒的短暂时间，这是为了让这个按压状态持续一小段时间，以便手指离开时候，还能看见View的按压状态 &#125; else if (!post(mUnsetPressedState)) &#123;//如果不是临时按压，则直接发送，发送失败，则直接执行 mUnsetPressedState.run(); &#125; removeTapCallback(); //移除这个callBack，这个callBack内部就是把临时按压状态设置成按压状态，因为这个已经没必要了，手指已经up了 &#125; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; //按下事件把长按事件执行的变量设置为false，代表还没执行长按，因为才按下，表示新的一个长按事件可以开始计算了 if (performButtonActionOnTouchDown(event)) &#123; //先把这个事件交由该方法，该方法内部会判断是否为上下文的菜单按钮，或者是否为鼠标右键，如果是就弹出上下文菜单。 //现在有些手机的上下文菜单按钮也是在屏幕触屏上的 break; &#125; //这个方法会一直往上找父View，判断自身是否在一个可以滚动的容器中 boolean isInScrollingContainer = isInScrollingContainer(); //如果是在一个滚动的容器中，那么按压事件将会被推迟一段时间，如果这段时间内，发生了Move，那么按压状态讲不会被显示，直接滚动父视图 if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; //先添加临时的按压状态，该状态表示按压，但不会绘制 if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); //创建一个runnable对象，这个runnable内部会取消临时按压状态，设置为按压状态，并启动长按的延迟事件 &#125; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); //向消息机制发生一个64毫秒的延迟时间，该事件会取消临时按压状态，设置为直接按压，并启动长按时间的计时 &#125; else &#123; //如果不在一个滚动的容器中，则直接设置按压状态，并启动长按计时 setPressed(true); checkForLongClick(0); //长按事件就是向消息机制发送一个runnable对象，封装的就是我们在lisner中的代码，延迟500毫秒执行，也就是说长按事件在我们按下的时候发送，在up的时候检查一下执行了吗？如果没执行，就取消，并执行click &#125; break; case MotionEvent.ACTION_CANCEL: //如果是取消事件，那就好办了，把我们之前发送的几个延迟runnable对象给取消掉 setPressed(false); //设置为非按压状态 removeTapCallback(); //取消mPendingCheckForTap，也就是不用再把临时按压设置为按压了 removeLongPressCallback(); //取消长按事件的延迟回调 break; case MotionEvent.ACTION_MOVE: //move事件 final int x = (int) event.getX(); //取触摸点坐标 final int y = (int) event.getY(); // 用于判断是否在View中，为什么还要判断呢？ //这是因为父View是在Down事件中判断是否在该View中的，如果在，以后的Move和up都会传递过来，不再进行范围判断 if (!pointInView(x, y, mTouchSlop)) &#123; //mTouchSlop是一个常量，数值为8,也就是说，就算你的落点超出了View的8像素位置，也算在View中。 //是因为人的手指触摸点比较大，有可能你感觉点在某个控件的边缘，但是实际落点已经超出这个View，所以这里给了8像素的范围 removeTapCallback();//如果在范围外，就移除这些runnable回调 if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; //如果是按压状态，就取消长按，设置为非按压状态，为什么这个时候取消呢，因为在Down的时候，我们可以知道，只有是按压状态，才会设置长按 removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; //至此，可以返回true，消费该事件 &#125; return false; //如果不可点击，也不可长按，则返回false，因为View只具备消费点击事件&#125; 从上面的代码我们总结一下View对触摸事件的处理： 1、是否为diabale，如果是，直接根据是否设置了click和longclick来返回。2、是否设置了触摸代理对象，如果有，把事件传递给触摸代理对象，交由其处理，如果消费了，直接返回3、是否为click或者longclick的，如果是，返回true，不是返回false。 而View对click和longclick的处理如下： Down： 判断是否可以触摸上下文菜单。 是否在可以滑动的容器中，如果是先设置临时按压，再发送一个延迟消息把临时按压改为按压，并发送一个延迟500毫秒的事件去执行长按代码 如果不在滚动容器中，直接设置按压状态，并发送一个延迟500毫秒的事件去执行长按代码。 Move： 取触摸点坐标判断是否在View中（额外增加了8像素的范围） 如果在，不用做任何事。 如果不在，取消临时按压到按压回调，取消长按延迟回调，设置为非按压状态 Up 判断是否为按压或者临时按压状态 如果不是，不做任何处理 如果是先判断其是否可以获取焦点，然后请求焦点。 如果是临时按压状态，设置临时按压状态为按压状态。保证界面被绘制成按压状态，让用户可以看见。 如果长按回调还未触发，取消长按回调，如果不是焦点状态，触发click事件。 如果是临时按压状态，发送一个延迟取消按压状态的，保证按压状态持续一段时间，让用户可见。 如果不是临时按压状态，直接发送消息取消按压状态。发送失败，直接取消按压状态。 取消把临时按压设置按压的回调。 从中我们知道View的onTouchEvent主要处理了click和longclick事件，当按下时，向消息机制发送一个延迟500毫秒的长按回调事件，当移动时候判断是否移出了View的范围，超出则取消事件。当离开时，判断长按事件是否触发了，如果没触发且不是焦点，就触发click事件。 在这里最绕的就是临时按压和按压状态，临时按压是为了处理滑动容器的，让处于滑动容器中，按下时，我们先设置的是临时按压，持续64毫秒，是为了判断接下来的时间内是否发生了move事件，如果发生了，将不会再出发按压状态，这样不会让用户看到listView滚动时，item还处于按压状态。在离开时，我们再次判断是否处于临时按压，如果是在64毫秒内触发了down和up，说明按压状态还没来得急绘制，则强制设置为按压状态，保证用户能看到，并在取消回调的方法上加上64毫秒的延迟 6. onTouch与onClick123456789ImageView iv_image = (ImageView) findViewById(R.id.iv_image);iv_image.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("iv_image---onTouch--" + event.getAction()); return false; &#125;&#125;); 点击ImageView的时候只会打印一次，因为onTouch()返回false，只传递down事件，不会传递up事件1System.out: iv_image---onTouch--0 12345678910// ImageView天生不能被点击，没有点击事件ImageView iv_image = (ImageView) findViewById(R.id.iv_image);iv_image.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("iv_image---onTouch--" + event.getAction()); return true; // 把返回值改为true &#125;&#125;); 把onTouch()方法返回值改为true，点击ImageView会打印两次（down and up） 12System.out: iv_image---onTouch--0System.out: iv_image---onTouch--1 123456789101112131415ImageView iv_image = (ImageView) findViewById(R.id.iv_image);iv_image.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("iv_image---onTouch--" + event.getAction()); return true; &#125;&#125;);//添加click事件iv_image.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("iv_image---onClick"); &#125;&#125;); 还是打印两次，onTouch()返回true，click事件并不会得到执行123456789101112131415ImageView iv_image = (ImageView) findViewById(R.id.iv_image);iv_image.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("iv_image---onTouch--" + event.getAction()); return false; &#125;&#125;);iv_image.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("iv_image---onClick"); &#125;&#125;); 打印三次，两次touch事件（down and up）和一次click事件12345678Button button = (Button) findViewById(R.id.button);button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("button---onTouch--" + event.getAction()); return false; &#125;&#125;); 点击Button会打印两次 12345678910111213141516Button button = (Button) findViewById(R.id.button);button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("button---onTouch--" + event.getAction()); return true; &#125;&#125;);button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("button---onClick"); &#125;&#125;); 打印两次，因为onTouch()返回true，不会执行onTouchEvent()，而click事件是在onTouchEvent()中执行，所以也不会执行click事件12345678910111213141516Button button = (Button) findViewById(R.id.button);button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("button---onTouch--" + event.getAction()); return false; &#125;&#125;);button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("button---onClick"); &#125;&#125;); 打印三次1234567891011public boolean dispatchTouchEvent(MotionEvent event) &#123; if (!onFilterTouchEventForSecurity(event)) &#123; return false; &#125; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event);&#125; a 判断mOnTouchListener是否为nullb 判断当前的控件是否可用c 判断view的onTouch。d 如果以上一个返回为false。那么就会调用onTouchEvent 首先判断mOnTouchListener不为null，并且view是enable的状态，然后 mOnTouchListener.onTouch(this, event)返回true，这三个条件如果都满足，直接return true ; 也就是下面的onTouchEvent(event）不会被执行了。如果我们设置了setOnTouchListener，并且return true，那么View自己的onTouchEvent就不会被执行了 onTouch是优先于onClick执行, onClick的调用在onTouchEvent(event)方法中 view的事件分发 返回true，说明可以响应down事件和up事件 返回false，只会响应down事件。不会响应up事件。在down事件如果能消费(处理)当前事件。那么在up的时候也会把事件传递给当前的view，在down事件处理不了当前事件。那么在up的时候。也不会把事件传递给当前的view 模拟点击事件 123456789101112131415161718192021private void createClick(final View v) &#123; 08-23 03:22:35.028: I/System.out(1652): x轴坐标---151.0--y轴坐标---218.0 final int x = 151; final int y = 218; long downTime = System.currentTimeMillis(); MotionEvent motionEventDown = MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_DOWN, x, y, 0); v.dispatchTouchEvent(motionEventDown); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; long upTime = System.currentTimeMillis(); MotionEvent motionEventUp = MotionEvent.obtain(upTime, upTime, MotionEvent.ACTION_UP, x, y, 0); v.dispatchTouchEvent(motionEventUp); &#125; &#125;, 200); &#125; Android的事件分发实例分析 7. ScrollView的onTouchEvent普通的ViewGroup并没有对onTouchEvent事件做处理，只有可以滚动的才有，我们可以分析一下ScrollView Down时，判断落点是否在子View中，不再就不处理，因为ScrollView只有一个子View。 Move时，通过对比本次手指的位置和上一次的位置的距离，计算出Y方向的差值，然后用scorllBy进行滚动视图 Up时，通过速度进行fling，这里利用了两个帮助类，一个是计算速度的帮助类VelocityTracker，一个是滚动的帮助类Scroller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public boolean onTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.getEdgeFlags() != 0) &#123; //如果是down事件，并且触摸到边缘，就不处理EdgeFlags代表是否为边缘，其值是1/2/4/8。代表上下左右 return false; &#125; if (mVelocityTracker == null) &#123; //这是一个追踪触摸事件，并计算速度的帮助类，实现原理就是用三个数组分别记录每次触摸的x/y和时间 mVelocityTracker = VelocityTracker.obtain(); &#125; mVelocityTracker.addMovement(ev); final int action = ev.getAction(); switch (action &amp; MotionEvent.ACTION_MASK) &#123;//与上ff，去掉高位有关多点的信息 case MotionEvent.ACTION_DOWN: &#123;//如果是down final float y = ev.getY();//获取y坐标 if (!(mIsBeingDragged = inChild((int) ev.getX(), (int) y))) &#123;//判断是否开始拖动 //原理就是判断落点是否在child中，ScrollView只能由一个child，如果在，返回true，反之false //也就是说落点在child中，就是准备开始拖动，不在，就直接返回，这可能是因为设置了padding之类的缘故造成的 return false; &#125; if (!mScroller.isFinished()) &#123;//判断滚动是否完成 mScroller.abortAnimation();//如果没完成，停止滚动 //对应上一次用户手指离开时候处理fling状态，这次按下手指，直接停止滚动 &#125; //记录y坐标，以便下次事件来对比 mLastMotionY = y; mActivePointerId = ev.getPointerId(0);//记住多点的id，下次取值时只取该点的 break; &#125; case MotionEvent.ACTION_MOVE: if (mIsBeingDragged) &#123;//可以看出，如果down的时候落点在child外，则以后就算滑进了child也不处理 //根据上次记录的多点id，找到对应的点，取y值 final int activePointerIndex = ev.findPointerIndex(mActivePointerId); final float y = ev.getY(activePointerIndex); final int deltaY = (int) (mLastMotionY - y);//计算位移 mLastMotionY = y;//重新记录y值 scrollBy(0, deltaY);//滚动指定的距离，这也说明了ScrollView只具备纵向滑动 &#125; break; case MotionEvent.ACTION_UP: if (mIsBeingDragged) &#123;//如果是离开事件 final VelocityTracker velocityTracker = mVelocityTracker; velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);//计算最后1秒钟内的速度，并给定一个最大速度进行限制 //这个最大速度是根据屏幕密度不同而不同的，所以大家也没事别使劲滑动屏幕，因为有这个最大速度限制 //获取y方向的速度 int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId); if (getChildCount() &gt; 0 &amp;&amp; Math.abs(initialVelocity) &gt; mMinimumVelocity) &#123; //如果有子View，并且计算出来的y的速度比最小速度要大，执行fling状态 //手指滑动的方向和屏幕移动的方向是相反的，所以这里加- fling(-initialVelocity); &#125; mActivePointerId = INVALID_POINTER;//给mActivePointerId重新赋值为-1，防止下次事件找到了错误的点 mIsBeingDragged = false;//恢复默认值 if (mVelocityTracker != null) &#123;//清空速度计算帮助类 mVelocityTracker.recycle(); mVelocityTracker = null; &#125; &#125; break; case MotionEvent.ACTION_CANCEL: if (mIsBeingDragged &amp;&amp; getChildCount() &gt; 0) &#123;//判断条件，只有这2个条件成立，才会发生滚动事件，下面的值才会被改变，才需要恢复默认 mActivePointerId = INVALID_POINTER; mIsBeingDragged = false; if (mVelocityTracker != null) &#123; mVelocityTracker.recycle(); mVelocityTracker = null; &#125; &#125; break; case MotionEvent.ACTION_POINTER_UP://多点触摸时，不是最后一个点离开 onSecondaryPointerUp(ev); break; &#125; return true;&#125;//用于应对先按下1点，然后按下2点，1点离开后，2点仍能继续滑动的逻辑private void onSecondaryPointerUp(MotionEvent ev) &#123; final int pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt; MotionEvent.ACTION_POINTER_INDEX_SHIFT;//首先对高位进行与操作，然后右移8位，获取其高位代表index的值 final int pointerId = ev.getPointerId(pointerIndex);//取出该点的id if (pointerId == mActivePointerId) &#123;//如果这个id对应的就是第一个按下的点 //理论上pointerIndex应该是0，所以用第二个按下的点，即1index的点代替 final int newPointerIndex = pointerIndex == 0 ? 1 : 0; mLastMotionY = ev.getY(newPointerIndex);//取出新点的y坐标 mActivePointerId = ev.getPointerId(newPointerIndex);//记录新点的id if (mVelocityTracker != null) &#123;//清空之前存入的MotionEvent，也就是说最后的速度只计算该点产生的 mVelocityTracker.clear(); &#125; &#125;&#125; 通过以上分析，我们得出以下知识： 在down事件的时候先判断触摸是否处于边缘，如果是，则不处理 在down事件中判断落点是否在子View中，如果不在，不处理 在down事件中判断是否仍在滑动，如果是，先停止 记录第一个按下点的索引值 每次事件都记录住当前的y值 在move事件中通过记录的索引值找到对应的点，获取y坐标 与上一次y坐标进行比对，scrollBy两次的差值 在up事件的时候计算最后一秒钟的速度，并且有最大速度进行限制，当计算的速度大于系统默认的最小速度时，只想fling up和cancel事件还原变量为默认值 如果为多点离开，进行多点离开的处理 该处理方式时：如果离开的是第一个按下的点，那么由第二个按下的点代替其进行y值偏移计算的基点，并清空速度计算的帮助类，重新记录MotionEvnet 8. Layout和Scroll的区别 Layout中设置的是自身在父View中的显示区域 Scroll是调整自己的显示区域 当父View滚动或者layout变化后，自身在屏幕上的位置会发生变化。当自身Scroll滚动后，在屏幕上的显示位置是不变的，变的只是自身的显示内容。 Scroll滚动不会影响Layout，只是在draw的时候影响画布偏移和触摸时的坐标计算。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的消息机制]]></title>
    <url>%2F2017%2F04%2F30%2FAndroid%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. ANR异常Application No Response：应用程序无响应。在主线程中，是不允许执行耗时的操作的，如果主线程阻塞的时间大于6秒，就很有可能出现anr异常。主线程，要完成界面的更新，事件的处理，窗体显示的回调，所以如果主线程阻塞时间较长，就不能很好的处理以上比较重要的事情，那么Android有一个机制，就是如果他发现消息队列中有很多消息，主线程没办法响应的话，他就会抛出anr异常。所以，比较耗时的操作都必须要交给子线程。 解决办法：可以通过Handler来解决这个问题，将比较耗时的操作交给子线程，然后子线程通过Handler，发送消息给主线程，让主线程去更新界面。什么样的操作时比较耗时的？ 1、访问网络，2、大文件的拷贝，3、阻塞式的请求，socket 2. Handler、Looper、Message、MessageQueueAndroid 的Handler 机制（也有人叫消息机制）目的是为了跨线程通信，也就是多线程通信。之所以需要跨线程通信是因为在Android 中主线程通常只负责UI 的创建和修改，子线程负责网络访问和耗时操作，因此，主线程和子线程需要经常配合使用才能完成整个Android 功能。 在Android中，线程内部或者线程之间进行信息交互时经常会使用消息，这些基础的东西如果我们熟悉其内部的原理，将会使我们容易、更好地架构系统，避免一些低级的错误。在学习Android中消息机制之前，我们先了解与消息有关的几个类： Handler：消息处理器，发送消息和处理消息。你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里，或者接收Looper(从Message Queue取出)所送来的消息。 Looper：轮询器，从messagequeue取消息，分发给handler处理。一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列) Message 消息，数据的载体 MessageQueue 消息队列，存储消息 当我们的Android应用程序的进程一创建的时候，系统就给这个进程提供了一个Looper，Looper是一个死循环，它内部维护这个一个消息队列。Looper不停地从消息队列中取消息（Message），取到消息就发送给了Handler，最后Handler根据接收到的消息去修改UI。Handler的sendMessage方法就是将消息添加到消息队列中。 3. UI线程线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。 每一个线程里可含有一个Looper对象以及一个MessageQueue数据结构。在你的应用程序里，可以定义Handler的子类别来接收Looper所送出的消息。在你的Android程序里，新诞生一个线程，或执行 (Thread)时并不会自动建立其Message Looper。 Android里并没有Global的Message Queue数据结构，例如，不同APK里的对象不能透过Massage Queue来交换讯息(Message)。 例如：线程A的Handler对象可以传递消息给别的线程，让别的线程B或C等能送消息来给线程A(存于A的Message Queue里)。线程A的Message Queue里的消息，只有线程A所属的对象可以处理。使用Looper.myLooper()可以取得当前线程的Looper对象。可以自定义Handler类，只要继承Handler即可。使用new EventHandler(Looper.myLooper()); 可用来构造当前线程的Handler对象（其中EventHandler是自定义的Handler类）。 4. Activity.runOnUiThread()Activity中提供了一个runOnUiThread方法，用于进行消息处理。此方法是通过线程合并join来实现消息处理的。线程合并：主线程将子线程的任务拿到自己这里来执行并终止子线程。实例代码如下： 123456789101112131415/** * Runs the specified action on the UI thread. If thecurrent thread is * the UI thread, then the action is executedimmediately. If the * current thread is not the UI thread, the action is posted to the * event queue of the UI thread. * * 上面的意思为：在UI线程中运行我们的任务，如果当前线程是UI线程，则立即执行，如果 * 不是则该任务发送到UI线程的事件队列。 */runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //自定义我们的业务代码 &#125;&#125;); 5. View.post()、View.postDelayed()6. Message消息消息对象，顾名思义就是记录消息信息的类。这个类有几个比较重要的字段： arg1和arg2：我们可以使用两个字段用来存放我们需要传递的整型值，在Service中，我们可以用来存放Service的ID。 obj：该字段是Object类型，我们可以让该字段传递某个多项到消息的接受者中。 what：这个字段可以说是消息的标志，在消息处理中，我们可以根据这个字段的不同的值进行不同的处理，类似于我们在处理Button事件时，通过switch(v.getId())判断是点击了哪个按钮。 在使用Message时，我们可以通过new Message()创建一个Message实例，但是Android更推荐我们通过Message.obtain()或者Handler.obtainMessage()获取Message对象。这并不一定是直接创建一个新的实例，而是先从消息池中看有没有可用的Message实例，存在则直接取出并返回这个实例。反之如果消息池中没有可用的Message实例，则根据给定的参数new一个新Message对象。通过分析源码可得知，Android系统默认情况下在消息池中实例化10个Message对象。 12345//创建或获取消息的几种方式Message msg = new Message();// 创建一个新的消息对象Message msg = handler.obtainMessage();// 获取一个消息，如果消息池存在消息，则复用消息池中的消息，否则新创建一个消息对象Message msg = Message.obtain();Message.obtain(handler, what, obj).sendToTarget(); 7. MessageQueue消息队列消息队列，用来存放Message对象的数据结构，按照“先进先出”的原则存放消息。存放并非实际意义的保存，而是将Message对象以链表的方式串联起来的。MessageQueue对象不需要我们自己创建，而是有Looper对象对其进行管理，一个线程最多只可以拥有一个MessageQueue。我们可以通过Looper.myQueue()获取当前线程中的MessageQueue。 MessageQueue的管理者，在一个线程中，如果存在Looper对象，则必定存在MessageQueue对象，并且只存在一个Looper对象和一个MessageQueue对象。 1234public class Looper &#123; MessageQueue mQueue;//Looper身上维持着一个消息队列 ...&#125; 在Android系统中，除了主线程有默认的Looper对象，其它线程默认是没有Looper对象。如果想让我们新创建的线程拥有Looper对象时，我们首先应调用Looper.prepare()方法，然后再调用Looper.loop()方法。典型的用法如下： 12345678910class LooperThread extends Thread&#123; public Handler mHandler; public void run() &#123; Looper.prepare(); //其它需要处理的操作 Looper.loop(); &#125;&#125; 倘若我们的线程中存在Looper对象，则我们可以通过Looper.myLooper()获取，此外我们还可以通过Looper.getMainLooper()获取当前应用系统中主线程的Looper对象。在这个地方有一点需要注意，假如Looper对象位于应用程序主线程中，则Looper.myLooper()和Looper.getMainLooper()获取的是同一个对象。 8. Handler消息处理器消息的处理者。通过Handler对象我们可以封装Message对象，然后通过sendMessage(msg)把Message对象添加到MessageQueue中；当MessageQueue循环到该Message时，就会调用该Message对象对应的handler对象的handleMessage()方法对其进行处理。由于是在handleMessage()方法中处理消息，因此我们应该编写一个类继承自Handler，然后在handleMessage()处理我们需要的操作。 下面我们通过跟踪代码分析在Android中是如何处理消息。首先贴上测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MessageService extends Service&#123; private static final String TAG = "MessageService"; private static final int KUKA = 0; private Looper looper; private ServiceHandler handler; /** * 由于处理消息是在Handler的handleMessage()方法中，因此我们需要自己编写类 * 继承自Handler类，然后在handleMessage()中编写我们所需要的功能代码 * @author coolszy */ private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; // 根据what字段判断是哪个消息 switch (msg.what) &#123; case KUKA: //获取msg的obj字段。我们可在此编写我们所需要的功能代码 Log.i(TAG, "The obj field of msg:" + msg.obj); break; // other cases default: break; &#125; // 如果我们Service已完成任务，则停止Service stopSelf(msg.arg1); &#125; &#125; @Override public void onCreate() &#123; Log.i(TAG, "MessageService--&gt;onCreate()"); // 默认情况下Service是运行在主线程中，而服务一般又十分耗费时间，如果 // 放在主线程中，将会影响程序与用户的交互，因此把Service // 放在一个单独的线程中执行 HandlerThread thread = new HandlerThread("MessageDemoThread", Process.THREAD_PRIORITY_BACKGROUND); thread.start(); // 获取当前线程中的looper对象 looper = thread.getLooper(); //创建Handler对象，把looper传递过来使得handler、 //looper和messageQueue三者建立联系 handler = new ServiceHandler(looper); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.i(TAG, "MessageService--&gt;onStartCommand()"); //从消息池中获取一个Message实例 Message msg = handler.obtainMessage(); // arg1保存线程的ID，在handleMessage()方法中 // 我们可以通过stopSelf(startId)方法，停止服务 msg.arg1 = startId; // msg的标志 msg.what = KUKA; // 在这里我创建一个date对象，赋值给obj字段 // 在实际中我们可以通过obj传递我们需要处理的对象 Date date = new Date(); msg.obj = date; // 把msg添加到MessageQueue中 handler.sendMessage(msg); return START_STICKY; &#125; @Override public void onDestroy() &#123; Log.i(TAG, "MessageService--&gt;onDestroy()"); &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 运行结果： 注：在测试代码中我们使用了HandlerThread类，该类是Thread的子类，该类运行时将会创建looper对象，使用该类省去了我们自己编写Thread子类并且创建Looper的麻烦。下面我们分析下程序的运行过程： 8.1 onCreate()首先启动服务时将会调用onCreate()方法，在该方法中我们new了一个HandlerThread对象，提供了线程的名字和优先级。紧接着我们调用了start()方法，执行该方法将会调用HandlerThread对象的run()方法： 123456789101112public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 在run()方法中，系统给线程添加的Looper，同时调用了Looper的loop()方法： 12345678910111213141516171819202122232425public static final void loop() &#123; Looper me = myLooper(); MessageQueue queue = me.mQueue; while (true) &#123; Message msg = queue.next(); // might block //if (!me.mRun) &#123; // break; //&#125; if (msg != null) &#123; if (msg.target == null) &#123; // No target is a magic identifier for the quit message. return; &#125; if (me.mLogging!= null) me.mLogging.println( "&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what ); msg.target.dispatchMessage(msg); if (me.mLogging!= null) me.mLogging.println( "&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); msg.recycle(); &#125; &#125;&#125; 通过源码我们可以看到loop()方法是个死循环，将会不停的从MessageQueue对象中获取Message对象，如果MessageQueue 对象中不存在Message对象，则结束本次循环，然后继续循环；如果存在Message对象，则执行 msg.target.dispatchMessage(msg)，但是这个msg的.target字段的值是什么呢？我们先暂时停止跟踪源码，返回到onCreate()方法中。线程执行完start()方法后，我们可以获取线程的Looper对象，然后new一个ServiceHandler对象，我们把Looper对象传到ServiceHandler构造函数中将使handler、looper和messageQueue三者建立联系。 8.2 onStartCommand()执行完onStart()方法后，将执行onStartCommand()方法。首先我们从消息池中获取一个Message实例，然后给Message对象的arg1、what、obj三个字段赋值。紧接着调用sendMessage(msg)方法，我们跟踪源代码，该方法将会调用sendMessageDelayed(msg, 0)方法，而sendMessageDelayed()方法又会调用sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)方法，在该方法中我们要注意该句代码msg.target = this，msg的target指向了this，而this就是ServiceHandler对象，因此msg的target字段指向了ServiceHandler对象，同时该方法又调用MessageQueue 的enqueueMessage(msg, uptimeMillis)方法： 12345678910111213141516171819202122232425262728293031323334353637final boolean enqueueMessage(Message msg, long when) &#123; if (msg.when != 0) &#123; throw new AndroidRuntimeException(msg + " This message is already in use."); &#125; if (msg.target == null &amp;&amp; !mQuitAllowed) &#123; throw new RuntimeException("Main thread not allowed to quit"); &#125; synchronized (this) &#123; if (mQuiting) &#123; RuntimeException e = new RuntimeException( msg.target + " sending message to a Handler on a dead thread"); Log.w("MessageQueue", e.getMessage(), e); return false; &#125; else if (msg.target == null) &#123; mQuiting = true; &#125; msg.when = when; //Log.d("MessageQueue", "Enqueing: " + msg); Message p = mMessages; if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; this.notify(); &#125; else &#123; Message prev = null; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; msg.next = prev.next; prev.next = msg; this.notify(); &#125; &#125; return true;&#125; 该方法主要的任务就是把Message对象的添加到MessageQueue中（数据结构最基础的东西，自己画图理解下）。 handler.sendMessage()–&gt;handler.sendMessageDelayed()–&gt;handler.sendMessageAtTime()–&gt;msg.target = this;queue.enqueueMessage==&gt;把msg添加到消息队列中 8.3 handleMessage(msg)onStartCommand()执行完毕后我们的Service中的方法就执行完毕了，那么handleMessage()是怎么调用的呢？在前面分析的loop()方法中，我们当时不知道msg的target字段代码什么，通过上面分析现在我们知道它代表ServiceHandler对象，msg.target.dispatchMessage(msg);则表示执行ServiceHandler对象中的dispatchMessage()方法： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 该方法首先判断callback是否为空，我们跟踪的过程中未见给其赋值，因此callback字段为空，所以最终将会执行handleMessage()方法，也就是我们ServiceHandler类中复写的方法。在该方法将根据what字段的值判断执行哪段代码。 至此，我们看到，一个Message经由Handler的发送，MessageQueue的入队，Looper的抽取，又再一次地回到Handler的怀抱中。而绕的这一圈，也正好帮助我们将同步操作变成了异步操作。 9. Handler的源码分析先看构造方法 123456789101112public class Handler &#123; private Looper mLooper; private MessageQueue mQueue; public Handler() &#123; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException("Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; &#125;&#125; 在Handler的构造方法中，调用Looper.myLooper()方法获取一个Looper对象，如果Looper对象为空，则会抛异常，没有Looper对象不能创建Handler对象。但是我们在主线程new Handler的时候，并没有调用Looper.prepare()和Looper.loop()方法初始化Looper，也不会出现异常，这是因为Android系统在主线程创建的时候帮我们把Looper初始化了 9.1 主线程设置Looper，在ActivityThread类里面1234567891011121314public static final void main(String[] args) &#123; .... // 1.主线程创建Looper Looper.prepareMainLooper(); if (sMainThreadHandler == null) &#123; sMainThreadHandler = new Handler(); &#125; ActivityThread thread = new ActivityThread(); thread.attach(false); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; Looper.loop();&#125; MainThread 是Android 系统创建并维护的，创建的时候系统执行了Looper.prepare();方法，该方法内部创建了MessageQueue 消息队列（也叫消息池），该消息队列是Message 消息的容器，用于存储通过handler发送过来的Message。MessageQueue 是Looper 对象的成员变量，Looper 对象通过ThreadLocal 绑定在MainThread 中。因此我们可以简单的这么认为：MainThread 拥有唯一的一个Looper 对象，该Looper 对象有用唯一的MessageQueue 对象，MessageQueue 对象可以存储多个Message。 MainThread 中需要程序员手动创建Handler 对象，并覆写Handler 中的handleMessage(Message msg)方法，该方法将来会在主线程中被调用，在该方法里一般会写与UI 修改相关的代码。 MainThread 创建好之后，系统自动执行了Looper.loop();方法，该方法内部开启了一个“死循环”不断的去之前创建好的MessageQueue 中取Message。如果一有消息进入MessageQueue，那么马上会被Looper.loop();取出来，取出来之后就会调用之前创建好的handler 对象的handleMessage（Message）方法。 newThread 线程是我们程序员自定new 出来的子线程。在该子线程中处理完我们的“耗时”或者网络访问任务后，调用主线程中的handler 对象的sendMessage（msg）方法，该方法一被执行，内部将就msg添加到了主线程中的MessageQueue 队列中，这样就成为了Looper.loop()的盘中餐了，等待着被消费。 上面的过程有点类似生产者和消费者的过程。newThread 属于生产者，负责生产Message，MainThread 属于消费者。这是一个很复杂的过程，但是Android 显然已经将这种模式给封装起来了，就叫Handler 机制。我们使用时只需要在主线程中创建Handler，并覆写handler 中的handleMessage 方法，然后在子线程中调用handler 的sendMessage（msg）方法即可。 获取Looper对象后，接着获取Looper身上的MessageQueue对象，Handler就是把消息发送到该消息队列 Handler对象创建后，就可以通过handler.sendXxx()发送消息，可以发送一个普通的消息，也可以发送一个空消息，可以发送一个延时消息，也可以发送一个定时消息 123456789101112131415161718192021222324252627282930313233343536public class Handler &#123; ... // 发送一个普通消息 public boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0) &#125; // 发送一个空消息 public boolean sendEmptyMessage(int what) &#123; return sendEmptyMessageDelayed(what, 0); &#125; // 发送一个空的延时消息 public boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, 0); &#125; // 发送一个延时消息 public boolean sendMessageDelayed(Message msg, long delayTime) &#123; if (delayTime &lt; 0) delayTime = 0; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayTime); &#125; // 发送一个定时消息 public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; return enqueueMessage(queue, msg, uptimeMillis); &#125; //发送消息几个方法sendXxx()，最终都是调用enqueueMessage()方法，消息入队 public boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; // 把Message的target置为当前发送的Handler，以便Looper取到message后根据target把message分发给正确的Handler msg.target = this; // 往队列里面添加消息Message return queue.enqueueMessage(msg, uptimeMillis); &#125; ...&#125; 发送消息几个方法sendXxx()，最终都是调用enqueueMessage()方法，在该方法内部调用的是消息队列MessageQueue的enqueueMessage()方法，把消息发送到消息队列 把this，也就是当前handler对象赋值给Message 的target属性，当多个Handler发送消息到消息队列的时候，可以通过该属性判断消息是哪个Handler发送的 9.2 MessageQueue.enqueueMessage12345678910111213141516171819202122232425262728293031323334353637boolean enqueueMessage(Message msg, long when) &#123; ... synchronized (this) &#123; ... msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 当前发送的message需要马上被处理调，needWake唤醒状态置true msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // 当前发送的message被排队到其他message的后面，needWake唤醒状态置false needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (; ; ) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; if (needWake) &#123; // 是否唤醒主线程 nativeWake(mPtr); &#125; &#125; return true; &#125; 9.3 Handler的post()、postAtTime()、postDelayed()123456789101112131415161718192021public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postAtTime(Runnable r, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis);&#125;public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;// 把Runnable包装成一个消息Messageprivate static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain();// 获取消息对象 m.callback = r;// 把消息赋值给Message的callback属性 return m;&#125; 可以调用Handler的post()、postAtTime()、postDelayed()分别发送一个普通的、定时、延时的Runnable任务，Runnable会赋值给Message的callback属性，最终封装成一个消息发送出去 9.4 删除Callback和Message Handler.removeCallbacks() 从消息队列中删除所有回调 Handler.removeMessages() 从消息队列删除所有消息 Handler.removeCallbacksAndMessages() 从消息队列中删除所有Message和Callback 一般在Activity销毁的时候调用 12345public void onDestroy()&#123; handler.removeCallbacks(); handler.removeMessages(); handler.removeCallbacksAndMessages();&#125; 10. Looper 轮询器，从messagequeue取消息，分发给handler处理。创建Handler对象，必须有Looper对象，而Looper对象的初始化需要调用Looper.prepare()和Looper.loop()方法 10.1 Looper.prepare()123456789101112131415161718ThreadLocal&lt;Looper&gt; sThreadLocal;public static final void prepare() &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; // 3、在主线程中设置Looper， new Looper()里面创建了一个MessageQueue sThreadLocal.set(new Looper());&#125;public static final void prepareMainLooper() &#123; // 2、调用prepare prepare(); setMainLooper(myLooper()); if (Process.supportsProcesses()) &#123; myLooper().mQueue.mQuitAllowed = false; &#125;&#125; 先从ThreadLocal中获取一个Looper对象，如果该Looper对象不为空，则抛异常，这是因为一个线程仅能够绑定一个Looper对象。ThreadLocal是一个用于线程范围内共享数据的底层是一个map结构的类，key是当前线程，value是Looper。如果当前线程没有绑定Looper对象，则new Looper()创建一个Looper对象，并把该Looper对象设置sThreadLocal 10.2 Looper.loop()12345678910111213public static void loop() &#123; Looper me = myLooper(); // 获取当前线程的Looper对象，为空则抛异常 if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; MessageQueue queue = me.mQueue; // 获取Looper对象维持的消息队列 for (; ; ) &#123; // 开启死循环从消息队列获取消息 // 调用MessageQueue的next()取消息，如果没有消息，就阻塞 Message msg = queue.next(); // msg.target即Handler，获取消息后调用Handler的dispatchMessage()处理消息 msg.target.dispatchMessage(msg); &#125;&#125; 主线程调用Looper.loop()方法,主线程就会阻塞，是一个死循环，使用管道（Pipe），是Linux中的一种进程间通信方式，使用了特殊的文件，有两个文件描述符（一个是读取，一个是写入） 应用场景；主进程拿着读取描述符等待读取，没有内容时就阻塞，另一个进程拿写入描述符去写内容，唤醒主进程，主进程拿着读取描述符读取到内容，继续执行。 Handler应用场景：Handler在主线程中创建，Looper会在死循环里等待取消息，1、没取到，就阻塞，2、一旦被子线程唤醒，取到消息，就把Message交给Handler处理。子线程用Handler去发送消息，拿写入描述符去写消息，唤醒主线程。 12Looper.getMainLooper() == Looper.myLooper(); // 判断是否在主线程Handler mHandler = new Handler(Looper.getMainLooper()); 11. Handler.dispatchMessage12345678910111213public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; // 把Message交给Handler处理 handleMessage(msg); &#125;&#125; 调用Looper.loop()会开启一个死循环，从消息队列MessageQueue取消息，取到消息后调用msg.target.dispatchMessage(msg);即调用Handler的dispatchMessage()方法，在该方法内部调用的是handleMessage()，对，就是我们new Handler的时候实现的handleMessage()方法 所以Android的消息机制大概流程是：Handler把消息Message发送到消息队列MessageQueue，Looper从消息队列取消息，取到消息后回调Handler的handleMessage()方法 11.1 消息处理的优先级在dispatchMessage()方法中，如果msg.callback（一个Runnable）不为空，则先处理Message的Runnable；然后判断mCallback（通过Handler的构造方法传进来的Callback）是否为空，不为空，则执行Callback的handleMessage()方法，最后才是执行Handler的handleMessage() 所有消息处理的优先级是Message的callback –&gt; Handler的mCallback –&gt; Handler的handleMessage() 12. Handler机制的应用12.1 在主线程中给子线程发送消息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class MainActivity extends Activity &#123; private Handler subHandler;//是在子线程中创建的Handler对象 private Looper myLooper;//子线程中的Looper对象 private Handler handler = new Handler()&#123; @Override public void handleMessage(android.os.Message msg) &#123; switch (msg.what) &#123; case 1: Toast.makeText(MainActivity.this, msg.obj.toString(), Toast.LENGTH_SHORT).show(); break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /* * 匿名内部类对象对外部类有一个隐式的强引用 */ new Thread(new Runnable() &#123; @Override public void run() &#123; // 1. 创建了Looper对象，然后Looper对象中创建了MessageQueue // 2. 并将当前的Looper对象跟当前的线程（子线程）绑定ThreadLocal Looper.prepare(); // 1. 创建了handler对象，然后从当前线程中获取Looper对象，然后获取到MessageQueue对象 subHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; Toast.makeText(MainActivity.this, msg.obj.toString(), Toast.LENGTH_SHORT).show(); &#125; &#125;; myLooper = Looper.myLooper();//获取当前线程中的Looper对象 /* * 1. 从当前线程中找到之前创建的Looper对象，然后找到 MessageQueue * 2. 开启死循环，遍历消息池中的消息 * 3. 当获取到msg的时候，调用这个msg的handler的disPatchMsg方法，让msg执行起来 */ Looper.loop(); Log.d("tag", "loop()方法执行完了"); &#125; &#125;).start(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (myLooper!=null) &#123; myLooper.quit(); myLooper = null; &#125; &#125; public void sendMsg(View view)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; SystemClock.sleep(2000);//模拟一个耗时操作 Message msg = new Message(); msg.what = 1;//区分发送的消息 msg.obj = "来自子线程的问候"; handler.sendMessage(msg); &#125; &#125;).start(); &#125; public void sendMsg2(View view) &#123; //从消息池中获取一个旧的msg，如果没有重新创建消息 subHandler.obtainMessage(2, "我是主线程发送来的祝福").sendToTarget(); &#125;&#125; 12.2 同线程内不同组件间的消息传递Looper类用来管理特定线程内对象之间的消息交换(MessageExchange)。你的应用程序可以产生许多个线程。而一个线程可以有许多个组件，这些组件之间常常需要互相交换讯息。如果有这种需要，您可以替线程构造一个Looper对象，来担任讯息交换的管理工作。Looper对象会建立一个MessageQueue数据结构来存放各对象传来的消息(包括UI事件或System事件等)。每一个线程里可含有一个Looper对象以及一个MessageQueue数据结构。在你的应用程序里，可以定义Handler的子类别来接收Looper所送出的消息。 同线程不同组件之间的消息传递代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * ============================================================ * Copyright：$&#123;TODO&#125;有限公司版权所有 (c) 2017 * Author： AllenIverson * Email： 815712739@qq.com * GitHub： https://github.com/JackChen1999 * 博客： http://blog.csdn.net/axi295309066 * 微博： AndroidDeveloper * GitBook： https://www.gitbook.com/@alleniverson * &lt;p&gt; * Project_Name：HandlerDemo * Package_Name：com.github.handlerdemo.activity * Version：1.0 * time：2017/3/1 16:23 * des ： * gitVersion：2.12.0.windows.1 * updateAuthor：$Author$ * updateDate：$Date$ * updateDes：$&#123;TODO&#125; * ============================================================ */public classHandlerActivity extends Activity&#123; private Button sendBtn; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); sendBtn=(Button)findViewById(R.id.send); tv=(TextView)findViewById(R.id.textview); sendBtn.setOnClickListener(newMyOnClickListener()); &#125; class MyOnClickListener implements OnClickListener &#123; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send: // 取得当前线程的Looper，此时的线程为主线程（UI线程） Looper looper = Looper.myLooper(); // 构造一个Handler对象使之与Looper通信 MyHandler mHandler = newMyHandler(looper); // 产生一个消息通过Handler传递给Looper String msgStr = "main"; // 构造一个消息，这里what参数设为1，obj参数设为msgStr变量。 Message msg = mHandler.obtainMessage(1, 1, 1, msgStr); // 发送消息，调用Handler对象的handleMessage方法 mHandler.sendMessage(msg); break; &#125; &#125; &#125; // 自定义Handler类 class MyHandler extends Handler &#123; // 指定Looper对象来构造Handler对象，而我们平时直接使用的Handler无参构造方法实际上默认是本线程的looper，可通过查看SDk源代码了解。 public MyHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 1: tv.setText(String.valueOf(msg.obj)); break; &#125; &#125; &#125;&#125; 说明：此程序启动时，当前线程(即主线程, mainthread)已诞生了一个Looper对象，并且有了一个MessageQueue数据结构。 调用Looper类别的静态myLooper()函数，以取得目前线程里的Looper对象。looper = Looper.myLooper (); 构造一个MyHandler对象来与Looper沟通。Activity等对象可以藉由MyHandler对象来将消息传给Looper，然后放入MessageQueue里；MyHandler对象也扮演Listener的角色，可接收Looper对象所送来的消息。mHandler = new MyHandler (looper); 先构造一个Message对象，并将数据存入对象里。Message msg = mHandler.obtainMessage(1, 1, 1, msgStr);这里也可以这样写： 123Message msg = new Message();msg.what = 1;msg.obj = msgStr; 通过mHandler对象将消息m传给Looper，然后放入MessageQueue里。mHandler.sendMessage(msg); 此时，Looper对象看到MessageQueue里有消息m，就将它广播出去，mHandler对象接到此讯息时，会调用其handleMessage()函数来处理，于是让msgStr显示于TextView上（更新UI）。 12.3 子线程传递消息给主线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * ============================================================ * Copyright：$&#123;TODO&#125;有限公司版权所有 (c) 2017 * Author： AllenIverson * Email： 815712739@qq.com * GitHub： https://github.com/JackChen1999 * 博客： http://blog.csdn.net/axi295309066 * 微博： AndroidDeveloper * GitBook： https://www.gitbook.com/@alleniverson * &lt;p&gt; * Project_Name：HandlerDemo * Package_Name：com.github.handlerdemo.activity * Version：1.0 * time：2017/3/1 16:23 * des ： * gitVersion：2.12.0.windows.1 * updateAuthor：$Author$ * updateDate：$Date$ * updateDes：$&#123;TODO&#125; * ============================================================ */public classHandlerActivity extends Activity&#123; private Button sendBtn; private TextView tv; private MyHandler mHandler = null; Thread thread; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); sendBtn = (Button)findViewById(R.id.send); tv = (TextView)findViewById(R.id.textview); sendBtn.setOnClickListener(newMyOnClickListener()); &#125; class MyOnClickListener implements OnClickListener &#123; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send: thread = new MyThread(); thread.start(); break; &#125; &#125; &#125; // 自定义Handler类 class MyHandler extends Handler &#123; // 指定Looper对象来构造Handler对象，而我们平时直接使用的Handler无参构造方法实际上默认是本线程的looper，可通过查看SDk源代码了解。 public MyHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg)&#123; switch (msg.what) &#123; case 1: tv.setText(String.valueOf(msg.obj)); break; &#125; &#125; &#125; private class MyThread extends Thread &#123; @Override public void run() &#123; // 获得当前线程的Looper对象 Looper curLooper =Looper.myLooper(); // 获得主线程（UI线程）的Looper对象 Looper mainLooper =Looper.getMainLooper(); String msgStr; if (curLooper == null) &#123; mHandler = newMyHandler(mainLooper); msgStr = "curLooper isnull"; &#125; else &#123; mHandler = newMyHandler(curLooper); msgStr = "This iscurLooper"; &#125; Message msg =mHandler.obtainMessage(1, 1, 1, msgStr); mHandler.sendMessage(msg); &#125; &#125;&#125; Android会自动替主线程建立MessageQueue。在这个子线程里并没有建立Message Queue。所以curLooper值为null，而mainLooper则指向主线程里的Looper。于是执行mHandler= new MyHandler (mainLooper);此mHandler属于主线程 mHandler.sendMessage(msg);就将msg消息存入到主线程的MessageQueue里 mainLooper看到Message Queue里有讯息，就会作出处理，于是由主线程执行到mHandler的handleMessage()来处理消息。 12.4 在子线程中直接更新View不抛异常的问题下面代码，我们在子线程中直接操作View，但是并不会抛出异常 12345678910111213public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); tv = (TextView) findViewById(R.id.tv); iv = (ImageView) findViewById(R.id.iv); //搞不懂为什么在子线程里可以修改ui new Thread()&#123; public void run() &#123; tv.setText("wwwwwwwww"); iv.setImageResource(R.drawable.ic_launcher); &#125; &#125;.start();&#125; 原因： 在更新ui界面时View会把要界面传给ViewRoot 自定义Handler它是Activity和WindowMangerImpl之间的桥梁，要修改界面上的数据的经过它，它把数据传递给WindowManagerImple或DecorView之前，会调用checkThread方法，判断当前线程是否是主线程，不是的话跑异常。 而上面的代码是在onCreate里面修改的view，那时候view还没有被真正的被放在ContentView里面，ViewRoot还没有被创建，mParent为null。mparent（放ContentView的容器类型ViewParent）为null时不调用checkThread方法，当执行到ActivityThread的handlerResumeActivity方法时ViewRoot方法才会被创建，该方法在Activity的onResume方法执行完以后的200到300毫秒以后得到执行，并且把界面传递给WidowManagerImpl进行显示，由于在viewRoot被创建前已经修改了控件的值，所以显示的是已经修改的值。 所以在onResume方法被执行完的200毫秒之前那是还没有ViewRoot和mparent是可以修改主线程UI界面的 只有当viewRoot被创建了以后 在子线程view被添加到了contentView上时，或已添加到ContentView上在修改显示内容时会调用View的requestLayout方法，requestLayout会调用ViewRoot的checkThread方法，才会抛异常。 如果修改一个view的内容不调用requestLayout方法时是可以子线程中修改的并且不抛异常。如给一个view设置监听事件，虽然设置监听是在子线程里设置的但是调用执行监听事件的代码是在主线程里调用的从而执行也将在主线程执行。又如post方法，它只是给主线程所在的handler发送消息，handler分发消息时执行具体任务，并没有执行checkThread。又如创建一个VIew，为VIEW设置内容，添加view到该view等等，因为还没被添加到ContentView上所以不会执行checkThread。 13. Handler的核心代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Handler &#123; private Looper mLooper; private MessageQueue mQueue; public Handler()&#123; mLooper = Looper.myLooper(); if (mLooper == null)&#123; throw new RuntimeException("Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; &#125; public void handleMessage()&#123; &#125; public void dispatchMessage(Message msg)&#123; handleMessage(); &#125; public boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg,0) &#125; public boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what,0); &#125; public boolean sendEmptyMessageDelayed(int what, long delayMillis)&#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg,0); &#125; public boolean sendMessageDelayed(Message msg, long delayTime)&#123; if (delayTime &lt; 0) delayTime = 0; return sendMessageAtTime(msg,SystemClock.uptimeMillis()+delayTime); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis)&#123; MessageQueue queue = mQueue; return enqueueMessage(queue,msg,uptimeMillis); &#125; public boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)&#123; msg.target = this; return queue.enqueueMessage(msg, uptimeMillis); &#125; public void post(Runnable r)&#123; sendMessageDelayed(getPostMessage(r),0); &#125; public static Message getPostMessage(Runnable r)&#123; Message m = Message.obtain(); m.callback = r; return m; &#125; &#125; 14. Looper的核心代码1234567891011121314151617181920212223242526272829303132333435363738public class Looper &#123; static final ThreadLocal&lt;Looper&gt; mThreadLocal = new InheritableThreadLocal&lt;&gt;(); MessageQueue mQueue; Thread mCurrentThread; private static Looper sMainLooper; private Looper() &#123; mQueue = new MessageQueue(); mCurrentThread = Thread.currentThread(); &#125; public static void prepare() &#123; if (mThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; mThreadLocal.set(new Looper()); &#125; public void prepareMainLooper()&#123; prepare(); sMainLooper = myLooper(); &#125; public static void loop() &#123; Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");&#125; MessageQueue queue = me.mQueue; for(;;)&#123; Message msg = queue.next();//block msg.target.dispatchMessage(msg); &#125; &#125; public static Looper myLooper() &#123; return mThreadLocal.get(); &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>消息机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2017%2F04%2F30%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[这里首先介绍了java5中的并发的小工具包：java.util.concurrent.atomic，然后介绍了线程池的概念，对使用java5的方式创建不同形式的线程进行了演示，之后介绍了两个 对象：Callable和Future，用于获取线程执行后的结果，对于线程锁技术则在另外一篇文章中介绍。 Java5中的线程并发库都在java.util.concurrent包及子包中 1. Executor类的继承结构 Executor是线程池的顶级接口，只有一个执行任务的方法execute() ExecutorService是Executor的子接口，该接口中包含了线程池常用的一些方法 方法 功能描述 execute() 执行任务 shutdown() 调用后不再接收新任务，如果里面有任务，就执行完 shutdownNow() 调用后不再接受新任务，如果有等待任务，移出队列；有正在执行的，尝试停止之 isShutdown() 判断线程池是否关闭 isTerminated() 判断线程池中任务是否执行完成 submit() 提交任务 invokeAll() 执行一组任务 2. ThreadPoolExecutorExecutorService的默认实现，同时也是Executors的底层实现 2.1 构造方法123456789public ThreadPoolExecutor( int corePoolSize, //核心线程数 int maximumPoolSize, //最大线程数 long keepAliveTime, //保持时间 TimeUnit unit, //时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列 ThreadFactory threadFactory, //线程工厂 RejectedExecutionHandler handler //异常捕获器) 2.1.1 int corePoolSize核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中 2.1.2 int maximumPoolSize线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程 2.1.3 long keepAliveTime表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0 2.1.4 TimeUnit unit参数keepAliveTime的时间单位，有7种取值 TimeUnit.DAYS //天 TimeUnit.HOURS //小时 TimeUnit.MINUTES //分钟 TimeUnit.SECONDS //秒 TimeUnit.MILLISECONDS //毫秒 TimeUnit.MICROSECONDS //微妙 TimeUnit.NANOSECONDS //纳秒 2.1.5 RejectedExecutionHandler ThreadPoolExecutor.AbortPolicy当添加任务出错时的策略捕获器，丢弃任务并抛出RejectedExecutionException异常 ThreadPoolExecutor.DiscardPolicy也是丢弃任务，但是不抛出异常 ThreadPoolExecutor.DiscardOldestPolicy丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） ThreadPoolExecutor.CallerRunsPolicy由调用线程处理该任务 3. 任务提交给线程池之后的处理策略3.1 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建执行这个任务 3.2 如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中 3.2.1 若添加成功，则该任务会等待空闲线程将其取出去执行 3.2.2 若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务 3.3 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止 4. 阻塞队列的介绍4.1 BlockingQueue 阻塞队列 功能描述 BlockingQueue 阻塞队列的顶级接口，主要用于实现生产者消费者队列 BlockingDeque 双端队列 SynchronousQueue 同步队列，无界队列，直接提交策略，交替队列，在某次添加元素后必须等待其他线程取走后才能继续添加 LinkedBlockingQueue 无界队列，基于链表的阻塞队列，可以并发运行，FIFO ArrayBlockingQueue 基于数组的有界(固定大小的数组)阻塞队列，只有put方法和take方法才具有阻塞功能，公平性 fairness PriorityBlockingQueue 基于优先级的阻塞队列，依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序 DelayQueue 延时队列 4.2 排队策略直接提交工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 无界队列使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）使用无界队列将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列。例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性 有界队列当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 4.3 BlockingQueue 方法 Throw exception 抛出异常 Special value 特殊值 Blocks 阻塞 Time out 超时 Insert add() offer() put() offer(e，time，unit) Remove remove() poll() take() poll(time，unit) Examine检查 element() peek() 不可用 不可用 BlockingQueue 不接受 null 元素。试图 add、put 或 offer 一个 null 元素时，某些实现会抛出 NullPointerException。null 被用作指示 poll 操作失败的警戒值。 BlockingQueue 可以是限定容量的。它在任意给定时间都可以有一个 remainingCapacity，超出此容量，便无法无阻塞地 put 附加元素。没有任何内部容量约束的 BlockingQueue 总是报告 Integer.MAX_VALUE 的剩余容量。 BlockingQueue 实现主要用于生产者-使用者队列，但它另外还支持 Collection 接口。因此，举例来说，使用 remove(x) 从队列中移除任意一个元素是有可能的。然而，这种操作通常不 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。 BlockingQueue 实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的 Collection 操作（addAll、containsAll、retainAll 和 removeAll）没有必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了 c 中的一些元素后，addAll(c) 有可能失败（抛出一个异常）。 BlockingQueue 实质上不支持使用任何一种“close”或“shutdown”操作来指示不再添加任何项。这种功能的需求和使用有依赖于实现的倾向。例如，一种常用的策略是：对于生产者，插入特殊的end-of-stream或poison对象，并根据使用者获取这些对象的时间来对它们进行解释。 4.4 BlockingDeque双端队列 4.5 ArrayBlockingQueue一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象必须明确大小，像数组一样。其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。 实现互斥，你一下我一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BlockingQueueCondition &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newSingleThreadExecutor(); final Business3 business = new Business3(); service.execute(new Runnable()&#123; public void run() &#123; for(int i=0;i&lt;50;i++)&#123; business.sub(); &#125; &#125; &#125;); for(int i=0;i&lt;50;i++)&#123; business.main(); &#125; &#125;&#125;class Business3&#123; BlockingQueue subQueue = new ArrayBlockingQueue(1); BlockingQueue mainQueue = new ArrayBlockingQueue(1); &#123; try &#123; mainQueue.put(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void sub()&#123; try &#123; mainQueue.take(); for(int i=0;i&lt;10;i++)&#123; System.out.println(Thread.currentThread().getName() + " : " + i); &#125; subQueue.put(1); &#125;catch(Exception e)&#123; &#125; &#125; public void main()&#123; try &#123; subQueue.take(); for(int i=0;i&lt;5;i++)&#123; System.out.println(Thread.currentThread().getName() + " : " + i); &#125; mainQueue.put(1); &#125;catch(Exception e)&#123; &#125; &#125;&#125; 输出结果 1234567891011121314151617181920212223242526272829303132333435363738394041pool-1-thread-1 : 0pool-1-thread-1 : 1pool-1-thread-1 : 2pool-1-thread-1 : 3pool-1-thread-1 : 4pool-1-thread-1 : 5pool-1-thread-1 : 6pool-1-thread-1 : 7pool-1-thread-1 : 8pool-1-thread-1 : 9main : 0main : 1main : 2main : 3main : 4pool-1-thread-1 : 0pool-1-thread-1 : 1pool-1-thread-1 : 2pool-1-thread-1 : 3pool-1-thread-1 : 4pool-1-thread-1 : 5pool-1-thread-1 : 6pool-1-thread-1 : 7pool-1-thread-1 : 8pool-1-thread-1 : 9main : 0main : 1main : 2main : 3main : 4pool-1-thread-1 : 0pool-1-thread-1 : 1pool-1-thread-1 : 2pool-1-thread-1 : 3pool-1-thread-1 : 4pool-1-thread-1 : 5pool-1-thread-1 : 6pool-1-thread-1 : 7pool-1-thread-1 : 8pool-1-thread-1 : 9... 4.6 LinkedBlockingQueue一个可改变大小的阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象如果没有明确大小，默认值是Integer.MAX_VALUE。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 4.7 SynchronousQueue同步队列。同步队列没有任何容量，每个插入必须等待另一个线程移除，反之亦然。是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。 4.8 DelayQueue延时队列，对元素进行持有直到一个特定的延迟到期，只有在延迟期满时才能从中提取元素。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。 4.9 PriorityBlockingQueue基于优先级的阻塞队列，依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序，应用：Volley 4.10 生产者消费者生产者生产任务，消费者消费任务，那么这时就需要一个任务队列，生产者向队列里插入任务，消费者从队列里提取任务执行 5. 线程池工具类Executorsjdk1.5之后的一个新类，提供了一些静态工厂，生成一些常用的线程池，ThreadPoolExecutor是Executors类的底层实现 方法 功能描述 newCachedThreadPool() 创建一个可缓存的线程池 newFixedThreadPool() 创建一个固定大小的线程池 newScheduledThreadPool() 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求 newSingleThreadExecutor() 创建单个线程的线程池，始终保证线程池中会有一个线程在。当某线程死去，会找继任者 defaultThreadFactory() 创建一个默认线程池工厂 6. 线程池在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程，这就是封装 记住：任务是提交给整个线程池，一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。 示例： 创建固定大小的线程池 创建缓存线程池 用线程池创建定时器 创建单一线程池（始终保证线程池中会有一个线程在。当某线程死去，会找继任者） 注意： 定时器中总是相对时间，我们要想指定具体时间的方法：比如明天早上10点钟执行，则可以使用明天早上10点的时间减去当前的时间，得到时间间隔 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class ThreadPoolTest &#123; public static void main(String[] args)&#123; //创建固定大小的线程池，这里只能完成3个任务 //ExecutorService threadPool = Executors.newFixedThreadPool(3); //创建缓存线程池，根据任务来自动创建线程的数量，可以完成创建的所有任务 //ExecutorService threadPool = Executors.newCachedThreadPool(); //创建单一线程池（始终保持线程池中有一个线程存活。当唯一线程死去，会创建新的继任者、 ExecutorService threadPool = Executors.newSingleThreadExecutor(); for(int i=1;i&lt;=10;i++)&#123; //内部类不能访问外部类的局部变量，所以i要定义为final，又由于i++. //所以在循环内部定义一个变量接收i final int task = i; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; for(int j=1;j&lt;=10;j++)&#123; System.out.println(Thread.currentThread().getName() +" is looping of "+ j+" for task of " +task); &#125; &#125; &#125;); &#125; //验证10个任务都提交给了线程池 System.out.println("all of 10 tasks have committed! "); //threadPool.shutdown(); //等任务完成后，杀死线程、 //threadPool.shutdownNow(); //立即停止线程 //用线程池启动定时器 Executors.newScheduledThreadPool(3).schedule( new Runnable() &#123; //任务 @Override public void run() &#123; System.out.println("bombing!"); &#125; &#125;, 5, //5秒以后执行 TimeUnit.SECONDS); //单位 //在某个时间执行一次后，再指定后续的执行间隔时间 Executors.newScheduledThreadPool(3).scheduleAtFixedRate(new Runnable()&#123; @Override public void run() &#123; System.out.println("bombing!"); &#125; &#125;, 10, //第一次在10秒时爆炸 3, //以后每隔3秒爆炸一次。 TimeUnit.SECONDS); &#125; &#125; 7. 线程池的简单使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * 一个简易的线程池管理类，提供三个线程池 */public class ThreadManager &#123; public static final String DEFAULT_SINGLE_POOL_NAME = "DEFAULT_SINGLE_POOL_NAME"; private static ThreadPoolProxy mLongPool = null; private static Object mLongLock = new Object(); private static ThreadPoolProxy mShortPool = null; private static Object mShortLock = new Object(); private static ThreadPoolProxy mDownloadPool = null; private static Object mDownloadLock = new Object(); private static Map&lt;String, ThreadPoolProxy&gt; mMap = new HashMap&lt;String, ThreadPoolProxy&gt;(); private static Object mSingleLock = new Object(); /** 获取下载线程 */ public static ThreadPoolProxy getDownloadPool() &#123; synchronized (mDownloadLock) &#123; if (mDownloadPool == null) &#123; mDownloadPool = new ThreadPoolProxy(3, 3, 5L); &#125; return mDownloadPool; &#125; &#125; /** 获取一个用于执行长耗时任务的线程池，避免和短耗时任务处在同一个队列而阻塞了重要的短耗时任务，通常用来联网操作 */ public static ThreadPoolProxy getLongPool() &#123; synchronized (mLongLock) &#123; if (mLongPool == null) &#123; mLongPool = new ThreadPoolProxy(5, 5, 5L); &#125; return mLongPool; &#125; &#125; /** 获取一个用于执行短耗时任务的线程池，避免因为和耗时长的任务处在同一个队列而长时间得不到执行，通常用来执行本地的IO/SQL */ public static ThreadPoolProxy getShortPool() &#123; synchronized (mShortLock) &#123; if (mShortPool == null) &#123; mShortPool = new ThreadPoolProxy(2, 2, 5L); &#125; return mShortPool; &#125; &#125; /** 获取一个单线程池，所有任务将会被按照加入的顺序执行，免除了同步开销的问题 */ public static ThreadPoolProxy getSinglePool() &#123; return getSinglePool(DEFAULT_SINGLE_POOL_NAME); &#125; /** 获取一个单线程池，所有任务将会被按照加入的顺序执行，免除了同步开销的问题 */ public static ThreadPoolProxy getSinglePool(String name) &#123; synchronized (mSingleLock) &#123; ThreadPoolProxy singlePool = mMap.get(name); if (singlePool == null) &#123; singlePool = new ThreadPoolProxy(1, 1, 5L); mMap.put(name, singlePool); &#125; return singlePool; &#125; &#125; public static class ThreadPoolProxy &#123; private ThreadPoolExecutor mPool; private int mCorePoolSize; private int mMaximumPoolSize; private long mKeepAliveTime; private ThreadPoolProxy(int corePoolSize, int maximumPoolSize, long keepAliveTime) &#123; mCorePoolSize = corePoolSize; mMaximumPoolSize = maximumPoolSize; mKeepAliveTime = keepAliveTime; &#125; /** 执行任务，当线程池处于关闭，将会重新创建新的线程池 */ public synchronized void execute(Runnable run) &#123; if (run == null) &#123; return; &#125; if (mPool == null || mPool.isShutdown()) &#123; //参数说明 //当线程池中的线程小于mCorePoolSize，直接创建新的线程加入线程池执行任务 //当线程池中的线程数目等于mCorePoolSize，将会把任务放入任务队列BlockingQueue中 //当BlockingQueue中的任务放满了，将会创建新的线程去执行， //但是当总线程数大于mMaximumPoolSize时，将会抛出异常，交给RejectedExecutionHandler处理 //mKeepAliveTime是线程执行完任务后，且队列中没有可以执行的任务，存活的时间，后面的参数是时间单位 //ThreadFactory是每次创建新的线程工厂 mPool = new ThreadPoolExecutor(mCorePoolSize, mMaximumPoolSize, mKeepAliveTime, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), Executors.defaultThreadFactory(), new AbortPolicy()); &#125; mPool.execute(run); &#125; /** 取消线程池中某个还未执行的任务 */ public synchronized void cancel(Runnable run) &#123; if (mPool != null &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123; mPool.getQueue().remove(run); &#125; &#125; /** 取消线程池中某个还未执行的任务 */ public synchronized boolean contains(Runnable run) &#123; if (mPool != null &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123; return mPool.getQueue().contains(run); &#125; else &#123; return false; &#125; &#125; /** 立刻关闭线程池，并且正在执行的任务也将会被中断 */ public void stop() &#123; if (mPool != null &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123; mPool.shutdownNow(); &#125; &#125; /** 平缓关闭单任务线程池，但是会确保所有已经加入的任务都将会被执行完毕才关闭 */ public synchronized void shutdown() &#123; if (mPool != null &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123; mPool.shutdownNow(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程范围内共享数据]]></title>
    <url>%2F2017%2F04%2F30%2F%E7%BA%BF%E7%A8%8B%E8%8C%83%E5%9B%B4%E5%86%85%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[笔记摘要所谓线程范围内共享数据，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据，API中为我们提供了一个操作线程范围内共享数据的类ThreadLocal，对于线程范围内共享数据的应用，在ThreadLocal的应用场景中进行了介绍，然后主要对它的使用进行讲解，演示了由单一数据的共享到将多个数据封装到一个对象中，然后进行共享。在开始先用一个Map集合简单实现线程范围内数据的共享 1. 使用Map实现线程范围内数据的共享原理：将线程对象作为map的键存入，这样就保证了map对象的唯一，也就保证了线程内数据的唯一 关键: 明确一点，把当前线程对象作为map集合的键存进去 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.HashMap; import java.util.Map; import java.util.Random; public class ThreadScopeShareData &#123; private static int data = 0; //定义一个全局的成员变量 private static Map&lt;Thread, Integer&gt; threadData = new HashMap&lt;Thread, Integer&gt;(); public static void main(String[] args) &#123; //启动两个线程 for(int i=0;i&lt;2;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; int data = new Random().nextInt(); //准备一个数据 System.out.println(Thread.currentThread().getName() + " has put data :" + data); //把当前线程对象作为键，就可以保证map对象的唯一，即保证线程内的数据唯一 threadData.put(Thread.currentThread(), data); new A().get(); new B().get(); &#125; &#125;).start(); &#125; &#125; //定义一个类模拟获取数据 static class A&#123; public void get()&#123; int data = threadData.get(Thread.currentThread()); System.out.println("A from " + Thread.currentThread().getName() + " get data :" + data); &#125; &#125; static class B&#123; public void get()&#123; int data = threadData.get(Thread.currentThread()); System.out.println("B from " + Thread.currentThread().getName() + " get data :" + data); &#125; &#125; &#125; 打印结果 123456Thread-0 has put data:-49248136Thread-1 has put data:311124475A from Thread-0 get data:-49248136A from Thread-1 get data:311124475B from Thread-0 get data:-49248136B from Thread-1 get data:311124475 2. ThreadLocal类ThreadLocal的作用和目的： 用于实现线程内的数据共享，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。 每个线程调用全局ThreadLocal对象的set方法，就相当于往其内部的map中增加一条记录，key分别是各自的线程，value是各自的set方法传进去的值。在线程结束时可以调用ThreadLocal.clear()方法，这样会更快释放内存，不调用也可以，因为线程结束后也可以自动释放相关的ThreadLocal变量。 3. ThreadLocal的应用场景1、订单处理包含一系列操作：减少库存量、增加一条流水台账、修改总账，这几个操作要在同一个事务中完成，通常也即同一个线程中进行处理，如果累加公司应收款的操作失败了，则应该把前面的操作回滚，否则，提交所有操作，这要求这些操作使用相同的数据库连接对象，而这些操作的代码分别位于不同的模块类中。 2、 银行转账包含一系列操作：把转出帐户的余额减少，把转入帐户的余额增加，这两个操作要在同一个事务中完成，它们必须使用相同的数据库连接对象，转入和转出操作的代码分别是两个不同的帐户对象的方法。 3、例如Strut2的ActionContext，同一段代码被不同的线程调用运行时，该代码操作的数据是每个线程各自的状态和数据，对于不同的线程来说，getContext方法拿到的对象都不相同，对同一个线程来说，不管调用getContext方法多少次和在哪个模块中getContext方法，拿到的都是同一个。 线程范围内共享数据示意图 实现对ThreadLocal变量的封装， 让外界不要直接操作ThreadLocal变量由于对基本类型的数据的封装，这种应用相对很少见。而对对象类型的数据的封装，比较常见，即让某个类针对不同线程分别创建一个独立的实例对象。所以我们要对数据进行封装。 实现方式一示例说明： 1、 该示例包含了对基本类型数据的共享和对象类型数据的共享 2、定义一个全局共享的ThreadLocal变量，然后启动多个线程向该ThreadLocal变量中存储一个随机值，接着各个线程调用另外其他多个类的方法，这多个类的方法中读取这个ThreadLocal变量的值，就可以看到多个类在同一个线程中共享同一份数据。 3、但这里每次存储数据时，都是使用同一个ThreadLocal对象，只是重新赋值而已 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.HashMap; import java.util.Map; import java.util.Random; public class ThreadLocalTest &#123; private static ThreadLocal&lt;Integer&gt; x = new ThreadLocal&lt;Integer&gt;(); //创建一个存储封装类对象的ThreadLocal private static ThreadLocal&lt;MyThreadScopeData&gt; myThreadScopeData = new ThreadLocal&lt;MyThreadScopeData&gt;(); private static int data = 0; public static void main(String[] args)&#123; //产生两个线程 for(int i=0;i&lt;2;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; //共享单一的数据 int data = new Random().nextInt(); System.out.println(Thread.currentThread().getName()+"has put data : "+data); x.set(data); //共享多个数据 //将数据封装在myData对象中，并将myData作为myThreadScopeData的键 MyThreadScopeData myData = new MyThreadScopeData(); myData.setName("name "+data); myData.setAge(data); myThreadScopeData.set(myData); new A().get(); new B().get(); &#125; &#125;).start(); &#125; &#125; static class A&#123; public void get()&#123; int data = x.get(); System.out.println("A from "+Thread.currentThread().getName()+" get data :"+data); //从myData中取出数据，并获取当前线程名，数据 MyThreadScopeData myData = myThreadScopeData.get(); System.out.println("A from "+Thread.currentThread().getName()+" getMyData: " + myData.getName() + "," +myData.getAge()); &#125; &#125; static class B&#123; public void get()&#123; int data = x.get(); System.out.println("B from "+Thread.currentThread().getName()+" get data :"+data); MyThreadScopeData myData = myThreadScopeData.get(); System.out.println("B from "+Thread.currentThread().getName()+" getMyData: " + myData.getName() + "," +myData.getAge()); &#125; &#125; &#125; //封装数据的类 class MyThreadScopeData&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 输出结果 12345678910Thread-0has put data : 1317043235Thread-1has put data : -969579752A from Thread-0 get data :1317043235A from Thread-1 get data :-969579752A from Thread-0 getMyData: name 1317043235,1317043235A from Thread-1 getMyData: name -969579752,-969579752B from Thread-0 get data :1317043235B from Thread-1 get data :-969579752B from Thread-0 getMyData: name 1317043235,1317043235B from Thread-1 getMyData: name -969579752,-969579752 实现方式二 示例说明： 这里模拟原始的单例模式，它们的区别是：单例模式中只有唯一的一个实例，而这里是每个线程拥有自己唯一的实例，只要是已经创建，就直接返回，保证每个线程拥有自己的唯一一份实例 优点： 这里可以返回每个线程自己唯一的实例对象，所以不必在外面定义，当在代码中的任意地方想获取到一个可以存储自己数据的线程实例的时候直接去调用getThreadInstance方法即可，直接定义在数据对象的内部，和数据关系更紧密，而方式一，则每次想存入数据的时候都需要在外面创建一个ThreadLocal对象用于存储数据。所以方式二更具封装性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package cn.itcast.heima2; import java.util.HashMap; import java.util.Map; import java.util.Random; public class ThreadLocalTest &#123; //创建一个ThreadLocal对象 private static ThreadLocal&lt;Integer&gt; x = new ThreadLocal&lt;Integer&gt;(); public static void main(String[] args) &#123; for(int i=0;i&lt;2;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; int data = new Random().nextInt(); System.out.println(Thread.currentThread().getName() + " has put data :" + data); x.set(data); //往当前线程存入一条数据 //获取与当前线程绑定的实例并设置值 MyThreadScopeData.getThreadInstance().setName("name：" + data); MyThreadScopeData.getThreadInstance().setAge(data); new A().get(); new B().get(); &#125; &#125;).start(); &#125; &#125; static class A&#123; public void get()&#123; int data = x.get(); //获取当前线程中的数据 System.out.println("A from " + Thread.currentThread().getName() + " get data :" + data); //获取与当前线程绑定的实例 MyThreadScopeData myData = MyThreadScopeData.getThreadInstance(); System.out.println("A from " + Thread.currentThread().getName() + " getMyData: " + myData.getName() + "," + myData.getAge()); &#125; &#125; static class B&#123; public void get()&#123; int data = x.get(); System.out.println("B from " + Thread.currentThread().getName() + " get data :" + data); MyThreadScopeData myData = MyThreadScopeData.getThreadInstance(); System.out.println("B from " + Thread.currentThread().getName() + " getMyData: " + myData.getName() + ",age: " + myData.getAge()); &#125; &#125; &#125; //一个绑定当前线程的类 class MyThreadScopeData&#123; private MyThreadScopeData()&#123;&#125; //构造方法私有化 private static ThreadLocal&lt;MyThreadScopeData&gt; map = new ThreadLocal&lt;MyThreadScopeData&gt;(); //定义一个静态方法，返回各线程自己的实例 //这里不必用同步，因为每个线程都要创建自己的实例，所以没有线程安全问题。 public static /*synchronized*/ MyThreadScopeData getThreadInstance()&#123; MyThreadScopeData instance = map.get(); //获取当前线程绑定的实例 if(instance == null)&#123; instance = new MyThreadScopeData(); map.set(instance); //创建完之后，将实例对象存进去 &#125; return instance; &#125; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 输出结果 12345678910Thread-0 has put data :2105117242Thread-1 has put data :-368218341A from Thread-1 get data :-368218341A from Thread-1 getMyData: name：-368218341,-368218341A from Thread-0 get data :2105117242A from Thread-0 getMyData: name：2105117242,2105117242B from Thread-0 get data :2105117242B from Thread-1 get data :-368218341B from Thread-0 getMyData: name：2105117242,age: 2105117242B from Thread-1 getMyData: name：-368218341,age: -368218341 4. 总结一个ThreadLocal代表一个变量，故其中只能放一个数据，有两个变量都要线程范围内共享，则要定义两个ThreadLocal对象，如果数据更多就很麻烦，可以先定义一个对象封装变量，然后在ThreadLocal中存储这一个对象，而这些操作都在提供线程数据类中完成]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JDK5中同步技术的3个面试题]]></title>
    <url>%2F2017%2F04%2F30%2F%E4%BD%BF%E7%94%A8JDK5%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%9A%843%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一题现有的程序代码模拟产生了16个日志对象，并且需要运行16秒才能打印完这些日志，请在程序中增加4个线程去调用parseLog()方法来分头打印这16个日志对象，程序只需要运行4秒即可打印完这些日志对象。 123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args)&#123; System.out.println("begin:"+(System.currentTimeMillis()/1000)); /*模拟处理16行日志，下面的代码产生了16个日志对象，当前代码需要运行16秒才能打印完这些日志。 修改程序代码，开四个线程让这16个对象在4秒钟打完。 */ for(int i=0;i&lt;16;i++)&#123; //这行代码不能改动 final String log = ""+(i+1); //这行代码不能改动 &#123; Test.parseLog(log); &#125; &#125; &#125; //parseLog方法内部的代码不能改动 public static void parseLog(String log)&#123; System.out.println(log+":"+(System.currentTimeMillis()/1000)); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 实现：通过阻塞队列实现线程间的通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue; //BlockingQueue public class Test &#123; public static void main(String[] args)&#123; //创建一个空间大小为16的阻塞队列，空间大小可以任意，因为每次打印都要1秒，在此期间， //4个线程足以不断去从队列中取数据，然后打印,即在1秒内打印4条日志信息 final BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(16); //开启4个线程打印 for(int i=0;i&lt;4;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; while(true)&#123; try &#123; //开始没有数据，阻塞，一旦有其中一个线程就去取数据，即不再阻塞，就开始打印 String log = queue.take(); parseLog(log); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125; //打印秒数 System.out.println("begin:"+(System.currentTimeMillis()/1000)); for(int i=0;i&lt;16;i++)&#123; // 这行代码不能改动 final String log = ""+(i+1); // 这行代码不能改动 &#123; try &#123; queue.put(log); // 向队列中存储数据 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //Test.parseLog(log); &#125; &#125; &#125; //parseLog方法内部的代码不能改动 public static void parseLog(String log)&#123; System.out.println(log+":"+(System.currentTimeMillis()/1000)); try &#123; Thread.sleep(1000); // 模拟每条日志打印需要1秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 第二题现成程序中的Test类中的代码在不断地产生数据，然后交给TestDo.doSome()方法去处理，就好像生产者在不断地产生数据，消费者在不断消费数据。 请将程序改造成有10个线程来消费生成者产生的数据，这些消费者都调用TestDo.doSome()方法去进行处理，故每个消费者都需要一秒才能处理完，程序应保证这些消费者线程依次有序地消费数据，只有上一个消费者消费完后，下一个消费者才能消费数据，下一个消费者是谁都可以，但要保证这些消费者线程拿到的数据是有顺序的。 1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) &#123; System.out.println("begin:"+(System.currentTimeMillis()/1000)); for(int i=0;i&lt;10;i++)&#123; //这行不能改动 String input = i+""; //这行不能改动 String output = TestDo.doSome(input); System.out.println(Thread.currentThread().getName()+ ":" + output); &#125; &#125; &#125; //不能改动此TestDo类 class TestDo &#123; public static String doSome(String input)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String output = input + ":"+ (System.currentTimeMillis() / 1000); return output; &#125; &#125; 在实现之前先介绍一个阻塞队列：SynchronousQuene，一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。 应用：它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.concurrent.SynchronousQueue; /*Semaphore与SynchronousQueue的混合使用。 由于Semaphore只有1个许可权，所以谁先拿到谁执行，然后释放，保证依次执行, 用锁也行，只要保证一个线程执行即可 SynchronousQueue是必须有其他线程取的动作，这样一一对应 */ public class Test &#123; public static void main(String[] args) &#123; //定义一个许可权为1的信号灯 final Semaphore semaphore = new Semaphore(1); //产生的结果无序 final SynchronousQueue&lt;String&gt; queue = new SynchronousQueue&lt;String&gt;(); //产生10个线程 for(int i=0;i&lt;10;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; try &#123; semaphore.acquire(); //获取许可 String input = queue.take(); //获取并移除此队列的头 String output = TestDo.doSome(input); System.out.println(Thread.currentThread().getName()+ ":" + output); semaphore.release(); //释放许可 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; System.out.println("begin:"+(System.currentTimeMillis()/1000)); for(int i=0;i&lt;10;i++)&#123; //这行不能改动 String input = i+""; //这行不能改动 try &#123; queue.put(input); //将指定元素添加到此队列 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //不能改动此TestDo类 class TestDo &#123; public static String doSome(String input)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String output = input + ":"+ (System.currentTimeMillis() / 1000); return output; &#125; &#125; 第三题现有程序同时启动了4个线程去调用TestDo.doSome(key, value)方法，由于TestDo.doSome(key, value)方法内的代码是先暂停1秒，然后再输出以秒为单位的当前时间值，所以，会打印出4个相同的时间值，如下所示： 12344:4:12581996151:1:12581996153:3:12581996151:2:1258199615 请修改代码，如果有几个线程调用TestDo.doSome(key, value)方法时，传递进去的key相等（equals比较为true），则这几个线程应互斥排队输出结果，即当有两个线程的key都是”1”时，它们中的一个要比另外其他线程晚1秒输出结果，如下所示： 12344:4:12581996151:1:12581996153:3:12581996151:2:1258199616 总之，当每个线程中指定的key相等时，这些相等key的线程应每隔一秒依次输出时间值（要用互斥），如果key不同，则并行执行（相互之间不互斥）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//不能改动此Test类 public class Test extends Thread&#123; private TestDo testDo; private String key; private String value; public Test(String key,String key2,String value)&#123; this.testDo = TestDo.getInstance(); /*常量"1"和"1"是同一个对象，下面这行代码就是要用"1"+""的方式产生新的对象， 以实现内容没有改变，仍然相等（都还为"1"），但对象却不再是同一个的效果*/ this.key = key+key2; this.value = value; &#125; public static void main(String[] args) throws InterruptedException&#123; Test a = new Test("1","","1"); Test b = new Test("1","","2"); Test c = new Test("3","","3"); Test d = new Test("4","","4"); System.out.println("begin:"+(System.currentTimeMillis()/1000)); a.start(); b.start(); c.start(); d.start(); &#125; public void run()&#123; testDo.doSome(key, value); &#125; &#125; class TestDo &#123; private TestDo() &#123;&#125; private static TestDo _instance = new TestDo(); public static TestDo getInstance() &#123; return _instance; &#125; public void doSome(Object key, String value) &#123; // 以大括号内的是需要局部同步的代码，不能改动! &#123; try &#123; Thread.sleep(1000); System.out.println(key+":"+value + ":" + (System.currentTimeMillis() / 1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 对于源代码中关于实现值相同而对象不同的效果进行解释：对于：12a = "1"+"";b = "1"+""; 编译器自动优化，所以a和b是同一个对象 而对于：key = key+key2; 由于是变量，编译器无法识别，这时a和b把“1”和“”赋值给key和key2时会得到两个不同的对象 思想：将集合中的对象作为同步代码块的锁，即this锁，每次将对象存入集合中的时候，就判断是否原集合中已经存在一个与将要存入集合的对象值相同的对象，即用equals比较，如果有，那么就获取原来的这个对象，把这个对象作为将要存入对象的锁，这样它们持有的就是同一把锁，即可实现互斥，这样就可以实现值相同的对象在不同的时刻打印的效果 代码中出现的问题：在遍历ArrayList集合查找与要存入值相同元素的时候，进行了添加的动作，所以会出现并发修改异常，因此使用并发的CopyOnWriteArrayList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.ArrayList; import java.util.Iterator; import java.util.concurrent.CopyOnWriteArrayList; //不能改动此Test类 public class Test extends Thread&#123; private TestDo testDo; private String key; private String value; public Test(String key,String key2,String value)&#123; this.testDo = TestDo.getInstance(); /*常量"1"和"1"是同一个对象，下面这行代码就是要用"1"+""的方式产生新的对象， 以实现内容没有改变，仍然相等（都还为"1"），但对象却不再是同一个的效果*/ this.key = key+key2; //这里是变量，所以不会优化 /* a = "1"+""; b = "1"+"" 编译器自动优化，所以a和b是同一个对象 */ this.value = value; &#125; public static void main(String[] args) throws InterruptedException&#123; Test a = new Test("1","","1"); Test b = new Test("1","","2"); Test c = new Test("3","","3"); Test d = new Test("4","","4"); System.out.println("begin:"+(System.currentTimeMillis()/1000)); a.start(); b.start(); c.start(); d.start(); &#125; public void run()&#123; testDo.doSome(key, value); &#125; &#125; class TestDo &#123; private TestDo() &#123;&#125; private static TestDo _instance = new TestDo(); public static TestDo getInstance() &#123; return _instance; &#125; //private ArrayList keys = new ArrayList(); //迭代的时候不能修改数据，所以使用同步的ArrayList private CopyOnWriteArrayList keys = new CopyOnWriteArrayList(); public void doSome(Object key, String value) &#123; Object o = key; if(!keys.contains(o))&#123; //比较是否已经存入了一个相同值的对象 keys.add(o); &#125;else&#123; //迭代，找出原集合里和传进来的值相同的对象 for(Iterator iter=keys.iterator();iter.hasNext();)&#123; try &#123; Thread.sleep(20); // 迭代的时候休息一会，在ArrayList下演示并发修改异常 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Object oo = iter.next(); if(oo.equals(o))&#123; //如果两个对象的值相同 //就让原集合中的那个相等值的对象作为锁对象，由于原对象之前做的就是锁 //这样两个锁就相同了，就可以实现互斥 o = oo; break; &#125; &#125; &#125; synchronized(o) // 以大括号内的是需要局部同步的代码，不能改动! &#123; try &#123; Thread.sleep(1000); System.out.println(key+":"+value + ":" + (System.currentTimeMillis() / 1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步工具类]]></title>
    <url>%2F2017%2F04%2F30%2F%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内容摘要这里主要介绍了java5中线程锁技术以外的其他同步工具，首先介绍Semaphore：一个计数信号量。用于控制同时访问资源的线程个数，CyclicBarrier同步辅助类：从字面意思看是路障，这里用于线程之间的相互等待，到达某点后，继续向下执行。CountDownLatch同步辅助类：在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。犹如倒计时计数器，然后是Exchanger：实现两个对象之间数据交换，可阻塞队列：ArrayBlockingQueue，通过阻塞队列间的通信来演示其作用，最后介绍了几个同步集合。 1. Semaphore实现信号灯Semaphore可以维护当前访问自身的线程个数，并提供了同步机制，使用Semaphore可以控制同时访问资源的线程个数，例如，实现一个文件允许的并发访问数。Semaphore 只对可用许可的号码进行计数，并采取相应的行动。 Semaphore实现的功能就像：银行办理业务，一共有5个窗口，但一共有10个客户，一次性最多有5个客户可以进行办理，其他的人必须等候，当5个客户中的任何一个离开后，在等待的客户中有一个人可以进行业务办理。 Semaphore提供了两种规则： 一种是公平的：获得资源的先后，按照排队的先后。在构造函数中设置true实现 一种是野蛮的：谁有本事抢到资源，谁就可以获得资源的使用权。 与传统的互斥锁的异同： 单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁“，再由另外一个线程释放”锁“，这可以应用于死锁恢复的一些场合。 应用场景：共享资源的争夺，例如游戏中选手进入房间的情况。 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; public class SemaphoreTest &#123; public static void main(String[] args) &#123; //创建一个可根据需要创建新线程的线程池 ExecutorService service = Executors.newCachedThreadPool(); final Semaphore sp = new Semaphore(3); //创建10个线程 for(int i=0;i&lt;10;i++)&#123; Runnable runnable = new Runnable()&#123; public void run()&#123; try &#123; sp.acquire(); //获取灯，即许可权 &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; System.out.println("线程" + Thread.currentThread().getName() + "进入，当前已有" + (3-sp.availablePermits()) + "个并发"); try &#123; Thread.sleep((long)(Math.random()*10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("线程" + Thread.currentThread().getName() + "即将离开"); sp.release(); // 释放一个许可，将其返回给信号量 //下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元 System.out.println("线程" + Thread.currentThread().getName() + "已离开，当前已有" + (3-sp.availablePermits()) + "个并发"); &#125; &#125;; service.execute(runnable); &#125; &#125; &#125; 输出结果 123456789101112131415161718192021222324252627282930线程pool-1-thread-3进入，当前已有3个并发线程pool-1-thread-2进入，当前已有3个并发线程pool-1-thread-1进入，当前已有3个并发线程pool-1-thread-2即将离开线程pool-1-thread-2已离开，当前已有2个并发线程pool-1-thread-5进入，当前已有3个并发线程pool-1-thread-1即将离开线程pool-1-thread-1已离开，当前已有2个并发线程pool-1-thread-4进入，当前已有3个并发线程pool-1-thread-4即将离开线程pool-1-thread-4已离开，当前已有2个并发线程pool-1-thread-8进入，当前已有3个并发线程pool-1-thread-3即将离开线程pool-1-thread-7进入，当前已有3个并发线程pool-1-thread-3已离开，当前已有3个并发线程pool-1-thread-8即将离开线程pool-1-thread-8已离开，当前已有2个并发线程pool-1-thread-9进入，当前已有3个并发线程pool-1-thread-7即将离开线程pool-1-thread-7已离开，当前已有2个并发线程pool-1-thread-6进入，当前已有3个并发线程pool-1-thread-9即将离开线程pool-1-thread-9已离开，当前已有2个并发线程pool-1-thread-10进入，当前已有3个并发线程pool-1-thread-5即将离开线程pool-1-thread-5已离开，当前已有2个并发线程pool-1-thread-6即将离开线程pool-1-thread-6已离开，当前已有1个并发线程pool-1-thread-10即将离开线程pool-1-thread-10已离开，当前已有0个并发 控制一个方法的并发量，比如同时只能有3个线程进来 12345678910111213141516171819202122232425262728293031323334353637383940public class ThreadPoolTest &#123; //信号量 private static Semaphore semaphore = new Semaphore(3);//允许个数，相当于放了3把锁 public static void main(String[] args) &#123; for(int i=0;i&lt;10;i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; method(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; //同时最多只允许3个线程过来 public static void method() throws InterruptedException&#123; semaphore.acquire();//获取一把锁 System.out.println("ThreadName="+Thread.currentThread().getName()+"过来了"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("ThreadName="+Thread.currentThread().getName()+"出去了"); semaphore.release();//释放一把锁 &#125;&#125; 输出结果 1234567891011121314151617181920ThreadName=Thread-1过来了ThreadName=Thread-4过来了ThreadName=Thread-0过来了ThreadName=Thread-1出去了ThreadName=Thread-4出去了ThreadName=Thread-2过来了ThreadName=Thread-3过来了ThreadName=Thread-0出去了ThreadName=Thread-5过来了ThreadName=Thread-3出去了ThreadName=Thread-2出去了ThreadName=Thread-6过来了ThreadName=Thread-7过来了ThreadName=Thread-5出去了ThreadName=Thread-9过来了ThreadName=Thread-7出去了ThreadName=Thread-6出去了ThreadName=Thread-8过来了ThreadName=Thread-9出去了ThreadName=Thread-8出去了 三个线程a、b、c 并发运行，b，c 需要a 线程的数据怎么实现 根据问题的描述，我将问题用以下代码演示，ThreadA、ThreadB、ThreadC，ThreadA 用于初始化数据num，只有当num 初始化完成之后再让ThreadB 和ThreadC 获取到初始化后的变量num。 分析过程如下： 考虑到多线程的不确定性，因此我们不能确保ThreadA 就一定先于ThreadB 和ThreadC 前执行，就算ThreadA先执行了，我们也无法保证ThreadA 什么时候才能将变量num 给初始化完成。因此我们必须让ThreadB 和ThreadC去等待ThreadA 完成任何后发出的消息。 现在需要解决两个难题，一是让ThreadB 和ThreadC 等待ThreadA 先执行完，二是ThreadA 执行完之后给ThreadB 和ThreadC 发送消息。 解决上面的难题我能想到的两种方案，一是使用纯Java API 的Semaphore 类来控制线程的等待和释放，二是使用Android 提供的Handler 消息机制 1234567891011121314151617181920212223242526272829303132333435363738394041public class ThreadCommunication &#123; private static int num;//定义一个变量作为数据 public static void main(String[] args) &#123; Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //模拟耗时操作之后初始化变量num Thread.sleep(1000); num = 1; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() +"获取到num 的值为："+num); &#125; &#125;); Thread threadC = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() +"获取到num 的值为："+num); &#125; &#125;); //同时开启3 个线程 threadA.start(); threadB.start(); threadC.start(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ThreadCommunication &#123; private static int num; /** * 定义一个信号量，该类内部维持了多个线程锁，可以阻塞多个线程，释放多个线程， * 线程的阻塞和释放是通过permit 概念来实现的线程通过semaphore.acquire()方法获取permit， * 如果当前semaphore 有permit 则分配给该线程，如果没有则阻塞该线程直到semaphore * 调用release（）方法释放permit。构造函数中参数：permit（允许） 个数 */ private static Semaphore semaphore = new Semaphore(0); public static void main(String[] args) &#123; Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //模拟耗时操作之后初始化变量num Thread.sleep(1000); num = 1; //初始化完参数后释放两个permit semaphore.release(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //获取permit，如果semaphore 没有可用的permit 则等待 // 如果有则消耗一个 semaphore.acquire(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() +"获取到num 的值为："+num); &#125; &#125;); Thread threadC = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //获取permit，如果semaphore 没有可用的permit 则等待 // 如果有则消耗一个 semaphore.acquire(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() +"获取到num 的值为："+num); &#125; &#125;); //同时开启3 个线程 threadA.start(); threadB.start(); threadC.start(); &#125;&#125; 2. CyclicBarrier一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 CyclicBarrier 支持一个可选的 Runnable 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作 很有用。 3个线程到达某个集合点后再向下执行,使用await方法实现 123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.CyclicBarrier; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); final CyclicBarrier cb = new CyclicBarrier(3); for(int i=0;i&lt;3;i++)&#123; Runnable runnable = new Runnable()&#123; public void run()&#123; try &#123; Thread.sleep((long)(Math.random()*10000)); System.out.println("线程" + Thread.currentThread().getName() + "即将到达集合地点1，当前已有" + (cb.getNumberWaiting()+1) + "个已经到达，" + (cb.getNumberWaiting()==2?"都到齐了，继续走啊":"正在等候")); cb.await();//在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。 Thread.sleep((long)(Math.random()*10000)); System.out.println("线程" + Thread.currentThread().getName() + "即将到达集合地点2，当前已有" + (cb.getNumberWaiting()+1) + "个已经到达，" + (cb.getNumberWaiting()==2?"都到齐了，继续走啊":"正在等候")); cb.await(); Thread.sleep((long)(Math.random()*10000)); System.out.println("线程" + Thread.currentThread().getName() + "即将到达集合地点3，当前已有" + (cb.getNumberWaiting() + 1) + "个已经到达，" + (cb.getNumberWaiting()==2?"都到齐了，继续走啊":"正在等候")); cb.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; service.execute(runnable); &#125; service.shutdown(); &#125; &#125; 输出结果 123456789线程pool-1-thread-3即将到达集合地点1，当前已有1个已经到达，正在等候线程pool-1-thread-1即将到达集合地点1，当前已有2个已经到达，正在等候线程pool-1-thread-2即将到达集合地点1，当前已有3个已经到达，都到齐了，继续走啊线程pool-1-thread-1即将到达集合地点2，当前已有1个已经到达，正在等候线程pool-1-thread-2即将到达集合地点2，当前已有2个已经到达，正在等候线程pool-1-thread-3即将到达集合地点2，当前已有3个已经到达，都到齐了，继续走啊线程pool-1-thread-3即将到达集合地点3，当前已有1个已经到达，正在等候线程pool-1-thread-1即将到达集合地点3，当前已有2个已经到达，正在等候线程pool-1-thread-2即将到达集合地点3，当前已有3个已经到达，都到齐了，继续走啊 3. CountDownLatch一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。犹如倒计时计数器，调用CountDownLatch对象的countDown方法就将计数器减1，当计数到达0时，则所有等待者或单个等待者开始执行。 可以实现一个人（也可以是多个人）等待其他所有人都来通知他，也可以实现一个人通知多个人的效果，类似裁判一声口令，运动员开始奔跑（一对多），或者所有运送员都跑到终点后裁判才可以公布结果（多对一）。 用指定的计数 初始化 CountDownLatch。在调用 countDown() 方法之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。 实现运动员比赛的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.concurrent.CountDownLatch; import java.util.concurrent.CyclicBarrier; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class CountdownLatchTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); //构造一个用给定计数初始化的 CountDownLatch,相当于裁判的口哨 final CountDownLatch cdOrder = new CountDownLatch(1); //相当于定义3个运行员 final CountDownLatch cdAnswer = new CountDownLatch(3); for (int i = 0; i &lt; 3; i++) &#123; Runnable runnable = new Runnable() &#123; public void run() &#123; try &#123; System.out.println("线程" + Thread.currentThread().getName() + "正准备接受命令"); // 等待发令枪 cdOrder.await();//使当前线程在锁存器倒计数至零之前一直等待 System.out.println("线程" + Thread.currentThread().getName() + "已接受命令"); Thread.sleep((long) (Math.random() * 10000)); System.out .println("线程" + Thread.currentThread().getName() + "回应命令处理结果"); // 各个运动员完报告成绩之后，通知裁判 cdAnswer.countDown();//递减锁存器的计数，如果计数到达零，则释放所有等待的线程 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; service.execute(runnable); &#125; try &#123; Thread.sleep((long) (Math.random() * 10000)); System.out.println("线程" + Thread.currentThread().getName() + "即将发布命令"); // 发令枪打响，比赛开始 cdOrder.countDown(); System.out.println("线程" + Thread.currentThread().getName() + "已发送命令，正在等待结果"); // 裁判等待各个运动员的结果 cdAnswer.await(); // 裁判公布获得所有运动员的成绩 System.out.println("线程" + Thread.currentThread().getName() + "已收到所有响应结果"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; service.shutdown(); &#125; &#125; 输出结果 123456789101112线程pool-1-thread-2正准备接受命令线程pool-1-thread-3正准备接受命令线程pool-1-thread-1正准备接受命令线程main即将发布命令线程main已发送命令，正在等待结果线程pool-1-thread-1已接受命令线程pool-1-thread-2已接受命令线程pool-1-thread-3已接受命令线程pool-1-thread-1回应命令处理结果线程pool-1-thread-3回应命令处理结果线程pool-1-thread-2回应命令处理结果线程main已收到所有响应结果 4. Exchanger用于实现两个对象之间的数据交换，每个对象在完成一定的事务后想与对方交换数据，第一个先拿出数据的对象将一直等待第二个对象拿着数据到来时，彼此才能交换数据。 方法：exchange（V x） 等待另一个线程到达此交换点（除非当前线程被中断），然后将给定的对象传送给该线程，并接收该线程的对象。 应用：使用 Exchanger 在线程间交换缓冲区 示例：模拟毒品交易情景 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.Exchanger; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ExchangerTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); final Exchanger exchanger = new Exchanger(); service.execute(new Runnable()&#123; public void run() &#123; try &#123; String data1 = "毒品"; System.out.println("线程" + Thread.currentThread().getName() + "正在把: " + data1 +" 交易出去"); Thread.sleep((long)(Math.random()*10000)); String data2 = (String)exchanger.exchange(data1); System.out.println("线程" + Thread.currentThread().getName() + "换得了: " + data2); &#125;catch(Exception e)&#123; &#125; &#125; &#125;); service.execute(new Runnable()&#123; public void run() &#123; try &#123; String data1 = "美金"; System.out.println("线程" + Thread.currentThread().getName() + "正在把: " + data1 +" 交易出去"); Thread.sleep((long)(Math.random()*10000)); String data2 = (String)exchanger.exchange(data1); System.out.println("线程" + Thread.currentThread().getName() + "换得了: " + data2); &#125;catch(Exception e)&#123; &#125; &#125; &#125;); &#125; &#125; 1234线程pool-1-thread-1正在把: 毒品 交易出去线程pool-1-thread-2正在把: 美金 交易出去线程pool-1-thread-1换得了: 美金线程pool-1-thread-2换得了: 毒品 5. ArrayBlockingQueue一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列包含固定长度的队列和不固定长度的队列。 这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。 通俗的讲：当指定队列大小，如果已经放满，其他存入数据的线程就阻塞，等着该队列中有空位，才能放进去。当取的比较快，队列中没有数据，取数据的线程阻塞，等队列中放入了数据，才可以取。 ArrayBlockingQueue中只有put和take方法才具有阻塞功能。方法类型如下 功能 抛出异常 特殊值 阻塞 超时 插入 add(e) offer(e) put(e) offer(e, time, unit) 移除 remove() poll() take() poll(time, unit) 检查 element() peek() 不可用 不可用 示例：用3个空间的队列来演示向阻塞队列中存取数据的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.xushuai.thread; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue; public class BlockingQueueTest &#123; public static void main(String[] args) &#123; final BlockingQueue queue = new ArrayBlockingQueue(3); for(int i=0;i&lt;2;i++)&#123; new Thread()&#123; public void run()&#123; while(true)&#123; try &#123; Thread.sleep((long)(Math.random()*1000)); System.out.println(Thread.currentThread().getName() + "准备放数据!"); queue.put(1); //放进去后，可能立即执行“准备取数据” System.out.println(Thread.currentThread().getName() + "已经放了数据，" + "队列目前有" + queue.size() + "个数据"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; new Thread()&#123; public void run()&#123; while(true)&#123; try &#123; //将此处的睡眠时间分别改为100和1000，观察运行结果 Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + "准备取数据!"); queue.take(); //取出后可能來不及执行下面的打印语句，就跑到了“准备放数据”， System.out.println(Thread.currentThread().getName() + "已经取走数据，" + "队列目前有" + queue.size() + "个数据"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; &#125; 输出结果1234567891011121314151617181920212223242526Thread-0准备放数据!Thread-0已经放了数据，队列目前有1个数据Thread-0准备放数据!Thread-0已经放了数据，队列目前有2个数据Thread-1准备放数据!Thread-1已经放了数据，队列目前有3个数据Thread-2准备取数据!Thread-2已经取走数据，队列目前有2个数据Thread-0准备放数据!Thread-0已经放了数据，队列目前有3个数据Thread-0准备放数据!Thread-1准备放数据!Thread-2准备取数据!Thread-2已经取走数据，队列目前有2个数据Thread-0已经放了数据，队列目前有3个数据Thread-0准备放数据!Thread-2准备取数据!Thread-2已经取走数据，队列目前有2个数据Thread-1已经放了数据，队列目前有3个数据Thread-1准备放数据!Thread-2准备取数据!Thread-2已经取走数据，队列目前有2个数据Thread-0已经放了数据，队列目前有3个数据Thread-0准备放数据!Thread-2准备取数据!... 6. 阻塞队列间的通信A队列向空间中存数据，B从空间里取数据，A存入后，通知B去取，B取过之后，通知A去放，依次循环 示例：子线程先循环10次，接着主线程循环100次，接着又回到子线程，循环10次，再回到主线程又循环100，如此循环50次。 说明：这里通过使 用两个具有1个空间的队列来实现同步通知的功能（实现了锁和condition的功能），以便实现队列间的通信，其中使用到了构造代码块为主队列先存入一个数据，以使其先阻塞，子队列先执行。 使用构造代码块的原因： 成员变量在创建类的实例对象时，才分配空间，才能有值，所以创建一个构造方法来给main_quene赋值，这里不可以使用静态代码块，因为静态在还没创建对象就存在， 而sub_quene和main_quene是对象创建以后的成员变量，所以这里用匿名构造方法，它的运行时期在任何构造方法之前，创建几个对象就执行几次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue; public class BlockingQueueCommunication &#123; public static void main(String[] args)&#123; final Business business = new Business(); new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=1;i&lt;=50;i++)&#123; business.sub(i); &#125; &#125; &#125;).start(); //主线程外部循环 for(int i=1;i&lt;=50;i++)&#123; business.main(i); &#125; &#125; //业务类 static class Business&#123; BlockingQueue&lt;Integer&gt; sub_quene = new ArrayBlockingQueue&lt;Integer&gt;(1); BlockingQueue&lt;Integer&gt; main_quene = new ArrayBlockingQueue&lt;Integer&gt;(1); &#123; //为了让子队列先走，所以在一开始就往主队列中存入一个对象，使其阻塞。 try &#123; main_quene.put(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //子队列先走 public void sub(int i)&#123; try &#123; sub_quene.put(1); //子队列第一次存入，可以执行，但由于只有1个空间，已经存满，所以只有在执行后要等到take之后才能继续下次执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //子队列循环执行 for(int j=1;j&lt;=10;j++)&#123; System.out.println("sub thread sequence of"+i+",loop of "+j); &#125; try &#123; main_quene.take(); //让主队列从已经填满的队列中取出数据，使其开始第一次执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void main(int i)&#123; try &#123; main_quene.put(1); //主队列先前放过1个空间，现在处于阻塞状态，等待子队列通知，即子线程中的main_quene.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //主队列循环执行 for(int j=1;j&lt;=100;j++)&#123; System.out.println("main thread sequence of"+i+", loop of "+j); &#125; try &#123; sub_quene.take(); //让子队列从已经填满的队列中取出数据，使其执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 7. 同步集合类7.1 同步Map集合 java.util.concurrent.ConcurrentMap ConcurrentHashMap ConcurrentNavigableMap ConcurrentSkipListMap ConcurrentHashMap同步的HashMap，支持获取的完全并发和更新的所期望可调整并发的哈希表。此类遵守与 Hashtable 相同的功能规范，并且包括对应于 Hashtable 的每个方法的方法版本。 不过，尽管所有操作都是线程安全的，但获取操作不 必锁定，并且不 支持以某种防止所有访问的方式锁定整个表。此类可以通过程序完全与 Hashtable 进行互操作，这取决于其线程安全，而与其同步细节无关。 内部原理： 其实内部使用了代理模式，你给我一个HashMap，我就给你一个同步的HashMap。同步的HashMap在调用方法时，是去分配给原始的HashMap只是在去调用方法的同时加上了Synchronized，以此实现同步效果 ConcurrentHashMap是线程安全的HashMap的实现，默认构造同样有initialCapacity和loadFactor属性，不过还多了一个concurrencyLevel属性，三属性默认值分别为16、0.75及16。其内部使用锁分段技术，维持这锁Segment的数组，在Segment数组中又存放着Entity[]数组，内部hash算法将数据较均匀分布在不同锁中。 put(key , value) 并没有在此方法上加上synchronized，首先对key.hashcode进行hash操作，得到key的hash值。hash操作的算法和map也不同，根据此hash值计算并获取其对应的数组中的Segment对象(继承自ReentrantLock)，接着调用此Segment对象的put方法来完成当前操作。 ConcurrentHashMap基于concurrencyLevel划分出了多个Segment来对key-value进行存储，从而避免每次put操作都得锁住整个数组。在默认的情况下，最佳情况下可允许16个线程并发无阻塞的操作集合对象，尽可能地减少并发时的阻塞现象。 get(key) 首先对key.hashCode进行hash操作，基于其值找到对应的Segment对象，调用其get方法完成当前操作。而Segment的get操作首先通过hash值和对象数组大小减1的值进行按位与操作来获取数组上对应位置的HashEntry。在这个步骤中，可能会因为对象数组大小的改变，以及数组上对应位置的HashEntry产生不一致性，那么ConcurrentHashMap是如何保证的？ 对象数组大小的改变只有在put操作时有可能发生，由于HashEntry对象数组对应的变量是volatile类型的，因此可以保证如HashEntry对象数组大小发生改变，读操作可看到最新的对象数组大小。 在获取到了HashEntry对象后，怎么能保证它及其next属性构成的链表上的对象不会改变呢？这点ConcurrentHashMap采用了一个简单的方式，即HashEntry对象中的hash、key、next属性都是final的，这也就意味着没办法插入一个HashEntry对象到基于next属性构成的链表中间或末尾。这样就可以保证当获取到HashEntry对象后，其基于next属性构建的链表是不会发生变化的。 ConcurrentHashMap默认情况下采用将数据分为16个段进行存储，并且16个段分别持有各自不同的锁Segment，锁仅用于put和remove等改变集合对象的操作，基于volatile及HashEntry链表的不变性实现了读取的不加锁。这些方式使得ConcurrentHashMap能够保持极好的并发支持，尤其是对于读远比插入和删除频繁的Map而言，而它采用的这些方法也可谓是对于Java内存模型、并发机制深刻掌握的体现。 ConcurrentNavigableMapjava.util.concurrent.ConcurrentNavigableMap 是一个支持并发访问的 java.util.NavigableMap，它还能让它的子 map 具备并发访问的能力。所谓的 “子 map” 指的是诸如 headMap()，subMap()，tailMap() 之类的方法返回的 map。 NavigableMap 中的方法不再赘述，本小节我们来看一下 ConcurrentNavigableMap 添加的方法。 headMap()headMap(T toKey) 方法返回一个包含了小于给定 toKey 的 key 的子 map。如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素(译者注：map 集合持有的其实只是对象的引用)。 以下示例演示了对 headMap() 方法的使用： 1234567ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put("1", "one"); map.put("2", "two"); map.put("3", "three"); ConcurrentNavigableMap headMap = map.headMap("2"); headMap 将指向一个只含有键 “1” 的 ConcurrentNavigableMap，因为只有这一个键小于 “2”。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。 tailMap()tailMap(T fromKey) 方法返回一个包含了不小于给定 fromKey 的 key 的子 map。如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素(译者注：map 集合持有的其实只是对象的引用)。 以下示例演示了对 tailMap() 方法的使用： 1234567ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put("1", "one"); map.put("2", "two"); map.put("3", "three"); ConcurrentNavigableMap tailMap = map.tailMap("2"); tailMap 将拥有键 “2” 和 “3”，因为它们不小于给定键 “2”。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。 subMap()subMap() 方法返回原始 map 中，键介于 from(包含) 和 to (不包含) 之间的子 map。示例如下： 1234567ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put("1", "one"); map.put("2", "two"); map.put("3", "three"); ConcurrentNavigableMap subMap = map.subMap("2", "3"); 返回的 submap 只包含键 “2”，因为只有它满足不小于 “2”，比 “3” 小。 更多方法ConcurrentNavigableMap 接口还有其他一些方法可供使用，比如： descendingKeySet() descendingMap() navigableKeySet() 关于这些方法更多信息参考官方 Java 文档。 7.2 同步List集合 ConcurrentSkipListSet CopyOnWriteArraySet CopyOnWriteArrayList ConcurrentSkipListSet一个基于 ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现。类似于TreeSet，set 的元素可以根据它们的自然顺序进行排序，也可以根据创建 set 时所提供的Comparator 进行排序，具体取决于使用的构造方法。 CopyOnWriteArrayListArrayList 的一个线程安全的变体，可解决线程安全问题，在遍历的时候，同时进行添加操作。其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 CopyOnWriteArrayList是一个线程安全、并且在读操作时无锁的ArrayList，其具体实现方法如下。 CopyOnWriteArrayList() 和ArrayList不同，此步的做法为创建一个大小为0的数组。 add(E) add方法并没有加上synchronized关键字，它通过使用ReentrantLock来保证线程安全。此处和ArrayList的不同是每次都会创建一个新的Object数组，此数组的大小为当前数组大小加1，将之前数组中的内容复制到新的数组中，并将新增加的对象放入数组末尾，最后做引用切换将新创建的数组对象赋值给全局的数组对象。 remove(E) 和add方法一样，此方法也通过ReentrantLock来保证其线程安全，但它和ArrayList删除元素采用的方式并不一样。 首先创建一个比当前数组小1的数组，遍历新数组，如找到equals或均为null的元素，则将之后的元素全部赋值给新的数组对象，并做引用切换，返回true；如未找到，则将当前的元素赋值给新的数组对象，最后特殊处理数组中的最后一个元素，如最后一个元素等于要删除的元素，即将当前数组对象赋值为新创建的数组对象，完成删除操作，如最后一个元素也不等于要删除的元素，那么返回false。 此方法和ArrayList除了锁不同外，最大的不同在于其复制过程并没有调用System的arrayCopy来完成，理论上来说会导致性能有一定下降。 get(int) 此方法非常简单，直接获取当前数组对应位置的元素，这种方法是没有加锁保护的，因此可能会出现读到脏数据的现象。但相对而言，性能会非常高，对于写少读多且脏数据影响不大的场景而言是不错的选择。 iterator() 调用iterator方法后创建一个新的COWIterator对象实例，并保存了一个当前数组的快照，在调用next遍历时则仅对此快照数组进行遍历，因此遍历此list时不会抛出ConcurrentModificatiedException。 与ArrayList的性能对比，在读多写少的并发场景中，较之ArrayList是更好的选择，单线程以及多线程下增加元素及删除元素的性能不比ArrayList好 CopyOnWriteArraySet对其所有操作使用内部 CopyOnWriteArrayList 的 Set。因此，它共享以下相同的基本属性： 它最适合于 set 大小通常保持很小、只读操作远多于可变操作以及需要在遍历期间防止线程间冲突的应用程序。 它是线程安全的。 因为通常需要复制整个基础数组，所以可变操作（添加、设置、移除，等等）的开销巨大。 迭代器不支持可变移除操作。 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 CopyOnWriteArraySet基于CopyOnWriteArrayList实现，其唯一的不同是在add时调用的是CopyOnWriteArrayList的addIfAbsent方法。保证了无重复元素，但在add时每次都要进行数组的遍历，因此性能会略低于上个。 7.3 ConcurrentLinkedQueueConcurrentLinkedQueue是一个基于链接节点的、无界的、线程安全的队列。此队列按照 FIFO（先进先出）原则对元素进行排序，队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列检索操作从队列头部获得元素。当许多线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择，此队列不允许 null 元素。 7.4 ConcurrentLinkedDeque一个基于链接节点的、无界的、线程安全的双端队列]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个线程之间共享数据的方式探讨]]></title>
    <url>%2F2017%2F04%2F30%2F%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[内容摘要多个线程之间共享数据，按照每个线程执行代码是否相同，我们可以采取不同的处理方式，这里通过简单的卖票示例说明了当每个线程执行相同代码的情况，对于多个线程执行不同代码的情况，处理方式比较灵活，这里主要介绍了2种方式，通过2种方式的对比和归纳，我们可以总结出在多个线程执行不同的代码情况下，如何进行代码的设计 1. 如果每个线程执行的代码相同可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如：卖票系统 1.1 简单的卖票系统示例12345678910111213141516171819202122232425262728293031323334class Ticket implements Runnable&#123; private int tick = 20; Object obj = new Object(); public void run()&#123; while(true)&#123; synchronized(obj)&#123; if(tick&gt;0)&#123; //只能try，因为run是复写了Runnable接口的run,接口的run没有抛 //try&#123;Thread.sleep(10);&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"....sale : "+ tick--); &#125; &#125; &#125; &#125; &#125; class TicketDemo &#123; public static void main(String[] args) &#123; //只建立了一个Ticket对象，内存中只有一个tick成员变量，所以是共享数据 Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; 1234567891011121314151617181920Thread-0....sale : 20Thread-0....sale : 19Thread-0....sale : 18Thread-0....sale : 17Thread-0....sale : 16Thread-0....sale : 15Thread-0....sale : 14Thread-0....sale : 13Thread-0....sale : 12Thread-3....sale : 11Thread-3....sale : 10Thread-3....sale : 9Thread-3....sale : 8Thread-3....sale : 7Thread-3....sale : 6Thread-3....sale : 5Thread-3....sale : 4Thread-3....sale : 3Thread-3....sale : 2Thread-3....sale : 1 2. 如果每个线程执行的代码不同 这时候不需要用不同的Runnable对象，有如下两种方式来实现这些Runnable对象之间的数据共享。 2.1 方式1将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样容易实现针对该数据进行的各个操作的互斥和通信。 思想：一个类提供数据和操作数据的同步方法，另外定义两个线程通过构造函数接收并操作数据，在主函数中直接创建线程对象，即可完成操作 2.2 方式2将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方式也分配给外部类，以便实现对共享数据进行的各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。 思想：一个外部类里面有两个内部类，为了让这两个内部类共享数据，让它们都操作外部类的同一个成员，方法和数据都在这个成员身上，直接调用方法即可完成 数据的操作 2.3 方式3：将上面两种方式的组合将共享数据封装在另外一个对象中，每个线程对共享数据的操作方法也分配到那个对象身上去完成，对象作为这个外部类中的成员变量或方法中的局部变量，每个线程的Runnable的对象作为外部类中的成员内部类或局部外部类。 2.4 技巧总结要同步互斥的几段代码最好是分别放在几个独立的方法中，这些方法再放在同一个类中，这样比较容易实现它们之间的同步互斥或通信。极端且简单的方式，即在任意一个类中定义一个static的变量，这将被所有线程共享。 2.5 对于每个线程执行的代码不同下的3种方式，通过一个面试题来说明需求：设计4个线程，其中两个线程每次对j增加1，另外两个线程每次对j减少1，写出程序 使用方式1实现将数据和操作共享数据的方法封装在一个类中，定义两个Runnable实现类，让两个Runnable都持有共享数据的引用，在Runnable的构造函数中，直接传入去操作，在实现类的run方法中调用封装类的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MultyThreadShareMethod1 &#123; public static void main(String[] args)&#123; //将数据封装到一个对象上， ShareData2 data1 = new ShareData2(); //在runnable的构造函数中直接传入去操作 for(int i=0;i&lt;2;i++)&#123; new Thread(new MyRunnable1(data1)).start(); new Thread(new MyRunnable2(data1)).start(); &#125; &#125; &#125; //封装共享数据和操作共享数据方法的类 class ShareData2&#123; private int j = 10; public synchronized void increment() &#123; j++; System.out.println(Thread.currentThread().getName()+" inc : "+j); &#125; public synchronized void decrement() &#123; j--; System.out.println(Thread.currentThread().getName()+" dec : "+j); &#125; &#125; //增加的线程，需要传入一个共享数据 class MyRunnable1 implements Runnable &#123; private ShareData2 data; public MyRunnable1(ShareData2 data) &#123; this.data = data; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; data.increment(); &#125; &#125; &#125; //减少的线程，需要传入一个共享数据 class MyRunnable2 implements Runnable &#123; private ShareData2 data; public MyRunnable2(ShareData2 data) &#123; this.data = data; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; data.decrement(); &#125; &#125; &#125; 输出结果 12345678910111213141516171819202122232425262728293031323334353637383940Thread-0 inc : 11Thread-0 inc : 12Thread-0 inc : 13Thread-0 inc : 14Thread-0 inc : 15Thread-0 inc : 16Thread-0 inc : 17Thread-0 inc : 18Thread-0 inc : 19Thread-0 inc : 20Thread-1 dec : 19Thread-3 dec : 18Thread-3 dec : 17Thread-3 dec : 16Thread-3 dec : 15Thread-3 dec : 14Thread-3 dec : 13Thread-3 dec : 12Thread-3 dec : 11Thread-3 dec : 10Thread-3 dec : 9Thread-2 inc : 10Thread-2 inc : 11Thread-1 dec : 10Thread-1 dec : 9Thread-1 dec : 8Thread-1 dec : 7Thread-1 dec : 6Thread-1 dec : 5Thread-1 dec : 4Thread-1 dec : 3Thread-1 dec : 2Thread-2 inc : 3Thread-2 inc : 4Thread-2 inc : 5Thread-2 inc : 6Thread-2 inc : 7Thread-2 inc : 8Thread-2 inc : 9Thread-2 inc : 10 使用方式2实现将数据和操作共享数据的方法封装在一个类中 两个Runnable作为它的内部类，相对于方式1，这里没有将数据传给Runnable，而是让它们自己去取，在自己的run方法中调用操作数据的方法 这里的共享变量可以定义为静态类型的成员变量，也可以定义为final类型的局部变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MultyThreadShareData &#123; //共享数据作为外部类的成员变量 //private static ShareData data = new ShareData(); public static void main(String[] args)&#123; //也可以定义为final类型的局部变量 final ShareData data = new ShareData(); //开启4条线程 for(int i=0;i&lt;2;i++)&#123; //增加的线程 new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=0;i&lt;100;i++)&#123; data.increment(); &#125; &#125; &#125;).start(); //减少的线程 new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=0;i&lt;100;i++)&#123; data.decrement(); &#125; &#125; &#125;).start(); &#125; &#125; &#125; //封装共享数据和操作共享数据方法的类 class ShareData&#123; private int j = 0; public synchronized void increment() &#123; j++; System.out.println(Thread.currentThread().getName()+" inc : "+j); &#125; public synchronized void decrement() &#123; j--; System.out.println(Thread.currentThread().getName()+" dec : "+j); &#125; &#125; 两种方式的组合实现1234567891011121314151617181920212223242526272829303132333435363738394041public class MultyThreadShareDataTest &#123; private int j; public static void main(String args[])&#123; MultyThreadShareDataTest tt = new MultyThreadShareDataTest(); Inc inc=tt.new Inc(); Dec dec=tt.new Dec(); for(int i=0;i&lt;2;i++)&#123; Thread t=new Thread(inc); t.start(); t=new Thread(dec); t.start(); &#125; &#125; private synchronized void inc()&#123; j++; System.out.println(Thread.currentThread().getName()+"-inc:"+j); &#125; private synchronized void dec()&#123; j--; System.out.println(Thread.currentThread().getName()+"-dec:"+j); &#125; class Inc implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;100;i++)&#123; inc(); &#125; &#125; &#125; class Dec implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;100;i++)&#123; dec(); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2017%2F04%2F30%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 多线程概述1.1 多线程引入 由上图中程序的调用流程可知，这个程序只有一个执行流程，所以这样的程序就是单线程程序。假如一个程序有多条执行流程，那么，该程序就是多线程程序。 1.2 多线程概述1.2.1 什么是进程？进程就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。 1.2.2 多进程有什么意义呢?单进程的计算机只能做一件事情，而我们现在的计算机都可以做多件事情。举例：一边玩游戏(游戏进程)，一边听音乐(音乐进程)。也就是说现在的计算机都是支持多进程的，可以在一个时间段内执行多个任务。并且呢，可以提高CPU的使用率，解决了多部分代码同时运行的问题。 其实，多个应用程序同时执行都是CPU在做着快速的切换完成的。这个切换是随机的。CPU的切换是需要花费时间的，从而导致了效率的降低。 1.2.3 什么是线程?线程是程序的执行单元，执行路径；是进程中的单个顺序控制流，是一条执行路径；一个进程如果只有一条执行路径，则称为单线程程序。一个进程如果有多条执行路径，则称为多线程程序。 1.2.4 多线程有什么意义呢?多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。程序的执行其实都是在抢CPU的资源，CPU的执行权。多个进程是在抢这个资源，而其中的某一个进程如果执行路径比较多，就会有更高的几率抢到CPU的执行权。我们是不敢保证哪一个线程能够在哪个时刻抢到，所以线程的执行有随机性。 1.2.5 什么是并行、并发呢？前者是逻辑上同时发生，指在某一个时间内同时运行多个程序；后者是物理上同时发生，指在某一个时间点同时运行多个程序。那么，我们能不能实现真正意义上的并发呢？答案是可以的，多个CPU就可以实现，不过你得知道如何调度和控制它们。 PS： 一个进程中可以有多个执行路径，称之为多线程。 一个进程中至少要有一个线程。 开启多个线程是为了同时运行多部分代码，每一个线程都有自己运行的内容，这个内容可以称为线程要执行的任务。 1.3 Java程序运行原理java 命令会启动 java 虚拟机，启动 JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。所以 main方法运行在主线程中。在此之前的所有程序都是单线程的。 思考：JVM虚拟机的启动是单线程的还是多线程的？ 答案：JVM启动时启动了多条线程，至少有两个线程可以分析的出来 执行main函数的线程，该线程的任务代码都定义在main函数中。 负责垃圾回收的线程。System类的gc方法告诉垃圾回收器调用finalize方法，但不一定立即执行。 2. 多线程的实现方案由于线程是依赖进程而存在的，所以我们应该先创建一个进程出来。而进程是由系统创建的，所以我们应该去调用系统功能创建一个进程。Java是不能直接调用系统功能的，所以，我们没有办法直接实现多线程程序。但是呢?Java可以去调用C/C++写好的程序来实现多线程程序。由C/C++去调用系统功能创建进程，然后由Java去调用这样的东西，然后提供一些类供我们使用。我们就可以实现多线程程序了。 2.1 多线程的实现方案一：继承Thread类，重写run()方法 定义一个类继承Thread类 覆盖Thread类中的run方法 直接创建Thread的子类对象创建线程 调用start方法开启线程并调用线程的任务run方法执行 12345678910111213141516171819202122232425262728293031323334package cn.itcast;//多线程的实现方案一：继承Thread类，重写run()方法//1、定义一个类继承Thread类。class MyThread extends Thread &#123; private String name; MyThread(String name) &#123; this.name = name; &#125; // 2、覆盖Thread类中的run方法。 public void run() &#123; for (int x = 0; x &lt; 5; x++) &#123; System.out.println(name + "...x=" + x + "...ThreadName=" + Thread.currentThread().getName()); &#125; &#125;&#125;class ThreadTest &#123; public static void main(String[] args) &#123; // 3、直接创建Thread的子类对象创建线程。 MyThread d1 = new MyThread("黑马程序员"); MyThread d2 = new MyThread("中关村在线"); // 4、调用start方法开启线程并调用线程的任务run方法执行。 d1.start(); d2.start(); for (int x = 0; x &lt; 5; x++) &#123; System.out.println("x = " + x + "...over..." + Thread.currentThread().getName()); &#125; &#125;&#125; 运行结果： 123456789101112131415黑马程序员...x=0...ThreadName=Thread-0中关村在线...x=0...ThreadName=Thread-1x = 0...over...main中关村在线...x=1...ThreadName=Thread-1黑马程序员...x=1...ThreadName=Thread-0中关村在线...x=2...ThreadName=Thread-1x = 1...over...main中关村在线...x=3...ThreadName=Thread-1黑马程序员...x=2...ThreadName=Thread-0中关村在线...x=4...ThreadName=Thread-1x = 2...over...mainx = 3...over...mainx = 4...over...main黑马程序员...x=3...ThreadName=Thread-0黑马程序员...x=4...ThreadName=Thread-0 2.1.2 为什么要重写run()方法？Thread类用于描述线程，线程是需要任务的。所以Thread类也有对任务的描述。这个任务就是通过Thread类中的run方法来体现。也就是说，run方法就是封装自定义线程运行任务的函数，run方法中定义的就是线程要运行的任务代码。所以只有继承Thread类，并复写run方法，将运行的代码定义在run方法中即可。 2.1.3 启动线程使用的是那个方法启动线程调用的是start()方法，不是run()方法，run()方法只是封装了被线程执行的代码，调用run()只是普通方法的调用，无法启动线程。 2.1.4 线程能不能多次启动不能，会出现IllegalThreadStateException非法的线程状态异常。 2.1.5 run()和start()方法的区别 run()：仅仅是封装了被线程执行的代码，直接调用就是普通方法 start()：首先是启动了线程，然后再由jvm去调用了该线程的run()方法 2.1.6 Thread类的基本获取和设置方法 public final String getName()：获取线程的名称 public final void setName(String name)：设置线程的名称 Thread(String name) ：通过构造方法给线程起名字 思考：如何获取main方法所在的线程名称呢? 1public static Thread currentThread() // 获取任意方法所在的线程名称 2.2 多线程的实现方案二：实现Runnable接口 定义类实现Runnable接口 覆盖接口中的run方法，将线程的任务代码封装到run方法中 通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。为什么？因为线程的任务都封装在Runnable接口子类对象的run方法中。所以要在线程对象创建时就必须明确要运行的任务 调用线程对象的start方法开启线程 12345678910111213141516171819202122232425262728package cn.itcast;//多线程的实现方案二：实现Runnable接口//1、定义类实现Runnable接口。class MyThread implements Runnable &#123; // 2、覆盖接口中的run方法，将线程的任务代码封装到run方法中。 public void run() &#123; show(); &#125; public void show() &#123; for (int x = 0; x &lt; 5; x++) &#123; System.out.println(Thread.currentThread().getName() + "..." + x); &#125; &#125;&#125;class ThreadTest &#123; public static void main(String[] args) &#123; MyThread d = new MyThread(); // 3、通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。 Thread t1 = new Thread(d); Thread t2 = new Thread(d); // 4、调用线程对象的start方法开启线程。 t1.start(); t2.start(); &#125;&#125; 运行结果： 12345678910Thread-0...0Thread-1...0Thread-0...1Thread-1...1Thread-0...2Thread-1...2Thread-0...3Thread-1...3Thread-0...4Thread-1...4 如何获取线程名称：Thread.currentThread().getName() 如何给线程设置名称：setName()、Thread(Runnable target, String name) 实现接口方式的好处： 可以避免由于Java单继承带来的局限性，所以，创建线程的第二种方式较为常用。 适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。 2.3 多线程程序实现方案三：实现Callable接口 创建一个线程池对象，控制要创建几个线程对象。 1public static ExecutorService newFixedThreadPool(int nThreads) 这种线程池的线程可以执行：可以执行Runnable对象或者Callable对象代表的线程。 调用如下方法即可 Future&lt;?&gt; submit(Runnable task)提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future Future submit(Callable task)提交一个Callable任务用于执行，返回一个表示任务的未决结果的 Future 结束线程：shutdown() 关闭线程池 123456789101112131415161718192021222324252627282930313233343536373839package cn.itcast;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Callable;//Callable:是带泛型的接口。//这里指定的泛型其实是call()方法的返回值类型。class MyCallable implements Callable &#123; public Object call() throws Exception &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(Thread.currentThread().getName() + ":" + x); &#125; return null; &#125;&#125;/* * 多线程实现的方式3： A:创建一个线程池对象，控制要创建几个线程对象。 public static ExecutorService * newFixedThreadPool(int nThreads) B:这种线程池的线程可以执行： * 可以执行Runnable对象或者Callable对象代表的线程 做一个类实现Runnable接口。 C:调用如下方法即可 Future&lt;?&gt; * submit(Runnable task) &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) D:我就要结束，可以吗? 可以。 */public class CallableDemo &#123; public static void main(String[] args) &#123; // 创建线程池对象 ExecutorService pool = Executors.newFixedThreadPool(2); // 可以执行Runnable对象或者Callable对象代表的线程 pool.submit(new MyCallable()); pool.submit(new MyCallable()); // 结束 pool.shutdown(); &#125;&#125; 运行结果： 实现Callable的优缺点 好处：可以有返回值；可以抛出异常。 弊端：代码比较复杂，所以一般不用 2.4 匿名内部类方式使用多线程12345678910111213141516//新创建一个线程，重写run()方法new Thread() &#123; @Override public void run() &#123; super.run(); // code &#125;&#125;.start();//新创建一个线程，传递一个Runnable对象new Thread(new Runnable() &#123; @Override public void run() &#123; // code &#125;&#125;).start(); 3. 线程调度和线程控制3.1 线程调度假如我们的计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到 CPU时间片，也就是使用权，才可以执行指令。那么Java是如何对线程进行调用的呢？ 3.1.1 线程有两种调度模型分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 Java使用的是抢占式调度模型。 3.1.2 如何设置和获取线程优先级12public final int getPriority(); //获取线程的优先级public final void setPriority(int newPriority); //设置线程的优先级 注意：线程默认的优先级是5；线程优先级的范围是：1-10；线程优先级高仅仅表示线程获取CPU的时间片的几率高，但是要在次数比较多，或者多次运行的时候才能卡到比较好的结果。 3.2 线程控制 方法声明 功能描述 sleep(long millis) 线程休眠，让当前线程暂停，进入休眠等待状态 join() 线程加入，调用该方法的线程会插入优先先执行 yield() 线程礼让，暂停当前正在执行的线程对象，并执行其他线程。 setDaemon(boolean on) 将该线程标记为守护线程（后台线程）或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 stop() 让线程停止，过时了，但是还可以使用 interrupt() 中断线程。 把线程的状态终止，并抛出一个InterruptedException。 setPriority(int newPriority) 更改线程的优先级 isInterrupted() 线程是否被中断 4. 线程的生命周期4.1 线程的状态 线程状态 状态说明 新建状态 等待状态，调用start()方法启动 就绪状态 有执行资格，但是没有执行权 运行状态 具有执行资格和执行权 阻塞状态 遇到sleep()方法和wait()方法时，失去执行资格和执行权，sleep()方法时间到或者调用notify()方法时，获取执行资格，变为临时状态 死亡状态 中断线程，或者run()方法结束 4.2 线程的生命周期图 5. 线程安全问题5.1 判断一个程序是否会有线程安全问题的标准 是否是多线程环境 是否有共享数据 是否有多条语句操作共享数据 5.2 如何解决多线程安全问题呢?基本思想：让程序没有安全问题的环境。解决办法：同步机制：同步代码块、同步方法。把多个语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可。 5.2.1 解决线程安全问题实现1：同步代码块，格式如下123synchronized(对象)&#123; 需要同步的代码;&#125; 123456789101112131415161718192021222324252627282930313233343536package cn.itcast;//卖票程序的同步代码块实现示例class Ticket implements Runnable &#123; private int num = 10; Object obj = new Object(); public void run() &#123; while (true) &#123; // 给可能出现问题的代码加锁 synchronized (obj) &#123; if (num &gt; 0) &#123; // 显示线程名及余票数 System.out.println(Thread.currentThread().getName() + "...sale..." + num--); &#125; &#125; &#125; &#125;&#125;class TicketDemo &#123; public static void main(String[] args) &#123; // 通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。 Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); // 调用线程对象的start方法开启线程。 t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 运行结果： 12345678910Thread-0...sale...10Thread-0...sale...9Thread-0...sale...8Thread-0...sale...7Thread-0...sale...6Thread-0...sale...5Thread-0...sale...4Thread-0...sale...3Thread-0...sale...2Thread-0...sale...1 同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。 同步代码块的对象可以是哪些呢? 可以是任意对象，但每个线程都必须是同一对象。 同步的前提：多个线程；多个线程使用的是同一个锁对象 同步的好处：同步的出现解决了多线程的安全问题。 同步的弊端：当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。 5.3 解决线程安全问题实现2：同步方法同步方法：就是把同步关键字加到方法上 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.itcast;//卖票程序的同步代码块实现示例class Ticket implements Runnable &#123; // 定义100张票 private static int tickets = 10; Object obj = new Object(); public void run() &#123; while (true) &#123; sellTicket(); &#125; &#125; private synchronized void sellTicket() &#123; if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票 "); &#125; &#125;&#125;class TicketDemo &#123; public static void main(String[] args) &#123; // 通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。 Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); // 调用线程对象的start方法开启线程。 t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 运行结果： 12345678910Thread-0正在出售第10张票 Thread-0正在出售第9张票 Thread-0正在出售第8张票 Thread-3正在出售第7张票 Thread-3正在出售第6张票 Thread-3正在出售第5张票 Thread-3正在出售第4张票 Thread-3正在出售第3张票 Thread-3正在出售第2张票 Thread-3正在出售第1张票 PS： 同步方法的锁对象是什么呢?this对象 如果是静态方法，同步方法的锁对象又是什么呢?该类的字节码文件（类的class文件） 那么，我们到底使用同步方法还是同步代码块？ 如果锁对象是this，就可以考虑使用同步方法。否则能使用同步代码块的尽量使用同步代码块。 5.3.1 线程安全与非线程安全的类某些线程安全的类：StringBuffer、Vector、HashTable，虽然线程安全，但是效率较低，我们一般不用，而用Collections工具类解决线程安全的问题。 1List&lt;String&gt; list = Colletions.syncrinizedList(new ArrayList&lt;String&gt;()); // 获取线程安全的List集合 5.3.2 JDK5中Lock锁的使用虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock Lock接口：Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作，此实现允许更灵活的结构。 void lock()：获取锁 void unlock()：释放锁 ReentrantLock：Lock的实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.itcast;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class SellTicket implements Runnable &#123; // 定义票 private int tickets = 100; // 定义锁对象 private Lock lock = new ReentrantLock(); public void run() &#123; while (true) &#123; try &#123; // 加锁 lock.lock(); if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票"); &#125; &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; &#125;&#125;/* * 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁， * 为了更清晰的表达如何加锁和释放锁,JDK5以后提供了一个新的锁对象Lock。 * * Lock： void lock()： 获取锁。 void unlock():释放锁。 ReentrantLock是Lock的实现类. */public class SellTicketDemo &#123; public static void main(String[] args) &#123; // 创建资源对象 SellTicket st = new SellTicket(); // 创建三个窗口 Thread t1 = new Thread(st, "窗口1"); Thread t2 = new Thread(st, "窗口2"); Thread t3 = new Thread(st, "窗口3"); // 启动线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果： 12345678910111213141516...窗口2正在出售第15张票窗口2正在出售第14张票窗口2正在出售第13张票窗口2正在出售第12张票窗口2正在出售第11张票窗口3正在出售第10张票窗口3正在出售第9张票窗口3正在出售第8张票窗口3正在出售第7张票窗口3正在出售第6张票窗口3正在出售第5张票窗口3正在出售第4张票窗口3正在出售第3张票窗口1正在出售第2张票窗口2正在出售第1张票 6. 死锁同步弊端：效率低，如果出现了同步嵌套，就容易产生死锁问题。死锁问题：是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.itcast;class Ticket implements Runnable &#123; private static int num = 100; Object obj = new Object(); boolean flag = true; public void run() &#123; if (flag) &#123; while (true) &#123; synchronized (obj) &#123; show(); &#125; &#125; &#125; else while (true) show(); &#125; public synchronized void show() &#123; synchronized (obj) &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "...function..." + num--); &#125; &#125; &#125;&#125;class DeadLockDemo &#123; public static void main(String[] args) &#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t.flag = false; t2.start(); &#125;&#125; 运行结果： 原因分析： 由上图可以看到程序已经被锁死，无法向下执行。run方法中的同步代码块需要获取obj对象锁，才能执行代码块中的show方法。而执行show方法则必须获取this对象锁，然后才能执行其中的同步代码块。当线程t1获取到obj对象锁执行同步代码块，线程t2获取到this对象锁执行show方法。同步代码块中的show方法因无法获取到this对象锁无法执行，show方法中的同步代码块因无法获取到obj对象锁无法执行，就会产生死锁。 7. 线程间通信多个线程在处理统一资源，但是任务却不同，这时候就需要线程间通信。为了实现线程间的通信Java提供了等待唤醒机制。等待/唤醒机制涉及的方法： wait()：让线程处于冻结状态，被wait的线程会被存储到线程池中。 notify()：唤醒线程池中的一个线程（任何一个都有可能）。 notifyAll()：唤醒线程池中的所有线程。 PS： 这些方法都必须定义在同步中，因为这些方法是用于操作线程状态的方法。 必须要明确到底操作的是哪个锁上的线程！ wait和sleep区别？ 4、为什么操作线程的方法wait、notify、notifyAll定义在了object类中，因为这些方法是监视器的方法，监视器其实就是锁。锁可以是任意的对象，任意的对象调用的方式一定在object类中。 5、生产者-消费者问题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package cn.itcast;class Student &#123; String name; int age; boolean flag;&#125;class SetThread implements Runnable &#123; private Student s; private int x = 0; public SetThread(Student s) &#123; this.s = s; &#125; public void run() &#123; while (true) &#123; synchronized (s) &#123; // 判断有没有 if (s.flag) &#123; try &#123; s.wait(); // t1等着，释放锁 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (x % 2 == 0) &#123; s.name = "张三"; s.age = 15; &#125; else &#123; s.name = "李四"; s.age = 16; &#125; x++; // x=1 // 修改标记 s.flag = true; // 唤醒线程 s.notify(); // 唤醒t2,唤醒并不表示你立马可以执行，必须还得抢CPU的执行权。 &#125; // t1有，或者t2有 &#125; &#125;&#125;class GetThread implements Runnable &#123; private Student s; public GetThread(Student s) &#123; this.s = s; &#125; public void run() &#123; while (true) &#123; synchronized (s) &#123; if (!s.flag) &#123; try &#123; s.wait(); // t2就等待了。立即释放锁。将来醒过来的时候，是从这里醒过来的时候 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(s.name + "---" + s.age); // 林青霞---27 // 刘意---30 // 修改标记 s.flag = false; // 唤醒线程 s.notify(); // 唤醒t1 &#125; &#125; &#125;&#125;public class StudentDemo &#123; public static void main(String[] args) &#123; // 创建资源 Student s = new Student(); // 设置和获取的类 SetThread st = new SetThread(s); GetThread gt = new GetThread(s); // 线程类 Thread t1 = new Thread(st); Thread t2 = new Thread(gt); // 启动线程 t1.start(); t2.start(); &#125;&#125; 运行结果： 8. 线程组 Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。默认情况下，所有的线程都属于主线程组。 123public final ThreadGroup getThreadGroup() //返回该线程所属的线程组。Thread(ThreadGroup group,Runnable target, String name) // 给线程设置分组 9. 线程池程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。 线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。 在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池。JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法 返回值 方法声明 功能描述 ExecutorService newCachedThreadPool() 创建一个可缓存的线程池对象 ExecutorService newFixedThreadPool(int) 创建一个固定大小的线程池对象 ExecutorService newSingleThreadExecutor() 创建一个单线程的线程池对象 ExecutorService newScheduledThreadPool() 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法： Future&lt;?&gt; submit(Runnable task) 提交一个Runnable任务用于执行，并返回一个表示该任务的 Future &lt;T&gt;Future&lt;T&gt; submit(Callable&lt;T&gt; task) 提交一个Callable任务用于执行，返回一个表示任务的未决结果的Future 10. 定时器的使用定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行。在Java中，可以通过Timer和TimerTask类来实现定义调度的功能 Timer定时类一种工具，线程用其安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行 方法声明 功能描述 public Timer() 构造方法 public void schedule(TimerTask task, long delay) 安排在指定延迟后执行指定的任务 public void schedule(TimerTask task,long delay,long period) 安排指定的任务从指定的延迟后开始进行重复的固定延迟执行 TimerTask任务类，有Timer安排为一次执行或重复执行的任务 方法声明 功能描述 public abstract void run() 此计时器任务要执行的操作 public boolean cancel() 取消此计时器任务 实际开发中使用的是Quartz：一个完全由java编写的开源调度框架。 11. 多线程总结11.1 三种多选实现方案 继承Thread类，重写run()方法。 实现Runnable接口，new Thread(new Runnable(){…}){…}; 实现Callable接口。和线程池结合。 11.2 实现Runnable好处 将线程的任务从线程的子类中分离出来，进行了单独的封装，实现数据和程序分离，按照面向对象的思想将任务封装成对象 避免了Java单继承的局限性。所以，创建线程的第二种方式较为常用 11.3 线程间的通信 多个线程在处理同一资源，但是任务却不同，这时候就需要线程间通信。 等待/唤醒机制涉及的方法 wait()：让线程处于冻结状态，被wait的线程会被存储到线程池中。 notify()：唤醒线程池中的一个线程（任何一个都有可能）。 notifyAll()：唤醒线程池中的所有线程。 11.4 wait、sleep区别 wait可以指定时间也可以不指定。sleep必须指定时间。 在同步中时，对CPU的执行权和锁的处理不同。 wait：释放CPU执行权，释放锁。Object中的方法。 sleep：释放CPU执行权，不释放锁。Thread中的方法。 sleep必需捕获异常，wait，notify，notifyAll不需要捕获异常 11.5 常用方法 方法声明 功能描述 String getName() 获取线程的名称 void setName(String name) 设置线程的名称 static Thread currentThread() 获取当前正在执行的线程 int getPriority() 获取线程优先级 void setPriority(int newPriority) 设置线程优先级（1-10） static void sleep(long millis) 线程休眠 void join() 线程加入，该线程执行完毕其他线程才可以执行 static void yield() 线程礼让 setDaemon(boolean on) 后台线程/守护线程 void stop( ) 已过时，不建议使用 interrupt( ) 中断线程 isInterrupted() 线程是否被中断 11.6 线程的生命周期 新建，就绪，运行，阻塞（同步阻塞，等待阻塞，其他阻塞），死亡]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程锁技术]]></title>
    <url>%2F2017%2F04%2F30%2F%E7%BA%BF%E7%A8%8B%E9%94%81%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[笔记摘要这里介绍了java5中的线程锁技术：Lock和Condition，实现线程间的通信，其中的读锁和写锁的使用通过一个缓存系统进行了演示，对于Condition的应用通过一个阻塞队列进行演示。 线程锁技术：Lock &amp; Condition 实现线程同步通信所属包：java.util.concurrent.locks 线程锁 说明 Synchronized 同步方法，锁对象是this；静态同步方法，锁对象是字节码.class；同步代码块，锁对象是任意对象，但必须是同一个对象 Lock 同步锁接口 ReentrantLock lock()，unlock()，newCondition() ReadWriteLock 读写锁接口 ReentrantReadWriteLock readLock()获取读锁，writeLock()获取写锁 Condition 线程间通信 await()等待 signal()唤醒 1. LockLock比传统线程模型中的synchronized方式更加面向对象，相对于synchronized 方法和语句它具有更广泛的锁定操作，此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的 Condition 对象。 于现实生活中类似，锁本身也是一个对象。两个线程执行的代码片段要实现同步互斥的结果，它们必须用同一个Lock对象，锁是上在代表要操作的资源的类的内部方法中，而不是线程代码中。 读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，写锁与写锁互斥，这是由JVM自己控制的。你只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！ 读写锁的使用情景： 如果代码只读数据，就可以很多人共同读取，但不能同时写。 如果代码修改数据，只能有一个人在写，且不能同时读数据。 API中ReentrantReadWriteLock类提供的一个读写锁缓存示例： 12345678910111213141516171819202122232425262728293031323334353637class CachedData &#123; Object data; volatile boolean cacheValid; ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); void processCachedData() &#123; rwl.readLock().lock(); if (!cacheValid) &#123; // Must release read lock before acquiring write lock rwl.readLock().unlock(); rwl.writeLock().lock(); // Recheck state because another thread might have acquired // write lock and changed state before we did. if (!cacheValid) &#123; data = ... cacheValid = true; &#125; // Downgrade by acquiring read lock before releasing write lock rwl.readLock().lock(); rwl.writeLock().unlock(); // Unlock write, still hold read &#125; use(data); rwl.readLock().unlock(); &#125; &#125; 读写锁的应用：编写一个缓存系统 注解：为了避免线程的安全问题，synchronized和ReadWriteLock都可以，synchronized也防止了并发读取，性能较低有一个线程先进去，开始读取数据，进行判断，发现没有数据，其他线程就没有必要进去了，就释放读锁，加上写锁，去查找数据写入，为了避免写入的其他对象等待，再做一次判断，数据写入完成后，释放写锁，上读锁，防止写入，还原原来的状态。 两次判断：第一次为了写入数据，所以释放读锁，上写锁。第二次为了防止阻塞的线程重复写入 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class CacheDemo &#123; //定义一个map用于缓存对象 private Map&lt;String, Object&gt; cache = new HashMap&lt;String, Object&gt;(); //获取一个读写锁对象 private ReadWriteLock rwl = new ReentrantReadWriteLock(); //带有缓存的获取指定值的方法 public Object getData(String key)&#123; rwl.readLock().lock(); //上读锁 Object value = null; try&#123; value = cache.get(key); //获取要查询的值 if(value == null)&#123; //线程出现安全问题的地方 rwl.readLock().unlock(); //没有数据，释放读锁，上写锁 // 多个线程去上写锁，第一个上成功后，其他线程阻塞，第一个线程开始执行下面的代码，最后 // 释放写锁后，后面的线程继续上写锁，为了避免后面的线程重复写入，进行二次判断 rwl.writeLock().lock(); try&#123; if(value==null)&#123; //二次判断，防止其他线程重复写数据 value = "aaaa"; //实际是去查询数据库 &#125; &#125;finally&#123; rwl.writeLock().unlock(); //写完数据，释放写锁 &#125; rwl.readLock().lock(); //恢复读锁 &#125; &#125;finally&#123; rwl.readLock().unlock(); //最终释放读锁 &#125; return value; //返回获取到的值 &#125; &#125; 虚假唤醒：用while代替if 1234567Lock lock = new ReentrantLock();try &#123; lock.lock(); //需要加锁的代码&#125;finally &#123; lock.unlock();&#125; 读写锁测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; final Queue3 q3 = new Queue3(); for(int i=0;i&lt;3;i++) &#123; new Thread()&#123; public void run()&#123; while(true)&#123; q3.get(); &#125; &#125; &#125;.start(); new Thread()&#123; public void run()&#123; while(true)&#123; q3.put(new Random().nextInt(10000)); &#125; &#125; &#125;.start(); &#125; &#125;&#125;class Queue3&#123; private Object data = null;ReadWriteLock rwl = new ReentrantReadWriteLock(); public void get()&#123; rwl.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + " be ready to read data!"); Thread.sleep((long)(Math.random()*1000)); System.out.println(Thread.currentThread().getName() + "have read data :" + data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; rwl.readLock().unlock(); &#125; &#125; public void put(Object data)&#123; rwl.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + " be ready to write data!"); Thread.sleep((long)(Math.random()*1000)); this.data = data; System.out.println(Thread.currentThread().getName() + " have write data: " + data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; rwl.writeLock().unlock(); &#125; &#125;&#125; 123456789101112131415161718Thread-0 be ready to read data!Thread-2 be ready to read data!Thread-4 be ready to read data!Thread-0have read data :nullThread-2have read data :nullThread-4have read data :nullThread-5 be ready to write data!Thread-5 have write data: 7975Thread-5 be ready to write data!Thread-5 have write data: 9832Thread-3 be ready to write data!Thread-3 have write data: 2813Thread-3 be ready to write data!Thread-3 have write data: 7998Thread-1 be ready to write data!Thread-1 have write data: 6737Thread-1 be ready to write data!... 2. ConditionCondition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法wait和notify的使用 一个锁内部可以有多个Condition，即有多路等待通知，传统的线程机制中一个监视器对象上只能有一路等待和通知，要想实现多路等待和通知，必须嵌套使用多个同步监视器对象。使用一个监视器往往会产生顾此失彼的情况。 在等待 Condition 时，允许发生“虚假唤醒”，这通常作为对基础平台语义的让步。对于大多数应用程序，这带来的实际影响很小，因为 Condition 应该总是在一个循环中被等待，并测试正被等待的状态声明。某个实现可以随意移除可能的虚假唤醒，但建议应用程序程序员总是假定这些虚假唤醒可能发生，因此总是在一个循环中等待。 Condition的应用：阻塞队列（使用了两个监视器） 说明：该应用是 java.util.concurrent.locks包中Condition接口中的示例代码。使用了两个Condition分别用于管理取数据的线程，和存数据的线程，这样就可以明确的唤醒需要的一类线程，如果使用一个Condition，当队列满了之后，唤醒的并不一定就是取数据的线程 1234567891011121314151617181920212223242526272829303132333435363738class BoundedBuffer &#123; final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) //循环判断队列是否已存满 notFull.await(); //如果队列存满了，则要存入数据的线程等待 items[putptr] = x; if (++putptr == items.length) putptr = 0;//当队列放满，指针回到0 ++count; //添加了一个数据 notEmpty.signal(); //队列中有数据了，所以就唤醒取数据的线程 &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) //循环判断，队列是否有空位 notEmpty.await(); //要取的线程等待 Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; //取走一个，说明队列有空闲的位置， notFull.signal(); //所以通知存入的线程 return x; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; Condition测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ConditionCommunication &#123; public static void main(String[] args) &#123; final Business business = new Business(); new Thread( new Runnable() &#123; @Override public void run() &#123; for(int i=1;i&lt;=5;i++)&#123; business.sub(i); &#125; &#125; &#125; ).start(); for(int i=1;i&lt;=5;i++)&#123; business.main(i); &#125; &#125; class Business &#123; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); private boolean bShouldSub = true; public void sub(int i)&#123; lock.lock(); try&#123; while(!bShouldSub)&#123; try &#123; condition.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=2;j++)&#123; System.out.println("sub thread sequence of " + j + ",loop of " + i); &#125; bShouldSub = false; condition.signal(); &#125;finally&#123; lock.unlock(); &#125; &#125; public void main(int i)&#123; lock.lock(); try&#123; while(bShouldSub)&#123; try &#123; condition.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=4;j++)&#123; System.out.println("main thread sequence of " + j + ",loop of " + i); &#125; bShouldSub = true; condition.signal(); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125;&#125; 输出结果 123456789101112131415161718192021222324252627282930sub thread sequence of 1,loop of 1sub thread sequence of 2,loop of 1main thread sequence of 1,loop of 1main thread sequence of 2,loop of 1main thread sequence of 3,loop of 1main thread sequence of 4,loop of 1sub thread sequence of 1,loop of 2sub thread sequence of 2,loop of 2main thread sequence of 1,loop of 2main thread sequence of 2,loop of 2main thread sequence of 3,loop of 2main thread sequence of 4,loop of 2sub thread sequence of 1,loop of 3sub thread sequence of 2,loop of 3main thread sequence of 1,loop of 3main thread sequence of 2,loop of 3main thread sequence of 3,loop of 3main thread sequence of 4,loop of 3sub thread sequence of 1,loop of 4sub thread sequence of 2,loop of 4main thread sequence of 1,loop of 4main thread sequence of 2,loop of 4main thread sequence of 3,loop of 4main thread sequence of 4,loop of 4sub thread sequence of 1,loop of 5sub thread sequence of 2,loop of 5main thread sequence of 1,loop of 5main thread sequence of 2,loop of 5main thread sequence of 3,loop of 5main thread sequence of 4,loop of 5 3. Condition练习一共有3个线程，两个子线程先后循环2次，接着主线程循环3次，接着又回到两 个子线程先后循环2次，再回到主线程又循环3次，如此循环5次。 思路：老二先执行，执行完唤醒老三，老三执行完唤醒老大，老大执行完唤醒老二，以此循环，所以定义3个Condition对象和一个执行标识即可 示例出现的问题：两个文件中有同名类的情况 解决方案：可以将一个文件中的那个同名外部类放进类中，但是静态不能创建内部类的实例对象，所以需要加上static，这样两个类的名称就不一样了。 一个是原来的类名，一个是在自己类名前面加上外部类的类名。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ThreeConditionCommunication &#123; public static void main(String[] args)&#123; final Business business = new Business(); //创建并启动子线程老二 new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=1;i&lt;=5;i++)&#123; business.sub2(i); &#125; &#125; &#125;).start(); //创建并启动子线程老三 new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=1;i&lt;=5;i++)&#123; business.sub3(i); &#125; &#125; &#125;).start(); //主线程 for(int i=1;i&lt;=5;i++)&#123; business.main(i); &#125; &#125; static class Business&#123; Lock lock = new ReentrantLock(); Condition condition1 = lock.newCondition(); Condition condition2 = lock.newCondition(); Condition condition3 = lock.newCondition(); //定义一个变量来决定线程的执行权 private int ShouldSub = 1; public void sub2(int i)&#123; //上锁，不让其他线程执行 lock.lock(); try&#123; if(ShouldSub != 2)&#123; //如果不该老二执行，就等待 try &#123; condition2.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=2;j++)&#123; System.out.println("sub thread sequence of"+i+",loop of "+j); &#125; ShouldSub = 3; //准备让老三执行 condition3.signal(); //唤醒老三 &#125;finally&#123; lock.unlock(); &#125; &#125; public void sub3(int i)&#123; lock.lock(); try&#123; if(ShouldSub != 3)&#123; try &#123; condition3.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=2;j++)&#123; System.out.println("sub2 thread sequence of"+i+",loop of "+j); &#125; ShouldSub = 1; //准备让老大执行 condition1.signal(); //唤醒老大 &#125;finally&#123; lock.unlock(); &#125; &#125; //主线程 public void main(int i)&#123; lock.lock(); try&#123; if(ShouldSub!=1)&#123; try &#123; condition1.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=3;j++)&#123; System.out.println("main thread sequence of"+i+", loop of "+j); &#125; ShouldSub = 2; //准备让老二执行 condition2.signal(); //唤醒老二 &#125;finally&#123; lock.unlock(); &#125; &#125; &#125; &#125; 输出结果1234567891011121314151617181920212223242526272829303132333435main thread sequence of1, loop of 1main thread sequence of1, loop of 2main thread sequence of1, loop of 3sub thread sequence of1,loop of 1sub thread sequence of1,loop of 2sub2 thread sequence of1,loop of 1sub2 thread sequence of1,loop of 2main thread sequence of2, loop of 1main thread sequence of2, loop of 2main thread sequence of2, loop of 3sub thread sequence of2,loop of 1sub thread sequence of2,loop of 2sub2 thread sequence of2,loop of 1sub2 thread sequence of2,loop of 2main thread sequence of3, loop of 1main thread sequence of3, loop of 2main thread sequence of3, loop of 3sub thread sequence of3,loop of 1sub thread sequence of3,loop of 2sub2 thread sequence of3,loop of 1sub2 thread sequence of3,loop of 2main thread sequence of4, loop of 1main thread sequence of4, loop of 2main thread sequence of4, loop of 3sub thread sequence of4,loop of 1sub thread sequence of4,loop of 2sub2 thread sequence of4,loop of 1sub2 thread sequence of4,loop of 2main thread sequence of5, loop of 1main thread sequence of5, loop of 2main thread sequence of5, loop of 3sub thread sequence of5,loop of 1sub thread sequence of5,loop of 2sub2 thread sequence of5,loop of 1sub2 thread sequence of5,loop of 2 多路等待和通知12345678910111213141516171819202122232425262728293031323334353637class BoundedBuffer &#123; final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) notEmpty.await(); Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; notFull.signal(); return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时器、互斥、同步通信技术]]></title>
    <url>%2F2017%2F04%2F30%2F%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%81%E4%BA%92%E6%96%A5%E3%80%81%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[笔记摘要这里分析了多线程的一些细节问题，并介绍了传统定时器的创建，同时实现了根据自己的调度计划的自定义定时器，对于传统互斥技术中发现的内部类问题，进行了分析，最后对于同步通信技术，是重点，分析了如何处理类似的问题，如何设计能够更加清晰简单，体现了高内聚和程序的健壮性 1. 多线程的几个知识点1.1 为何使用实现Runnable的方式创建线程更普遍？new Runnable()的方式，更加体现面向对象的思想 通过 new Thread()创建一个线程，代码封装在runnable对象中，代码和线程独立分开来，但最终将它们组合在一起。 1234567Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; // code &#125;&#125;); 1.2 获取线程名的时候，应使用currentThread().getName()方式因为this.getName()方式，只有在当前对象是Thread的时候可以，当我们使用runnable方式时，this代表的是runnable对象，它仅是要运行代码的宿主，而不是线程，当然编译也无法通过（没有此方法）。 1.3 创建线程的两种传统方式的run方法执行问题查看Thread类的run()方法的源代码，可以看到其实这两种方式都是在调用Thread对象的run()方法，如果Thread类的run()方法没有被覆盖，并且为该Thread对象设置了一个Runnable对象，该run方法会调用Runnable对象的run()方法。 下面是Thread类的run()方法的源码，可以看到runnable对象也是调用了Thread的run()方法。 当runnable对象不为null，并且有自己的run()方法，则执行自己的，如果target为null，则Thread类的run()方法什么也不执行，所以我们在创建线程的时候不直接创建Thread对象，而是创建其子类对象，目的是为了复写run方法，把要执行的代码放进去，否则该线程没有意义 123456Private Runnable target; public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 1.4 多线程的运行问题1：如果在Thread子类覆盖的run()方法中编写了运行代码，也为Thread子类对象传递了一个Runnable对象，那么，线程运行时的执行代码？ 是子类的run方法的代码？还是Runnable对象的run()方法的代码？如： 123456789101112// 匿名内部类的方式实现的一个子类，并在构造方法中传入了一个Runnable对象new Thread(new Runnable() &#123; public void run() &#123; // code &#125;&#125;) &#123; @Override public void run() &#123; super.run(); // code &#125;&#125;.start(); 会运行子类的run方法。因为当某个对象调用start方法之后，就会去找自己对象的run方法，如果没有就会找父类的run方法，父类的run方法会找runnable运行。 其实就是多态的一种体现，覆盖了父类的就执行自己的，没有覆盖就去找父类的执行 问题2：多线程机制是否会提高程序的运行效率？ 多线程机制并不会提高程序的运行效率，反而性能更低，因为CPU需要在不同线程之间频繁切换。 1.5 多线程下载的误解？多线程下载其实是抢了服务器的带宽，一个线程代表一个用户，每个线程分配的带宽是相等的，开启的线程多，就会分配更多的带宽，是在抢资源，而不是自己更快。 2. 传统定时器：Timer类定时器有两种：一种在指定时间只执行一次，另一种先在指定时间执行一次，之后每隔指定时间循环执行。 该示例说明了定时器的创建方式，并通过自定义定时器的方式，在一个定时器内部通过不同切换秒数，来实现在不同的间隔时间实现循环爆炸，另外还通过两个类之间的互相实现相同的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Date; import java.util.Timer; import java.util.TimerTask; public class TraditionalTimerTest &#123; private static int count = 0; public static void main(String[] args) &#123; //创建一个定时器并调度任务 /* new Timer().schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println("bombing!"); &#125; &#125;, 3000);//3秒以后爆炸 */ //&#125;, 10000,3000); //10秒以后爆炸，以后每隔3秒炸一次 //自定义一个定时器 class MyTimerTask extends TimerTask&#123; @Override public void run() &#123; count = (count+1)%2; //在0和1之间切换 System.out.println("bombing!"); new Timer().schedule(/*new TimerTask() &#123; @Override public void run() &#123; System.out.println("bombing!"); &#125; &#125;*/new MyTimerTask(),2000+2000*count); //实现循环，不能用this，因为是匿名，所以只能执行一次， //就像炸弹一样，炸完后就没有了，必须布置新的炸弹 //所以创建一个类，每次在最后new一个新的炸弹 &#125; &#125; //开启定时器，每隔2秒调用一次MyTimerTask new Timer().schedule(new MyTimerTask(), 2000); //为了观察定时器任务的执行：每隔1秒打印一次当前秒数 while(true)&#123; System.out.println(new Date().getSeconds()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; 使用互相调用的方式实现间隔2秒和4秒的连环爆炸123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Date; import java.util.Timer; import java.util.TimerTask; public class MyTraditionalTimer &#123; public static void main(String[] args)&#123; new Timer().schedule(new MyTimerTask(), 4000); //打印当前秒数 while(true)&#123; System.out.println(new Date().getSeconds()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; //每隔2秒调用MyTimerTask2 class MyTimerTask extends TimerTask&#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println("boomping!!!"); new Timer().schedule(new MyTimerTask2(),2000); &#125; &#125; //每隔4秒调用MyTimerTask2 class MyTimerTask2 extends TimerTask&#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println("boomping!!!"); new Timer().schedule(new MyTimerTask(), 4000); &#125; &#125; 3. 调度框架：quartsQuartz是一个开源的作业调度框架，它完全由Java写成，并设计用于J2SE和J2EE应用中。它提供了巨大的灵活性而不牺牲简单性。你能够用它来为执行一个作业而创建简单的或复杂的调度。它有很多特征，如：数据库支持，集群，插件，EJB作业预构建，JavaMail及其它，支持cron-like表达式等等。 对于定时器中不能很好实现的需求，我们可以想到quarts,这里并没有介绍其使用方式，以后开发用到，能够记起，去查资料 4. 传统线程互斥技术发现的问题：在主函数内部不能创建内部类的实例对象 内部类的一个重要特点就是可以访问外部类的成员变量，成员变量是对象身上的，对象创建完后，成员变量才分配空间，所以内部类访问外部类的成员变量需要外部类的实例对象。而静态方法先存在，所以不可以。 解决方式： 可以将内部类定义为静态的，或者将创建内部类的实例对象的语句封装在一个外部类的成员方法中，这里定义了一个init方法，因为方法调用需要对象，这个对象就是将来调用该方法的对象 示例说明： 本示例主要是对上面的问题进行了展示，另外对过去的互斥技术中的锁所使用的对象进行了分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class TraditionalThreadSychronized &#123; public static void main(String[] args) &#123; //无法创建，必须关联一个外部类的实例对象，可以定义一个方法， //或者将外部类定义为静态 //final Outputer outputer = new Outputer(); //编译错误 new TraditionalThreadSychronized().init(); &#125; //方法需要对象调用，所以就关联了一个外部类的对象 private void init() &#123; final Outputer outputer = new Outputer(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; outputer.output("11111"); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // outputer.output("are you happy?"); outputer.output2("22222"); &#125; &#125; &#125;).start(); &#125; static class Outputer &#123; // public void output(String name) &#123; // String lock = ""; int len = name.length(); // synchronized(lock)&#123; 使用同一把锁，任意对象都可以 // synchronized(this)&#123; 同步函数使用的是锁是this，即outputer对象 synchronized (Outputer.class) &#123; // 静态方法的锁只能是class字节码对象 for (int i = 0; i &lt; len; i++) &#123; System.out.print(name.charAt(i)); &#125; System.out.println(); &#125; &#125; // 同步函数使用的是锁是this /* public synchronized void output2(String name)&#123; int len = name.length(); for(int i=0;i&lt;len;i++)&#123; System.out.print(name.charAt(i)); &#125; System.out.println(); &#125; &#125; */ //定义同步的静态方法 public static synchronized void output2(String name) &#123; int len = name.length(); for (int i = 0; i &lt; len; i++) &#123; System.out.print(name.charAt(i)); &#125; System.out.println(); &#125; &#125; &#125; 5. 传统线程同步通信技术这里通过一道面试题进行讲解 需求：子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程又循环100次，如此循环50次 1、思路： 使用面向对象的方式思考，子线程的任务是循环10次，子线程的任务是循环100次，所以可以将它们各自的任务封装起来，在封装内部实现各自的同步（锁是放在代表要操作的资源的类的内部方法中），最后别的对象来调用，循环50次即可 2、Eclipse小技巧： 这里打印结果过长，我们可以使用eclipse将打印结果输出到文件中：Run As → Run Configurations → Common → File前打勾 → 指定路径 3、锁对象的定义 两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个锁对象，锁是放在代表要操作的资源的类的内部方法中，而不是在线程代码中。 4、实现按指定的顺序执行 需要用到wait，Notify，当轮到自己要执行的时候，让对象去唤醒自己，可以定义一个标识，来决定谁可以执行 5、wait方法必须放在synchronized的里面，而且调用它的对象必须和synchronized的对象是同一个。 6、While比if更严谨，因为会循环判断执行条件，所以可以防止伪唤醒，（并不是期望的对象来唤醒自己）。 经验：要用到共同数据（包括同步锁）或共同算法的若干个方法应该归于同一个类上，在这个类的内部去管理各个方法的状态，这种设计正好体现了高类聚和程序的健壮性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class TraditionalThreadCommunication &#123; public static void main(String[] args)&#123; //获取一个业务对象 final Business business = new Business(); //子线程 new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=1;i&lt;=50;i++)&#123; /*for(int j=0;j&lt;10;j++)&#123; System.out.println("sub thread sequence of"+i+",loop of "+j); &#125;*/ business.sub(i); &#125; &#125; &#125;).start(); //主线程 for(int i=1;i&lt;=50;i++)&#123; /* for(int j=0;j&lt;100;j++)&#123; System.out.println("main thread sequence of"+i+", loop of "+j); &#125; */ business.main(i); &#125; &#125; &#125; //定义一个业务类 class Business&#123; //定义一个boolean型变量来决定子线程和主线程的执行权 private boolean bShouldSub = true; //子线程 public synchronized void sub(int i)&#123;//把同步的鎖放在资源身上 //不该子线程执行，等待 if(!bShouldSub)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=10;j++)&#123; System.out.println("sub thread sequence of"+i+",loop of "+j); &#125; bShouldSub = false; this.notify(); //唤醒主线程 &#125; //主线程 public synchronized void main(int i)&#123; //若是子线程执行，主线程等待 if(bShouldSub)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=100;j++)&#123; System.out.println("main thread sequence of"+i+", loop of "+j); &#125; bShouldSub = true; this.notify(); //唤醒子线程 &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字解析]]></title>
    <url>%2F2017%2F04%2F30%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.cnblogs.com/dolphin0520/p/3920373.html volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。 volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。 目录大纲 内存模型的相关概念 并发编程中的三个概念 Java内存模型 深入剖析volatile关键字 使用volatile关键字的场景 1. 内存模型的相关概念大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。 也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码： 1i = i + 1; 当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。 这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。 比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。 最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 通过在总线加LOCK锁的方式 通过缓存一致性协议 这2种方式都是硬件层面上提供的方式。 在早期的CPU当中，是通过在总线上加LOCK锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。 所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 2. 并发编程中的三个概念在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念： 2.1 原子性原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？ 1i = 9; 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。 2.2 可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 举个简单的例子，看下面这段代码： 123456//线程1执行的代码int i = 0;i = 10; //线程2执行的代码j = i; 假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 2.3 有序性有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码： 1234int i = 0; boolean flag = false;i = 1; //语句1 flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子： 1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4 这段代码有4个语句，那么可能的一个执行顺序是： 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 3. Java内存模型在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。 在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。 Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。 举个简单的例子：在java中，执行下面这个语句： 1i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？ 4. 原子性在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i： 请分析以下哪些操作是原子性操作： 1234x = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 5. 可见性对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 6. 有序性在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 下面就来具体介绍下happens-before原则（先行发生原则）： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 这8条原则摘自《深入理解Java虚拟机》。这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。下面我们来解释一下前4条规则： 对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则具备传递性。 7. 深入剖析volatile关键字在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。 7.1 volatile关键字的两层语义一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行： 12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125; //线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值。 7.2 volatile保证原子性吗？从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？ 下面看一个例子： 1234567891011121314151617181920212223public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。 这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 把上面的代码改成以下任何一种都可以达到效果： 采用synchronized： 1234567891011121314151617181920212223public class Test &#123; public int inc = 0; public synchronized void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用Lock：1234567891011121314151617181920212223242526272829public class Test &#123; public int inc = 0; Lock lock = new ReentrantLock(); public void increase() &#123; lock.lock(); try &#123; inc++; &#125; finally&#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用AtomicInteger：1234567891011121314151617181920212223public class Test &#123; public AtomicInteger inc = new AtomicInteger(); public void increase() &#123; inc.getAndIncrement(); &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 7.3 volatile能保证有序性吗？在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子： 12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 7.4 volatile的原理和实现机制前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。下面这段话摘自《深入理解Java虚拟机》： “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将对缓存的修改操作立即写入主存； 如果是写操作，它会导致其他CPU中对应的缓存行无效。 7.5 使用volatile关键字的场景synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 对变量的写操作不依赖于当前值 该变量没有包含在具有其他变量的不变式中 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 下面列举几个Java中使用volatile的几个场景。 状态标记量 1234567891011121314151617181920volatile boolean flag = false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag = true;&#125;volatile boolean inited = false;//线程1:context = loadContext(); inited = true; //线程2:while(!inited )&#123;sleep()&#125;doSomethingwithconfig(context); double check 1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 至于为何需要这么写请参考： Java 中的双重检查（Double-Check） 单例模式与双重检测 8. 参考资料《Java编程思想》 《深入理解Java虚拟机》 http://jiangzhengjun.iteye.com/blog/652532 http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html http://ifeve.com/volatile/ http://blog.csdn.net/ccit0519/article/details/11241403 http://blog.csdn.net/ns_code/article/details/17101369 http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html http://www.cppblog.com/elva/archive/2011/01/21/139019.html http://ifeve.com/volatile-array-visiblity/ http://www.bdqn.cn/news/201312/12579.shtml http://exploer.blog.51cto.com/7123589/1193399 http://www.cnblogs.com/Mainz/p/3556430.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2017%2F04%2F30%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. 泛型概述泛型（Generic type 或者 generics）是对 Java 语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。可以把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行时传递的值的占位符一样。 泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。 在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。 泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。 可以在集合框架（Collection framework）中看到泛型的动机。例如，Map 类允许您向一个 Map添加任意类的对象，即使最常见的情况是在给定映射（map）中保存某个特定类型（比如 String）的对象。 因为 Map.get() 被定义为返回 Object，所以一般必须将 Map.get() 的结果强制类型转换为期望的类型，如下面的代码所示： 123Map m = new HashMap();m.put("key", "blarg");String s = (String) m.get("key"); 要让程序通过编译，必须将 get() 的结果强制类型转换为 String，并且希望结果真的是一个 String。但是有可能某人已经在该映射中保存了不是 String 的东西，这样的话，上面的代码将会抛出 ClassCastException。 理想情况下，您可能会得出这样一个观点，即 m 是一个 Map，它将 String 键映射到 String 值。这可以让您消除代码中的强制类型转换，同时获得一个附加的类型检查层，该检查层可以防止有人将错误类型的键或值保存在集合中。这就是泛型所做的工作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.itcast_01;import java.util.ArrayList;import java.util.Iterator;/* * ArrayList存储字符串并遍历 * * 我们按照正常的写法来写这个程序， 结果确出错了。 * 为什么呢? * 因为我们开始存储的时候，存储了String和Integer两种类型的数据。 * 而在遍历的时候，我们把它们都当作String类型处理的，做了转换，所以就报错了。 * 但是呢，它在编译期间却没有告诉我们。 * 所以，我就觉得这个设计的不好。 * 回想一下，我们的数组 * String[] strArray = new String[3]; * strArray[0] = "hello"; * strArray[1] = "world"; * strArray[2] = 10; * 集合也模仿着数组的这种做法，在创建对象的时候明确元素的数据类型。这样就不会在有问题了。 * 而这种技术被称为：泛型。 * * 泛型：是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。参数化类型，把类型当作参数一样的传递。 * 格式： * &lt;数据类型&gt; * 此处的数据类型只能是引用类型。 * 好处： * A:把运行时期的问题提前到了编译期间 * B:避免了强制类型转换 * C:优化了程序设计，解决了黄色警告线 */public class GenericDemo &#123; public static void main(String[] args) &#123; // 创建 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); // 添加元素 array.add("hello"); array.add("world"); array.add("java"); // array.add(new Integer(100)); //array.add(10); // JDK5以后的自动装箱 // 等价于：array.add(Integer.valueOf(10)); // 遍历 Iterator&lt;String&gt; it = array.iterator(); while (it.hasNext()) &#123; // ClassCastException // String s = (String) it.next(); String s = it.next(); System.out.println(s); &#125; // 看下面这个代码 // String[] strArray = new String[3]; // strArray[0] = "hello"; // strArray[1] = "world"; // strArray[2] = 10; &#125;&#125; 2. 泛型的好处Java 语言中引入泛型是一个较大的功能增强。不仅语言、类型系统和编译器有了较大的变化，以支持泛型，而且类库也进行了大翻修，所以许多重要的类，比如集合框架，都已经成为泛型化的了。这带来了很多好处： 2.1 类型安全泛型的主要目标是提高 Java 程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。 Java 程序中的一种流行技术是定义这样的集合，即它的元素或键是公共类型的，比如“String 列表”或者“String 到 String 的映射”。通过在变量声明中捕获这一附加的类型信息，泛型允许编译器实施这些附加的类型约束。类型错误现在就可以在编译时被捕获了，而不是在运行时当作 ClassCastException 展示出来。将类型检查从运行时挪到编译时有助于您更容易找到错误，并可提高程序的可靠性。 2.2 消除强制类型转换泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。尽管减少强制类型转换可以降低使用泛型类的代码的罗嗦程度，但是声明泛型变量会带来相应的罗嗦。 2.3 优化了程序设计，解决了黄色警告线3. 泛型的应用3.1 泛型的内部原理泛型是提供给javac编译器使用的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入。但是，编译器编译带类型说明的集合时会去除掉“类型”信息，目的就是使程序运行效率不受影响。因此，对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样。 12345678910111213package com.itheima.day2;import java.util.ArrayList;public class GenericTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; collection1 = new ArrayList&lt;String&gt;(); ArrayList collection2 = new ArrayList(); System. out.println(collection1.getClass() == collection2.getClass()); //结果：true &#125;&#125; 由于编译生成的字节码会去掉泛型的类型信息，只要能跳过编译器，就可以往某个泛型集合中加入其它类型的数据，例如，用反射得到集合，再调用其add方法即可。 123456789101112package com.itheima.day2;import java.util.ArrayList;public class GenericTest &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; collection1 = new ArrayList&lt;Integer&gt;(); collection1.getClass().getMethod( "add",Object.class).invoke(collection1, "abc"); System. out.println(collection1.get(0)); &#125;&#125; ArrayList类定义和ArrayList类引用中涉及如下术语： 整个称为ArrayList&lt;E&gt;泛型类型 ArrayList&lt;E&gt;中的E称为类型变量或类型参数 整个ArrayList&lt;Integer&gt;称为参数化的类型 ArrayList&lt;Integer&gt;中的Integer称为类型参数的实例或实际类型参数 ArrayList&lt;Integer&gt;中的&lt;&gt;念着typeof ArrayList称为原始类型 参数化类型与原始类型的兼容性：参数化类型可以引用一个原始类型的对象，编译报告警告，例如 1Collection&lt;String&gt; c = new Vector();//考虑到对以前代码的兼容性，编译器是可以通过的 原始类型可以引用一个参数化类型的对象，编译报告警告，例如1Collection c = new Vector&lt;String&gt;();//原来的方法接受一个集合参数，新的类型也要能传进去 参数化类型不考虑类型参数的继承关系： 12Vector&lt;String&gt; v = new Vector&lt;Object&gt;(); //错误!不写&lt;Object&gt;没错，写了就是明知故犯Vector&lt;Object&gt; v = new Vector&lt;String&gt;(); //也错误! 注意： 假设Vector&lt;String&gt; v = new Vector&lt;Object&gt;();可以的话，那么以后从v中取出的对象当作String用，而v实际指向的对象中可以加入任意的类型对象； 假设Vector&lt;Object&gt; v = new Vector&lt;String&gt;();可以的话，那么以后可以向v中加入任意的类型对象，而v实际指向的集合中只能装String类型的对象。 编译器不允许创建泛型变量的数组。即在创建数组实例时，数组的元素不能使用参数化的类型。 例如，下面语句有错误： 1Vector&lt;Integer&gt; vectorList[] = new Vector&lt;Integer&gt;[10]; 思考题： 下面的代码会报错误吗？ 12Vector v1 = new Vector&lt;String&gt;();Vector&lt;Object&gt; v = v1; 答案：编译的时候是不会报错的，因为编译器是一行一行按照语法检查代码的，因此不会出错。 4. 泛型类把泛型定义在类上，格式:public class 类名&lt;泛型类型1,…&gt;，注意:泛型类型必须是引用类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.itcast_04;/* * 泛型类的测试 */public class ObjectToolDemo &#123; public static void main(String[] args) &#123; // ObjectTool ot = new ObjectTool(); // // ot.setObj(new String("风清扬")); // String s = (String) ot.getObj(); // System.out.println("姓名是：" + s); // // ot.setObj(new Integer(30)); // Integer i = (Integer) ot.getObj(); // System.out.println("年龄是：" + i); // ot.setObj(new String("林青霞")); // // ClassCastException // Integer ii = (Integer) ot.getObj(); // System.out.println("姓名是：" + ii); System.out.println("-------------"); ObjectTool&lt;String&gt; ot = new ObjectTool&lt;String&gt;(); // ot.setObj(new Integer(27)); //这个时候编译期间就过不去 ot.setObj(new String("林青霞")); String s = ot.getObj(); System.out.println("姓名是：" + s); ObjectTool&lt;Integer&gt; ot2 = new ObjectTool&lt;Integer&gt;(); // ot2.setObj(new String("风清扬"));//这个时候编译期间就过不去 ot2.setObj(new Integer(27)); Integer i = ot2.getObj(); System.out.println("年龄是：" + i); &#125;&#125;//泛型类：把泛型定义在类上class ObjectTool&lt;T&gt; &#123; private T obj; public T getObj() &#123; return obj; &#125; public void setObj(T obj) &#123; this.obj = obj; &#125;&#125; 5. 泛型方法把泛型定义在方法上，格式:public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .) 12345678910111213141516171819202122232425262728293031package cn.itcast_05;public class ObjectToolDemo &#123; public static void main(String[] args) &#123; // ObjectTool ot = new ObjectTool(); // ot.show("hello"); // ot.show(100); // ot.show(true); // ObjectTool&lt;String&gt; ot = new ObjectTool&lt;String&gt;(); // ot.show("hello"); // // ObjectTool&lt;Integer&gt; ot2 = new ObjectTool&lt;Integer&gt;(); // ot2.show(100); // // ObjectTool&lt;Boolean&gt; ot3 = new ObjectTool&lt;Boolean&gt;(); // ot3.show(true); // 定义泛型方法后 ObjectTool ot = new ObjectTool(); ot.show("hello"); ot.show(100); ot.show(true); &#125;&#125;//泛型方法：把泛型定义在方法上class ObjectTool &#123; public &lt;T&gt; void show(T t) &#123; System.out.println(t); &#125;&#125; 6. 泛型接口把泛型定义在接口上，格式:public interface 接口名&lt;泛型类型1…&gt; 123456789101112131415161718192021222324252627282930313233343536373839package cn.itcast_06;public class InterDemo &#123; public static void main(String[] args) &#123; // 第一种情况的测试 // Inter&lt;String&gt; i = new InterImpl(); // i.show("hello"); // // 第二种情况的测试 Inter&lt;String&gt; i = new InterImpl&lt;String&gt;(); i.show("hello"); Inter&lt;Integer&gt; ii = new InterImpl&lt;Integer&gt;(); ii.show(100); &#125;&#125;//泛型接口：把泛型定义在接口上 interface Inter&lt;T&gt; &#123; public abstract void show(T t);&#125;// 实现类在实现接口的时候// 第一种情况：已经知道该是什么类型的了//public class InterImpl implements Inter&lt;String&gt; &#123;//// @Override// public void show(String t) &#123;// System.out.println(t);// &#125;// &#125;// 第二种情况：还不知道是什么类型的class InterImpl&lt;T&gt; implements Inter&lt;T&gt; &#123; @Override public void show(T t) &#123; System.out.println(t); &#125;&#125; 7. 泛型高级(通配符)为了解决类型被限制死了不能动态根据实例来确定的缺点，引入了“通配符泛型”，针对上面的例子，使用通配泛型格式为&lt;? extends Collection&gt;，“？”代表未知类型，这个类型是实现Collection接口。? extends E：向下限定，E及其子类，限定通配符的上边界。? super E：向上限定，E及其父类，限定通配符的下边界。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.itcast_07;import java.util.ArrayList;import java.util.Collection;/* * 泛型高级(通配符) * ?:任意类型，如果没有明确，那么就是Object以及任意的Java类了 * ? extends E:向下限定，E及其子类 * ? super E:向上限定，E极其父类 */public class GenericDemo &#123; public static void main(String[] args) &#123; // 泛型如果明确的写的时候，前后必须一致 Collection&lt;Object&gt; c1 = new ArrayList&lt;Object&gt;(); // Collection&lt;Object&gt; c2 = new ArrayList&lt;Animal&gt;(); // Collection&lt;Object&gt; c3 = new ArrayList&lt;Dog&gt;(); // Collection&lt;Object&gt; c4 = new ArrayList&lt;Cat&gt;(); // ?表示任意的类型都是可以的 Collection&lt;?&gt; c5 = new ArrayList&lt;Object&gt;(); Collection&lt;?&gt; c6 = new ArrayList&lt;Animal&gt;(); Collection&lt;?&gt; c7 = new ArrayList&lt;Dog&gt;(); Collection&lt;?&gt; c8 = new ArrayList&lt;Cat&gt;(); // ? extends E:向下限定，E及其子类 // Collection&lt;? extends Animal&gt; c9 = new ArrayList&lt;Object&gt;(); Collection&lt;? extends Animal&gt; c10 = new ArrayList&lt;Animal&gt;(); Collection&lt;? extends Animal&gt; c11 = new ArrayList&lt;Dog&gt;(); Collection&lt;? extends Animal&gt; c12 = new ArrayList&lt;Cat&gt;(); // ? super E:向上限定，E极其父类 Collection&lt;? super Animal&gt; c13 = new ArrayList&lt;Object&gt;(); Collection&lt;? super Animal&gt; c14 = new ArrayList&lt;Animal&gt;(); // Collection&lt;? super Animal&gt; c15 = new ArrayList&lt;Dog&gt;(); // Collection&lt;? super Animal&gt; c16 = new ArrayList&lt;Cat&gt;(); &#125;&#125;class Animal &#123;&#125;class Dog extends Animal &#123;&#125;class Cat extends Animal &#123;&#125; 泛型泛型是提供给javac编译器使用的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入，编译器编译带类型说明的集合时会去除掉“类型”信息，使程序运行效率不受影响，对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样。由于编译生成的字节码会去掉泛型的类型信息，只要能跳过编译器，就可以往某个泛型集合中加入其它类型的数据，例如，用反射得到集合，再调用其add方法即可。 泛型引用和创建两端，给出的泛型变量必须相同 泛型类12A&lt;T&gt;Class&lt;T&gt; type 泛型类中使用泛型 成员类型 返回值和参数类型 局部变量的引用上 12345678class A&lt;T&gt; &#123; private T bean;//泛型可在成员变量上使用 public T fun(T t) &#123;&#125;//泛型可以在类中的方法上（返回值和参数类型）使用！ public void fun2() &#123;//泛型还可以在局部变量的引用类型上使用 T b = ... new T();//不行的！ &#125;&#125; 泛型方法12public &lt;T&gt; T add(T x, T y)&#123; &#125; 泛型方法与泛型类没有什么关系，泛型方法不一定非要在泛型类中！ 泛型的继承和实现1234567class A&lt;T&gt; &#123;&#125;// AA不是泛型类，只是它爸爸是泛型类！class AA extends A&lt;String&gt; &#123; &#125; 继承泛型类 子类不是泛型类：需要给父类传递类型常量 当给父类传递的类型常量为String时，那么在父类中所有T都会被String替换！ 123class AA1 extends A&lt;String&gt; &#123; &#125; 子类是泛型类：可以给父类传递类型常量，也可以传递类型变量 123class AA3&lt;E&gt; extends A&lt;E&gt; &#123; &#125; 通配符 无限通配符&lt;?&gt; 向下通配符&lt;? extends T&gt; 向上通配符&lt;? super T&gt; 类型推断 通过反射的方式获取泛型的实际类型 泛型只能是引用类型，不能是基本数据类型 泛型擦除泛型会在编译时擦除，List和List这两个的字节码文件那一个都是List.class Gson泛型封装在你真的会用Gson吗?Gson使用指南（一） 的第三节我介绍了在Gson中如何使用泛型来简化我们的类设计，但随之而来引入了一个新的问题：封装。不知道各位有没有想过这样一个问题：每次都要用 new TypeToken&lt;XXX&gt;(){}; 好麻烦，有没有更好的办法? 有更好的办法么?当然有！相信也有不少人自己作了尝试，只是有人欢喜有人愁了，不过没关系，今天我们就来解决这个问题。 约定1、本文涉及到的json格式 1234// data 为 object 的情况&#123;"code":"0","message":"success","data":&#123;&#125;&#125;// data 为 array 的情况&#123;"code":"0","message":"success","data":[]&#125; 2、假定第一种的对应的Java类型为 Result&lt;XXX&gt; ，第二种为 Result&lt;List&lt;XXX&gt;&gt; 为何封装，如何封装1. 为何封装： 写new TypeToken&lt;XXX&gt;(){} 麻烦，IDE格式化后还不好看 不同的地方每进行一次 new TypeToken&lt;XXX&gt;(){} 操作都会生成一个新的类 对于任意类XXX都只有两种情况new TypeToken&lt;Result&lt;XXX&gt;&gt;(){}和new TypeToken&lt;Result&lt;List&lt;XXX&gt;&gt;&gt;(){} 方便统一管理 2. 如何封装从上面的我们可以知道，最简单的方法就是提供两个方法分别对应data为Array和Object的情况并接收一个参数，即告知XXX的类型，自动将完成new TypeToken&lt;XXX&gt;(){}与new TypeToken&lt;Result&lt;List&lt;XXX&gt;&gt;&gt;(){}的过程。 方法原型： 1234// 处理 data 为 object 的情况public static &lt;T&gt; Result&lt;T&gt; fromJsonObject(Reader reader, Class&lt;T&gt; clazz) &#123;&#125;// 处理 data 为 array 的情况public static &lt;T&gt; Result&lt;List&lt;T&gt;&gt; fromJsonArray(Reader reader, Class&lt;T&gt; clazz)&#123;&#125; 为何失败?对于那些尝试着封装过的人可能都这么写过： 1234public static &lt;T&gt; Result&lt;List&lt;T&gt;&gt; fromJsonArray(Reader reader) &#123; Type type = new TypeToken&lt;Result&lt;List&lt;T&gt;&gt;&gt;()&#123;&#125;.getType(); return GSON.fromJson(reader, type);&#125; 当然上面的写法肯定是没有办法完成的，虽然代码不会报错，但运行结果肯定是不对的，因为这里的T 其实是一个 TypeVariable，他在运行时并不会变成我们想要的XXX，所以通过TypeToken 得到的 泛型信息只是 &quot;Result&lt;List&lt;T&gt;&gt;&quot;。 如何解决?既然TypeToken的作用是用于获取泛型的类，返回的类型为Type，真正的泛型信息就是放在这个Type里面，既然用TypeToken生成会有问题,那我们自己生成Type就行了嘛。 Type是Java中所有类型的父接口，在1.8以前是一个空接口，自1.8起多了个getTypeName()方法，下面有ParameterizedType、 GenericArrayType、 WildcardType、 TypeVariable 几个接口，以及Class类。这几个接口在本次封装过程中只会用到 ParameterizedType ，所以简单说一下： ParameterizedType 简单说来就是形如“ 类型&lt;&gt; ”的类型，如:Map&lt;String,User&gt;。下面就以 Map&lt;String,User&gt; 为例讲一下里面各个方法的作用。 12345678public interface ParameterizedType extends Type &#123; // 返回Map&lt;String,User&gt;里的String和User，所以这里返回[String.class,User.clas] Type[] getActualTypeArguments(); // Map&lt;String,User&gt;里的Map,所以返回值是Map.class Type getRawType(); // 用于这个泛型上中包含了内部类的情况,一般返回null Type getOwnerType(); &#125; 所以，知道了这里需要的泛型是怎么回事，一切都好说了，下面我们来完成之前留下的空方法。 1. 实现一个简易的 ParameterizedType123456789101112131415161718public class ParameterizedTypeImpl implements ParameterizedType &#123; private final Class raw; private final Type[] args; public ParameterizedTypeImpl(Class raw, Type[] args) &#123; this.raw = raw; this.args = args != null ? args : new Type[0]; &#125; @Override public Type[] getActualTypeArguments() &#123; return args; &#125; @Override public Type getRawType() &#123; return raw; &#125; @Override public Type getOwnerType() &#123;return null;&#125;&#125; 2. 生成Gson需要的泛型2.1 解析data是object的情况1234public static &lt;T&gt; Result&lt;T&gt; fromJsonObject(Reader reader, Class&lt;T&gt; clazz) &#123; Type type = new ParameterizedTypeImpl(Result.class, new Class[]&#123;clazz&#125;); return GSON.fromJson(reader, type);&#125; 2.2 解析data是array的情况是Array的情况要比是Object的情况多那么一步。 1234567public static &lt;T&gt; Result&lt;List&lt;T&gt;&gt; fromJsonArray(Reader reader, Class&lt;T&gt; clazz) &#123; // 生成List&lt;T&gt; 中的 List&lt;T&gt; Type listType = new ParameterizedTypeImpl(List.class, new Class[]&#123;clazz&#125;); // 根据List&lt;T&gt;生成完整的Result&lt;List&lt;T&gt;&gt; Type type = new ParameterizedTypeImpl(Result.class, new Type[]&#123;listType&#125;); return GSON.fromJson(reader, type);&#125; 本次代码较少，不提供源码 虽然这篇博客是以Gson为例，但从上面的内容可以看出实际上和Gson关系不大，主要的内容还是Java的泛型基础，所以这种封装的方法同样适用于其它的框架。 最后借这次机会给安利一个简易的泛型生成库 TypeBuilder ，其最初实现的目的就是让大家快速的生成泛型信息，同时也会作一些参数检查，保证正确性。 用上面的代码给大家举个例子 1234567891011121314151617public static &lt;T&gt; Result&lt;List&lt;T&gt;&gt; fromJsonArray(Reader reader, Class&lt;T&gt; clazz) &#123; Type type = TypeBuilder .newInstance(Result.class) .beginSubType(List.class) .addTypeParam(clazz) .endSubType() .build(); return GSON.fromJson(reader, type);&#125;public static &lt;T&gt; Result&lt;T&gt; fromJsonObject(Reader reader, Class&lt;T&gt; clazz) &#123; Type type = TypeBuilder .newInstance(Result.class) .addTypeParam(clazz) .build(); return GSON.fromJson(reader, type);&#125; TypeType 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型 ParameterizedTypeParameterizedType 表示参数化类型，如 Collection 方法 说明 Type[ ] getActualTypeArguments() 获取真实参数 12345678910public abstract class BaseProtocol&lt;T&gt; &#123; ... // 泛型解析 protected T parsejson(String jsonString)&#123; ParameterizedType genericSuperclass = (ParameterizedType) getClass().getGenericSuperclass(); Type[] args = genericSuperclass.getActualTypeArguments(); Type type = args[0]; return GsonUtil.changeGsonToBean(jsonString,type); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2017%2F04%2F30%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[系列阅读 Java基础：类加载器 Java基础：反射 Java基础：注解 Java基础：动态代理 1. 概述在运行时，动态创建一组指定的接口的实现类对象（代理对象）！ 代理是实现AOP（面向切面编程）的核心和关键技术，动态代理的用途与装饰模式很相似，就是为了对某个对象进行增强。所有使用装饰者模式的案例都可以使用动态代理来替换。 代理：本来应该自己做的事情，却请了别人来做，被请的人就是代理对象。 举例：春季回家买票让人代买 动态代理：在程序运行过程中产生的这个对象 而程序运行过程中产生对象其实就是我们刚才反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理 2. 工作原理 client调用代理 代理的构造方法接收一个invocationhandler参数 client调用代理的各个方法，代理的各个方法会把调用请求转发给invocationhandler invocationhandler通过invoke()方法把调用请求分发给目标对象的各个方法 1、在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib。 2、Proxy类中的方法创建动态代理类对象 1234public static Object newProxyInstance( ClassLoader loader, Class&lt;?&gt;[]interfaces, InvocationHandler h) 返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。最终会调用InvocationHandler的方法 3、InvocationHandler 1Object invoke(Object proxy,Method method,Object[] args) 在代理实例上处理方法调用并返回结果。 4、Proxy类中创建动态代理对象的方法的三个参数 ClassLoader对象定义了由哪个ClassLoader对象来对生成的代理对象进行加载 Interface对象的数组表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了 InvocationHandler对象表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke 方法来进行调用。 5、InvocationHandler接口中invoke()方法的三个参数： Object proxy：代表动态代理对象 Method method：代表正在执行的方法 Object[] args：代表调用目标方法时传入的实参 6、Proxy.newProxyInstance() 创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号 3. 动态代理的实现1234567891011package cn.itcast_06;/* * 用户操作接口 */public interface UserDao &#123; public abstract void add(); public abstract void delete(); public abstract void update(); public abstract void find();&#125; 1234567package cn.itcast_06;public interface StudentDao &#123; public abstract void login(); public abstract void regist();&#125; 12345678910111213141516171819202122package cn.itcast_06;public class UserDaoImpl implements UserDao &#123; @Override public void add() &#123; System.out.println("添加功能"); &#125; @Override public void delete() &#123; System.out.println("删除功能"); &#125; @Override public void update() &#123; System.out.println("修改功能"); &#125; @Override public void find() &#123; System.out.println("查找功能"); &#125;&#125; 1234567891011121314package cn.itcast_06;public class StudentDaoImpl implements StudentDao &#123; @Override public void login() &#123; System.out.println("登录功能"); &#125; @Override public void regist() &#123; System.out.println("注册功能"); &#125;&#125; 123456789101112131415161718192021package cn.itcast_06;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler &#123; private Object target; // 目标对象 public MyInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("权限校验"); Object result = method.invoke(target, args); System.out.println("日志记录"); return result; // 返回的是代理对象 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package cn.itcast_06;import java.lang.reflect.Proxy;public class Test &#123; public static void main(String[] args) &#123; UserDao ud = new UserDaoImpl(); ud.add(); ud.delete(); ud.update(); ud.find(); System.out.println("-----------"); // 我们要创建一个动态代理对象 // Proxy类中有一个方法可以创建动态代理对象 // public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] // interfaces,InvocationHandler h) // 我准备对ud对象做一个代理对象 MyInvocationHandler handler = new MyInvocationHandler(ud); UserDao proxy = (UserDao) Proxy.newProxyInstance(ud.getClass() .getClassLoader(), ud.getClass().getInterfaces(), handler); proxy.add(); proxy.delete(); proxy.update(); proxy.find(); System.out.println("-----------"); StudentDao sd = new StudentDaoImpl(); MyInvocationHandler handler2 = new MyInvocationHandler(sd); StudentDao proxy2 = (StudentDao) Proxy.newProxyInstance(sd.getClass() .getClassLoader(), sd.getClass().getInterfaces(), handler2); proxy2.login(); proxy2.regist(); &#125;&#125; 4. Spring原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class ProxyFactoryBean &#123; private Object mTarget; private Advice mAdvice; public Object getProxy()&#123; Object proxy = Proxy.newProxyInstance( mTarget.getClass().getClassLoader(), mTarget.getClass().getInterfaces(), mHandler ); return proxy; &#125; private InvocationHandler mHandler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; mAdvice.beforeMethod(method); Object result = method.invoke(mTarget, args); mAdvice.afterMethod(method); return result; &#125; &#125;; public void setTarget(Object target) &#123; mTarget = target; &#125; public void setAdvice(Advice advice) &#123; mAdvice = advice; &#125; public Object getTarget() &#123; return mTarget; &#125; public Advice getAdvice() &#123; return mAdvice; &#125;&#125;public class BeanFactory &#123; Properties mProperties = new Properties(); public BeanFactory(InputStream in)&#123; try &#123; mProperties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public Object getBean(String name)&#123; String classname = mProperties.getProperty(name); Object bean = null; try &#123; Class clazz = Class.forName(classname); bean = clazz.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (bean instanceof ProxyFactoryBean)&#123; Object proxy = null; ProxyFactoryBean factoryBean = (ProxyFactoryBean) bean; Advice advice = null; try &#123; advice = (Advice) Class.forName(mProperties.getProperty(name+".advice")).newInstance(); Object target = Class.forName(mProperties.getProperty(name+".target")).newInstance(); factoryBean.setAdvice(advice); factoryBean.setTarget(target); proxy = factoryBean.getProxy(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return proxy; &#125; return bean; &#125;&#125; 1234public interface Advice &#123; void beforeMethod(Method method); void afterMethod(Method method);&#125; 123456789public class AopFrameworkTest &#123; public static void main(String[] args) throws Exception &#123; InputStream ips = AopFrameworkTest.class.getResourceAsStream("config.properties"); Object bean = new BeanFactory(ips).getBean("xxx"); System.out.println(bean.getClass().getName()); ((Collection)bean).clear(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2017%2F04%2F30%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射注解动态代理相关阅读 Java基础：类加载器 Java基础：反射 Java基础：注解 Java基础：动态代理 1. 反射概述Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 Java 反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。 Java中，反射是一种强大的工具。它使您能够创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码链接。反射允许我们在编写于执行时，使我们的程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。这使反射成为构建灵活的应用的主要工具。但需注意的是：如果使用不当，反射的成本很高。 2. 反射的应用场景反射是Java中的高级特性，在各种Java框架中都需要使用反射。所以，就算你将来很长一段时间不使用反射，但你使用的框架都大量使用了反射，所以想深入学习框架，那么就一定要学习反射。 框架通常通过反射来识别一个对象的“类型信息”。当你传递给框架一个对象时，框架会通过反射来了解对象的真实类型（对象实体的类型，而不是引用的类型），这个类型有几个构造器，有什么样的属性，有什么样的方法。还可以通过反射调用构造器，调用方法，对属性进行读写操作。 你可能觉得这没有什么神奇的，那是你还没了解我说的是什么！你需要再想一想，写一个方法，参数是Object obj，然后你的方法需要创建一个与参数类型相同的对象出来，还要调用这个对象上的方法。需要注意，参数是Object类型，但用户调用这个方法时，可能传递的不是Object实体对象，它的真实类型有可能是任何类型。 目前好多框架都会用到java的反射机制。比如struts2，sping，hibernate。 如果我们不用struts2，自己写一个类似的功能也是可以实现的，比如浏览器通过HTTP发送数据，而这些数据都是字符串，我们接受到这些字符串时， 可以通过反射去构造一个对象(通过拦截器做成框架的功能)，这样就可以用对象的get和set方法了，而不用原始的getPeremter()方法。事实上， 在struts2出来之前，我们又不想用struts1的ActionForm就做过这样项目。 Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法 生成动态代理 3. 反射JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 要想解剖一个类，必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。 一句话概括：反射就是把java类中的各种成分映射成相应的java类（Class，Field，Method，Constructor），在程序运行的过程中，动态的访问java类中的成分，反射还可以实现框架的功能 例如：一个Java类中用一个Class类的对象来表示，一个类中的组成部分：成员变量，方法，构造方法，包等信息也用一个个的Java类来表示，就像汽车是一个类，汽车中的发动机，变速箱等等也是一个个的类。表示java类的Class类显然要提供一系列的方法，来获得其中的变量，方法，构造方法，修饰符，包等信息，这些信息就是用相应类的实例对象来表示，它们是Field、Method、Contructor、Package等。 3.1 反射的主要作用 运行时取得类的方法和字段的相关信息。 创建某个类的新实例(newInstance()) 取得字段引用直接获取和设置对象字段，无论访问修饰符是什么 观察或操作应用程序的运行时行为 调试或测试程序，因为可以直接访问方法、构造函数和成员字段 通过名字调用不知道的方法并使用该信息来创建对象和调用方法 4. 反射从Class类开始要想使用反射，首先你需要得到Class对象，然后才能通过Class对象获取Constructor、Field、Method等对象。所有的反射对象都不可能自己来new，说白一点，这些反射对象对应的是class文件上的信息，你怎么可能自己去new呢？如果可以自己去new一个Class类的对象，那么是不是就不用我们再去编写.java文件，然后再通过编译器去编译成.class文件了呢？当然这是不可能的！ 我们需要思考，Class除了可以返回当前对应类型的所有属性、方法、构造器的反射对象外，还有什么功能呢？例如对应类型的类名是什么？对应类型的父类是谁？对应类型是不是public类，是不是final类。对应类型有没有可能是个数组类型？有没有可能是接口类型？有没有可能是基本类型等等！如果你学会了这样思考，那么你今后学习新类是就方便多了！ 4.1 三种获取Class对象的方式 Object类的getClass()方法 12Person p = new Person();Class c = p.getClass(); 数据类型的静态属性class 1Class c2 =Person.class; 任意数据类型都具备一个class静态属性，看上去要比第一种方式简单 将类名作为字符串传递给Class类中的静态方法forName即可 1Class c3 = Class.forName("Person"); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package cn.itcast;class Person &#123; private String name; int age; public String address; public Person() &#123; &#125; private Person(String name) &#123; this.name = name; &#125; Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name, int age, String address) &#123; this.name = name; this.age = age; this.address = address; &#125; public void show() &#123; System.out.println("show"); &#125; public void method(String s) &#123; System.out.println("method " + s); &#125; public String getString(String s, int i) &#123; return s + "---" + i; &#125; private void function() &#123; System.out.println("function"); &#125; public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", address=" + address + "]"; &#125;&#125;/* * 反射：就是通过class文件对象，去使用该文件中的成员变量，构造方法，成员方法。 * * Person p = new Person(); p.使用 * * 要想这样使用，首先你必须得到class文件对象，其实也就是得到Class类的对象。 Class类： 成员变量 Field 构造方法 Constructor * 成员方法 Method * * 获取class文件对象的方式： A:Object类的getClass()方法 B:数据类型的静态属性class C:Class类中的静态方法 public * static Class forName(String className) * * 一般我们到底使用谁呢? 第三种：因为第三种是一个字符串，而不是一个具体的类名。这样我们就可以把这样的字符串配置到配置文件中。 */public class ReflectDemo &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 方式1 Person p = new Person(); Class c = p.getClass(); Person p2 = new Person(); Class c2 = p2.getClass(); System.out.println(p == p2);// false System.out.println(c == c2);// true // 方式2 Class c3 = Person.class; // int.class; // String.class; System.out.println(c == c3); // 方式3 // ClassNotFoundException Class c4 = Class.forName("cn.itcast_01.Person"); System.out.println(c == c4); &#125;&#125; 4.2 第三种和前两种的区别前两种你必须明确Person类型；后面是你我这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串,按照配置文件加载就可以了。 PS：所谓的框架就是对外提供一些接口，也就是功能扩展的标准，由实现类按照这个接口标准去实现。框架内部如果需要操纵这些实现类的对象完成某些操作，那么只需要把这些实现类的全名（包名+类名）写在某个配置文件中，框架代码只需要读取这个配置文件，就可以获取这个实现类的字节码文件，然后利用反射技术创建这个实现类的对象并且调用相应的方法完成一些操作。 用于描述字节码的类就是Class类，创建对象，可以提取字节码文件中的内容，如字段、构造函数、一般函数。该类就可以获取字节码文件中的所有内容，那么反射就是依靠该类完成的。想要对一个类文件进行解剖，只要获取到该类的字节码文件对象即可。 5. 加载类我们已经知道，main()方法是程序的入口。那是不是在main()方法开始执行之前，所有的class文件都已经加载到方法区中了呢？答案是：NO！通常只有需要执行到使用某个类的代码时，才会去CLASSPATH中加载class文件，如果程序从头到尾都没有使用某个类，那么这个类对应的class文件就不会被加载到内存。 可以导致一个类被加载可能有： 使用一个类的静态方法； 使用一个类的静态属性； 创建这个类的对象； 使用Class.forName()方法加载类； 反序列化一个类的对象； 加载一个类的子类时，也会加载其父类； 加载一个类时，也会加载与该类相关的类。 上面给出的几个可能也只是可能而已，如果当前类没有被加载过，才会去加载，如果已经加载到方法区中了，那么就不可能再去加载。 6. Class 字节码Class 类的实例表示正在运行的 Java 应用程序中的类和接口 方法 说明 forName() 通过类名获取类的字节码 getClassLoader() 获取该类的类加载器 getInterfaces() 获取所实现的接口 getSuperclass() 获取父类 getGenericSuperclass() 获取传递给父类参数化类型 newInstance() 创建实例 getName() 获取类名，接口名 getPackage() 获取包名 isPrimitive() 判定指定的 Class 对象是否表示一个基本类型 isArray() 判定此 Class 对象是否表示一个数组类 getResourceAsStream() 查找具有给定名称的资源 6.1 获取注解 方法 说明 getAnnotation() 获取指定类型的注解 getAnnotations() 获取所有的注解 getDeclaredAnnotations() 获取除了继承得到的所有注解 6.2 获取构造方法 方法 说明 getConstructor() 获取指定的非私有的构造方法 getDeclaredConstructor() 获取指定的构造方法 getConstructors() 获取公有的构造方法 getDeclaredConstructors() 获取所有的构造方法 6.3 获取成员方法 方法 说明 getMethod() 获取指定的非私有方法 getDeclaredMethod() 获取指定的方法 getMethods() 获取公有的方法 getDeclaredMethods() 获取所有的方法 6.4 获取成员变量 方法 说明 getField() 获取指定名称的字段 getFields() 获取公有的字段 getDeclaredField(String name) 获取指定名称的字段 getDeclaredFields() 获取所有的字段 7. AccessibleObjectAccessibleObject 类是 Field、Method 和 Constructor 对象的基类 方法 说明 getAnnotation() 获取指定类型的注解 getAnnotations() 获取所有的注解 getDeclaredAnnotations() 获取除了继承得到的所有注解 setAccessible(true) 暴力反射，取消访问检查 8. ConstructorConstructor 提供关于类的单个构造方法的信息以及对它的访问权限 方法 说明 newInstance() 通过构造方法创建实例 getParameterTypes() 获取构造器的所有参数的类型 getExceptionTypes() 获取构造器上声明的所有异常类型 getDeclaringClass() 获取构造器所属的类型 getModifiers() 获取构造器上的所有修饰符信息 9. Method表示一个类中的成员方法 方法 说明 invoke(Object obj, Object… args) 通过方法反射对象调用方法，如果当前方法是实例方法，那么当前对象就是obj，如果当前方法是static方法，那么可以给obj传递null。args表示是方法的参数 setAccessible(true) 暴力反射，取消访问检查 getAnnotation() 获取方法上指定类型的注解 getAnnotations() 获取所有的注解 getDeclaredAnnotations() 获取方法上说所有的注解 getGenericParameterTypes() 获取泛型的参数化类型 getModifiers() 获取方法的权限修饰符，Modifier.PUBLIC，Modifier.ABSTRACT，Modifier.STATIC getParameterTypes() 获取方法参数 10. Field表示一个类中的成员变量 方法 说明 getAnnotation() 获取字段上指定类型的注解 getAnnotations() 获取所有的注解 getDeclaredAnnotations() 获取字段所有的注解 set() 给指定字段设置新值 get() 获取字段值 setAccessible(true) 暴力反射，取消访问检查 getType() 获取字段的类型 getXXX(Object obj) 如果当前属性为基本类型，可以使用getXXX()系列方法获取基本类型属性值 setXXX(Object obj, XXX value) 如果当前属性为基本类型，可以使用setXXX()系统方法基本类型属性值 11. TypeType 是 Java 编程语言中所有类型的公共高级接口 11.1 ParameterizedTypeParameterizedType 表示参数化类型，如 Collection 方法 说明 Type[ ] getActualTypeArguments() 获取真实参数 123456789101112public abstract class BaseProtocol&lt;T&gt; &#123; ... /**泛型解析*/ protected T parsejson(String jsonString)&#123; ParameterizedType genericSuperclass = (ParameterizedType) getClass().getGenericSuperclass(); Type[] args = genericSuperclass.getActualTypeArguments(); Type type = args[0]; return GsonUtil.changeGsonToBean(jsonString,type); &#125;&#125; 12. ArrayArray 类提供了动态创建和访问 Java 数组的方法 方法 说明 Array.getLenght() 获取数组的长度 Array.get() 获取数组中指定索引的值 13. ModifierModifier类有一系列的static方法用来解析其他getModifiers()方法返回的int值 12345Method m = …int m = m.getModifiers();boolean b1 = Modifier.isAbstract(m);//解析m中是否包含abstract修饰boolean b2 = Modifier.isStatic(m);//解析m中是否包含static修饰String s = Modifiers.toString(m);//把所有修饰都转换成字符串 14. 反射的应用通过反射获取构造方法并使用 123456789101112131415161718192021222324252627282930package cn.itcast_02;import java.lang.reflect.Constructor;/* * 需求：通过反射获取私有构造方法并使用 * private Person(String name)&#123;&#125; * * Person p = new Person("风清扬"); * System.out.println(p); */public class ReflectDemo3 &#123; public static void main(String[] args) throws Exception &#123; // 获取字节码文件对象 Class c = Class.forName("cn.itcast_01.Person"); // 获取私有构造方法对象 // NoSuchMethodException：每个这个方法异常 // 原因是一开始我们使用的方法只能获取公共的，下面这种方式就可以了。 Constructor con = c.getDeclaredConstructor(String.class); // 用该私有构造方法创建对象 // IllegalAccessException:非法的访问异常。 // 暴力访问 con.setAccessible(true);// 值为true则指示反射的对象在使用时应该取消Java语言访问检查。 Object obj = con.newInstance("风清扬"); System.out.println(obj); &#125;&#125; 通过反射获取成员变量并使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.itcast_03;import java.lang.reflect.Constructor;import java.lang.reflect.Field;/* * 通过发生获取成员变量并使用 */public class ReflectDemo &#123; public static void main(String[] args) throws Exception &#123; // 获取字节码文件对象 Class c = Class.forName("cn.itcast_01.Person"); // 获取所有的成员变量 // Field[] fields = c.getFields(); // Field[] fields = c.getDeclaredFields(); // for (Field field : fields) &#123; // System.out.println(field); // &#125; /* * Person p = new Person(); p.address = "北京"; System.out.println(p); */ // 通过无参构造方法创建对象 Constructor con = c.getConstructor(); Object obj = con.newInstance(); System.out.println(obj); // 获取单个的成员变量 // 获取address并对其赋值 Field addressField = c.getField("address"); // public void set(Object obj,Object value) // 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 addressField.set(obj, "北京"); // 给obj对象的addressField字段设置值为"北京" System.out.println(obj); // 获取name并对其赋值 // NoSuchFieldException Field nameField = c.getDeclaredField("name"); // IllegalAccessException nameField.setAccessible(true); nameField.set(obj, "林青霞"); System.out.println(obj); // 获取age并对其赋值 Field ageField = c.getDeclaredField("age"); ageField.setAccessible(true); ageField.set(obj, 27); System.out.println(obj); &#125;&#125; 通过反射获取成员方法并使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.itcast_04;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class ReflectDemo &#123; public static void main(String[] args) throws Exception &#123; // 获取字节码文件对象 Class c = Class.forName("cn.itcast_01.Person"); // 获取所有的方法 // Method[] methods = c.getMethods(); // 获取自己的包括父亲的公共方法 // Method[] methods = c.getDeclaredMethods(); // 获取自己的所有的方法 // for (Method method : methods) &#123; // System.out.println(method); // &#125; Constructor con = c.getConstructor(); Object obj = con.newInstance(); /* * Person p = new Person(); p.show(); */ // 获取单个方法并使用 // public void show() // public Method getMethod(String name,Class&lt;?&gt;... parameterTypes) // 第一个参数表示的方法名，第二个参数表示的是方法的参数的class类型 Method m1 = c.getMethod("show"); // obj.m1(); // 错误 // public Object invoke(Object obj,Object... args) // 返回值是Object接收,第一个参数表示对象是谁，第二参数表示调用该方法的实际参数 m1.invoke(obj); // 调用obj对象的m1方法 System.out.println("----------"); // public void method(String s) Method m2 = c.getMethod("method", String.class); m2.invoke(obj, "hello"); System.out.println("----------"); // public String getString(String s, int i) Method m3 = c.getMethod("getString", String.class, int.class); Object objString = m3.invoke(obj, "hello", 100); System.out.println(objString); // String s = (String)m3.invoke(obj, "hello",100); // System.out.println(s); System.out.println("----------"); // private void function() Method m4 = c.getDeclaredMethod("function"); m4.setAccessible(true); m4.invoke(obj); &#125;&#125; 14.1 反射应用举例给ArrayList&lt;Integer&gt;的一个对象，在这个集合中添加一个字符串数据，如何实现呢？ 1234567891011121314151617181920212223242526272829package cn.itcast.test;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;/* * 我给你ArrayList&lt;Integer&gt;的一个对象，我想在这个集合中添加一个字符串数据，如何实现呢？ */public class ArrayListDemo &#123; public static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; // 创建集合对象 ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); // array.add("hello"); // array.add(10); Class c = array.getClass(); // 集合ArrayList的class文件对象 Method m = c.getMethod("add", Object.class); m.invoke(array, "hello"); // 调用array的add方法，传入的值是hello m.invoke(array, "world"); m.invoke(array, "java"); System.out.println(array); &#125;&#125; 通过配置文件运行类中的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.itcast.test;import java.io.FileReader;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.Properties;/* * 通过配置文件运行类中的方法 * * 反射： * 需要有配置文件配合使用。 * 用class.txt代替。 * 并且你知道有两个键。 * className * methodName */public class Test &#123; public static void main(String[] args) throws Exception &#123; // 反射前的做法 // Student s = new Student(); // s.love(); // Teacher t = new Teacher(); // t.love(); // Worker w = new Worker(); // w.love(); // 反射后的做法 // 加载键值对数据 Properties prop = new Properties(); FileReader fr = new FileReader("class.txt"); prop.load(fr); fr.close(); // 获取数据 String className = prop.getProperty("className"); String methodName = prop.getProperty("methodName"); // 反射 Class c = Class.forName(className); Constructor con = c.getConstructor(); Object obj = con.newInstance(); // 调用方法 Method m = c.getMethod(methodName); m.invoke(obj); &#125;&#125; 写一个方法：public void setProperty(Object obj, String propertyName, Object value){}，此方法可将obj对象中名为propertyName的属性的值设置为value12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.itcast.test;import java.lang.reflect.Field;public class Tool &#123; public void setProperty(Object obj, String propertyName, Object value) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123; // 根据对象获取字节码文件对象 Class c = obj.getClass(); // 获取该对象的propertyName成员变量 Field field = c.getDeclaredField(propertyName); // 取消访问检查 field.setAccessible(true); // 给对象的成员变量赋值为指定的值 field.set(obj, value); &#125;&#125;package cn.itcast.test;public class ToolDemo &#123; public static void main(String[] args) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123; Person p = new Person(); Tool t = new Tool(); t.setProperty(p, "name", "林青霞"); t.setProperty(p, "age", 27); System.out.println(p); System.out.println("-----------"); Dog d = new Dog(); t.setProperty(d, "sex", '男'); t.setProperty(d, "price", 12.34f); System.out.println(d); &#125;&#125;class Dog &#123; char sex; float price; @Override public String toString() &#123; return sex + "---" + price; &#125;&#125;class Person &#123; private String name; public int age; @Override public String toString() &#123; return name + "---" + age; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载器]]></title>
    <url>%2F2017%2F04%2F30%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[系列阅读 Java基础：类加载器 Java基础：反射 Java基础：注解 Java基础：动态代理 1. 什么是类加载器类加载器就是用来加载类的东西！类加载器也是一个类：ClassLoader 类加载器可以被加载到内存，是通过类加载器完成的！Java虚拟机中可以安装多个类加载器，系统默认三个主要类加载器，每个类负责加载特定位置的类： BootStrap：引导类加载器，加载rt.jar中的类 ExtClassLoader：扩展类加载器，加载lib/ext目录下的类 AppClassLoader：系统类加载器，加载CLASSPATH下的类，即我们写的类，以及第三方提供的类 类加载器之间存在上下级关系，系统类加载器的上级是扩展类加载器，而扩展类加载器的上级是引导类加载器 类加载器也是Java类，因为其它java类的类加载器本身也要被类加载器加载，显然必须有第一个类加载器不是java类，这正是BootStrap。 Java虚拟机中的所有类装载器采用具有父子关系的树形结构进行组织，在实例化每个类装载器对象时，需要为其指定一个父级类装载器对象或者默认采用系统类装载器为其父级类加载 2. 类的加载当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。 2.1 加载就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。 2.2 连接 验证：是否有正确的内部结构，并和其他类协调一致 准备：负责为类的静态成员分配内存，并设置默认初始化值 解析：将类的二进制数据中的符号引用替换为直接引用 2.3 初始化类会在首次被“主动使用”时执行初始化，为类（静态）变量赋予正确的初始值。在Java代码中，一个正确的初始值是通过类变量初始化语句或者静态初始化块给出的。 初始化一个类包括两个步骤： 如果类存在直接父类的话，且直接父类还没有被初始化，则先初始化其直接父类 如果类存在一个初始化方法，就执行此方法 注：初始化接口并不需要初始化它的父接口。 3. 类初始化时机 创建类的实例 访问类的静态变量，或者为静态变量赋值 调用类的静态方法 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 4. 类加载器负责将.class文件加载到内在中，并为之生成对应的Class对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。 4.1 类加载器的组成 BootstrapClassLoader 根类加载器 ExtensionClassLoader 扩展类加载器 SysetmClassLoader 系统类加载器 4.2类加载器的作用1、Bootstrap ClassLoader 根类加载器 也被称为引导类加载器，负责Java核心类的加载，比如System，String等。在JDK中JRE的lib目录下rt.jar文件中。 2、Extension ClassLoader 扩展类加载器 负责JRE的扩展目录中jar包的加载。在JDK中JRE的lib目录下ext目录 3、Sysetm ClassLoader 系统类加载器 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径。通过这些描述我们就可以知道我们常用的东西的加载都是由谁来完成的。到目前为止我们已经知道把class文件加载到内存了，那么，如果我们仅仅站在这些class文件的角度，我们如何来使用这些class文件中的内容呢?这就是我们反射要研究的内容。 5. JVM眼中的相同的类在JVM中，不可能存在一个类被加载两次的事情！一个类如果已经被加载了，当再次试图加载这个类时，类加载器会先去查找这个类是否已经被加载过了，如果已经被加载过了，就不会再去加载了。 但是，如果一个类使用不同的类加载器去加载是可以出现多次加载的情况的！也就是说，在JVM眼中，相同的类需要有相同的class文件，以及相同的类加载器。当一个class文件，被不同的类加载器加载了，JVM会认识这是两个不同的类，这会在JVM中出现两个相同的Class对象！甚至会出现类型转换异常！ 6. 类加载器的委托机制首先委托类加载器的父类去加载，如果父类无法加载则自己加载 当系统类加载器去加载一个类时，它首先会让上级去加载，即让扩展类加载器去加载类，扩展类加载器也会让它的上级引导类加载器去加载类。如果上级没有加载成功，那么再由自己去加载！ 例如我们自己写的Person类，一定是存放到CLASSPATH中，那么一定是由系统类加载器来加载。当系统类加载器来加载类时，它首先把加载的任务交给扩展类加载去，如果扩展类加载器加载成功了，那么系统类加载器就不会再去加载。这就是代理模式了！ 相同的道理，扩展类加载器也会把加载类的任务交给它的“上级”，即引导类加载器，引导类加载器加载成功，那么扩展类加载器也就不会再去加载了。引导类加载器是用C语言写的，是JVM的一部分，它是最上层的类加载器了，所以它就没有“上级了”。它只负责去加载“内部人”，即JDK中的类，但我们知道Person类不是我们自己写的类，所以它加载失败。 当扩展类加载器发现“上级”不能加载类，它就开始加载工作了，它加载的是lib\ext目录下的jar文件，当然，它也会加载失败，所以最终还是由系统类加载器在CLASSPATH中去加载Person，最终由系统类加载器加载到了Person类。 代理模式保证了JDK中的类一定是由引导类加载加载的！这就不会出现多个版本的类，这也是代理模式的好处。 6.1 类加载器之间的父子关系和管辖范围图 7. 自定义类加载器我们也可以通过继承ClassLoader类来完成自定义类加载器，自定义类加载器的目的一般是为了加载网络上的类，因为这会让class在网络中传输，为了安全，那么class一定是需要加密的，所以需要自定义的类加载器来加载（自定义的类加载器需要做解密工作）。 ClassLoader加载类都是通过loadClass()方法来完成的，loadClass()方法的工作流程如下： 调用findLoadedClass()方法查看该类是否已经被加载过了，如果该没有加载过，那么这个方法返回null 判断findLoadedClass()方法返回的是否为null，如果不是null那么直接返回，这可以避免同一个类被加载两次 如果findLoadedClass()返回的是null，那么就启动代理模式（委托机制），即调用上级的loadClass()方法，获取上级的方法是getParent()，当然上级可能还有上级，这个动作就一直向上走 如果getParent().loadClass()返回的不是null，这说明上级加载成功了，那么就加载结果 如果上级返回的是null，这说明需要自己出手了，这时loadClass()方法会调用本类的findClass()方法来加载类 这说明我们只需要重写ClassLoader的findClass()方法，这就可以了！如果重写了loadClass()方法覆盖了代理模式！ OK，通过上面的分析，我们知道要自定义一个类加载器，只需要继承ClassLoader类，然后重写它的findClass()方法即可。那么在findClass()方法中我们要完成哪些工作呢？ 找到class文件，把它加载到一个byte[]中； 调用defineClass()方法，把byte[]传递给这个方法即可。 loadClass()方法的实现代码12345678910111213141516171819202122protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = findLoadedClass(className); if (clazz == null) &#123; ClassNotFoundException suppressed = null; try &#123; clazz = parent.loadClass(className, false); &#125; catch (ClassNotFoundException e) &#123; suppressed = e; &#125; if (clazz == null) &#123; try &#123; clazz = findClass(className); &#125; catch (ClassNotFoundException e) &#123; e.addSuppressed(suppressed); throw e; &#125; &#125; &#125; return clazz;&#125; 自定义类加载器FileSystemClassLoader1234567891011121314151617181920212223242526272829public class FileSystemClassLoader extends ClassLoader &#123; private String classpath; public FileSystemClassLoader() &#123;&#125; public FileSystemClassLoader(String classpath) &#123; this.classpath = classpath; &#125; @Override public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; try &#123; byte[] datas = getClassData(name); if(datas == null) &#123; throw new ClassNotFoundException("类没有找到：" + name); &#125; return this.defineClass(name, datas, 0, datas.length); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new ClassNotFoundException("类找不到：" + name); &#125; &#125; private byte[] getClassData(String name) throws IOException &#123; name = name.replace(".", "\\") + ".class"; File classFile = new File(classpath, name); return FileUtils.readFileToByteArray(classFile); &#125;&#125; 12345ClassLoader loader = new FileSystemClassLoader("F:\\classpath");Class clazz = loader.loadClass("cn.itcast.utils.CommonUtils");Method method = clazz.getMethod("md5", String.class);String result = (String) method.invoke(null, "qdmmy6");System.out.println(result); 8. ClassLoader 方法 说明 getParent() 获取上级类加载器 loadClass() 实现了类加载的加载流程，也就是算法框架 findLoadedClass() 查看该类是否被加载过 findClass() 真正去加载类，自定义类加载器需要重写的方法 defineClass() 把Class的字节数组byte[]转成Class]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解]]></title>
    <url>%2F2017%2F04%2F30%2F%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[系列阅读 Java基础：类加载器 Java基础：反射 Java基础：注解 Java基础：动态代理 1. 概述注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记，没加，则等于没有某种标记，以后，javac编译器，开发工具和其他程序可以用反射来了解你的类及各种元素上有无何种标记，看你有什么标记，就去干相应的事。标记可以加在包，类，字段，方法，方法的参数以及局部变量上 开发中常见注解： @Override：作用在方法上的注解。当方法不是重写父类的方法时会报错 @Deprecated：作用在方法上。标记该方法为作废方法（已过时） @SuppressWarnings：作用在方法上，压制警告 应用 标记一些信息 运行时动态处理 编译时动态处理 2. 注解类型8种基本数据类型，String，Class，enum，annotation，以上类型的数组类型 3. 定义注解123456@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface ViewInject &#123; int value();//当使用注解时，如果只给名为value的属性赋值时，可以省略“value=” String name() default "zhangsan";//默认值&#125; @interface使用@interface声明一个注解类 @Target表示注解的作用目标，是一个枚举值 作用目标 说明 ElementType.FIELD 作用于成员变量 ElementType.METHOD 作用于方法 ElementType.CONSTRUCTOR 作用于构造方法 ElementType.PARAMETER 作用于方法的参数 ElementType.TYPE 作用于类，接口，enum， Annotation @Retention表示注解的保存策略，也是一个枚举值 注解的保留策略是指，注解是只保留在源代码上，还是保留到class文件上，再或者是类在运行时，可以被类加载器加载到内存中。 如果希望注解被反射，那么注解就要保留到运行时，而不是源代码或类文件上。 指定注解的保留策略需要使用元注解@Retention，它有一个value属性，类型为RetentionPolicy类型，RetentionPolicy是枚举类型 保存策略 说明 RetentionPolicy.SOURCE 注解只保存在源代码中，即.java文件 RetentionPolicy.CLASS 注解保存在字节码中,即.class文件 RetentionPolicy.RUNTIME 注解保存在内存中的字节码，可用于反射 注解的属性1String name() default "zhangsan";//默认值 定义注解的属性，有点像java类中的方法，上面的代码定义了一个类型为String类型，注解名为name的属性，default是给注解设置默认值 value属性1String value() default "xxx"; 如果注解中有一个名称为value的属性，且你只想设置value属性（即其他属性都采用默认值或者你只有一个value属性），那么可以省略value=部分，例如：@MyAnnotation(“AllenIverson”) 数组类型的属性12int [] arrayAttr() default &#123;1,2,3&#125;;//定义@MyAnnotation(arrayAttr=&#123;2,3,4&#125;)//使用 如果数组属性中只有一个元素，这时候属性值部分可以省略大括 4. Annotation4.1 注解的应用结构图 Annotation 方法声明 功能描述 annotationType() 获取注解类型 4.2 反射注解类上的注解：使用Class获取 Class.getAnnotation()：获取指定类型的注解 Class.getAnnotations()：获取所有的注解 Class.getDeclaredAnnotations()：获取除了继承得到的所有注解 方法上的注解：使用Method获取 Method.getAnnotation() ：获取方法上指定类型的注解 Method.getAnnotations()：获取所有的注解 Method.getDeclaredAnnotations()：获取除了继承得到的所有注解 构造方法上的注解：使用Constructor获取 Constructor.getAnnotation()获取指定类型的注解 Constructor.getAnnotations()获取所有的注解 Constructor.getDeclaredAnnotations() 获取除了继承得到的所有注解 属性上的注解：使用Field获取 Field.getAnnotation()：获取字段上指定类型的注解 Field.getAnnotations()：获取所有的注解 Field.getDeclaredAnnotations()：获取字段所有的注解 定义注解123456@Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface MyAnn &#123; String value() default "hello"; int value1() default 100;&#125; 使用注解 1234567@MyAnn(value="hello world", value1=200)public class MyClass &#123; private int a; @MyAnn("myMethod") public void fun() &#123;&#125;&#125; 通过反射读取注解 12345678910111213public class Demo1 &#123; public static void main(String[] args) throws Exception &#123; Class clazz = MyClass.class; MyAnn myAnn = (MyAnn) clazz.getAnnotation(MyAnn.class); System.out.println(myAnn.value()); System.out.println(myAnn.value1()); Method method = clazz.getMethod("fun"); MyAnn myAnn1 = method.getAnnotation(MyAnn.class); System.out.println(myAnn1.value()); System.out.println(myAnn1.value1()); &#125;&#125; 4.3 实现注解小框架123456789101112131415161718192021222324252627282930313233343536373839404142public class ViewUtils &#123; public static void inject(Activity activity) throws IllegalAccessException &#123; bindView(activity); &#125; private static void bindView(Activity activity) throws IllegalAccessException &#123; Field[] fields = activity.getClass().getDeclaredFields(); for (Field field : fields)&#123; ViewInject viewInject = field.getAnnotation(ViewInject.class); if (viewInject != null)&#123; int resId = viewInject.value(); View view = activity.findViewById(resId); field.setAccessible(true); field.set(activity,view); &#125; &#125; &#125; public static void onClick(final Activity activity)&#123; Method[] methods = activity.getClass().getDeclaredMethods(); for (final Method method : methods)&#123; Onclick onclick = method.getAnnotation(Onclick.class); if (onclick != null)&#123; int resId = onclick.value(); final View view = activity.findViewById(resId); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; method.setAccessible(true); try &#123; method.invoke(activity,view); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; &#125;&#125; 5. Annotation Processing Tool编译时注解在项目编译的时候生成新的Java文件，这样可以减少手动的代码输入，而且可以不用使用反射，对程序不会造成性能影响。 AbstractProcessor注解处理器，javac 自带的一个工具，用来在编译时期扫描处理注解信息 process() init() Filer Elements Messager Android 如何编写基于编译时注解的项目 Android 打造编译时注解解析框架 这只是一个开始 Android公共技术点之二-Annotation Processing Tool Annotation-Processing-Tool详解 Java 生成器源代码集合 6. javapoet动态生成Java代码，ButterKnife使用了该框架，实现了编译时注解 javapoet——让你从重复无聊的代码中解放出来 7. 注解框架 Dagger1 Dagger2 Guice Butterknife androidannotations]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程]]></title>
    <url>%2F2017%2F04%2F30%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 网络编程概述1.1 计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。 1.2 网络编程就是用来实现网络互连的不同计算机上运行的程序间可以进行数据交换。 1.3 网络模型计算机网络之间以何种规则进行通信，就是网络模型研究问题。 网络模型一般是指OSI（Open System Interconnection开放系统互连）参考模型或者TCP/IP参考模型。 应用层：http、https、ftp，传输层：TCP、UDP，网络层：IP，物理层，数据链路层 1.4 网络模型7层概述 物理层 主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 数据链路层 主要将从物理层接收的数据进行MAC地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。 网络层 主要将从下层接收到的数据进行IP地址（例192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。 传输层 定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 会话层 通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） 表示层 主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。 应用层 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西．就是终端应用）。 PS： 每个网卡的MAC地址都是全球唯一的。 路由器实现将数据包发送到指定的地点。 应用软件之间通信的过程就是层与层之间封包、解封包的过程。 OSI参考模型虽然设计精细，但过于麻烦，效率不高，因此才产生了简化版的TCP/IP参考模型。 1.5 封包、解封包的过程 2. 网络编程三要素网络模型说完了,我们要进行通讯,需要哪些要素呢? 比如说：我要跟你说话第一个条件：我要先找到你 (IP)第二个条件：你得有接收数据的地方，耳朵 (端口)第三个条件：我跟你说话,你能接收到,咱按什么方式接收啊,我说英文你懂吗,说韩文你懂吗,不懂是吧,所以我还是说中文把(协议) 2.1 IP地址网络中计算机的唯一标识，不易记忆，可用主机名。本地回环地址：127.0.0.1，主机名：localhost。计算机只能识别二进制的数据，所以我们的IP地址应该是一个二进制的数据。为了方便表示IP地址，我们就把IP地址的每一个字节上的数据换算成十进制，然后用.分开来表示：”点分十进制”。 所谓IP地址就是给每个连接在Internet上的主机分配的一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，比特换算成字节，就是4个字节。例如一个采用二进制形式的IP地址是“00001010000000000000000000000001”，这么长的地址，人们处理起来也太费劲了。为了方便人们的使用，IP地址经常被写成十进制的形式，中间使用符号“.”分开不同的字节。于是，上面的IP地址可以表示为“10.0.0.1”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多。 通过ping 127.0.0.1可以测试网络是不是通，如果不通，可能是网卡出问题了 通过ping命令还可以获取到url对应的IP地址，例如获取网易新闻url（c.m.163.com）的IP地址 查看本机IP地址ipconfig IP地址分类IP地址的组成：IP地址 = 网络号码+主机地址 IPV4数量已经不够分配，所以产生了IPV6。 InetAddress类的使用此类表示互联网协议 (IP) 地址 返回值 方法 说明 InetAddress getByName(String host) 根据主机名或者IP地址的字符串表示得到IP地址对象 String getHostName() 获取此 IP 地址的主机名 String getHostAddress() 返回 IP 地址字符串 代码示例：123456789101112131415161718package cn.itcast_01;import java.net.InetAddress;import java.net.UnknownHostException;public class InetAddressDemo &#123; public static void main(String[] args) throws UnknownHostException &#123; // public static InetAddress getByName(String host) // InetAddress address = InetAddress.getByName("liuyi"); // InetAddress address = InetAddress.getByName("192.168.12.92"); InetAddress address = InetAddress.getByName("192.168.12.63"); // 获取两个东西：主机名，IP地址 // public String getHostName() String name = address.getHostName(); // public String getHostAddress() String ip = address.getHostAddress(); System.out.println(name + "---" + ip); &#125;&#125; 运行结果： 2.2 端口号正在运行的程序的标识，用于标识进程的逻辑地址，不同进程的标识。有效端口：0~65535，其中0~1024系统使用或保留端口。 端口分为：物理端口，网卡口；逻辑端口，我们指的就是逻辑端口。 A：每个网络程序都会至少有一个逻辑端口 B：用于标识进程的逻辑地址，不同进程的标识 C：有效端口：0~65535，其中0~1024系统使用或保留端口。 D：所谓防火墙，其功能就是将发送到某程序端口的数据屏蔽掉以及将从该程序端口发出的数据也屏蔽掉。 2.3 传输协议传输协议就是通讯的规则，常见协议：TCP，UDP。 UDP将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小在限制在64k；因无连接，是不可靠协议；不需要建立连接，速度快 TCP建立连接，形成传输数据的通道；在连接中进行大数据量传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍低 UDP和TCP的特点 UDP：面向无连接；不可靠；速度快；将数据封包传输，数据包最大64k举例：聊天留言，在线视频，视频会议，发短信，邮局包裹。 TCP：面向连接；安全可靠效率稍低；通过三次握手确保连接的建立。举例：下载，打电话，QQ聊天(你在线吗,在线,就回应下,就开始聊天了) 2.4 域名解析在浏览器中输入新浪的域名，DNS解析域名成IP，然后计算机再通过获取到的IP访问新浪服务器。 域名解析，最先走是本地的hosts（C:\WINDOWS\system32\drivers\etc\hosts）文件，解析失败了，才去访问DNS服务器解析、获取IP地址。 123456789101112131415import java.net.InetAddress;import java.net.UnknownHostException;public class IPDemo&#123; public static void main(String[] args) throws UnknownHostException &#123; InetAddress ip = InetAddress.getLocalHost(); ip = InetAddress.getByName("192.168.1.110"); System.out.println(ip.getHostAddress()); System.out.println(ip.getHostName()); &#125;&#125; 运行结果 应用：通过hosts文件可以屏蔽游戏网站内容弹出，例如：在hosts文件中添加，127.0.0.1 www.game18.com 3. Socket套接字3.1 Socket套接字网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 3.2 Socket原理机制 通信的两端都有Socket 网络通信其实就是Socket间的通信 数据在两个Socket间通过IO传输 3.3 Socket机制图解 4. UDP编程UDP：UDP 协议全称是用户数据报协议，在网络中它与TCP 协议一样用于处理数据包，是一种无连接的协议。在OSI 模型中，在第四层——传输层，处于IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。UDP 协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天UDP 仍然不失为一项非常实用和可行的网络传输层协议。 4.1 UDP传输 DatagramSocket与DatagramPacket 建立发送端，接收端 建立数据包 调用Socket的发送接收方法 关闭Socket 发送端与接收端是两个独立的运行程序 4.2 DatagramSocket此类表示用来发送和接收数据报包的套接字 数据报套接字是包投递服务的发送或接收点。每个在数据报套接字上发送或接收的包都是单独编址和路由的。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达 在 DatagramSocket 上总是启用 UDP 广播发送。为了接收广播包，应该将 DatagramSocket 绑定到通配符地址。在某些实现中，将 DatagramSocket 绑定到一个更加具体的地址时广播包也可以被接收。 构造方法 12DatagramSocket(int port) // 创建数据报套接字并将其绑定到本地主机上的指定端口DatagramSocket(int port, InetAddress laddr) // 创建数据报套接字，将其绑定到指定的本地地址 UDP传输-发送端思路 建立udp的socket服务 将要发送的数据封装成数据包 通过udp的socket服务,将数据包发送出 关闭资源 123456789101112131415161718192021222324252627282930313233343536373839package cn.itcast_02;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;/* * UDP协议发送数据： * A:创建发送端Socket对象 * B:创建数据，并把数据打包 * C:调用Socket对象的发送方法发送数据包 * D:释放资源 */public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建发送端Socket对象 // DatagramSocket() DatagramSocket ds = new DatagramSocket(); // 创建数据，并把数据打包 // DatagramPacket(byte[] buf, int length, InetAddress address, int port) // 创建数据 byte[] bys = "hello,udp,我来了".getBytes(); // 长度 int length = bys.length; // IP地址对象 InetAddress address = InetAddress.getByName("192.168.12.92"); // 端口 int port = 10086; DatagramPacket dp = new DatagramPacket(bys, length, address, port); // 调用Socket对象的发送方法发送数据包 // public void send(DatagramPacket p) ds.send(dp); // 释放资源 ds.close(); &#125;&#125; 4.3 DatagramPacket此类表示数据报包。数据报包用来实现无连接包投递服务。每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。不对包投递做出保证。 构造方法 DatagramPacket(byte[] buf, int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 DatagramPacket(byte[] buf, int length, InetAddress address, int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。 DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)构造数据报包，用来将长度为 length 偏移量为 offset 的包发送到指定主机上的指定端口号。 UDP传输-接收端思路 建立udp的socket服务. 通过receive方法接收数据 将收到的数据存储到数据包对象中 通过数据包对象的功能来完成对接收到数据进行解析 可以对资源进行关闭 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.itcast_02;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;/* * UDP协议接收数据： * A:创建接收端Socket对象 * B:创建一个数据包(接收容器) * C:调用Socket对象的接收方法接收数据 * D:解析数据包，并显示在控制台 * E:释放资源 */public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建接收端Socket对象 // DatagramSocket(int port) DatagramSocket ds = new DatagramSocket(10086); // 创建一个数据包(接收容器) // DatagramPacket(byte[] buf, int length) byte[] bys = new byte[1024]; int length = bys.length; DatagramPacket dp = new DatagramPacket(bys, length); // 调用Socket对象的接收方法接收数据 // public void receive(DatagramPacket p) ds.receive(dp); // 阻塞式 // 解析数据包，并显示在控制台 // 获取对方的ip // public InetAddress getAddress() InetAddress address = dp.getAddress(); String ip = address.getHostAddress(); // public byte[] getData():获取数据缓冲区 // public int getLength():获取数据的实际长度 byte[] bys2 = dp.getData(); int len = dp.getLength(); String s = new String(bys2, 0, len); System.out.println(ip + "传递的数据是:" + s); // 释放资源 ds.close(); &#125;&#125; 运行结果： 4.4 UDP案例从键盘录入数据进行发送，如果输入的是886那么客户端就结束输入数据。 发送端 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.itcast_04;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;/* * 数据来自于键盘录入 * 键盘录入数据要自己控制录入结束。 */public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建发送端的Socket对象 DatagramSocket ds = new DatagramSocket(); // 封装键盘录入数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = null; while ((line = br.readLine()) != null) &#123; if ("886".equals(line)) &#123; break; &#125; // 创建数据并打包 byte[] bys = line.getBytes(); // DatagramPacket dp = new DatagramPacket(bys, bys.length, // InetAddress.getByName("192.168.12.92"), 12345); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.12.255"), 12345); // 发送数据 ds.send(dp); &#125; // 释放资源 ds.close(); &#125;&#125; 运行结果： 接收端 1234567891011121314151617181920212223242526272829303132333435package cn.itcast_04;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;/* * 多次启动接收端： * java.net.BindException: Address already in use: Cannot bind * 端口被占用。 */public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建接收端的Socket对象 DatagramSocket ds = new DatagramSocket(12345); while (true) &#123; // 创建一个包裹 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); // 接收数据 ds.receive(dp); // 解析数据 String ip = dp.getAddress().getHostAddress(); String s = new String(dp.getData(), 0, dp.getLength()); System.out.println("from " + ip + " data is : " + s); &#125; // 释放资源 // 接收端应该一直开着等待接收数据，是不需要关闭 // ds.close(); &#125;&#125; 运行结果： 5. TCP编程TCP/IP：Transmission Control Protocol/Internet Protocol 的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet 最基本的协议、Internet 国际互联网络的基础，由网络层的IP 协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4 层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP 负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP 是给因特网的每一台联网设备规定一个地址。 TCP/IP 协议栈主要分为四层:应用层、传输层、网络层、数据链路层,每层都有相应的协议，如下图： 所谓的协议就是双方进行数据传输的一种格式。 5.1 TCP传输 Socket和ServerSocket 建立客户端和服务器端 建立连接后，通过Socket中的IO流进行数据的传输 关闭socket 同样，客户端与服务器端是两个独立的应用程序。 5.2 Socket此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。 构造方法 Socket(String host, int port) ：创建一个流套接字并将其连接到指定主机上的指定端口号。 Socket(InetAddress address, int port) ：创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 TCP传输-客户端思路 建立客户端的Socket服务,并明确要连接的服务器。 如果连接建立成功,就表明,已经建立了数据传输的通道.就可以在该通道通过IO进行数据的读取和写入.该通道称为Socket流,Socket流中既有读取流,也有写入流. 通过Socket对象的方法,可以获取这两个流 通过流的对象可以对数据进行传输 如果传输数据完毕,关闭资源 123456789101112131415161718192021222324252627282930313233package cn.itcast_06;import java.io.IOException;import java.io.OutputStream;import java.net.Socket;/* * TCP协议发送数据： * A:创建发送端的Socket对象 * 这一步如果成功，就说明连接已经建立成功了。 * B:获取输出流，写数据 * C:释放资源 * * 连接被拒绝。TCP协议一定要先看服务器。 * java.net.ConnectException: Connection refused: connect */public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建发送端的Socket对象 // Socket(InetAddress address, int port) // Socket(String host, int port) // Socket s = new Socket(InetAddress.getByName("192.168.12.92"), 8888); Socket s = new Socket("192.168.12.92", 8888); // 获取输出流，写数据 // public OutputStream getOutputStream() OutputStream os = s.getOutputStream(); os.write("hello,tcp,我来了".getBytes()); // 释放资源 s.close(); &#125;&#125; 5.3 ServerSocket此类实现服务器套接字。服务器套接字等待请求通过网络传入。它基于该请求执行某些操作，然后可能向请求者返回结果。 构造方法1ServerSocket(int port) // 创建绑定到特定端口的服务器套接字 TCP传输-服务器端思路 建立服务器端的socket服务，需要一个端口 服务端没有直接流的操作,而是通过accept方法获取客户端对象，在通过获取到的客户端对象的流和客户端进行通信 通过客户端的获取流对象的方法,读取数据或者写入数据 如果服务完成,需要关闭客户端,然后关闭服务器，但是,一般会关闭客户端,不会关闭服务器,因为服务端是一直提供服务的 12345678910111213141516171819202122232425262728293031323334353637383940package cn.itcast_06;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;/* * TCP协议接收数据： * A:创建接收端的Socket对象 * B:监听客户端连接。返回一个对应的Socket对象 * C:获取输入流，读取数据显示在控制台 * D:释放资源 */public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建接收端的Socket对象 // ServerSocket(int port) ServerSocket ss = new ServerSocket(8888); // 监听客户端连接。返回一个对应的Socket对象 // public Socket accept() Socket s = ss.accept(); // 侦听并接受到此套接字的连接。此方法在连接传入之前一直阻塞。 // 获取输入流，读取数据显示在控制台 InputStream is = s.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); // 阻塞式方法 String str = new String(bys, 0, len); String ip = s.getInetAddress().getHostAddress(); System.out.println(ip + "---" + str); // 释放资源 s.close(); // ss.close(); //这个不应该关闭 &#125;&#125; 5.4 TCP传输案例客户端键盘录入，服务器输出到控制台 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940package cn.itcast_08;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;/* * 客户端键盘录入，服务器输出到控制台 */public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建客户端Socket对象 Socket s = new Socket("192.168.12.92", 22222); // 键盘录入数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // 把通道内的流给包装一下 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter( s.getOutputStream())); String line = null; while ((line = br.readLine()) != null) &#123; // 键盘录入数据要自定义结束标记 if ("886".equals(line)) &#123; break; &#125; bw.write(line); bw.newLine(); bw.flush(); &#125; // 释放资源 // bw.close(); // br.close(); s.close(); &#125;&#125; 运行结果： 服务器端： 1234567891011121314151617181920212223242526272829package cn.itcast_08;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建服务器Socket对象 ServerSocket ss = new ServerSocket(22222); // 监听客户端连接 Socket s = ss.accept(); // 包装通道内容的流 BufferedReader br = new BufferedReader(new InputStreamReader( s.getInputStream())); String line = null; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; // br.close(); s.close(); // ss.close(); &#125;&#125; 运行结果： 5.5 上传图片案例客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.itcast_13;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.net.Socket;public class UploadClient &#123; public static void main(String[] args) throws IOException &#123; // 创建客户端Socket对象 Socket s = new Socket("192.168.12.92", 19191); // 封装图片文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream( "林青霞.jpg")); // 封装通道内的流 BufferedOutputStream bos = new BufferedOutputStream(s.getOutputStream()); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); bos.flush(); &#125; s.shutdownOutput(); // 读取反馈 InputStream is = s.getInputStream(); byte[] bys2 = new byte[1024]; int len2 = is.read(bys2); String client = new String(bys2, 0, len2); System.out.println(client); // 释放资源 bis.close(); s.close(); &#125;&#125; 服务器端： 123456789101112131415161718192021222324252627282930313233343536373839package cn.itcast_13;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class UploadServer &#123; public static void main(String[] args) throws IOException &#123; // 创建服务器Socket对象 ServerSocket ss = new ServerSocket(19191); // 监听客户端连接 Socket s = ss.accept(); // 封装通道内流 BufferedInputStream bis = new BufferedInputStream(s.getInputStream()); // 封装图片文件 BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream("mn.jpg")); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); bos.flush(); &#125; // 给一个反馈 OutputStream os = s.getOutputStream(); os.write("图片上传成功".getBytes()); bos.close(); s.close(); &#125;&#125; 运行结果： 5.6 TCP传输容易出现的问题 客户端连接上服务端，两端都在等待，没有任何数据传输 通过例程分析：因为read方法或者readLine方法是阻塞式 解决办法：自定义结束标记，使用shutdownInput，shutdownOutput方法 6. TCP、UDP 特点对比TCP 协议是面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达)传输层协议。UDP 协议也是传输层协议，它是无连接，不保证可靠的传输层协议。 TCP UDP 面向连接 面向非连接 可靠的连接 不可靠的连接 速度慢 速度快 大文件、重要的数据等 适合小数据、不重要 7. TCP 三次握手过程1、请求端(通常称为客户)发送一个SYN 段指明客户打算连接的服务器的端口，以及初始序号(ISN) 2、服务器发回包含服务器的初始序号的SYN 报文段(报文段2)作为应答。同时，将确认序号设置为客户的ISN加1 以对客户的SYN 报文段进行确认。 3、客户必须将确认序号设置为服务器的ISN 加1 以对服务器的SYN 报文段进行确认(报文段3)这三个报文段完成连接的建立。这个过程也称为三次握手(three-way handshake)。 上面的过程如下图所示： #8. 客户端和服务器端原理 8.1 常见的客户端、服务器端最常见的客户端：浏览器，IE/chrome最常见的服务端：服务器，Tomcat 8.2 常见网络结构 8.3 URL和URIURI：统一资源标识符URI是统一资源标识符，是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。URI由包括确定语法和相关协议的方案所定义。由是三个组成部分：访问资源的命名机制、存放资源的主机名、资源自身的名称，由路径表示。 URL：统一资源定位符也就是说根据URL能够定位到网络上的某个资源，它是指向互联网“资源”的指针。 每个URL都是URI，但不一定每个URI都是URL。这是因为URI还包括一个子类，即统一资源名称（URN），它命名资源但不指定如何定位资源。 URL是统一资源定位，是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 比如百度URL即是http://www.baidu.com。 9. TCP的三次握手/四次挥手TCP是面向连接的运输层协议，TCP协议提供可靠的连接服务，所以用了建立链接的三次握手和关闭连接的四次挥手来保证可靠服务。通过TCP通信就像是两个应用在打电话一样，打电话前得先拨号建立连接，通话结束后要挂机释放连接。 9.1 建立TCP连接的三次握手TCP连接的三次握手分别为： 客户端发送一个带SYN标志的TCP报文到服务器，表示告诉服务器我想建立一个连接。 服务器收到客户端的带SYN标志的文后，就给客户端回复一个带ACK标志和带SYN标志的报文，ACK表示回复客户端：OK，我准备好了建立连接；然后SYN表示服务器又问客户端：你准备好建立连接了么？ 然后客户端又要发送一个带ACK标志的TCP报文，回答服务器说：我准备好了。然后一个TCP连接就建立起来了。 SYN相当于询问的标志，ACK相当于回复的标志。 这里有一个问题：为什么最后客户端还要发送一次确认呢？这主要是防止已经失效了的请求报文段突然又传到了服务器，因而产生错误。“已经失效了的请求报文段”大致是这样产生的:A发出第一个连接请求报文段并没有丢失，在一些网络结点上面长时间滞留，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但B收到这个失效的报文段后，就误以为是A发出的又一次新的连接请求，于是就向A发出确认报文段，同意建立连接，如果不采用三次握手，那么只要B发出确认后，新的连接就建立了。 9.2 释放TCP连接的四次挥手由于TCP是全双工的，所以在释放TCP连接时，要双方都得单独关闭。意思就是服务器和客户端都要释放连接。原则是某一方主动关闭时，先发一个FIN报文来表示终止这个方向的连接，收到一个FIN报文就意味着这个方向不再有数据流动，但另一个方向仍可以有数据流动，当这一个方向也发送了FIN报文后，那么这一方的连接也可以关闭了。释放TCP连接相对于要复杂点，具体释放TCP连接的四次挥手流程如下： A发送一个FIN给B，说：我这边要传给你的数据已经传完了，我要关闭连接了。A进入FIN-WAIT-1状态，等待B确认。 B收到了上面的FIN报文后，回复一个ACK报文说：OK。A就关闭了A-&gt;B的连接。但是此时B还能给A发送数据，A也能接收B发来的数据。（此时A收到确认后进入FIN-WAIT-2状态。TCP处于半关闭状态） 当B也发送完数据后，就给A发送一个FIN报文说：我这边要传给你的数据也已经传完了，我也要关闭连接了。（B进入LAST-ACK状态，等待A确认） A收到了上面的报文后，回复一个ACK报文说：OK。A进入TIME-WAIT状态。现在TCP连接还没有释放掉，然后经过等待计时器(TIME-WAIT timer)设置的时间2MSL后，A才进入CLOSE状态。 然后，当A撤销相应的传输控制块TCB后，一个TCP连接就关闭了。 10. Http、Tcp、Udp、Socket的区别IP，网络层协议；TCP和UDP，传输层协议；HTTP，应用层协议；SOCKET：TCP/IP网络的API。 TCP/IP代表传输控制协议/网际协议，指的是一系列协议。 TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。 TCP和UDP是FTP，HTTP和SMTP之类使用的传输层协议。虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。 HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。 记住，需要IP协议来连接网络;TCP是一种允许我们安全传输数据的机制，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的特殊协议。 Socket 接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，用以开发TCP/IP网络上的应用程序。 本节原文链接：http://www.jianshu.com/p/1f512687ea19 11. URLURI：统一资源标示符。 URL：统一资源定位符，也就是说根据URL能够定位到网络上的某个资源，它是指向互联网“资源”的指针。 每个URL都是URI，但不一定每个URI都是URL。这是因为URI还包括一个子类，即统一资源名称（URN），它命名资源但不指定如何定位资源。 12345678910111213141516171819public class URLDemo&#123; public static void main(String[] args) throws MalformedURLException,IOException &#123; String str_url = "http://192.168.1.100:8080/myweb/1.html?name=lisi"; URL url = new URL(str_url); System.out.println("getProtocol：" + url.getProtocol()); System.out.println("getHost：" + url.getHost()); System.out.println("getPort：" + url.getPort()); System.out.println("getFile：" + url.getFile()); System.out.println("getPath：" + url.getPath()); System.out.println("getQuery：" + url.getQuery()); InputStream in = url.openStream();//相当于 url.openConnection().getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String text = new String(buf,0,len); System.out.println(text); in.close(); &#125;&#125; 运行结果 之所以运行结果中响应头不见了，只能看到主体数据的原因在于：URLConnection对象已经把响应头给解析了 12. URLConnection123456789101112131415public class URLDemo&#123; public static void main(String[] args) throws MalformedURLException,IOException &#123; String str_url = "http://192.168.1.100:8080/myweb/1.html?name=lisi"; URL url = new URL(str_url); //获取url对象的Url连接器对象。将连接封装成了对象： // java中内置的可以解析的具体协议对象+socket。 URLConnection conn = url.openConnection(); System.out.println(conn); //由于URLConnection对象已经把响应头给解析了，所以， // 可以通过URLConnection对象获取响应头某属性名对应的属性值。 String value = conn.getHeaderField("Content-Type"); System.out.println(value); &#125;&#125; 运行结果 13. HttpURLConnection12345678910URL newURL = new URL(url);URLConnection urlConnection = newURL.openConnection();urlConnection.setConnectTimeout(mConfig.connTimeOut);urlConnection.setReadTimeout(mConfig.soTimeOut);urlConnection.setDoInput(true);urlConnection.setUseCaches(false);// HttpsURLConnectionHttpsURLConnection.setDefaultSSLSocketFactory(sslFactory);HttpsURLConnection.setDefaultHostnameVerifier(); HttpURLConnection常用方法 方法声明 功能描述 addRequestProperty() 添加请求属性 setRequestMethod() 设置请求方式 connect() 连接网络 disconnect() 断开连接 setDoOutput() 设置打开连接对象输出流，把要提交的数据写入流中 setDoInput() 设置打开连接对象输入流 setConnectTimeout() 设置连接超时 setReadTimeout() 设置读取超时 setUseCaches() 设置是否使用缓存 getResponseCode() 获取响应码 getOutputStream() 获取输出流 getInputStream() 获取输入流 getErrorStream() 获取错误流 getResponseMessage() 获取响应信息 getContentLength() 获取内容长度 getContentEncoding() 获取内容编码 getContentType() 获取内容类型 getHeaderFields() 获取所有的头字段 setRequestProperty和addRequestProperty的区别setRequestProperty和addRequestProperty的区别就是，setRequestProperty会覆盖已经存在的key的所有values，有清零重新赋值的作用。而addRequestProperty则是在原来key的基础上继续添加其他value。 1234567/** * Adds the given property to the request header. Existing properties with * the same name will not be overwritten by this method. */ public void addRequestProperty(String field, String newValue) &#123; ... &#125; 字节流转换为字符123456789101112131415161718public class Tools &#123; public static String getTextFromStream(InputStream is) &#123; try &#123; byte[] b = new byte[1024]; int len; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while ((len = is.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //把输出流里的内容转换成字节数组 String text = new String(bos.toByteArray()); return text; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 14. URLEncoder和URLDecoder12URLEncoder.encode();URLDecoder.decode();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给那些让我糊里糊涂的HTTP、TCP、UDP、Socket]]></title>
    <url>%2F2017%2F04%2F30%2F%E5%86%99%E7%BB%99%E9%82%A3%E4%BA%9B%E8%AE%A9%E6%88%91%E7%B3%8A%E9%87%8C%E7%B3%8A%E6%B6%82%E7%9A%84HTTP%E3%80%81TCP%E3%80%81UDP%E3%80%81Socket%2F</url>
    <content type="text"><![CDATA[写给那些让我糊里糊涂的HTTP、TCP、UDP、Socket先来一个讲TCP、UDP和HTTP关系的，注意红色mark的部分 1. TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。在传输层中有TCP协议与UDP协议。在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。 2. HTTP协议是建立在请求/响应模型上的。首先由客户建立一条与服务器的TCP链接，并发送一个请求到服务器，请求中包含请求方法、URI、协议版本以及相关的MIME样式的消息。服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的MIME式样的消息。 HTTP/1.0为每一次HTTP的请求/响应建立一条新的TCP链接，因此一个包含HTML内容和图片的页面将需要建立多次的短期的TCP链接。一次TCP链接的建立将需要3次握手。 另外，为了获得适当的传输速度，则需要TCP花费额外的回路链接时间（RTT）。每一次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只是保证链接的可靠性，因此HTTP/1.1提出了可持续链接的实现方法。HTTP/1.1将只建立一次TCP的链接而重复地使用它传输一系列的请求/响应消息，因此减少了链接建立的次数和经常性的链接开销。 3. 结论虽然HTTP本身是一个协议，但其最终还是基于TCP的。不过，目前，有人正在研究基于TCP+UDP混合的HTTP协议。 4. Socket是什么呢？Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 socket、tcp、udp、http 的认识及区别1. 先来一个讲TCP、UDP和HTTP关系的1.1 TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议与UDP协议。在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。 1.2 HTTP协议是建立在请求/响应模型上的。首先由客户建立一条与服务器的TCP链接，并发送一个请求到服务器， 请求中包含请求方法、URI、协议版本以及相关的MIME样式的消息。 服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的MIME式样的消息。 HTTP/1.0为每一次HTTP的请求/响应建立一条新的TCP链接， 因此一个包含HTML内容和图片的页面将需要建立多次的短期的TCP链接。 一次TCP链接的建立将需要3次握手。 另外，为了获得适当的传输速度，则需要TCP花费额外的回路链接时间（RTT）。 每一次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只是保证链接的可靠性，因此HTTP/1.1提出了可持续链接的实现方法。 HTTP/1.1将只建立一次TCP的链接而重复地使用它传输一系列的请求/响应消息，因此减少了链接建立的次数和经常性的链接开销。 1.3 结论虽然HTTP本身是一个协议，但其最终还是基于TCP的。不过，目前，有人正在研究基于TCP+UDP混合的HTTP协议。 Socket是什么呢？Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中， Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面， 对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 2. TCP、UDP、HTTP、SOCKET之间的区别TCP和UDP：传输层协议； HTTP：应用层协议； SOCKET：TCP/IP网络的API。 TCP/IP代表传输控制协议/网际协议，指的是一系列协议。 TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。 TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。 TCP和UDP是FTP、HTTP和SMTP之类使用的传输层协议。 虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。 这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。 HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。 客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。 记住，需要IP协议来连接网络;TCP是一种允许我们安全传输数据的机制，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的特殊协议。 Socket 接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，用以开发TCP/IP网络上的应用程序。 3. socket、tcp、udp、http 的认识及区别网络由下往上分为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 IP 协议对应于网络层，TCP协议对应于传输层，HTTP协议对应于应用层，三者从本质上来说没有可比性，socket则是对TCP/IP协议的封装和应用。 可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据；socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。 实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、 listen、connect、accept、send、read和write等等 实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口 4. TCP连接的三次握手第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据 断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手” TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上（实际上也很大程度上保证了）保证了连接的可靠性； 而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号， 发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议 也正由于上面的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。 所以采用TCP传输协议的MSN比采用UDP的QQ传输文件慢，但并不能说QQ的通信是不安全的，因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，即使是这样，UDP因为在底层协议的封装上没有采用类似 TCP的“三次握手”而实现了TCP所无法达到的传输效率。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类]]></title>
    <url>%2F2017%2F04%2F30%2FString%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[相关阅读 Java基础：String类 Java字符串格式化 Java基础：正则表达式 1. 概述字符串是由多个字符组成的一串数据(字符序列)，字符串可以看成是字符数组。 在实际开发中，字符串的操作是最常见的操作，没有之一。而Java没有内置的字符串类型，所以，就在Java类库中提供了一个类String 供我们来使用。String 类代表字符串。 2. String类的特点 字符串是常量,它的值在创建之后不能更改 Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。 字符串如果是变量相加，先开空间，在拼接。 字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。 1234567891011package cn.itcast_02; /* * 字符串的特点：一旦被赋值，就不能改变。 */ public class StringDemo &#123; public static void main(String[] args) &#123; String s = "hello"; s += "world"; System.out.println("s:" + s); // helloworld &#125; &#125; 字符串在内存中1 字符串在内存中2 String s1 = new String(“hello”);和String s2 = “hello”;有什么区别？ 前者创建了2个或1个对象，后者创建了1个或0个对象。 123456789String s1 = new String(“hello”);String s2 = “hello”;s1 == s2; // false s1.equals(s2); // trueString s3 = “hello”; String s4 = “world”; String s5 = “helloworld”;S5== s3 + s4 ; //fale s5 == “hello” + ”world”; //true 字符串如果是变量相加，先开空间，再拼接。 字符串如果是常量相加，是先加，然后到字符串常量池中找，如果有就直接返回，否则就创建。 3. 常见操作方法3.1 构造方法 方法 说明 String() 创建一个内容为空的字符串 String(byte[]) 根据指定的字节数组创建对象 String(byte[]，int，int) 根据字节数组的一部分创建对象 String(char[]) 根据指定的字符数组创建对象 String(char[]，int，int) 根据字符数组的一部分创建对象 String(String) 根据指定的字符串内容创建对象 String(byte[] bytes, Charset charset) 使用指定的编码构造字符串对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.itcast_01; /* * 字符串：就是由多个字符组成的一串数据。也可以看成是一个字符数组。 * 通过查看API，我们可以知道 * A:字符串字面值"abc"也可以看成是一个字符串对象。 * B:字符串是常量，一旦被赋值，就不能被改变。 * * 构造方法： * public String():空构造 * public String(byte[] bytes):把字节数组转成字符串 * public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串 * public String(char[] value):把字符数组转成字符串 * public String(char[] value,int index,int count):把字符数组的一部分转成字符串 * public String(String original):把字符串常量值转成字符串 * * 字符串的方法： * public int length()：返回此字符串的长度。 */ public class StringDemo &#123; public static void main(String[] args) &#123; // public String():空构造 String s1 = new String(); System.out.println("s1:" + s1); System.out.println("s1.length():" + s1.length()); System.out.println("--------------------------"); // public String(byte[] bytes):把字节数组转成字符串 byte[] bys = &#123; 97, 98, 99, 100, 101 &#125;; String s2 = new String(bys); System.out.println("s2:" + s2); System.out.println("s2.length():" + s2.length()); System.out.println("--------------------------"); // public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串 // 我想得到字符串"bcd" String s3 = new String(bys, 1, 3); System.out.println("s3:" + s3); System.out.println("s3.length():" + s3.length()); System.out.println("--------------------------"); // public String(char[] value):把字符数组转成字符串 char[] chs = &#123; 'a', 'b', 'c', 'd', 'e', '爱', '林', '亲' &#125;; String s4 = new String(chs); System.out.println("s4:" + s4); System.out.println("s4.length():" + s4.length()); System.out.println("--------------------------"); // public String(char[] value,int index,int count):把字符数组的一部分转成字符串 String s5 = new String(chs, 2, 4); System.out.println("s5:" + s5); System.out.println("s5.length():" + s5.length()); System.out.println("--------------------------"); //public String(String original):把字符串常量值转成字符串 String s6 = new String("abcde"); System.out.println("s6:" + s6); System.out.println("s6.length():" + s6.length()); System.out.println("--------------------------"); //字符串字面值"abc"也可以看成是一个字符串对象。 String s7 = "abcde"; System.out.println("s7:"+s7); System.out.println("s7.length():"+s7.length()); &#125; &#125; 运行结果： 1234567891011121314151617181920s1:s1.length():0--------------------------s2:abcdes2.length():5--------------------------s3:bcds3.length():3--------------------------s4:abcde爱林亲s4.length():8--------------------------s5:cde爱s5.length():4--------------------------s6:abcdes6.length():5--------------------------s7:abcdes7.length():5 3.2 判断功能 方法 说明 equals() 比较字符串的内容是否相等，区分大小写 equalsIgnoreCase() 比较字符串的内容是否相等，忽略大小写 contains(String str) 判断大字符串中是否包含小字符串 startsWith() 判断字符串是否以某个字符串开头 endsWith() 判断字符串是否以某个字符串结尾 isEmpty() 判断字符串是否为空 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.itcast_03; /* * String类的判断功能： * boolean equals(Object obj):比较字符串的内容是否相同,区分大小写 * boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 * boolean contains(String str):判断大字符串中是否包含小字符串 * boolean startsWith(String str):判断字符串是否以某个指定的字符串开头 * boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾 * boolean isEmpty():判断字符串是否为空。 * * 注意： * 字符串内容为空和字符串对象为空。 * String s = ""; * String s = null; */ public class StringDemo &#123; public static void main(String[] args) &#123; // 创建字符串对象 String s1 = "helloworld"; String s2 = "helloworld"; String s3 = "HelloWorld"; // boolean equals(Object obj):比较字符串的内容是否相同,区分大小写 System.out.println("equals:" + s1.equals(s2)); System.out.println("equals:" + s1.equals(s3)); System.out.println("-----------------------"); // boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 System.out.println("equals:" + s1.equalsIgnoreCase(s2)); System.out.println("equals:" + s1.equalsIgnoreCase(s3)); System.out.println("-----------------------"); // boolean contains(String str):判断大字符串中是否包含小字符串 System.out.println("contains:" + s1.contains("hello")); System.out.println("contains:" + s1.contains("hw")); System.out.println("-----------------------"); // boolean startsWith(String str):判断字符串是否以某个指定的字符串开头 System.out.println("startsWith:" + s1.startsWith("h")); System.out.println("startsWith:" + s1.startsWith("hello")); System.out.println("startsWith:" + s1.startsWith("world")); System.out.println("-----------------------"); // 练习：boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾这个自己玩 // boolean isEmpty():判断字符串是否为空。 System.out.println("isEmpty:" + s1.isEmpty()); String s4 = ""; String s5 = null; System.out.println("isEmpty:" + s4.isEmpty()); // NullPointerException // s5对象都不存在，所以不能调用方法，空指针异常 System.out.println("isEmpty:" + s5.isEmpty()); &#125; &#125; 运行结果： 1234567891011121314151617equals:trueequals:false-----------------------equals:trueequals:true-----------------------contains:truecontains:false-----------------------startsWith:truestartsWith:truestartsWith:false-----------------------isEmpty:falseisEmpty:trueException in thread &quot;main&quot; java.lang.NullPointerException at Test.main(Test.java:43) 3.3 获取功能 方法 说明 length() 获取字符串长度 charAt(int index) 获取指定位置的字符 indexOf(int ch) 字符第一次出现的索引 indexOf(String str) 字符串第一次出现的索引 indexOf(int ch,int fromIndex) 字符从指定位置后第一次出现的索引 indexOf(String str,int from) 字符串从指定位置后第一次出现的索引 lastIndexOf() 字符串最后一次出现的索引 subString(int start) 从指定位置开始截取字符串 subString(int start,int end) 截取字符串，包左不包右 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.itcast_04; /* * String类的获取功能 * int length():获取字符串的长度。 * char charAt(int index):获取指定索引位置的字符 * int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 * 为什么这里是int类型，而不是char类型? * 原因是：'a'和97其实都可以代表'a' * int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。 * int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现处的索引。 * int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现处的索引。 * String substring(int start):从指定位置开始截取字符串,默认到末尾。 * String substring(int start,int end):从指定位置开始到指定位置结束截取字符串。 */ public class StringDemo &#123; public static void main(String[] args) &#123; // 定义一个字符串对象 String s = "helloworld"; // int length():获取字符串的长度。 System.out.println("s.length:" + s.length()); System.out.println("----------------------"); // char charAt(int index):获取指定索引位置的字符 System.out.println("charAt:" + s.charAt(7)); System.out.println("----------------------"); // int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 System.out.println("indexOf:" + s.indexOf('l')); System.out.println("----------------------"); // int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。 System.out.println("indexOf:" + s.indexOf("owo")); System.out.println("----------------------"); // int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现处的索引。 System.out.println("indexOf:" + s.indexOf('l', 4)); System.out.println("indexOf:" + s.indexOf('k', 4)); // -1 System.out.println("indexOf:" + s.indexOf('l', 40)); // -1 System.out.println("----------------------"); // 自己练习：int indexOf(String str,int // fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现处的索引。 // String substring(int start):从指定位置开始截取字符串,默认到末尾。包含start这个索引 System.out.println("substring:" + s.substring(5)); System.out.println("substring:" + s.substring(0)); System.out.println("----------------------"); // String substring(int start,int // end):从指定位置开始到指定位置结束截取字符串。包括start索引但是不包end索引 System.out.println("substring:" + s.substring(3, 8)); System.out.println("substring:" + s.substring(0, s.length())); &#125; &#125; 运行结果： 1234567891011121314151617s.length:10----------------------charAt:r----------------------indexOf:2----------------------indexOf:4----------------------indexOf:8indexOf:-1indexOf:-1----------------------substring:worldsubstring:helloworld----------------------substring:loworsubstring:helloworld 3.4 转换功能 方法 说明 getBytes() 把字符串转成字节数组 getCharArray() 把字符串转成字符数组 valueOf(char[] chs) 把字符数组转成字符串 valueOf(int i) 把int类型的数据转成字符串 toLowerCase() 把字符串转成小写 toUpperCase() 把字符串转成大写 concat(String str) 字符串拼接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.itcast_05; /* * String的转换功能： * byte[] getBytes():把字符串转换为字节数组。 * char[] toCharArray():把字符串转换为字符数组。 * static String valueOf(char[] chs):把字符数组转成字符串。 * static String valueOf(int i):把int类型的数据转成字符串。 * 注意：String类的valueOf方法可以把任意类型的数据转成字符串。 * String toLowerCase():把字符串转成小写。 * String toUpperCase():把字符串转成大写。 * String concat(String str):把字符串拼接。 */ public class StringDemo &#123; public static void main(String[] args) &#123; // 定义一个字符串对象 String s = "JavaSE"; // byte[] getBytes():把字符串转换为字节数组。 byte[] bys = s.getBytes(); for (int x = 0; x &lt; bys.length; x++) &#123; System.out.println(bys[x]); &#125; System.out.println("----------------"); // char[] toCharArray():把字符串转换为字符数组。 char[] chs = s.toCharArray(); for (int x = 0; x &lt; chs.length; x++) &#123; System.out.println(chs[x]); &#125; System.out.println("----------------"); // static String valueOf(char[] chs):把字符数组转成字符串。 String ss = String.valueOf(chs); System.out.println(ss); System.out.println("----------------"); // static String valueOf(int i):把int类型的数据转成字符串。 int i = 100; String sss = String.valueOf(i); System.out.println(sss); System.out.println("----------------"); // String toLowerCase():把字符串转成小写。 System.out.println("toLowerCase:" + s.toLowerCase()); System.out.println("s:" + s); // System.out.println("----------------"); // String toUpperCase():把字符串转成大写。 System.out.println("toUpperCase:" + s.toUpperCase()); System.out.println("----------------"); // String concat(String str):把字符串拼接。 String s1 = "hello"; String s2 = "world"; String s3 = s1 + s2; String s4 = s1.concat(s2); System.out.println("s3:"+s3); System.out.println("s4:"+s4); &#125; &#125; 运行结果： 1234567891011121314151617181920212223247497118978369----------------JavaSE----------------JavaSE----------------100----------------toLowerCase:javases:JavaSEtoUpperCase:JAVASE----------------s3:helloworlds4:helloworld 3.5 其他功能 方法 说明 replace(char old,char new) 替换字符 replace(String old,String new) 替换字符串 trim() 去掉字符串两端空格 compareTo() 按字典顺序比较字符串 compareToIngnoreCase() 按字典顺序比较字符串，忽略大小写 format() 格式化字符串 1String.format(Locale.CHINA，"第%03d条数据%s"，10，"str") 更多关于字符串格式化的内容，请看 Java字符串格式化String.format()的使用123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast_06; /* * String类的其他功能： * * 替换功能： * String replace(char old,char new) * String replace(String old,String new) * * 去除字符串两空格 * String trim() * * 按字典顺序比较两个字符串 * int compareTo(String str) * int compareToIgnoreCase(String str) */ public class StringDemo &#123; public static void main(String[] args) &#123; // 替换功能 String s1 = "helloworld"; String s2 = s1.replace('l', 'k'); String s3 = s1.replace("owo", "ak47"); System.out.println("s1:" + s1); System.out.println("s2:" + s2); System.out.println("s3:" + s3); System.out.println("---------------"); // 去除字符串两空格 String s4 = " hello world "; String s5 = s4.trim(); System.out.println("s4:" + s4 + "---"); System.out.println("s5:" + s5 + "---"); // 按字典顺序比较两个字符串 String s6 = "hello"; String s7 = "hello"; String s8 = "abc"; String s9 = "xyz"; System.out.println(s6.compareTo(s7));// 0 System.out.println(s6.compareTo(s8));// 7 System.out.println(s6.compareTo(s9));// -16 &#125; &#125; 运行结果： 123456789s1:helloworlds2:hekkoworkds3:hellak47rld---------------s4: hello world ---s5:hello world---07-16 4. String类练习4.1 把数组中的数据按照指定个格式拼接成一个字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.itcast_07; /* * 需求：把数组中的数据按照指定个格式拼接成一个字符串 * 举例： * int[] arr = &#123;1,2,3&#125;; * 输出结果： * "[1, 2, 3]" * 分析： * A:定义一个字符串对象，只不过内容为空 * B:先把字符串拼接一个"[" * C:遍历int数组，得到每一个元素 * D:先判断该元素是否为最后一个 * 是：就直接拼接元素和"]" * 不是：就拼接元素和逗号以及空格 * E:输出拼接后的字符串 * * 把代码用功能实现。 */ public class StringTest2 &#123; public static void main(String[] args) &#123; // 前提是数组已经存在 int[] arr = &#123; 1, 2, 3 &#125;; // 写一个功能，实现结果 String result = arrayToString(arr); System.out.println("最终结果是：" + result); &#125; /* * 两个明确： 返回值类型：String 参数列表：int[] arr */ public static String arrayToString(int[] arr) &#123; // 定义一个字符串 String s = ""; // 先把字符串拼接一个"[" s += "["; // 遍历int数组，得到每一个元素 for (int x = 0; x &lt; arr.length; x++) &#123; // 先判断该元素是否为最后一个 if (x == arr.length - 1) &#123; // 就直接拼接元素和"]" s += arr[x]; s += "]"; &#125; else &#123; // 就拼接元素和逗号以及空格 s += arr[x]; s += ", "; &#125; &#125; return s; &#125; &#125; 4.2 字符串反转1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.itcast_07; import java.util.Scanner; /* * 字符串反转 * 举例：键盘录入”abc” * 输出结果：”cba” * * 分析： * A:键盘录入一个字符串 * B:定义一个新字符串 * C:倒着遍历字符串，得到每一个字符 * a:length()和charAt()结合 * b:把字符串转成字符数组 * D:用新字符串把每一个字符拼接起来 * E:输出新串 */ public class StringTest3 &#123; public static void main(String[] args) &#123; // 键盘录入一个字符串 Scanner sc = new Scanner(System.in); System.out.println("请输入一个字符串："); String line = sc.nextLine(); /* // 定义一个新字符串 String result = ""; // 把字符串转成字符数组 char[] chs = line.toCharArray(); // 倒着遍历字符串，得到每一个字符 for (int x = chs.length - 1; x &gt;= 0; x--) &#123; // 用新字符串把每一个字符拼接起来 result += chs[x]; &#125; // 输出新串 System.out.println("反转后的结果是：" + result); */ // 改进为功能实现 String s = myReverse(line); System.out.println("实现功能后的结果是：" + s); &#125; /* * 两个明确： 返回值类型：String 参数列表：String */ public static String myReverse(String s) &#123; // 定义一个新字符串 String result = ""; // 把字符串转成字符数组 char[] chs = s.toCharArray(); // 倒着遍历字符串，得到每一个字符 for (int x = chs.length - 1; x &gt;= 0; x--) &#123; // 用新字符串把每一个字符拼接起来 result += chs[x]; &#125; return result; &#125; &#125; 4.3 统计大串中小串出现的次数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package cn.itcast_07; /* * 统计大串中小串出现的次数 * 举例： * 在字符串"woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun" * 结果： * java出现了5次 * * 分析： * 前提：是已经知道了大串和小串。 * * A:定义一个统计变量，初始化值是0 * B:先在大串中查找一次小串第一次出现的位置 * a:索引是-1，说明不存在了，就返回统计变量 * b:索引不是-1，说明存在，统计变量++ * C:把刚才的索引+小串的长度作为开始位置截取上一次的大串，返回一个新的字符串，并把该字符串的值重新赋值给大串 * D:回到B */ public class StringTest5 &#123; public static void main(String[] args) &#123; // 定义大串 String maxString = "woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun"; // 定义小串 String minString = "java"; // 写功能实现 int count = getCount(maxString, minString); System.out.println("Java在大串中出现了：" + count + "次"); &#125; /* * 两个明确： 返回值类型：int 参数列表：两个字符串 */ public static int getCount(String maxString, String minString) &#123; // 定义一个统计变量，初始化值是0 int count = 0; /* // 先在大串中查找一次小串第一次出现的位置 int index = maxString.indexOf(minString); // 索引不是-1，说明存在，统计变量++ while (index != -1) &#123; count++; // 把刚才的索引+小串的长度作为开始位置截取上一次的大串，返回一个新的字符串，并把该字符串的值重新赋值给大串 // int startIndex = index + minString.length(); // maxString = maxString.substring(startIndex); maxString = maxString.substring(index + minString.length()); // 继续查 index = maxString.indexOf(minString); &#125; */ int index; //先查，赋值，判断 while((index=maxString.indexOf(minString))!=-1)&#123; count++; maxString = maxString.substring(index + minString.length()); &#125; return count; &#125; &#125; 5. StringBuffer我们如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。而StringBuffer就可以解决这个问题 StringBuffer是线程安全的可变字符序列。 StringBuffer和String的区别? 前者长度和内容可变，后者不可变。如果使用前者做字符串的拼接，不会浪费太多的资源。 6. 常见操作方法 6.1 构造方法和获取方法123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast_01; /* * StringBuffer: * 线程安全的可变字符串。 * * StringBuffer和String的区别? * 前者长度和内容可变，后者不可变。 * 如果使用前者做字符串的拼接，不会浪费太多的资源。 * * StringBuffer的构造方法： * public StringBuffer():无参构造方法 * public StringBuffer(int capacity):指定容量的字符串缓冲区对象 * public StringBuffer(String str):指定字符串内容的字符串缓冲区对象 * * StringBuffer的获取方法： * public int capacity()：返回当前容量。 理论值 * public int length():返回长度（字符数）。 实际值 */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // public StringBuffer():无参构造方法 StringBuffer sb = new StringBuffer(); System.out.println("sb:" + sb); System.out.println("sb.capacity():" + sb.capacity()); System.out.println("sb.length():" + sb.length()); System.out.println("--------------------------"); // public StringBuffer(int capacity):指定容量的字符串缓冲区对象 StringBuffer sb2 = new StringBuffer(50); System.out.println("sb2:" + sb2); System.out.println("sb2.capacity():" + sb2.capacity()); System.out.println("sb2.length():" + sb2.length()); System.out.println("--------------------------"); // public StringBuffer(String str):指定字符串内容的字符串缓冲区对象 StringBuffer sb3 = new StringBuffer("hello"); System.out.println("sb3:" + sb3); System.out.println("sb3.capacity():" + sb3.capacity()); System.out.println("sb3.length():" + sb3.length()); &#125; &#125; 6.2 添加功能1234567891011121314151617181920212223242526272829303132333435package cn.itcast_02; /* * StringBuffer的添加功能： * public StringBuffer append(String str):可以把任意类型数据添加到字符串缓冲区里面,并返回字符串缓冲区本身 * * public StringBuffer insert(int offset,String str):在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身 */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // public StringBuffer append(String str) // StringBuffer sb2 = sb.append("hello"); // System.out.println("sb:" + sb); // System.out.println("sb2:" + sb2); // System.out.println(sb == sb2); // true // 一步一步的添加数据 // sb.append("hello"); // sb.append(true); // sb.append(12); // sb.append(34.56); // 链式编程 sb.append("hello").append(true).append(12).append(34.56); System.out.println("sb:" + sb); // public StringBuffer insert(int offset,String // str):在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身 sb.insert(5, "world"); System.out.println("sb:" + sb); &#125; &#125; 运行结果： 12sb:hellotrue1234.56sb:helloworldtrue1234.56 6.3 删除功能123456789101112131415161718192021222324252627282930313233package cn.itcast_03; /* * StringBuffer的删除功能 * public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身 * public StringBuffer delete(int start,int end):删除从指定位置开始指定位置结束的内容，并返回本身 */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // 创建对象 StringBuffer sb = new StringBuffer(); // 添加功能 sb.append("hello").append("world").append("java"); System.out.println("sb:" + sb); // public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身 // 需求：我要删除e这个字符，肿么办? // sb.deleteCharAt(1); // 需求:我要删除第一个l这个字符，肿么办? // sb.deleteCharAt(1); // public StringBuffer delete(int start,int // end):删除从指定位置开始指定位置结束的内容，并返回本身 // 需求：我要删除world这个字符串，肿么办? // sb.delete(5, 10); // 需求:我要删除所有的数据 sb.delete(0, sb.length()); System.out.println("sb:" + sb); &#125; &#125; 运行结果： 12sb:helloworldjavasb: 6.4 替换功能123456789101112131415161718192021222324package cn.itcast_04; /* * StringBuffer的替换功能： * public StringBuffer replace(int start,int end,String str):从start开始到end用str替换 */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // 添加数据 sb.append("hello"); sb.append("world"); sb.append("java"); System.out.println("sb:" + sb); // public StringBuffer replace(int start,int end,String // str):从start开始到end用str替换 // 需求：我要把world这个数据替换为"节日快乐" sb.replace(5, 10, "节日快乐"); System.out.println("sb:" + sb); &#125; &#125; 运行结果： 12sb:helloworldjavasb:hello节日快乐java 6.5 反转功能1234567891011121314151617181920package cn.itcast_05; /* * StringBuffer的反转功能： * public StringBuffer reverse() */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // 添加数据 sb.append("霞青林爱我"); System.out.println("sb:" + sb); // public StringBuffer reverse() sb.reverse(); System.out.println("sb:" + sb); &#125; &#125; 运行结果： 12sb:霞青林爱我sb:我爱林青霞 6.6 截取功能12345678910111213141516171819202122232425262728package cn.itcast_06; /* * StringBuffer的截取功能:注意返回值类型不再是StringBuffer本身了 * public String substring(int start) * public String substring(int start,int end) */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // 添加元素 sb.append("hello").append("world").append("java"); System.out.println("sb:" + sb); // 截取功能 // public String substring(int start) String s = sb.substring(5); System.out.println("s:" + s); System.out.println("sb:" + sb); // public String substring(int start,int end) String ss = sb.substring(5, 10); System.out.println("ss:" + ss); System.out.println("sb:" + sb); &#125; &#125; 运行结果： 12345sb:helloworldjavas:worldjavasb:helloworldjavass:worldsb:helloworldjava 7. StringBuffer类练习7.1 String和StringBuffer的相互转换1234567891011121314151617181920212223242526272829303132333435363738package cn.itcast_07; /* * 为什么我们要讲解类之间的转换： * A -- B的转换 * 我们把A转换为B，其实是为了使用B的功能。 * B -- A的转换 * 我们可能要的结果是A类型，所以还得转回来。 * * String和StringBuffer的相互转换? */ public class StringBufferTest &#123; public static void main(String[] args) &#123; // String -- StringBuffer String s = "hello"; // 注意：不能把字符串的值直接赋值给StringBuffer // StringBuffer sb = "hello"; // StringBuffer sb = s; // 方式1:通过构造方法 StringBuffer sb = new StringBuffer(s); // 方式2：通过append()方法 StringBuffer sb2 = new StringBuffer(); sb2.append(s); System.out.println("sb:" + sb); System.out.println("sb2:" + sb2); System.out.println("---------------"); // StringBuffer -- String StringBuffer buffer = new StringBuffer("java"); // String(StringBuffer buffer) // 方式1:通过构造方法 String str = new String(buffer); // 方式2：通过toString()方法 String str2 = buffer.toString(); System.out.println("str:" + str); System.out.println("str2:" + str2); &#125; &#125; 运行结果： 12345sb:hellosb2:hello---------------str:javastr2:java 7.2 把数组拼接成一个字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.itcast_07; /* * 把数组拼接成一个字符串 */ public class StringBufferTest2 &#123; public static void main(String[] args) &#123; // 定义一个数组 int[] arr = &#123; 44, 33, 55, 11, 22 &#125;; // 定义功能 // 方式1：用String做拼接的方式 String s1 = arrayToString(arr); System.out.println("s1:" + s1); // 方式2:用StringBuffer做拼接的方式 String s2 = arrayToString2(arr); System.out.println("s2:" + s2); &#125; // 用StringBuffer做拼接的方式 public static String arrayToString2(int[] arr) &#123; StringBuffer sb = new StringBuffer(); sb.append("["); for (int x = 0; x &lt; arr.length; x++) &#123; if (x == arr.length - 1) &#123; sb.append(arr[x]); &#125; else &#123; sb.append(arr[x]).append(", "); &#125; &#125; sb.append("]"); return sb.toString(); &#125; // 用String做拼接的方式 public static String arrayToString(int[] arr) &#123; String s = ""; s += "["; for (int x = 0; x &lt; arr.length; x++) &#123; if (x == arr.length - 1) &#123; s += arr[x]; &#125; else &#123; s += arr[x]; s += ", "; &#125; &#125; s += "]"; return s; &#125; &#125; 运行结果： 12s1:[44, 33, 55, 11, 22]s2:[44, 33, 55, 11, 22] 7.3 把字符串反转12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.itcast_07; import java.util.Scanner; /* * 把字符串反转 */ public class StringBufferTest3 &#123; public static void main(String[] args) &#123; // 键盘录入数据 Scanner sc = new Scanner(System.in); System.out.println("请输入数据："); String s = sc.nextLine(); // 方式1：用String做拼接 String s1 = myReverse(s); System.out.println("s1:" + s1); // 方式2：用StringBuffer的reverse()功能 String s2 = myReverse2(s); System.out.println("s2:" + s2); &#125; // 用StringBuffer的reverse()功能 public static String myReverse2(String s) &#123; // StringBuffer sb = new StringBuffer(); // sb.append(s); // StringBuffer sb = new StringBuffer(s); // sb.reverse(); // return sb.toString(); // 简易版 return new StringBuffer(s).reverse().toString(); &#125; // 用String做拼接 public static String myReverse(String s) &#123; String result = ""; char[] chs = s.toCharArray(); for (int x = chs.length - 1; x &gt;= 0; x--) &#123; // char ch = chs[x]; // result += ch; result += chs[x]; &#125; return result; &#125; &#125; 运行结果： 1234请输入数据：hello worlds1:dlrow ollehs2:dlrow olleh 7.4 判断一个字符串是否是对称字符串1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.itcast_07; import java.util.Scanner; /* * 判断一个字符串是否是对称字符串 * 例如"abc"不是对称字符串，"aba"、"abba"、"aaa"、"mnanm"是对称字符串 * * 分析： * 判断一个字符串是否是对称的字符串，我只需要把 * 第一个和最后一个比较 * 第二个和倒数第二个比较 * ... * 比较的次数是长度除以2。 */ public class StringBufferTest4 &#123; public static void main(String[] args) &#123; // 创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println("请输入一个字符串："); String s = sc.nextLine(); // 一个一个的比较 boolean b = isSame(s); System.out.println("b:" + b); //用字符串缓冲区的反转功能 boolean b2 = isSame2(s); System.out.println("b2:"+b2); &#125; public static boolean isSame2(String s) &#123; return new StringBuffer(s).reverse().toString().equals(s); &#125; // public static boolean isSame(String s) &#123; // // 把字符串转成字符数组 // char[] chs = s.toCharArray(); // // for (int start = 0, end = chs.length - 1; start &lt;= end; start++, end--) &#123; // if (chs[start] != chs[end]) &#123; // return false; // &#125; // &#125; // // return true; // &#125; public static boolean isSame(String s) &#123; boolean flag = true; // 把字符串转成字符数组 char[] chs = s.toCharArray(); for (int start = 0, end = chs.length - 1; start &lt;= end; start++, end--) &#123; if (chs[start] != chs[end]) &#123; flag = false; break; &#125; &#125; return flag; &#125; &#125; 运行结果： 1234请输入一个字符串：abcbab:trueb2:true 8. String常见问题8.1 Strings = new String(“xyz”)；创建了几个String Object？二者之间有什么区别？ 两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。new String()每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过”xyz”，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。 8.2 String和StringBuffer的区别？ String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。String类表示内容不可改变的字符串，而StringBuffer类表示内容可以被修改的字符串。String重写了equals()方法和hashCode()方法，而StringBuffer没有重写equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。StringBuffer更加高效。 8.3 StringBuffer与StringBuilder的区别？ StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。 8.4 如何把一段逗号分割的字符串转换成一个数组? 用正则表达式：String [ ] result = Str.split(“, ”) ; 8.5 Strings=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;; 一共创建了多少个对象？ 一个，相当于直接定义了一个”abcd”的字符串。Javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。 8.6 编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。 8.7 有一个字符串，其中包含中文字符、英文字符和数字字符，请统计和打印出各个字符的个数 思路：取出字符串的每一个字符到HashMap中去找，如果不存在，则把该字符和1分别作为键和值添加到集合中，如果存在，则把该字符和值加1作为键和值添加到集合中。最后遍历集合即可得到字符的个数 8.8 如果一串字符如”aaaabbc中国1512”要分别统计英文字符的数量，中文字符的数量，和数字字符的数量，假设字符中没有中文字符、英文字符、数字字符之外的其他特殊字符。 123456789// 字符串反转Public static String Reverce(String str)&#123; return new StringBuffer(str).reverce().toString();&#125;// 判断字符串是否对称Public static boolean isSame(String str)&#123; return new StringBuffer(str).reverce().toString().equals(str);&#125; 8.9 把数组拼接成指定格式的字符串 8.10 把字符串中的字符进行排序]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串格式化]]></title>
    <url>%2F2017%2F04%2F30%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原文出处：http://blog.csdn.net/lonely_fireworks/article/details/7962171/ 相关阅读 Java基础：String类 Java字符串格式化 Java基础：正则表达式 1. 常规类型的格式化String类的format()方法用于创建格式化的字符串以及连接多个字符串对象。熟悉C语言的同学应该记得C语言的sprintf()方法，两者有类似之处。 format()方法有两种重载形式 format(String format, Object… args) 新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。 format(Locale locale, String format, Object… args)使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。 显示不同转换符实现不同数据类型到字符串的转换，如图所示。 转换符 说明 示例 %s 字符串类型 “mingrisoft” %c 字符类型 ‘m’ %b 布尔类型 true %d 整数类型（十进制） 99 %x 整数类型（十六进制） FF %o 整数类型（八进制） 77 %f 浮点类型 99.99 %a 十六进制浮点类型 FF.35AE %e 指数类型 9.38e+5 %g 通用浮点类型（f和e类型中较短的） %h 散列码，Integer.toHexString(arg.hashCode()) %% 百分比类型 ％ %n 换行符 %tx 日期与时间类型（x代表不同的日期与时间转换符 2. 测试用例123456789101112131415161718public static void main(String[] args) &#123; String str=null; str=String.format("Hi,%s", "王力"); System.out.println(str); str=String.format("Hi,%s:%s.%s", "王南","王力","王张"); System.out.println(str); System.out.printf("字母a的大写是：%c %n", 'A'); System.out.printf("3&gt;7的结果是：%b %n", 3&gt;7); System.out.printf("100的一半是：%d %n", 100/2); System.out.printf("100的16进制数是：%x %n", 100); System.out.printf("100的8进制数是：%o %n", 100); System.out.printf("50元的书打8.5折扣是：%f 元%n", 50*0.85); System.out.printf("上面价格的16进制数是：%a %n", 50*0.85); System.out.printf("上面价格的指数表示：%e %n", 50*0.85); System.out.printf("上面价格的指数和浮点数结果的长度较短的是：%g %n", 50*0.85); System.out.printf("上面的折扣是%d%% %n", 85); System.out.printf("字母A的散列码是：%h %n", 'A'); &#125; 输出结果 12345678910111213Hi,王力 Hi,王南:王力.王张 字母a的大写是：A 3&gt;7的结果是：false 100的一半是：50 100的16进制数是：64 100的8进制数是：144 50元的书打8.5折扣是：42.500000 元 上面价格的16进制数是：0x1.54p5 上面价格的指数表示：4.250000e+01 上面价格的指数和浮点数结果的长度较短的是：42.5000 上面的折扣是85% 字母A的散列码是：41 3. 搭配转换符的标志 4. 测试用例12345678910111213141516public static void main(String[] args) &#123; String str=null; //$使用 str=String.format("格式参数$的使用：%1$d,%2$s", 99,"abc"); System.out.println(str); //+使用 System.out.printf("显示正负数的符号：%+d与%d%n", 99,-99); //补O使用 System.out.printf("最牛的编号是：%03d%n", 7); //空格使用 System.out.printf("Tab键的效果是：% 8d%n", 7); //.使用 System.out.printf("整数分组的效果是：%,d%n", 9989997); //空格和小数点后面个数 System.out.printf("一本书的价格是：% 50.5f元%n", 49.8); &#125; 输出结果 123456格式参数$的使用：99,abc 显示正负数的符号：+99与-99 最牛的编号是：007 Tab键的效果是：7 整数分组的效果是：9,989,997 一本书的价格是：49.80000元 5. 日期和事件字符串格式化在程序界面中经常需要显示时间和日期，但是其显示的 格式经常不尽人意，需要编写大量的代码经过各种算法才得到理想的日期与时间格式。字符串格式中还有%tx转换符没有详细介绍，它是专门用来格式化日期和时 间的。%tx转换符中的x代表另外的处理日期和时间格式的转换符，它们的组合能够将日期和时间格式化成多种格式。 常见日期和时间组合的格式，如图所示。| 转换符 | 说明 | 示例 || :— | :——————– | :————————– || c | 包括全部日期和时间信息 | 星期六 十月 27 14:21:20 CST 2007 || F | “年-月-日”格式 | 2007-10-27 || D | “月/日/年”格式 | 10/27/07 || r | “HH:MM:SS PM”格式（12时制） | 02:25:51 下午 || T | “HH:MM:SS”格式（24时制） | 14:28:16 || R | “HH:MM”格式（24时制） | 14:28 | 6. 测试用例123456789101112131415public static void main(String[] args) &#123; Date date=new Date(); //c的使用 System.out.printf("全部日期和时间信息：%tc%n",date); //f的使用 System.out.printf("年-月-日格式：%tF%n",date); //d的使用 System.out.printf("月/日/年格式：%tD%n",date); //r的使用 System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date); //t的使用 System.out.printf("HH:MM:SS格式（24时制）：%tT%n",date); //R的使用 System.out.printf("HH:MM格式（24时制）：%tR",date); &#125; 输出结果123456全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012 年-月-日格式：2012-09-10 月/日/年格式：09/10/12 HH:MM:SS PM格式（12时制）：10:43:36 上午 HH:MM:SS格式（24时制）：10:43:36 HH:MM格式（24时制）：10:43 定义日期格式的转换符可以使日期通过指定的转换符生成新字符串。这些日期转换符如图所示。12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; Date date=new Date(); //b的使用，月份简称 String str=String.format(Locale.US,"英文月份简称：%tb",date); System.out.println(str); System.out.printf("本地月份简称：%tb%n",date); //B的使用，月份全称 str=String.format(Locale.US,"英文月份全称：%tB",date); System.out.println(str); System.out.printf("本地月份全称：%tB%n",date); //a的使用，星期简称 str=String.format(Locale.US,"英文星期的简称：%ta",date); System.out.println(str); //A的使用，星期全称 System.out.printf("本地星期的简称：%tA%n",date); //C的使用，年前两位 System.out.printf("年的前两位数字（不足两位前面补0）：%tC%n",date); //y的使用，年后两位 System.out.printf("年的后两位数字（不足两位前面补0）：%ty%n",date); //j的使用，一年的天数 System.out.printf("一年中的天数（即年的第几天）：%tj%n",date); //m的使用，月份 System.out.printf("两位数字的月份（不足两位前面补0）：%tm%n",date); //d的使用，日（二位，不够补零） System.out.printf("两位数字的日（不足两位前面补0）：%td%n",date); //e的使用，日（一位不补零） System.out.printf("月份的日（前面不补0）：%te",date); &#125; 输出结果 123456789101112英文月份简称：Sep 本地月份简称：九月 英文月份全称：September 本地月份全称：九月 英文星期的简称：Mon 本地星期的简称：星期一 年的前两位数字（不足两位前面补0）：20 年的后两位数字（不足两位前面补0）：12 一年中的天数（即年的第几天）：254 两位数字的月份（不足两位前面补0）：09 两位数字的日（不足两位前面补0）：10 月份的日（前面不补0）：10 和日期格式转换符相比，时间格式的转换符要更多、更精确。它可以将时间格式化成时、分、秒甚至时毫秒等单位。格式化时间字符串的转换符如图所示。 转换符 说明 示例 H 2位数字24时制的小时（不足2位前面补0） 15 I 2位数字12时制的小时（不足2位前面补0） 03 K 2位数字24时制的小时（前面不补0） 15 L 2位数字12时制的小时（前面不补0） 3 M 2位数字的分钟（不足2位前面补0） 03 S 2位数字的秒（不足2位前面补0） 09 L 3位数字的毫秒（不足3位前面补0） 015 N 9位数字的毫秒数（不足9位前面补0） 562000000 p 小写字母的上午或下午标记 中：下午,英：pm z 相对于GMT的RFC822时区的偏移量 +0800 Z 时区缩写字符串 CST S 1970-1-1 00:00:00 到现在所经过的秒数 1193468128 Q 1970-1-1 00:00:00 到现在所经过的毫秒数 1193468128984 7. 测试代码12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; Date date = new Date(); //H的使用 System.out.printf("2位数字24时制的小时（不足2位前面补0）:%tH%n", date); //I的使用 System.out.printf("2位数字12时制的小时（不足2位前面补0）:%tI%n", date); //k的使用 System.out.printf("2位数字24时制的小时（前面不补0）:%tk%n", date); //l的使用 System.out.printf("2位数字12时制的小时（前面不补0）:%tl%n", date); //M的使用 System.out.printf("2位数字的分钟（不足2位前面补0）:%tM%n", date); //S的使用 System.out.printf("2位数字的秒（不足2位前面补0）:%tS%n", date); //L的使用 System.out.printf("3位数字的毫秒（不足3位前面补0）:%tL%n", date); //N的使用 System.out.printf("9位数字的毫秒数（不足9位前面补0）:%tN%n", date); //p的使用 String str = String.format(Locale.US, "小写字母的上午或下午标记(英)：%tp", date); System.out.println(str); System.out.printf("小写字母的上午或下午标记（中）：%tp%n", date); //z的使用 System.out.printf("相对于GMT的RFC822时区的偏移量:%tz%n", date); //Z的使用 System.out.printf("时区缩写字符串:%tZ%n", date); //s的使用 System.out.printf("1970-1-1 00:00:00 到现在所经过的秒数：%ts%n", date); //Q的使用 System.out.printf("1970-1-1 00:00:00 到现在所经过的毫秒数：%tQ%n", date); &#125; 输出结果 12345678910111213142位数字24时制的小时（不足2位前面补0）:11 2位数字12时制的小时（不足2位前面补0）:11 2位数字24时制的小时（前面不补0）:11 2位数字12时制的小时（前面不补0）:11 2位数字的分钟（不足2位前面补0）:03 2位数字的秒（不足2位前面补0）:52 3位数字的毫秒（不足3位前面补0）:773 9位数字的毫秒数（不足9位前面补0）:773000000 小写字母的上午或下午标记(英)：am 小写字母的上午或下午标记（中）：上午 相对于GMT的RFC822时区的偏移量:+0800 时区缩写字符串:CST 1970-1-1 00:00:00 到现在所经过的秒数：1347246232 1970-1-1 00:00:00 到现在所经过的毫秒数：1347246232773 8. 在android String resource中使用&amp;#1601&lt;string name="downloaded"&gt;&amp;#160;%s %%&lt;/string&gt; 在显示文本信息时，一句话结束之后需要用空格来分隔两个句子，但是在string.xml中当内容没有在双引号内时空格是没有用的。 要想让string.xml中的字符串显示空格可以用 &amp;#160 ; 来代替空格，但是 &amp;#160 ; 来代替空格时他只是被当做了一个字符并且会和其他的单词组合在一起变成一个新的字符串， 也就是说它是没用分隔符的功能的。 9. Formatterprintf 风格的格式字符串的解释程序。此类提供了对布局对齐和排列的支持，以及对数值、字符串和日期/时间数据的常规格式和特定于语言环境的输出的支持 1234567891011121314151617181920StringBuilder sb = new StringBuilder(); // Send all output to the Appendable object sb Formatter formatter = new Formatter(sb, Locale.US); // Explicit argument indices may be used to re-order output. formatter.format("%4$2s %3$2s %2$2s %1$2s", "a", "b", "c", "d") // -&gt; " d c b a" // Optional locale as the first argument can be used to get // locale-specific formatting of numbers. The precision and width can be // given to round and align the value. formatter.format(Locale.FRANCE, "e = %+10.4f", Math.E); // -&gt; "e = +2,7183" // The '(' numeric flag may be used to format negative numbers with // parentheses rather than a minus sign. Group separators are // automatically inserted. formatter.format("Amount gained or lost since last statement: $ %(,.2f", balanceDelta); // -&gt; "Amount gained or lost since last statement: $ (6,217.58)" 12345678// Writes a formatted string to System.out. System.out.format("Local time: %tT", Calendar.getInstance()); // -&gt; "Local time: 13:34:18" // Writes formatted output to System.err. System.err.printf("Unable to open file '%1$s': %2$s", fileName, exception.getMessage()); // -&gt; "Unable to open file 'food': No such file or directory" 10. 格式字符串语法产生格式化输出的每个方法都需要格式字符串 和参数列表。格式字符串是一个 String，它可以包含固定文本以及一个或多个嵌入的格式说明符 10.1 常规类型、字符类型和数值类型的格式说明符的语法如下1%[argument_index$][flags][width][.precision]conversion 格式说明符 描述 argument_index 可选的argument_index是一个十进制整数，用于表明参数在参数列表中的位置。第一个参数由 “1$” 引用，第二个参数由 “2$” 引用，依此类推 flags 可选 flags 是修改输出格式的字符集。有效标志集取决于转换类型 width 可选 width 是一个非负十进制整数，表明要向输出中写入的最少字符数 precision 可选 precision 是一个非负十进制整数，通常用来限制字符数。特定行为取决于转换类型 conversion 所需 conversion 是一个表明应该如何格式化参数的字符。给定参数的有效转换集取决于参数的数据类型 10.2 转换conversion10.3 日期和时间格式化1%[argument_index$][flags][width]conversion 11. NumberFormat12. MessageFormat1234567/* * 包含了点位符的字符串就是模板！ * 点位符：&#123;0&#125;、&#123;1&#125;、&#123;2&#125; * 可变参数，需要指定模板中的点位符的值！有几个点位符就要提供几个参数 */String s = MessageFormat.format("&#123;0&#125;或&#123;1&#125;错误！", "用户名", "密码");System.out.println(s);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F04%2F30%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[相关阅读 Java基础：String类 Java字符串格式化 Java基础：正则表达式 1. 正则表达式概述正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本 许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有regexp、regex，复数有regexps、regexes、regexen 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑 1.1 给定一个正则表达式和另一个字符串，我们可以达到如下的目的 给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”） 可以通过正则表达式，从字符串中获取我们想要的特定部分 1.2 正则表达式的特点是 灵活性、逻辑性和功能性非常的强； 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。 由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容 2. 正则表达式基础知识2.1 规则字符在java.util.regex Pattern类中2.2 常见符号2.2.1 字符 符号 说明 X 字符X \\ 反斜线 \t 制表符 (‘\u0009’) \n 回车 \r 换行 \f 换页符 (‘\u000C’) \a 报警 (bell) 符 (‘\u0007’) 2.2.2 字符类 符号 说明 [abc] a、b或c [^abc] 任何字符，除了a、b或c [a-zA-Z] a到z,或A到Z [0-9] 0到9的字符 [a-d[m-p]] a到 d或 m 到 p：[a-dm-p]（并集） [a-z&amp;&amp;[def]] d、e或 f（交集） [a-z&amp;&amp;[^bc]] a到 z，除了 b和 c：[ad-z]（减去） [a-z&amp;&amp;[^m-p]] a到 z，而非 m到 p：[a-lq-z]（减去） 2.2.3 预定义字符 符号 说明 . 任何字符 \d 数字：[0-9] \D 非数字： [^0-9] \s 空白字符：[ \t\n\x0B\f\r] \S 非空白字符：[^\s] \w 单词字符：[a-zA-Z_0-9] \W 非单词字符：[^\w] 2.3 边界匹配器 符号 说明 ^ 行开头 $ 行结尾 \b 单词边界 \B 非单词边界 \A 输入的开头 \G 上一个匹配的结尾 \Z 输入的结尾，仅用于最后的结束符（如果有的话） \z 输入的结尾 2.3.1 Greedy数量词 符号 说明 X？ 0次或1次 X* 0次以上 X+ 1次以上 X{n} 恰好n次 X{n,} 至少n次 X{n,m} n-m次 2.3.2 组和捕获捕获组可以通过从左到右计算其开括号来编号。例如，在表达式 ((A)(B(C)))中，存在四个这样的组： ((A)(B(C))) \A (B(C)) (C) 组零始终代表整个表达式。在替换中常用$匹配组的内容。 3. 正则表达式的应用3.1 判断功能1public boolean matches(String regex)：编译给定正则表达式并尝试将给定输入与其匹配。 3.2 分割功能1public String[] split(String regex)：根据指定的正则表达式分割字符串 3.3 替换功能1public String replaceAll(String regex,String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 ##3.4 获取功能Pattern和Matcher类的使用 123456789101112131415161718192021222324252627package cn.itcast_05;import java.util.regex.Matcher;import java.util.regex.Pattern;/* * 获取功能 * Pattern和Matcher类的使用 * * 模式和匹配器的基本使用顺序 */public class RegexDemo &#123; public static void main(String[] args) &#123; // 模式和匹配器的典型调用顺序 // 把正则表达式编译成模式对象 Pattern p = Pattern.compile("a*b"); // 通过模式对象得到匹配器对象，这个时候需要的是被匹配的字符串 Matcher m = p.matcher("aaaaab"); // 调用匹配器对象的功能 boolean b = m.matches(); System.out.println(b); //这个是判断功能，但是如果做判断，这样做就有点麻烦了，我们直接用字符串的方法做 String s = "aaaaab"; String regex = "a*b"; boolean bb = s.matches(regex); System.out.println(bb); &#125;&#125; 3.4 注意事项Pattern类为正则表达式的编译表示形式。指定为字符串的正则表达式必须首先被编译为此类的实例。然后，可将得到的模式用于创建Matcher对象，依照正则表达式，该对象可以与任意字符序列匹配。执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式 4. 正则表达式的练习4.1 判断功能：校验邮箱12345678910111213141516171819202122232425262728293031323334package cn.itcast_02;import java.util.Scanner;/* * 校验邮箱 * * 分析： * A:键盘录入邮箱 * B:定义邮箱的规则 * 1517806580@qq.com * liuyi@163.com * linqingxia@126.com * fengqingyang@sina.com.cn * fqy@itcast.cn * C:调用功能，判断即可 * D:输出结果 */public class RegexTest &#123; public static void main(String[] args) &#123; //键盘录入邮箱 Scanner sc = new Scanner(System.in); System.out.println("请输入邮箱："); String email = sc.nextLine(); //定义邮箱的规则 //String regex = "[a-zA-Z_0-9]+@[a-zA-Z_0-9]&#123;2,6&#125;(\\.[a-zA-Z_0-9]&#123;2,3&#125;)+"; String regex = "\\w+@\\w&#123;2,6&#125;(\\.\\w&#123;2,3&#125;)+"; //调用功能，判断即可 boolean flag = email.matches(regex); //输出结果 System.out.println("flag:"+flag); &#125;&#125; 4.2 分割功能代码示例：我有如下一个字符串:”91 27 46 3850”，请写代码实现最终输出结果是：”27 3846 50 91” 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.itcast_03;import java.util.Arrays;/* * 我有如下一个字符串:"91 27 46 38 50" * 请写代码实现最终输出结果是："27 38 46 50 91" * * 分析： * A:定义一个字符串 * B:把字符串进行分割，得到一个字符串数组 * C:把字符串数组变换成int数组 * D:对int数组排序 * E:把排序后的int数组在组装成一个字符串 * F:输出字符串 */public class RegexTest &#123; public static void main(String[] args) &#123; // 定义一个字符串 String s = "91 27 46 38 50"; // 把字符串进行分割，得到一个字符串数组 String[] strArray = s.split(" "); // 把字符串数组变换成int数组 int[] arr = new int[strArray.length]; for (int x = 0; x &lt; arr.length; x++) &#123; arr[x] = Integer.parseInt(strArray[x]); &#125; // 对int数组排序 Arrays.sort(arr); // 把排序后的int数组在组装成一个字符串 StringBuilder sb = new StringBuilder(); for (int x = 0; x &lt; arr.length; x++) &#123; sb.append(arr[x]).append(" "); &#125; //转化为字符串 String result = sb.toString().trim(); //输出字符串 System.out.println("result:"+result); &#125;&#125; 4.3 替换功能：论坛中不能出现数字字符，用*替换12345678910111213141516171819202122232425package cn.itcast_04;/* * 替换功能 * String类的public String replaceAll(String regex,String replacement) * 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 */public class RegexDemo &#123; public static void main(String[] args) &#123; // 定义一个字符串 String s = "helloqq12345worldkh622112345678java"; // 我要去除所有的数字,用*给替换掉 // String regex = "\\d+"; // String regex = "\\d"; //String ss = "*"; // 直接把数字干掉 String regex = "\\d+"; String ss = ""; String result = s.replaceAll(regex, ss); System.out.println(result); &#125;&#125; 4.4 获取功能：获取由三个字符组成的单词123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.itcast_05;import java.util.regex.Matcher;import java.util.regex.Pattern;/* * 获取功能： * 获取下面这个字符串中由三个字符组成的单词 * da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu? */public class RegexDemo2 &#123; public static void main(String[] args) &#123; // 定义字符串 String s = "da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu?"; // 规则 String regex = "\\b\\w&#123;3&#125;\\b"; // 把规则编译成模式对象 Pattern p = Pattern.compile(regex); // 通过模式对象得到匹配器对象 Matcher m = p.matcher(s); // 调用匹配器对象的功能 // 通过find方法就是查找有没有满足条件的子串 // public boolean find() // boolean flag = m.find(); // System.out.println(flag); // // 如何得到值呢? // // public String group() // String ss = m.group(); // System.out.println(ss); // // // 再来一次 // flag = m.find(); // System.out.println(flag); // ss = m.group(); // System.out.println(ss); while (m.find()) &#123; System.out.println(m.group()); &#125; // 注意：一定要先find()，然后才能group() // IllegalStateException: No match found // String ss = m.group(); // System.out.println(ss); &#125;&#125; 5. 正则表达式工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 正则工具类 提供验证邮箱、手机号、电话号码、身份证号码、数字等方法 */public final class RegexUtils &#123; /** * 验证Email * * @param email * email地址，格式：zhangsan@sina.com，zhangsan@xxx.com.cn，xxx代表邮件服务商 * @return 验证成功返回true，验证失败返回false ^ ：匹配输入的开始位置。 \：将下一个字符标记为特殊字符或字面值。 * ：匹配前一个字符零次或几次。 + ：匹配前一个字符一次或多次。 (pattern) 与模式匹配并记住匹配。 x|y：匹配 x 或 * y。 [a-z] ：表示某个范围内的字符。与指定区间内的任何字符匹配。 \w ：与任何单词字符匹配，包括下划线。 * * &#123;n,m&#125; 最少匹配 n 次且最多匹配 m 次 $ ：匹配输入的结尾。 */ public static boolean checkEmail(String email) &#123; String regex = "^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w&#123;2,3&#125;)&#123;1,3&#125;)$"; return Pattern.matches(regex, email); &#125; /** * 验证身份证号码 * * @param idCard * 居民身份证号码15位或18位，最后一位可能是数字或字母 * @return 验证成功返回true，验证失败返回false */ public static boolean checkIdCard(String idCard) &#123; String regex = "[1-9]\\d&#123;13,16&#125;[a-zA-Z0-9]&#123;1&#125;"; return Pattern.matches(regex, idCard); &#125; /** * 验证手机号码（支持国际格式，+86135xxxx...（中国内地），+00852137xxxx...（中国香港）） * * @param mobile * 移动、联通、电信运营商的号码段 * &lt;p&gt; * 移动的号段：134(0-8)、135、136、137、138、139、147（预计用于TD上网卡） * 、150、151、152、157（TD专用）、158、159、187（未启用）、188（TD专用） * &lt;/p&gt; * &lt;p&gt; * 联通的号段：130、131、132、155、156（世界风专用）、185（未启用）、186（3g） * &lt;/p&gt; * &lt;p&gt; * 电信的号段：133、153、180（未启用）、189 * &lt;/p&gt; * &lt;p&gt; * 虚拟运营商的号段：170 * &lt;/p&gt; * @return 验证成功返回true，验证失败返回false */ public static boolean checkMobile(String mobile) &#123; String regex = "(\\+\\d+)?1[34578]\\d&#123;9&#125;$"; return Pattern.matches(regex, mobile); &#125; /** * 验证固定电话号码 * * @param phone * 电话号码，格式：国家（地区）电话代码 + 区号（城市代码） + 电话号码，如：+8602085588447 * &lt;p&gt; * &lt;b&gt;国家（地区） 代码 ：&lt;/b&gt;标识电话号码的国家（地区）的标准国家（地区）代码。它包含从 0 到 9 * 的一位或多位数字， 数字之后是空格分隔的国家（地区）代码。 * &lt;/p&gt; * &lt;p&gt; * &lt;b&gt;区号（城市代码）：&lt;/b&gt;这可能包含一个或多个从 0 到 9 的数字，地区或城市代码放在圆括号—— * 对不使用地区或城市代码的国家（地区），则省略该组件。 * &lt;/p&gt; * &lt;p&gt; * &lt;b&gt;电话号码：&lt;/b&gt;这包含从 0 到 9 的一个或多个数字 * &lt;/p&gt; * @return 验证成功返回true，验证失败返回false */ public static boolean checkPhone(String phone) &#123; // String regex = "(\\+\\d+)?(\\d&#123;3,4&#125;\\-?)?\\d&#123;7,8&#125;$"; String regex = "^1\\d&#123;10&#125;$"; return Pattern.matches(regex, phone); &#125; /** * 验证整数（正整数和负整数） * * @param digit * 一位或多位0-9之间的整数 * @return 验证成功返回true，验证失败返回false */ public static boolean checkDigit(String digit) &#123; String regex = "\\-?[1-9]\\d+"; return Pattern.matches(regex, digit); &#125; /** * 验证整数和浮点数（正负整数和正负浮点数） * * @param decimals * 一位或多位0-9之间的浮点数，如：1.23，233.30 * @return 验证成功返回true，验证失败返回false */ public static boolean checkDecimals(String decimals) &#123; String regex = "\\-?[1-9]\\d+(\\.\\d+)?"; return Pattern.matches(regex, decimals); &#125; /** * 验证空白字符 * * @param blankSpace * 空白字符，包括：空格、\t、\n、\r、\f、\x0B * @return 验证成功返回true，验证失败返回false */ public static boolean checkBlankSpace(String blankSpace) &#123; String regex = "\\s+"; return Pattern.matches(regex, blankSpace); &#125; /** * 验证中文 * * @param chinese * 中文字符 * @return 验证成功返回true，验证失败返回false */ public static boolean checkChinese(String chinese) &#123; String regex = "^[\u4E00-\u9FA5]+$"; return Pattern.matches(regex, chinese); &#125; /** * 验证日期（年月日） * * @param birthday * 日期，格式：1992-09-03，或1992.09.03 * @return 验证成功返回true，验证失败返回false */ public static boolean checkBirthday(String birthday) &#123; String regex = "[1-9]&#123;4&#125;([-./])\\d&#123;1,2&#125;\\1\\d&#123;1,2&#125;"; return Pattern.matches(regex, birthday); &#125; /** * 验证URL地址 * * @param url * 格式：http://blog.csdn.net:80/xyang81/article/details/7705960? 或 * http://www.csdn.net:80 * @return 验证成功返回true，验证失败返回false */ public static boolean checkURL(String url) &#123; String regex = "(https?://(w&#123;3&#125;\\.)?)?\\w+\\.\\w+(\\.[a-zA-Z]+)*(:\\d&#123;1,5&#125;)?(/\\w*)*(\\??(.+=.*)?(&amp;.+=.*)?)?"; return Pattern.matches(regex, url); &#125; /** * 匹配中国邮政编码 * * @param postcode * 邮政编码 * @return 验证成功返回true，验证失败返回false */ public static boolean checkPostcode(String postcode) &#123; String regex = "[1-9]\\d&#123;5&#125;"; return Pattern.matches(regex, postcode); &#125; /** * 匹配IP地址(简单匹配，格式，如：192.168.1.1，127.0.0.1，没有匹配IP段的大小) * * @param ipAddress * IPv4标准地址 * @return 验证成功返回true，验证失败返回false */ public static boolean checkIpAddress(String ipAddress) &#123; String regex = "[1-9](\\d&#123;1,2&#125;)?\\.(0|([1-9](\\d&#123;1,2&#125;)?))\\.(0|([1-9](\\d&#123;1,2&#125;)?))\\.(0|([1-9](\\d&#123;1,2&#125;)?))"; return Pattern.matches(regex, ipAddress); &#125; public static boolean checkNickname(String nickname) &#123; String regex = "^[a-zA-Z0-9\u4E00-\u9FA5_]+$"; return Pattern.matches(regex, nickname); &#125; public static boolean hasCrossSciptRiskInAddress(String str) &#123; String regx = "[`~!@#$%^&amp;*+=|&#123;&#125;':;',\\[\\].&lt;&gt;~！@#￥%……&amp;*——+|&#123;&#125;【】‘；：”“’。，、？-]"; if (str != null) &#123; str = str.trim(); Pattern p = Pattern.compile(regx, Pattern.CASE_INSENSITIVE); Matcher m = p.matcher(str); return m.find(); &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
</search>