<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TextureView+MediaPlayer实现在线短视频播放]]></title>
    <url>%2F2017%2F05%2F24%2Fandroid%2FTextureView%2F</url>
    <content type="text"><![CDATA[##Android多媒体开发系列文章 Android多媒体开发：录音机 Android多媒体开发：照相机 TextureView+MediaPlayer实现在线短视频播放 Android多媒体开发：第三方框架 TextureView+MediaPlayer实现在线短视频播放 列表item布局文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/iv_bg" android:layout_width="match_parent" android:layout_height="200dp" android:scaleType="centerCrop" android:src="@mipmap/beautiful" android:visibility="visible"/&gt; &lt;com.jackchan.videoplayer.view.VideoPlayer android:id="@+id/videoPlayer" android:layout_width="match_parent" android:layout_height="200dp" android:visibility="visible"/&gt; &lt;/FrameLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center_vertical" android:orientation="horizontal" android:padding="10dp"&gt; &lt;ImageView android:id="@+id/iv_author" android:layout_width="20dp" android:layout_height="20dp" android:background="@drawable/qq_allshare_normal"/&gt; &lt;TextView android:id="@+id/tv_author_name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="10dp" android:text="飞行的钢蛋儿" android:textColor="#000"/&gt; &lt;TextView android:id="@+id/tv_play_count" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginLeft="10dp" android:layout_weight="1" android:text="109万次播放" android:textColor="#8b8787"/&gt; &lt;ImageView android:id="@+id/iv_comment" android:layout_width="20dp" android:layout_height="20dp" android:layout_marginRight="2dp" android:background="@drawable/comment_video_normal"/&gt; &lt;TextView android:id="@+id/tv_comment_count" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="10dp" android:text="3940" android:textColor="#8b8787"/&gt; &lt;ImageView android:id="@+id/iv_comment_more" android:layout_width="20dp" android:layout_height="20dp" android:background="@drawable/more_pgc_comment_normal_night"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 其中VideoPlayer是自定义View，继承于RelativeLayout，是视频播放的关键类 VideoPlayer12345678910 public VideoPlayer(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); initView(); &#125; //初始化布局 private void initView() &#123; View view = View.inflate(getContext(), R.layout.video_play, this); ButterKnife.bind(this,view);... &#125; 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;!--视频播放界面--&gt; &lt;TextureView android:id="@+id/video_view" android:layout_width="match_parent" android:layout_height="200dp" android:visibility="visible"/&gt; &lt;!--视频播放控制界面--&gt; &lt;com.jackchan.videoplayer.view.VideoMediaController android:id="@+id/mediaController" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/RelativeLayout&gt; 实现视频播放功能的是TextureView，VideoMediaController视频播放控制器，自定义View，继承于RelativeLayout 视频播放（视频的初始化）12345678910111213141516171819private void play(String url)&#123; try &#123; mPlayer = MediaHelper.getInstance(); mPlayer.reset(); mPlayer.setDataSource(url); //让MediaPlayer和TextureView进行视频画面的结合 mPlayer.setSurface(mSurface); //设置监听 mPlayer.setOnBufferingUpdateListener(onBufferingUpdateListener); mPlayer.setOnCompletionListener(onCompletionListener); mPlayer.setOnErrorListener(onErrorListener); mPlayer.setOnPreparedListener(onPreparedListener); mPlayer.setScreenOnWhilePlaying(true);//在视频播放的时候保持屏幕的高亮 //异步准备 mPlayer.prepareAsync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 准备完成监听12345678910111213141516private MediaPlayer.OnPreparedListener onPreparedListener = new MediaPlayer.OnPreparedListener() &#123; @Override public void onPrepared(MediaPlayer mp) &#123; //隐藏视频加载进度条 mediaController.setPbLoadingVisiable(View.GONE); //进行视频的播放 MediaHelper.play(); hasPlay = true; //隐藏标题 mediaController.delayHideTitle(); //设置视频的总时长 mediaController.setDuration(mPlayer.getDuration()); //更新播放的时间和进度 mediaController.updatePlayTimeAndProgress(); &#125;&#125;; 进行TextureView控件创建的监听1videoView.setSurfaceTextureListener(surfaceTextureListener); 1234567891011121314151617181920212223242526private TextureView.SurfaceTextureListener surfaceTextureListener = new TextureView.SurfaceTextureListener() &#123; //创建完成 TextureView才可以进行视频画面的显示 @Override public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) &#123; // Log.i(TAG,"onSurfaceTextureAvailable"); mSurface = new Surface(surface);//连接对象（MediaPlayer和TextureView） play(info.url); &#125; @Override public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) &#123; // Log.i(TAG,"onSurfaceTextureSizeChanged"); &#125; @Override public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) &#123; // Log.i(TAG,"onSurfaceTextureDestroyed"); return true; &#125; @Override public void onSurfaceTextureUpdated(SurfaceTexture surface) &#123; // Log.i(TAG,"onSurfaceTextureUpdated"); &#125;&#125;; VideoMediaController 布局文件如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="200dp" &gt; &lt;!--视频加载进度条--&gt; &lt;ProgressBar android:id="@+id/pb_loading" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:visibility="gone"/&gt; &lt;RelativeLayout android:id="@+id/rl_play_finish" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#b4000000" android:visibility="visible"&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:orientation="horizontal"&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="20dp" android:orientation="vertical" &gt; &lt;ImageView android:id="@+id/iv_replay" android:layout_width="50dp" android:layout_height="50dp" android:src="@drawable/replay_video"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_marginTop="5dp" android:text="重播" android:textColor="#fff" android:textSize="14sp"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="wrap_content" android:orientation="vertical" &gt; &lt;ImageView android:id="@+id/iv_share" android:layout_width="50dp" android:layout_height="50dp" android:src="@drawable/share_video"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_marginTop="5dp" android:text="分享" android:textColor="#fff" android:textSize="14sp"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;TextView android:id="@+id/tv_title" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="10dp" android:gravity="center" android:text="@string/title" android:textColor="#fff" android:textSize="14sp"/&gt; &lt;ImageView android:id="@+id/iv_play" android:layout_width="50dp" android:layout_height="50dp" android:layout_gravity="center" android:src="@drawable/new_play_video" android:visibility="visible"/&gt; &lt;TextView android:id="@+id/tv_all_time" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="bottom|right" android:layout_margin="10dp" android:background="@drawable/tv_time_bg" android:paddingBottom="5dp" android:paddingLeft="10dp" android:paddingRight="10dp" android:paddingTop="5dp" android:text="02:30" android:textColor="#fff" android:textSize="10sp" android:visibility="visible"/&gt; &lt;LinearLayout android:id="@+id/ll_play_control" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="bottom" android:background="#ca000000" android:gravity="center_vertical" android:padding="10dp" android:visibility="visible" &gt; &lt;TextView android:id="@+id/tv_use_time" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="10dp" android:text="00:00" android:textColor="#fff" android:textSize="10sp"/&gt; &lt;SeekBar android:id="@+id/seekBar" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginRight="10dp" android:layout_weight="1" android:progressDrawable="@drawable/sb_progress_drawable" android:thumb="@drawable/biz_video_progress_thumb" /&gt; &lt;TextView android:id="@+id/tv_time" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="10dp" android:text="02:30" android:textColor="#fff" android:textSize="10sp"/&gt; &lt;ImageView android:id="@+id/iv_fullscreen" android:layout_width="20dp" android:layout_height="20dp" android:src="@drawable/enlarge_fullscreen"/&gt; &lt;/LinearLayout&gt;&lt;/FrameLayout&gt; 显示或者隐藏视频控制界面1234567891011121314151617181920212223242526272829303132333435private void showOrHideVideoController() &#123; if(llPlayControl.getVisibility() == View.GONE)&#123; //显示（标题、播放按钮、视频进度控制） tvTitle.setVisibility(View.VISIBLE); ivPlay.setVisibility(View.VISIBLE); //加载动画 Animation animation = AnimationUtils.loadAnimation(getContext(),R.anim.bottom_enter); animation.setAnimationListener(new SimpleAnimationListener()&#123; @Override public void onAnimationEnd(Animation animation) &#123; super.onAnimationEnd(animation); llPlayControl.setVisibility(View.VISIBLE); //过2秒后自动隐藏 mHandler.sendEmptyMessageDelayed(MSG_HIDE_CONTROLLER,2000); &#125; &#125;); //执行动画 llPlayControl.startAnimation(animation); &#125;else&#123; //隐藏（标题、播放按钮、视频进度控制） tvTitle.setVisibility(View.GONE); ivPlay.setVisibility(View.GONE); //加载动画 Animation animation = AnimationUtils.loadAnimation(getContext(),R.anim.bottom_exit); animation.setAnimationListener(new SimpleAnimationListener()&#123; @Override public void onAnimationEnd(Animation animation) &#123; super.onAnimationEnd(animation); llPlayControl.setVisibility(View.GONE); &#125; &#125;); //执行动画 llPlayControl.startAnimation(animation); &#125;&#125; 更新播放的时间和进度 12345678910111213141516public void updatePlayTimeAndProgress() &#123; //获取目前播放的进度 int currentPosition = MediaHelper.getInstance().getCurrentPosition(); //格式化 String useTime = formatDuration(currentPosition); tvUseTime.setText(useTime); //更新进度 int duration = MediaHelper.getInstance().getDuration(); if(duration == 0)&#123; return; &#125; int progress = 100*currentPosition/duration; seekBar.setProgress(progress); //发送一个更新的延时消息 mHandler.sendEmptyMessageDelayed(MSG_UPDATE_TIME_PROGRESS,500);&#125; 自定义SeekBar123456789&lt;SeekBar android:id="@+id/seekBar" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginRight="10dp" android:layout_weight="1" android:progressDrawable="@drawable/sb_progress_drawable" android:thumb="@drawable/biz_video_progress_thumb" /&gt; sb_progress_drawable 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:id="@android:id/background" android:drawable="@drawable/sb_bg"/&gt; &lt;item android:id="@android:id/secondaryProgress"&gt; &lt;scale android:scaleWidth="100%"&gt; &lt;selector&gt; &lt;item android:state_enabled="false"&gt; &lt;color android:color="@android:color/transparent"/&gt; &lt;/item&gt; &lt;item android:drawable="@drawable/sb_second"/&gt; &lt;/selector&gt; &lt;/scale&gt; &lt;/item&gt; &lt;item android:id="@android:id/progress"&gt; &lt;scale android:scaleWidth="100%"&gt; &lt;selector&gt; &lt;item android:state_enabled="false"&gt; &lt;color android:color="@android:color/transparent"/&gt; &lt;/item&gt; &lt;item android:drawable="@drawable/sb_progress"/&gt; &lt;/selector&gt; &lt;/scale&gt; &lt;/item&gt;&lt;/layer-list&gt; 列表的item滚动出屏幕时停止播放1234567891011121314151617181920212223private RecyclerView.OnScrollListener onScrollListener = new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); &#125; //进行滑动 @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); //获取屏幕上显示的第一个条目和最后一个条目的下标 int firstVisibleItemPosition = lm.findFirstVisibleItemPosition(); int lastVisibleItemPosition = lm.findLastVisibleItemPosition(); //获取播放条目的下标 int currentPosition = adapter.currentPosition; if((firstVisibleItemPosition &gt; currentPosition || lastVisibleItemPosition &lt; currentPosition) &amp;&amp; currentPosition &gt; -1)&#123; //让播放隐藏的条目停止 MediaHelper.release(); adapter.currentPosition = -1; adapter.notifyDataSetChanged(); &#125; &#125; &#125;; 代码：https://github.com/JackChan1999/VideoPlayer]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化 - 消除卡顿]]></title>
    <url>%2F2017%2F05%2F24%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E6%B6%88%E9%99%A4%E5%8D%A1%E9%A1%BF%2F</url>
    <content type="text"><![CDATA[消除卡顿 什么是卡顿及卡顿的衡量标准 产生卡顿的原因 通用优化流程 定位卡顿原因 什么是卡顿卡顿是人的一种视觉感受，比如我们滑动界面时，如果滑动不流程我们就会有卡顿的感觉，这种感觉我们需要有一个量化指标，在编程时如果开发的程序超过了这个指标我们认为其是卡顿的。 FPS（帧率）：每秒显示帧数（Frames per Second）。表示图形处理器每秒钟能够更新的次数。高的帧率可以得到更流畅、更逼真的动画。一般来说12fps大概类似手动快速翻动书籍的帧率，这明显是可以感知到不够顺滑的。30fps就是可以接受的，但是无法顺畅表现绚丽的画面内容。提升至60fps则可以明显提升交互感和逼真感，但是一般来说超过75fps就不容易察觉到有明显的流畅度提升了，如果是VR设备需要高于75fps，才可能消除眩晕的感觉。 开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms≈1000/60的时间来处理所有的任务。Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps。 如果你的某个操作花费时间是24ms，系统在得到VSYNC信号的时候就无法进行正常渲染，这样就发生了丢帧现象。那么用户在32ms内看到的会是同一帧画面。 如果此时用户在看动画的执行或者滚动屏幕（如RecyclerView），就会感觉到界面不流畅了（卡了一下）。丢帧导致卡顿产生。 流畅的情况下： 出现了丢帧现象（卡顿） 严重丢帧（卡死了） 给我们一种感觉，如果帧率越低，卡顿就越严重，那么是不是就可以使用帧率来衡量卡顿那？ 如何衡量卡顿FPS的高低不能准确的反映应用的流程度。如下图所示，只有有更新的时候才刷新界面。 当界面没有变动的时候，手机不需要对界面进行更新，所以此时的FPS会很低，如果1秒钟内都没有变动那么FPS=0。所以我们需要利用其他方式来衡量应用的流程度，比如可以利用丢帧数来衡量。 单位时间内丢帧数可以反映出应用是否流程。不丢帧是终极目标，但每秒丢帧在6-7帧左右可以接受，如果丢10帧以上就需要优化了。 丢帧情况（单位时间内均匀分布） 卡顿情况 0-10帧 流畅 10-20帧 较卡 20-40帧 很卡 40-60帧 卡死了 对于我们开发人员来说，会使用一些工具找出卡顿比较集中的地方，找出原因，消除或减弱卡顿。（测试团队会有专门的工具去测试丢帧的情况） 卡顿产生的原因核心：分析在16ms中我们的应用做了什么工作，那些工作阻止我们在16ms时更新界面。 通常情况下，在16ms中我们有那些工作需要处理。 单以XML布局被绘制出来为例进行说明。 处理过程： CPU负责把UI组件计算成多边形和纹理 OpenGL负责绘制图像（Display List） GPU栅格化需要显示内容并渲染到屏幕上 而实际开发中我们还加入交互、业务处理等工作，这些工作都需要在16ms中处理完成。对于开发人员来说，需要有一个工具，很直观的帮助我们判断出那些工作占用了多少时间。 Profile GPU Rendering通过手机开发者选项中提供的Profile GPU Rendering（GPU呈现模式分析）功能，我们可以清楚的看到处理流程中各部分的耗时。手机端工具（开发助手àGPU渲染图）。建议大家在Android6.0及以上手机测试。 打开Profile GPU Rendering操作截图如下： 大家可以拿着真机配置一下。看看有什么变化。 条形图说明 水平方向的一根绿线代表16ms。 每条都代表一帧画面所有工作内容 每条中不同的颜色代表不同的工作内容 Android6.0及以上的手机颜色对应关系如下： 原因分析 通用优化流程第一步：UI层优化 UI问题比较容易查找 一旦出现问题影响范围广（xml、mesure、layout、draw、Display List 、栅格化……） 工具：设备过渡绘制查看功能、HierarchyViewer等 常见问题：过渡绘制、布局复杂、层级过深…… 过渡绘制在屏幕一个像素上绘制多次（超过两次）。如：文本框，如果设置了背景颜色（黑色），那么显示的文字（白色）就需要在背景之上再次绘制。 打开手机开发者中的过渡绘制区域即可查看。蓝色标识这个区域绘制了两次。 说明： 如果大面积都是蓝色，属于正常情况。 重点关注大面积绿色及以后的，表示存在过渡绘制。 设备中的该选项只能直观的让我们感受到应用的界面是否存在过渡绘制，如果存在，我们需要利用Hierarchy Viewer查找布局中不合理的地方。 过渡绘制小案例效果图如下 大面积存在过渡绘制，文字区域最严重。查询Item布局文件找出过渡绘制的原因 自定义控件绘制优化Clip Rect 与 Quick Reject Clip Rect：识别可见区域 Quick Reject：控件所在的矩形区域是否有交集 在Canvas中有上述两个方法，帮助我们进行判断，避免出现过渡绘制。 我们可以通过canvas.clipRect()来帮助系统识别那些可见的区域，在这个区域之外的我们不在进行绘制。如侧拉菜单，当菜单显示的时候被菜单遮挡的部分是不用进行绘制的，一旦绘制就会出现过渡绘制现象。系统的控件会控制过渡绘制，但我们自己的控件就需要自行管理了。所以在使用侧拉菜单时就需要优先考虑系统提供的了。 如果系统没有提供的，我们自己编写时也需要注意，避免出现过渡绘制。 自定义控件过渡绘制案例效果 需要资源：img 编写自定义控件MyVIew，在布局中引入该控件 12345&lt;com.itheima.overdrawdemo.MyView android:layout_width="match_parent" android:layout_height="match_parent" android:background="@android:color/transparent"&gt;&lt;/com.itheima.overdrawdemo.MyView&gt; 图片资源数组 1private int[] ids = new int[]&#123;R.drawable.img1, R.drawable.img2, R.drawable.img3, R.drawable.img4, R.drawable.img5, R.drawable.img6&#125;; 初始化时加载图片资源，同时对一会需要使用到的画笔做初始化 12345678private void init() &#123; for (int i = 0; i &lt; 6; i++) &#123; imgs[i] = BitmapFactory.decodeResource(getResources(), ids[i]); &#125; paint=new Paint(); paint.setAntiAlias(true);&#125; 先将图片摆放好 123for (int i = 0; i &lt; imgs.length; i++) &#123; canvas.drawBitmap(imgs[i],i*20,0,paint);&#125; 通过过渡绘制的开启，观察结果 原因比较简单，对于“大王”这张牌来说，我们不需要绘制完整的图片，如果都绘制了就会出现上面的情况 处理思路：找出牌需要绘制的区域，让canvas在绘制这张牌时仅仅按区域绘制一部分即可。对于“大王”这张牌来说我们仅仅绘制如下内容 重点来了，我们该如何划定这个区域？ 在Canvas中clipRect方法可以帮助我们划定一个区域，进行绘制。 方法参数说明： clipRect(int left, int top, int right, int bottom) canvas.clipRect(0, 0, 20, imgs[i].getHeight()); 设置完成后，我们来绘制大王这张牌。 canvas.drawBitmap(imgs[0],0,0,paint); 再增加循环，快速绘制所有的牌。 1234for (int i = 0; i &lt; imgs.length; i++) &#123; canvas.clipRect(i * 20, 0, (i + 1) * 20, imgs[i].getHeight()); canvas.drawBitmap(imgs[i],i*20,0,paint);&#125; 大家会发现绘制完成的结果不是我们想要的。 我们需要借助save和restore来完成裁剪的操作。 save：用来保存Canvas的状态。save之后，可以调用Canvas的平移、放缩、旋转、错切、裁剪等操作。 restore：用来恢复Canvas之前保存的状态。防止save后对Canvas执行的操作对后续的绘制有影响。 save和restore要配对使用(restore可以比save少，但不能多)，如果restore调用次数比save多，会引发Error。save和restore之间，往往夹杂的是对Canvas的特殊操作 代码修改如下 123456for (int i = 0; i &lt; imgs.length; i++) &#123; canvas.save(); canvas.clipRect(i * 20, 0, (i + 1) * 20, imgs[i].getHeight()); canvas.drawBitmap(imgs[i],i*20,0,paint); canvas.restore();&#125; 效果如下 剩下最后一个工作，把最上面的牌绘制完整 12345678910for (int i = 0; i &lt; imgs.length; i++) &#123; canvas.save(); if(i&lt;imgs.length-1) &#123; canvas.clipRect(i * 20, 0, (i + 1) * 20, imgs[i].getHeight()); &#125;else if(i==imgs.length-1)&#123; canvas.clipRect(i * 20, 0, i * 20+imgs[i].getWidth(), imgs[i].getHeight()); &#125; canvas.drawBitmap(imgs[i],i*20,0,paint); canvas.restore();&#125; Hierarchy Viewer(层级查看器)工具使用Hierarchy Viewer可以很直接的呈现布局的层次关系，视图组件的各种属性。我们可以通过红，黄，绿三种不同的颜色来区分布局的Measure，Layout，Executive的相对性能表现如何。 打开工具 选择需要查看的内容 查看各个节点Measure，Layout，Executive 三个小圆点, 依次表示Measure, Layout,Draw, 可以理解为对应View的onMeasure, onLayout, onDraw三个方法. 绿色, 表示该View的此项性能比该View Tree中超过50%的View都要快. 黄色, 表示该View的此项性能比该View Tree中超过50%的View都要慢. 红色, 表示该View的此项性能是View Tree中最慢的. 一般来说: 1． Measure红点, 可能是布局中嵌套RelativeLayout, 或是嵌套LinearLayout都使用了weight属性. 2． Layout红点, 可能是布局层级太深. 3． Draw红点, 可能是自定义View的绘制有问题, 复杂计算等. 我们之前的小案例，可以进行层级优化。 常规做法 没有用的父布局——没有背景绘制或没有大小限制的父布局，不会对界面效果产生任何影响。特别是进来的布局，很容易产生问题。可以通过标签替代。 在布局层次一样的情况下，建议使用LinearLayout代替RelativeLayout。 使用LinearLayout导致的层次变深，可以使用RelativeLayout进行替换。同样的界面我们可以使用不同的方式去实现，选择一个层级最少的方案。 不常用的UI被设置成了GONE，尝试使用代替。 去掉多余的背景颜色，减少过渡绘制，对于有多层背景色的布局来说，留最上面的一层即可。谨慎使用alpha，如果后渲染的元素有设置alpha值，那么这个元素就会和屏幕上已经渲染好的元素做blend处理，这样会导致不少性能问题，特别是出现在列表的Item中。 对于使用Selector当背景的布局，可以将normal状态的color设置为透明。 我们不能因为提高性能而忽略了界面需要达到的效果（平衡Design与Performance）。 第二步：代码问题查找工具：Lint 常见问题：我们重点关注Performance和Xml中的一些建议 在绘制时实例化对象（onDraw） 手机不能进入休眠状态（Wake lock） 资源忘记回收 Handler使用不当倒置内存泄漏 没有使用SparseArray代替HashMap 未被使用的资源 布局中无用的参数 可优化布局（如：ImageView与TextView的组合是否可以使用TextView独立完成） 效率低下的 无用的命名空间等 Lint工具使用Android Studio中开启Lint工具 选中需要分析的Module，点击工具栏中Analyze中的Inspect Code选项。 选择需要分析的Module或整个项目 我们可以逐一阅读一下，但是重点关注性能问题，xml中的一些问题也尽可能进行修复。 问题处理1. 案例中性能问题处理 其他的一些性能问题 建议使用concate方法进行连接字符串，会比append的方式性能好。 2. 案例中xml提到的内容如下 其他问题： 无效的命名空间 无效的布局参数 比如在线性布局中的控件使用到了相对布局中的属性，运行时需要处理，影响代码的执行效率。 3. 案例中关于定义声明变量的警告 意见或建议 不断关注Lint中提到的问题，将公司中命名规范中没有提到的内容逐一补全。 Lint不是万能的。 第三步：优化App的逻辑层工具：Traceview 常见问题：主线程耗时大的函数、滑动过程中的CPU工作问题，工具可以提供每个函数的耗时和调用次数，我们重点关注两种类型的函数： 主线程里占用CUP时间很长的函数，特别关注IO操作（文件IO、网络IO、数据库操作等） 主线程调用次数多的函数 使用Traceview找出卡住主线程的地方Traceview工具使用 通过Android Studio打开里面的Android Device Monitor，切换到DDMS窗口，点击左边栏上面想要跟踪的进程，再点击上面的Start Method Profiling的按钮，如下图所示： 启动跟踪之后，再操控app，做一些你想要跟踪的事件，例如滑动RecyclerView，点击某些视图进入另外一个页面等等。操作完之后，回到Android Device Monitor，再次点击相同的按钮停止跟踪。此时工具会为刚才的操作生成TraceView的详细视图。 重点关注Incl Cpu Time、Call+Recur Calls/Total、Real Time/Call 通过降序排序，我们可以分别找到这两列中数值比较大的内容。 指标说明: 指标 说明 Incl(Inclusive) Cpu Time 方法本身和其调用的所有子方法占用CPU时间 Excl(Exclusive) Cpu Time 方法本身占用CPU时间 Incl Real Time 方法(包含子方法)开始到结束用时 Excl Real Time 方法本身开始到结束用时 Call + Recursion Calls/Total 方法被调用次数 + 方法被递归调用次数 Cpu Time/Call 方法调用一次占用CPU时间. 方法实际执行时间(不包括io等待时间) Real Time/Call 方法调用一次实际执行时间. 方法开始结束时间差(包括等待时间) 小案例： 我们可以在ViewHolder的设置数据中做点手脚，比如睡几毫秒（8ms），通过监控滚动，我们是否可以定位到问题代码。 好的做法 不要阻塞UI线程，占用CUP较多的工作尽可能放在子线程中执行。 需要结合使用场景选择不同的线程处理方案 AsyncTask:为UI线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。 HandlerThread: 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。 ThreadPool: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。 IntentService: 适合于执行由UI触发的后台Service任务，并可以把后台任务执行的情况通过一定的机制反馈给UI。 如果大量操作数据库数据时建议使用批处理操作。如：批量添加数据。 综合案例应用启动性能优化。 使用NoHttp获取应用列表 问题表现：通常从用户点击到应用完全展示完首页，需要用户等待一段时间。我们如何缩短时间并提高用户体验。 分析：应用在启动的过程中我们的代码能够影响启动速度的地方如下 Application的onCreate 首屏Activity的渲染 步骤： 利用Traceview工具观察启动过程方法耗时情况，重点关注onCreate方法（自定义Application和首页Activity）。问题：Traceview工具如何在应用启动时监控数据？ 分析自定义Application耗时操作，判断onCreate方法中的内容（如：第三方的工具是否可以不占用主线程进行初始化）。 查看界面是否存在过渡绘制。 利用Hierarchy Viewer工具查看界面需要优化的点。 启动过程中的白屏优化。 第一步：观察耗时情况 在onCreate开始和结尾打上trace 12Debug.startMethodTracing("POApp");Debug.stopMethodTracing(); 运行程序, 会在sdcard上生成一个”POApp.trace”的文件. 注意: 需要给程序加上写存储的权限: 1&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; Android6.0以后的模拟器需要为应用打开读写权限 通过adb pull将其导出到本地 1adb pull /sdcard/ POApp.trace 存放文件路径 第二步：分析数据通过DDMS的FileàOpen File 查询结果如下 说明：我们使用Real Time/Call进行排序可以得到上图内容 大家可以发现在Application中阻塞主线程干的工作都是NoHttp的初始化工作。为了提高应用的启动速度，我们可以将这个工作放到子线程中完成，通常我们会使用IntentService来处理这个工作。 代码如下： 1234567891011121314151617181920/** * Created by itheima. */public class MyApplication extends Application &#123; @Override public void onCreate() &#123; // 如果没有办法手动操作监控，可以使用如下代码重点关注我们感兴趣的方法 // 监控的结果会生成文件存储SDCard上// Debug.startMethodTracing("AppStartupDemo");// 文件的名称 super.onCreate(); InitService.start(this); SystemClock.sleep(1000);// Debug.stopMethodTracing(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 将MyApplication中onCreate方法内容耗时的初始化工作移动到该类中 */public class InitService extends IntentService &#123; // 问题：由于将NoHttp的初始化工作移动到了子线程，当主线程使用NoHttp发现没有初始化完成，报异常了。 // 方案一：使用boolean值进行初始化工作的标记，如果完成boolean为true，可以在使用该工具的地方每隔一个时间段判断一下。 // 方案二：当初始化工作完成后，发出一个通知，如果有观察者，则进行后续工作的处理 public static boolean isInit=false;// 标记是否初始化完成 public InitService() &#123; super("init"); &#125; @Override protected void onHandleIntent(@Nullable Intent intent) &#123; // 耗时操作 Logger.setTag("NoHttp"); Logger.setDebug(true); NoHttp.initialize(this, new NoHttp.Config() .setConnectTimeout(30 * 1000) .setReadTimeout(30 * 1000) ); isInit=true; &#125; /** * 启动service * @param myApplication */ public static void start(MyApplication myApplication) &#123; Intent intent = new Intent(myApplication, InitService.class); myApplication.startService(intent); &#125;&#125; 修改完成后，会引发一个问题，及在首页访问网络时，由于NoHttp的初始化还没有完成会报出如下异常： 如果我们在首页就需要立即访问网络，就需要对初始化进行监控，可以简单的使用一个boolean值，进行判断，当初始化完成后boolean值修改为true。我们在MainActivity中可以使用Handler间隔一段时间就检查一下boolean即可。 第三步：过渡绘制进入首页后，应用的启动速度限制就集中在首页的界面渲染上了。因此我们开始对界面进行优化处理。 过渡绘制查看结果。 表现还好，我们可以检查一下Item，看看是否可以优化掉一次绘制。 第四步：优化界面布局Hierarchy Viewer工具派上用场了，我们可以检查一下布局是否合理。 重点观察其中一个条目 优化完成后的结构图 我们先优化掉两个用处不大的LinearLayout,然后在考虑是否可以继续优化掉条目中的LinearLayout。 第五步：Launch screens设置两种处理方案： 方案一：设置一个背景图 12&lt;item name="android:windowBackground"&gt;@drawable/splash&lt;/item&gt;&lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; 注意：当界面加载完成后需要将背景改成白色。 方案二：设置成透明的界面，制造延时启动效果 12&lt;item name="android:windowIsTranslucent"&gt;true&lt;/item&gt;&lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; AndroidPerformanceMonitorGitHub BlockCanary — 轻松找出Android App界面卡顿元凶 BlockCanary是一个Android平台的一个非侵入式的性能监控组件，应用只需要实现一个抽象类，提供一些该组件需要的上下文环境，就可以在平时使用应用的时候检测主线程上的各种卡慢问题，并通过组件提供的各种信息分析出原因并进行修复。 取名为BlockCanary则是为了向LeakCanary致敬，顺便本库的UI部分是从LeakCanary改来的，之后可能会做一些调整。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化]]></title>
    <url>%2F2017%2F05%2F23%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[性能优化系列阅读 Android性能优化 性能优化 - 消除卡顿 性能优化 - 内存优化 Android性能分析工具 性能分析工具 - TraceView 内存优化1-内存的管理机制 2-常见问题 3-Memory Monitor工具使用 4-内存抖动案例及优化 5-利用Allocation Tracker查找内存抖动中有问题的代码 6-利用Heap Viewer监控内存泄漏 7-利用AS中的Heap Viewer查看内存泄漏原因 8-AS中的Heap Viewer展示信息说明 9-利用LeakCanary工具监控内存泄漏 10-利用LeakCanary工具监控应用市场项目中的内存泄漏 11-Handler内存泄漏原因分析 12-内存碎片问题展示 13-使用对象池优化内存碎片问题 界面卡顿优化1-什么是卡顿 2-卡顿产生的原因分析-Profile GPU Rendering工具使用 3-卡顿产生的原因分析-渲染流程讲解 4-过渡绘制及优化 5-分析自定义控件的过渡绘制 6-解决自定义控件的过渡绘制 7-层级查看器的使用 8-界面优化常用做法 9-Lint可以查找那些代码问题 10-使用Lint进行代码问题的查找 11-Traceview工具使用 12-Traceview案例分析 13-减少CPU主线程占用时间的常规做法 14-综合案例编写 15-综合案例优化步骤 16-使用IntentService处理掉Application中的初始化工作 17-应用异常处理 18-过渡绘制 19-优化布局层级 20-Launch screens设置 网络优化1-什么是网络优化 2-网络优化工作流程 3-网络监控工具使用 4-通信数据优化 5-为什么需要批量处理请求 6-如何进行批量处理请求 7-预取数据 8-预取数据案例 9-网络状态管理 10-案例_网络类型判断 11-案例_主动获取新闻 12-案例_获取新闻详情 13-案例_定时器使用（AlarmManager） 14-案例_定时器使用（JobScheduler） 15-案例_批量上传数据 16-案例_SyncAdater框架 17-SyncAdapter使用_创建SyncAdapter类 18-SyncAdapter使用_创建SyncService类 19-SyncAdapter使用_账户创建 20-SyncAdapter使用_触发SyncAdapter 电量优化1-手机系统对应用的电量监控 2-使用Battery Historian查看电量监控数据 3-电量报表数据查看 4-应用电量分布情况 5-通用电量优化方案 6-常用API介绍 7-Doze模式 8-App Standby模式 ##内存泄露 内存泄露是指对象已经不再使用，但是因为某种原因还存在于内存中，没有及时地被垃圾回收器（GC）回收，从而造成了内存溢出 导致内存溢出的最主要的原因就是某些长存对象持有了一些其它应该被回收的对象的引用，导致垃圾回收器无法去回收这些对象，那也就出现内存泄露了。或者说是长生命周期对象持有了短生命周期对象的引用就很可能发生内存泄露 监测内存泄露的工具 Leakcanary：内存泄露监测神器，出自著名的开源组织square Eclipse Analysis Memory Tools(MAT)：Eclipse的内存分析工具 dumpsys meminfo命令 ddms的heap内存监测工具 Android studio Monitors：在该监听器下有图形化的分析工具，memory，cpu，gpu，network ##内存溢出 ##垃圾回收 java中用有向图表示引用关系，可达，存在连接通路，不可达 GC为了能够正确释放对象，GC必须监控每一个对象的运行状态，包括对象的申请，引用，被引用，复制等，GC都要进行监控 java的内存管理就是对象的分配和释放问题，在java中，程序员需要通过关键字new为每个对象申请内存空间（基本数据类型除外），所有的对象都在堆heap中分配空间，另外对象的释放是由GC决定和执行的，在java中，内存的分配是有程序完成的，而内存的释放是由GC来完成的，这种收支两条线的方法确实减少了程序员的工作，但同时它也加重了JVM的工作，这也是java运行速度较慢的原因之一。因为GC为了能够正确释放对象，GC必须监控每一个对象的运行状态，包括对象的申请，引用，被引用，复制等，GC都需要进行监控 监控对象状态是为了更加准确，及时的释放对象，而释放对象的根本原则就是该对象不再被引用 ###GC的工作原理 为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。 以下，我们举一个例子说明如何用有向图表示内存管理。对于程序的每一个时刻，我们都有一个有向图表示JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。 Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。 ##内存管理 从上图可以看出，java内存区域主要分为2部分 线程共享内存区：java堆，方法区 线程私有内存区：虚拟机栈，本地方法栈，程序计数器，这部分内存是随着线程的产生二产生，消亡而消亡，因此不需要过多的考虑内存回收的问题，编译时就已经确定所需内存的大小 ###1、栈 对象的引用，数组的引用 ###2、堆 new出来的对象，数组 ###3、方法区 类信息，常量（常量池），静态变量Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中 ###4、程序计数器 一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变计数器的值来选择下一条需要执行的字节码指令，分支，跳转，循环等基础功能都要依赖它来实现。每条线程都有一个独立的程序计数器，各个线程间的计数器互不影响，因此该区域是线程私有的 ##内存分配策略 java程序运行时的内存分配策略有三种，分别是静态分配，栈式分配和堆式分配，对应的三种存储策略使用的内存空间分别是静态存储区（也叫方法区），栈区和堆区。 ###1、静态存储区（方法区） 主要存放静态数据，全局static数据和常量，这块内存在编译时就已经分配好，并且在程序整个运行期间都会存在 ###2、栈区 当方法被执行时，方法内部的局部变量（其中包括基本数据类型和对象的引用）都在栈上创建，并在方法执行结束的时候这些局部变量所持有的内存都将自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量很有限 栈还分配堆中对象或数组的引用内存空间 ###3、堆区 又称为动态内存分配，通常就是指程序运行时直接new出来的内存，也就是对象的实例，数组，这部分内存在不使用时将由java垃圾回收器来负责回收 ##JVM ##电量优化 ##布局优化 ##性能优化 ###1、使用IntentService 使用IntentService有两个好处，一个是任务执行完的时候，IntentService会自动结束，不会像Service那样长期呆在后台；另外一个是不需要手动开辟子线程去执行耗时操作，因为IntentService已经帮我们做了这些工作 ###2、使用优化的数据容器 SparseArray稀疏数组，替代HashMap SparseBooleanArray 替代HashMap LongSparseArray ArrayMap ###3、使用线程池管理线程 在需要开辟子线程去执行耗时任务的时候不要通过new Thread的方式，因为创建和销毁一个线程所消耗的资源可能会比执行这个线程所消耗的资源更多，所以我们应该使用线程池技术，去统一的管理和缓存线程，提高效率 ###4、优化Bitmap 内存溢出大部分情况都是大图片导致的，大图片占用的内存是像素总数x每个像素占用的字节数，一张很小的图片都有可能占用很大的内存，所以我们很有必要对图片进行压缩，缓存图片（三级缓存），复用Bitmap（inBitmap属性），回收Bitmap（recycle()） 性能分析专题 Android性能优化典范1 Android性能优化典范2 Android性能优化典范3 Android界面性能调优手册]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存优化]]></title>
    <url>%2F2017%2F05%2F23%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[为什么内存优化？在一个商业项目中，很有可能因为工程师的疏忽，导致代码质量不佳，影响到程序的运行效率，从而让用户感知到应用的卡顿、崩溃。而Android开发中，每个Android应用在手机上申请的内存空间都是有限的。虽然手机发展越来越快，可申请到的内存越来越大，但是也不能大手大脚，随便浪费应用可使用的内存空间。内存一旦不够时，你这个应用就会因为OOM（out of memory）而崩溃。因此，内存优化这一块内容，在开发应用时是非常重要的。 1. 内存优化的关键点—避免内存泄露内存优化中非常关键的一点，就是避免内存泄露。因为内存泄露会严重的导致内存浪费，所以避免内存泄露，是内存优化中必不可少的。 2. java中的四种引用类型java引用类型不是指像int、char等这些基本的数据类型。java中的引用类型有四种：强引用、软引用、弱引用、虚引用。这四种引用类型，它们关于对象的可及性是由强到弱的。 12345678910111213141516171819202122232425262728public class ReferenceDemo &#123; public static void main(String[] args) &#123; // 强引用：对象类型 对象的名字(实例) = 对象的构造方法; String str = "abc"; // 常量池 // String str = new String("abc"); // 堆内存 // 软引用,当内存不足的时候，才会释放掉它引用的对象 SoftReference&lt;String&gt; softReference = new SoftReference&lt;String&gt;(str); // 弱引用,只要系统产生了GC(垃圾回收)，它引用的对象就会被释放掉 WeakReference&lt;String&gt; weakReference = new WeakReference&lt;String&gt;(str); // 虚引用，实际用的不多，就是判断对象已被回收 // PhantomReference&lt;String&gt; phantomReference = new PhantomReference&lt;String&gt;(referent,q); str = null; System.out.println("强引用：" + str); softReference.clear(); System.out.println("软引用：" + softReference.get()); // 通过GC，将String对象回收了，那你引用中的对象也会变成null，gc只回收堆内存 System.gc(); System.out.println("弱引用：" + weakReference.get()); &#125;&#125; 2.1 强引用最常见的强引用方式如下： 123//强引用 对象类型 对象名 = new 对象构造方法();//比如下列代码String str = new String("abc"); 在上述代码中，这个str对象就是强可及对象。强可及对象永远不会被GC回收。它宁愿被抛出OOM异常，也不会回收掉强可及对象。 清除强引用对象中的引用链如下： 123String str = new String("abc");//置空str = null; 2.2 软应用软引用方式如下： 12//软引用SoftReferenceSoftReference&lt;String&gt; softReference = new SoftReference&lt;String&gt;(str); 在上述代码中，这个str对象就是软可及对象。当系统内存不足时，软可及对象会被GC回收。 清除软引用对象中的引用链可以通过模拟系统内存不足来清除，也可以手动清除，手动清除如下： 12SoftReference&lt;String&gt; softReference = new SoftReference&lt;String&gt;(str);softReference.clear(); 2.3 弱引用弱引用方式如下： 12//弱引用WeakReferenceWeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(str); 在上述代码中，这个str对象就是弱可及对象。当每次GC时，弱可及对象就会被回收。 清除弱引用对象中的引用链可以通过手动调用gc代码来清除，如下： 12WeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(str);System.gc(); 当然，也可以通过类似软引用，调用clear()方法也可以。 2.4 虚引用虚引用方式如下： 12//虚引用PhantomReferencePhantomReference phantomReference = new PhantomReference&lt;&gt;(arg0, arg1); 虚引用一般在代码中出现的频率极低，主要目的是为了检测对象是否已经被系统回收。它在一些用来检测内存是否泄漏的开源项目中使用到过，如LeakCanary。 2.5 补充 一个对象的可及性由最强的那个来决定。 System.gc()方法只会回收堆内存中存放的对象。 1234String str = "abc";//弱引用WeakReferenceWeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(str);System.gc(); 像这样的代码，即使gc后，str对象仍然可以通过弱引用拿到。因为像”abc”这种，并没有存放在堆内存中，它被存放在常量池里，所以gc不会去回收。 3. 内存泄露的原因对无用对象的引用一直未被释放，就会导致内存泄露。如果对象已经用不到了，但是因为疏忽，导致代码中对该无用对象的引用一直没有被清除掉，就会造成内存泄露。 比如你按back键关掉了一个Activity，那么这个Activity页面就暂时没用了。但是某个后台任务如果一直持有着对该Activity对象的引用，这个时候就会导致内存泄露。 4. 检测内存泄露—LeakCanary在全球最大的同性交友网站github中，有一个非常流行的开源项目LeakCanary，它能很方便的检测到当前开发的java项目中是否存在内存泄露。 5. LeakCanary的使用5.1 官方使用文档描述从LeakCanary的文档描述中，可以得知使用方式，简单翻译为如下步骤： 1.在你的项目中，找到moudle级别的build.gradle文件，并在dependencies标签里加上以下代码： 123456dependencies &#123;//... 你项目中以前声明的一些依赖 debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5' releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5' testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5'&#125; 2.在你Android项目中，找到先前写的Application类（PS：如果没有，那么请自行新建并在AndroidManifest中声明），并添加如下代码： 12345678910111213public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) &#123; // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return; &#125; LeakCanary.install(this); // Normal app init code... &#125;&#125; 3.导入完毕！当你的应用出现内存泄露时，LeakCanary会在通知栏上进行通知，注意查看。下图是一个LeakCanary检测到内存泄露时的实示例。 5.2 检测Fragment上述步骤默认会检测Activity，但是不会去检测Fragment，如果需要对某个Fragment检测的话，需要利用到LeakCanary的其他写法。 首先，在先前的Application类中，改写为以下代码： 1234567891011public class MyApplication extends Application &#123; public static RefWatcher mRefWatcher; @Override public void onCreate() &#123; super.onCreate(); //... mRefWatcher = LeakCanary.install(this); // Normal app init code... &#125;&#125; 然后在Fragment中的onDestroy方法中，去使用这个静态的RefWatcher进行观察，如果onDestroy了当前这个Fragment还没被回收，说明该Fragment产生了内存泄露。 12345@Overridepublic void onDestroy() &#123; super.onDestroy(); MyApplication.mRefWatcher.watch(this);&#125; 5.3 检测某个特定对象有时候如果需要检测某个特定的可疑对象在某个时机下是否内存泄露，那么只需要执行如下代码 （假如对象名为someObjNeedGced）： 1234//...RefWatcher refWatcher = MyApplication.refWatcher;refWatcher.watch(someObjNeedGced);//... 当执行了refWatcher.watch方法时，如果这个对象还在内存中被其他对象引用，就会在 logcat 里看到内存泄漏的提示。 6 LeakCanary的原理简介LeakCanary的代码执行流程图如下： LeakCanary 的机制如下： RefWatcher.watch() 会以监控对象来创建一个KeyedWeakReference 弱引用对象 在AndroidWatchExecutor的后台线程里，来检查弱引用已经被清除了，如果没被清除，则执行一次 GC 如果弱引用对象仍然没有被清除，说明内存泄漏了，系统就导出 hprof 文件，保存在 app 的文件系统目录下 HeapAnalyzerService启动一个单独的进程，使用HeapAnalyzer来分析 hprof 文件。它使用另外一个开源库 HAHA。 HeapAnalyzer 通过查找KeyedWeakReference 弱引用对象来查找内在泄漏 HeapAnalyzer计算KeyedWeakReference所引用对象的最短强引用路径，来分析内存泄漏，并且构建出对象引用链出来。 内存泄漏信息送回给DisplayLeakService，它是运行在 app 进程里的一个服务。然后在设备通知栏显示内存泄漏信息。 7 常见的内存泄露7.1 内部类导致内存泄露内部类实例会隐式的持有外部类的引用。 比如说在Activity中去创建一个内部类实例，然后在内部类实例中去执行一些需要耗时间的任务。任务在执行过程中，将Activity关掉，这个时候Activity对象是不会被释放的，因为那个内部类还持有着对Activity的引用。但是Activity此时已经是个没用的Activity了，所有这时，内存泄露就出现了。 隐式持有外部类的说明：内部类可以直接去调用外部类的方法，如果没有持有外部类的引用，内部类是没办法去调用外部类的属性和方法的，但是内部类又没有明显的去指定和声明引用，所以称之为隐式引用。 7.1.1 Thread线程在Activity中创建一个内部类去继承Thread，然后让该Thread执行一些后台任务，未执行完时，关闭Activity，此时会内存泄露。核心代码如下： 123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startThread(); &#125; &#125;); &#125; private void startThread() &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; SystemClock.sleep(1000); &#125; &#125; &#125;; thread.start(); &#125;&#125; 当点击页面按钮执行startThread()后，再按下back键关闭Activity，几秒后LeakCanary就会提示内存泄露了。 为了避免此种Thread相关内存泄露，只需要避免这个内部类去隐式引用外部类Activity即可。 解决方案：让这个内部类声明为静态类。代码如下： 12345678910111213141516171819202122public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ...与先前相比未做变化，不再描述 &#125; private void startThread() &#123; Thread thread = new MyStaticThread(); thread.start(); &#125; private static class MyStaticThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 200; i++) &#123; SystemClock.sleep(1000); &#125; &#125; &#125;&#125; 这样声明为静态类后，该内部类将不会再去隐式持有外部类的应用。 如果像这样的循环操作，为了效率和优化，建议通过申明一个boolean类型的标志位来控制后台任务。比如在外部类Activity的onDestory退出方法中，将boolean值进行修改，使后台任务退出循环。代码如下： 123456789101112131415161718192021222324public class MainActivity extends AppCompatActivity &#123; ... //Activity页面是否已经destroy private static boolean isDestroy = false; private static class MyStaticThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if(!isDestroy)&#123; SystemClock.sleep(1000); &#125; &#125; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); isDestroy = true; &#125;&#125; 因为申明为了静态内部类，该内部类不再持有外部类Activity的引用，所以此时不能再去使用外部类中的方法、变量。除非外部类的那些方法、变量是静态的。 Q：在防止内存泄露的前提下，如果一定要去使用那些外部类中非静态的方法、变量，该怎么做？ A：通过使用弱引用或者软引用的方式，来引用外部类Activity。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... &#125; private void startThread() &#123; Thread thread = new MyStaticThread(MainActivity.this); thread.start(); &#125; private boolean isDestroy = false;//Activity页面是否已经destroy private static class MyStaticThread extends Thread &#123; private WeakReference&lt;MainActivity&gt; softReference = null; MyStaticThread(MainActivity mainActivity)&#123; this.softReference = new WeakReference&lt;MainActivity&gt;(mainActivity); &#125; @Override public void run() &#123; //能够isDestroy变量是非静态的，它属于MainActivity，我们只要拿到了MainActivity对象，就能拿到isDestroy MainActivity mainActivity = softReference.get(); for (int i = 0; i &lt; 200; i++) &#123; //使用前最好对MainActivity对象做非空判断，如果它已经被回收，就不再执行后台任务 if(mainActivity!=null&amp;&amp;!mainActivity.isDestroy)&#123; SystemClock.sleep(1000); &#125; &#125; &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); isDestroy = true; &#125;&#125; 7.1.2 Handler在使用Handler时，经常可以看到有人在Activity、Fragment中写过内部类形式的Handler，比如说写一个内部类形式的handler来执行一个延时的任务，像这样： 1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends AppCompatActivity &#123; private static final int MESSAGE_DELAY = 0; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButton = (Button) findViewById(R.id.button); mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startDelayTask(); &#125; &#125;); &#125; private void startDelayTask() &#123; //发送一条消息，该消息会被延时10秒后才处理 Message message = Message.obtain(); message.obj = "按钮点击15秒后再弹出"; message.what = MESSAGE_DELAY; mHandler.sendMessageDelayed(message, 15000); &#125; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MESSAGE_DELAY: Toast.makeText(MainActivity.this, (String) msg.obj, Toast.LENGTH_SHORT).show(); mButton.setText("延时修改了按钮的文本"); break; &#125; &#125; &#125;;&#125; 当点击了按钮后会发送出一条消息，该消息将会15秒后再进行处理，如果中途退出Activity，不一会LeakCanary就会检测到内存泄露。 上述代码发生内存泄露也是因为内部类持有外部类的引用。这个内部类Handler会拿着外部类Activity的引用，而那个Message又拿着Handler的引用。这个Message又要在消息队列里排队等着被handler中的死循环来取消息。从而形成了一个引用链，最后导致关于外部类Activity的引用不会被释放。 该情况的的解决方案，是与上一节的Thread线程相同的。只要将Handler设置为static的静态内部类方式，就解决了handler持有外部类引用的问题。 如果handler已申明为静态内部类，那么Handler就不再持有外部类的引用，无法使用外部类中非静态的方法、变量了。 如果想在避免内存泄露的同时，想使用非静态的方法、变量，同样可以用弱（软）引用来做。 123456789101112131415161718192021222324252627282930313233343536373839public class MainActivity extends AppCompatActivity &#123; private static final int MESSAGE_DELAY = 0; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... &#125; private void startDelayTask() &#123; //发送一条消息，该消息会被延时10秒后才处理 ... &#125; private Handler mHandler = new InsideHandler(MainActivity.this); private static class InsideHandler extends Handler &#123; private WeakReference&lt;MainActivity&gt; mSoftReference; InsideHandler(MainActivity activity) &#123; mSoftReference = new WeakReference&lt;MainActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity mainActivity = mSoftReference.get(); if (mainActivity != null) &#123; switch (msg.what) &#123; case MESSAGE_DELAY: Toast.makeText(mainActivity, (String) msg.obj, Toast.LENGTH_SHORT).show(); //通过软引用中的mainActivity可以拿到那个非静态的button对象 mainActivity.mButton.setText("延时修改了按钮的文本"); break; &#125; &#125; &#125; &#125;&#125; 最后，更完美的做法是在这些做法的基础上，再添加这段逻辑：当Activity页面退出时，将handler中的所有消息进行移除，做到滴水不漏。 其实就是在onDestroy中写上： 123456@Overrideprotected void onDestroy() &#123; super.onDestroy(); //参数为null时，handler中所有消息和回调都会被移除 mHandler.removeCallbacksAndMessages(null);&#125; PS：弱引用和软引用的区别：弱引用会很容易被回收掉，软引用没那么快。如果你希望能尽快清掉这块内存使用就使用弱引用；如果想在内存实在不足的情况下才清掉，使用软引用。 下图是在内部类Handler使用软引用时LeakCanary出现的提示。 因为使用软引用，GC会有点偷懒，所以leakCanary会检测到一些异常，出现这样的提示。 7.1.3 非静态内部类的静态实例有时候会使用，代码如下： 123456789101112131415161718192021public class MainActivity extends AppCompatActivity &#123; private static User sUser = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initData(); &#125; private void initData() &#123; if(sUser==null)&#123; sUser = new User(); &#125; &#125; private class User&#123; User()&#123; &#125; &#125;&#125; 在代码中，非静态的内部类创建了一个静态实例。非静态内部类会持有外部类Activity的引用，后来又创建了一个这个内部类的静态实例。 这个静态实例不会在Activity被关掉时一块被回收（静态实例的生命周期跟Activity可不一样，你Activity挂了，但是写在Activity中的静态实例还是会在，静态实例的生命周期跟应用的生命周期一样长）。 非静态内部类持有外部引用，而该内部类的静态实例不会及时回收，所以才导致了内存泄露。 解决方案：将内部类申明为静态的内部类。 12345678public class MainActivity extends AppCompatActivity &#123; ... private static class User&#123; ... &#125;&#125; 7.2 Context导致内存泄露有时候我们会创建一个静态类，比如说AppManager、XXXManager。这些静态类可能还是以单例的形式存在。而这些静态类需要做一个关于UI的处理，所以传递了一个Context进来，代码如下： 1234567891011121314151617181920212223242526public class ToastManager &#123; private Context mContext; ToastManager(Context context)&#123; mContext = context; &#125; private static ToastManager mManager = null; public void showToast(String str)&#123; if(mContext==null)&#123; return; &#125; Toast.makeText(mContext, str, Toast.LENGTH_SHORT).show(); &#125; public static ToastManager getInstance(Context context)&#123; if(mManager==null)&#123; synchronized (ToastManager.class)&#123; if(mManager==null)&#123; mManager = new ToastManager(context); &#125; &#125; &#125; return mManager; &#125;&#125; 而在使用时是这样写的： 12345678public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; ... ToastManager instance = ToastManager.getInstance(MainActivity.this); &#125;&#125; 这个时候代码也会发生内存泄露。因为静态实例比Activity生命周期长，你在使用静态类时将Activity作为context参数传了进来，即时Activity被关掉，但是静态实例中还保有对它的应用，所以会导致Activity没法被及时回收，造成内存泄露。 解决方案：在传Context上下文参数时，尽量传跟Application应用相同生命周期的Context。比如getApplicationContext()，因为静态实例的生命周期跟应用Application一致。 123456789public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ToastManager instance = ToastManager.getInstance(getApplicationContext()); &#125;&#125; 7.2.1 Context的作用域系统中的Context的具体实现子类有：Activity、Application、Service。 虽然Context能做很多事，但并不是随便拿到一个Context实例就可以为所欲为，它的使用还是有一些规则限制的。在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。 出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。 上图中Application和Service所不推荐的两种使用情况： 1.如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错 1android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want? 这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service的原因跟Application一致。 2.在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。一句话总结：凡是跟UI相关的，都建议使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例Context都可以，当然了，注意Context引用的持有，防止内存泄漏。 8. 内存优化—减少内存使用（Reduce）如果减少某些不必要内存的使用，也可以达到内存优化的目的。 比如说Bitmap。它在使用时会花掉较多的内存。那我们就可以考虑在应用bitmap时减少某些不必要内存的使用。 边界压缩一张拍出来的图片分辨率可能会很大，如果不做压缩去展示的话，会消耗大量内存，可能造成OOM，通过BitmapFactory.Options去设置inSampleSize，可以对图片进行边界的压缩，减少内存开销。 做法：先设置BitmapFactory.inJustDecodeBounds为true，然后decodeFile，这样将会只去解析图片大小等信息，避免了将原图加载进内存。拿到原图尺寸信息后，根据业务逻辑换算比例，设置inSampleSize，接着设置BitmapFactory.inJustDecodeBounds为false，最后再去decodeFile，从而实现对图片边界大小进行了压缩再展示。 色彩压缩除此之外，还可以通过设置Bitmap图片的Config配置来减少内存使用。配置有以下四种： 色彩 说明 ALPHA_8 Alpha由8位组成，代表8位Alpha位图 ARGB_4444 由4个4位组成即16位，代表16位ARGB位图 ARGB_8888 由4个8位组成即32位，代表32位ARGB位图，图片质量最佳 RGB_565 R为5位，G为6位，B为5位，共16位，它是没有透明度的 如果配置不一样，需要的内存也不同。比如ARGB4444、ARGB8888、RGB565。配置的位数越高，图片质量越佳，当然需要的内存就越多。如果图片不需要透明度，就采用RGB565的配置。通过Bitmap.Config配置，也可以起到压缩图片大小作用。 在实际中，可以通过以下代码来进行图片转bitmap解码时的Config。 123BitmapFactory.Options options = new BitmapFactory.Options();options.inPreferredConfig = Bitmap.Config.RGB_565;Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_menu_add, options); 如果通过在列表中展示缩略图的形式来加载图片，如果需要查看高清图片，另启动一个页面（对话框）来加载高清图片，这样可以避免在列表中加载太多高清图片，减少内存开销。 9. 内存优化—回收（Recycle）一些资源时使用时记得回收，比如说BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap、TypeArray等资源的代码，应该在使用之后或者Activity销毁时及时关闭或者注销，否则这些资源可能将不会被回收，造成内存泄漏。 10. 内存优化—重用（Reuse）10.1 对象池在程序里面经常会遇到的一个问题是短时间内创建大量的对象，导致内存紧张，从而触发GC导致性能问题。对于这个问题，我们可以使用对象池技术来解决它。通常对象池中的对象可能是bitmaps，views，messages等等。 比如说Message.obtain()方法。通过handler去发消息Message时，通过Message.obtain()来获得一个消息，就比直接通过new一个Message要更好。因为Message中内部就维护了一个对象池用来存放消息，通过obtain方法来取消息的话，会先从内部的对象池中去取，如果取不到，再去新创建一个消息进行使用。 关于对象池的操作原理，请看下面的图示： 使用对象池技术有很多好处，它可以避免内存抖动，提升性能，但是在使用的时候有一些内容是需要特别注意的。通常情况下，初始化的对象池里面都是空白的，当使用某个对象的时候先去对象池查询是否存在，如果不存在则创建这个对象然后加入对象池。 但是我们也可以在程序刚启动的时候就事先为对象池填充一些即将要使用到的数据，这样可以在需要使用到这些对象的时候提供更快的首次加载速度，这种行为就叫做预分配。 使用对象池也有不好的一面，我们需要手动管理这些对象的分配与释放，所以我们需要慎重地使用这项技术，避免发生对象的内存泄漏。为了确保所有的对象能够正确被释放，我们需要保证加入对象池的对象和其他外部对象没有互相引用的关系。 10.2 缓存无论是为了提高CPU的计算速度还是提高数据的访问速度，在绝大多数的场景下，我们都会使用到缓存。 例如缓存到内存里面的图片资源，网络请求返回数据的缓存等等。凡是可能需要反复读取的数据，都建议使用合适的缓存策略。比如图片三级缓存、ListView中的Adapter使用contentView进行复用、使用holder避免重复的findViewById。再比如以下的代码，都是缓存的体现。 1234567891011121314//原代码for (int i = 0; i &lt; 1024; i++) &#123; if(i&lt;getCount())&#123; Log.d("TAG", "some log" + i); &#125;&#125;//有缓存体现的代码，避免重复调用1024次getCount方法int count = getCount();for (int i = 0; i &lt; 1024; i++) &#123; if(i&lt;count)&#123; Log.d("TAG", "some log" + i); &#125;&#125; 10.2.1 缓存中的lru算法lru算法（Least Recently Use），即最近最少使用算法，在Android中比较常用。当内存超过限定大小时，凡是近时间内最少使用的那一个对象，就会从缓存容器中被移除掉。 LRU Cache的基础构建用法如下： 1234//往缓存中添加图片，PicUrl是图片的地址，将其作为key，bitmap位图则作为valuebitmapLRUCache.put(picUrl,bitmap);//通过picUrl图片地址，从缓存中取bitmapbitmapLRUCache.get(picUrl); 为了给LRU Cache设置一个比较合理的缓存大小值，我们通常是用下面的方法来做界定的： 1234//当前应用最大可用内存long maxMemory = Runtime.getRuntime().maxMemory();//创建一个LRUCache，设置缓存大小界限为最大可用内存的八分之一BitmapLRUCache bitmapLRUCache = new BitmapLRUCache((int)maxMemory / 8); 使用LRU Cache时为了能够让Cache知道每个加入的Item的具体大小，我们需要Override下面的方法： 123456789101112public class BitmapLRUCache extends LruCache&lt;String,Bitmap&gt; &#123; public BitmapLRUCache(int maxSize) &#123; super(maxSize); &#125; @Override protected int sizeOf(String key, Bitmap value) &#123; int byteCount = value.getByteCount();//该bitmap位图所占用的内存字节数 return byteCount; &#125;&#125; 11 内存优化—检查（Review）代码写完了只是个开始。比较规范的编码，都需要Review的。代码检查时的注意点可参考上述内容。 接下来要提到的是UI检查。 11.1 查看UI布局是否过度绘制（overdraw）查看的前提是：移动设备已经开启了开发者选项。 在开发者选项中，点击“调试GPU过度绘制”，将弹出对话框，然后选择“显示过度绘制区域”，如下图所示： 屏幕这时候会变得花花绿绿的. 这些颜色是用来帮助你诊断应用程序的显示行为的。 这些颜色用于表示每个像素被重绘的次数, 含义如下： 真实颜色: 没有被重绘 蓝色: 重绘一次 绿色: 重绘两次 粉色: 重绘三次 红色: 重绘四次或更多次 通过这个工具，可以实现这些事情： 展示一个APP在何处做了不必要的渲染绘制。 帮助你查看在哪里可以减少渲染绘制。 有些重绘是不可避免的. 尽量调整APP的用户界面, 目标是让大部分的屏幕都是真实的颜色以及重绘一次的蓝色。 11.2 查看UI布局的渲染速度查看的前提是：移动设备已经开启了开发者选项。 在开发者选项中，点击“GPU呈现模式分析”，将弹出对话框，然后选择“在屏幕上显示为条形图”，如下图所示： 这时，将会在屏幕下方出现条形图，如下图所示： 该工具会为每个可见的APP显示一个图表，水平轴即时间流逝, 垂直轴表示每帧经过的时间,单位是毫秒。 在与APP的交互中, 垂直栏会显示在屏幕上, 从左到右移动, 随着时间推移，绘制帧的性能将会迅速体现出来。 绿色的线是用于标记16毫秒的分隔线（PS：人眼的原因, 1秒24帧的动画才能感到顺畅. 所以每帧的时间大概有41ms多一点点(1000ms/24). 但是但是, 注意了, 这41ms不是全都留给你Java代码, 而是所有java native 屏幕等等的, 最后留给我们用java级别代码发挥的时间, 只有16~17ms），只要有一帧超过了绿线, 你的APP就会丢失一帧。 11.3 查看UI布局的层级和实现方式有的UI界面写的效率比较低，我们可以通过一些工具来进行UI方面的视图检查。Hierarchy Viewer工具可以展示当前手机界面的View层级。 使用该工具的前提是：只能在模拟器或开发版手机上才能用，普通的商业手机是无法连上的。主要是出于安全考虑，普通商业手机中view server这个服务是没有开启的. Hierarchy Viewer就无法连接到机器获取view层级信息。 PS：如果愿意花功夫捣鼓，也可以在真机上强行开启View Server，详情见网上资料 先打开模拟器运行要查看的页面，然后打开Hierarchy Viewer工具，它位于android的sdk所在目录中，具体位置为…\sdk\tools\hierarchyviewer.bat。打开后如图所示： 列表展示手机中已打开的页面（包括状态栏等）。这里以电话应用中的DialtactsActivity为例，双击DialtactsActivity，将会打开关于该页面的树状图。如下图所示： 图中标出了3个部分： Tree View 树状图的形式展示该Activity中的View层级结构。可以放大缩小，每个节点代表一个View，点击可以弹出其属性的当前值，并且在LayoutView中会显示其在界面中相应位置。 Tree Overview 它是Tree View的概览图。有一个选择框， 可以拖动选择查看。选中的部分会在Tree View中显示 Layout View 匹配手机屏幕的视图，如果在Tree View中点击了某个节点，呢么这个节点在手机中的真是位置将会在Layout View中以红框的形式被标出。 接下来介绍点击Tree View中某个节点时，它所展示的信息类似于下图： 下面的三个圆点，依次表示Measure、Layout、Draw，可以理解为对应View的onMeasure，onLayout，onDraw三个方法的执行速度。 绿色：表示该View的此项性能比该View Tree中超过50%的View都要快 黄色：表示该View的此项性能比该View Tree中超过50%的View都要慢 红色：表示该View的此项性能是View Tree中最慢的 如果界面中的Tree View中红点较多，那就需要注意了。一般的布局可能有以下几点： Measure红点，可能是布局中多次嵌套RelativeLayout，或是嵌套的LinearLayout都使用了weight属性 Layout红点，可能是布局层级太深 Draw红点，可能是自定义View的绘制有问题，复杂计算等 12. UI布局优化12.1 避免过度绘制(Overdraw)12.2 减少布局层级12.3 复用（id、style）12.4 使用include、merge、viewStub标签12.4.1 include标签include标签常用于将布局中的公共部分提取出来供其他layout共用，以实现布局模块化，这在布局编写上提供了大大的便利。 下面以在一个布局main.xml中用include引入另一个布局foot.xml为例。main.mxl代码如下 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;ListView android:id="@+id/simple_list_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_marginBottom="@dimen/dp_80" /&gt; &lt;include layout="@layout/foot.xml" /&gt;&lt;/RelativeLayout&gt; 其中include引入的foot.xml为公用的页面底部，foot.xml代码如下 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="@dimen/dp_40" android:layout_above="@+id/text"/&gt; &lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:layout_height="@dimen/dp_40" android:layout_alignParentBottom="true" android:text="@string/app_name" /&gt;&lt;/RelativeLayout&gt; &lt;include&gt;标签唯一需要的属性是layout属性，指定需要包含的布局文件。在该标签中，还可以定义android:id和android:layout_*属性来覆盖被引入布局根节点的对应属性值。注意重新定义android:id后，子布局的顶结点i就变化了。 12.4.2 merge标签在使用了include后可能导致布局嵌套过多，多余不必要的layout节点，从而导致解析变慢，不必要的节点和嵌套可通过上文中提到的hierarchy viewer来查看。而merge标签可以消除那些include时不必要的layout节点。 merge标签可用于两种典型情况： 布局顶结点是FrameLayout且不需要设置background或padding等属性，可以用merge代替，因为Activity内容试图的parent view就是个FrameLayout，所以可以用merge消除只剩一个。 某布局作为子布局被其他布局include时，使用merge当作该布局的顶节点，这样在被引入时顶结点会自动被忽略，而将其子节点全部合并到主布局中 以上一节中的&lt;include&gt;标签的示例为例，用hierarchy viewer查看main.xml布局如下图： 可以发现多了一层没必要的RelativeLayout，将foot.xml中RelativeLayout改为merge，如下： 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;merge xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;Button android:id="@+id/button" android:layout_width="match_parent" android:layout_height="@dimen/dp_40" android:layout_above="@+id/text"/&gt; &lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:layout_height="@dimen/dp_40" android:layout_alignParentBottom="true" android:text="@string/app_name" /&gt;&lt;/merge&gt; 运行后再次用hierarchy viewer查看main.xml布局如下图： 这样就不会有多余的RelativeLayout节点了。 12.4.3 viewStub标签viewstub标签同include标签一样可以用来引入一个外部布局，不同的是，viewstub引入的布局默认不会扩张，即既不会占用显示也不会占用位置，从而在解析layout时节省cpu和内存。 viewstub常用来引入那些默认不会显示，只在特殊情况下显示的布局，如进度布局、网络失败显示的刷新布局、信息出错出现的提示布局等。 下面以在一个布局main.xml中加入网络错误时的提示页面network_error.xml为例。main.mxl代码如下： 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; …… &lt;ViewStub android:id="@+id/network_error_layout" android:layout_width="match_parent" android:layout_height="match_parent" android:layout="@layout/network_error" /&gt;&lt;/RelativeLayout&gt; 其中network_error.xml为只有在网络错误时才需要显示的布局，默认不会被解析，示例代码如下： 12345678910111213141516171819&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;Button android:id="@+id/network_setting" android:layout_width="@dimen/dp_160" android:layout_height="wrap_content" android:layout_centerHorizontal="true" android:text="@string/network_setting" /&gt; &lt;Button android:id="@+id/network_refresh" android:layout_width="@dimen/dp_160" android:layout_height="wrap_content" android:layout_below="@+id/network_setting" android:layout_centerHorizontal="true" android:layout_marginTop="@dimen/dp_10" android:text="@string/network_refresh" /&gt;&lt;/RelativeLayout&gt; 在java中通过(ViewStub)findViewById(id)找到ViewStub，通过stub.inflate()展开ViewStub，然后得到子View，如下 1234567891011121314151617private View networkErrorView;private void showNetError() &#123; // not repeated infalte if (networkErrorView != null) &#123; networkErrorView.setVisibility(View.VISIBLE); return; &#125; ViewStub stub = (ViewStub)findViewById(R.id.network_error_layout); networkErrorView = stub.inflate(); Button networkSetting = (Button)networkErrorView.findViewById(R.id.network_setting); Button refresh = (Button)findViewById(R.id.network_refresh);&#125;private void showNormal() &#123; if (networkErrorView != null) &#123; networkErrorView.setVisibility(View.GONE); &#125;&#125; 在上面showNetError()中展开了ViewStub，同时我们对networkErrorView进行了保存，这样下次不用继续inflate。 上面展开ViewStub部分代码 12ViewStub stub = (ViewStub)findViewById(R.id.network_error_layout);networkErrorView = stub.inflate(); 也可以写成下面的形式 123View viewStub = findViewById(R.id.network_error_layout);viewStub.setVisibility(View.VISIBLE); // ViewStub被展开后的布局所替换networkErrorView = findViewById(R.id.network_error_layout); // 获取展开后的布局 两者效果一致，只是不用显示的转换为ViewStub。通过viewstub的原理我们可以知道将一个view设置为GONE不会被解析，从而提高layout解析速度，而VISIBLE和INVISIBLE这两个可见性属性会被正常解析。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>内存优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存分析工具]]></title>
    <url>%2F2017%2F05%2F23%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[内存分析工具 1.1 heap工具获得hprof文件heap工具主要是用来检测堆内存的分配情况的。它可以导出一个hprof文件，这个是手机某个时间段的内存镜像，通过分析该文件，就可以得知堆内存的分配情况。heap工具位于Android Device Monitor中（这个Android Device Monitor在Eclipse中即DDMS界面）。 Android Studio中，在你要分析的应用已执行的前提下，通过在Tools→Android→Android Device Monitor中打开。如下图： 打开后，操作步骤顺序如下： 在Android Device Monitor界面中选择你要分析的应用程序的包名； 点击Update Heap来更新统计信息； 然后点击Cause GC即可查看当前堆的使用情况； 点击Dump HPROF file，准备生成hprof文件。 第4步点击后，几秒钟内会出现一个窗口提示你去保存文件，（这个应用当前的内存信息会被保存在这个hprof文件中），将文件保存在顺手的地方（比如说桌面）即可。 1.2 分析hprof文件（AS、eclipse插件MAT）其实leakCanary内部也是通过分析hprof文件来进行内存泄露的判断。 1.2.1 通过Android Studio打开hprof文件拿到一个hprof文件后，可以直接通过Android Studio来打开。只需将该文件拖放到Android Studio中，就打开了。 打开后选择Package Tree View，内存使用情况就是以包名分类。如下图 ： 在界面中找到你的应用程序的包名，打开即可看到内存的使用情况。自己写的类一目了然，我们还可以借助右侧的Analyzer Task去做一些分析，比如说分析出存在泄漏的leakActivity，如下图所示： 1.2.2 通过MAT打开hprof文件MAT工具（Memory Analysis Tools）其实是Eclipse时代的产物，它也是用来分析 hprof 文件的，不过LeakCanary可以帮助我们自动分析，而使用MAT需要我们自己去导出并且分析hprof 文件，使用的过程有些麻烦, 当前很多比较有经验的老程序员都知晓这个，如果面试的时候能和他们扯起这个，是一个加分项。 首先在eclipse上安装MAT插件： 去官方网站，查看最新版本的地址，当前最新地址如下： Update Site Archived Update Site：MemoryAnalyzer 打开eclipse，Help-&gt;Install New SoftWare, 输入上面的update site，如图： 安装完成后提示重启Eclipse，重启后打开window→ open perspective，看到Memory Analysis证明安装成功。 为了节省大家的时间，建议直接下载它的Stand-alone版本，免安装。 MAT的使用步骤如下： 1、首先需要Dump出一份hprof文件，可以在android studio或者eclipse导出。方法在上一节已介绍过（heap的介绍中） 2、直接Dump出的hprof文件要经过转换才能被 MAT识别，Android SDK提供了这个工具 hprof-conv, 在SDK目录下（sdk/platform-tools）。 该工具需要通过命令行来进行转换。以下为参考转换流程。 将导出来的hprof文件放到此目录下（sdk/platform-tools），重命令为input.hprof。 命令行cd 到此目录下，然后输入命令：hprof-conv input.hprof out.hprof PS：注意空格，前一段的hprof-conv代表要执行hprof-conv工具；中间的input.hprof代表你想对这个叫input.hprof的文件进行转换；最后那段out.hprof代表你转换出来的结果文件名叫做out.hprof 3、 执行后，此目录下（sdk/platform-tools）将会出现一个新文件名为：out.hprof，它即是我们的转换后的结果文件。 4、 打开MAT，导入我们的转换后的hprof文件（最好先将out.hprof放到一个独立的文件夹中，因为导入时MAT会在当前文件夹生成很多解析文件出来），导入完成后，先弹出如下start wizard 对话框，默认选第一个“leak suspect report”我们直接点finish。成功打开后如下图所示： 5、 在OverView页项下面，点击 Actions下的 Histogram 6、将得到 Histogram结果，它按类名将所有的实例对象列出来。 7、在第一行的正则表达式中输入我们demo里面的类名MainActivity 8、选中匹配出的结果右键打开菜单选择 list objects-&gt;with incoming refs。 9、得到该类的实例，以及展开后可以看到它的引用路径 10、快速找出MainActivity实例没被释放的原因，可以右健 Path to GCRoots–&gt;exclue all phantom/weak/soft etc. reference 11、可以看到，MainActivity在AsyncTask中引用，没有被释放。 1.3 性能分析工具TraceViewTraceView工具可以帮助开发者找到代码的性能瓶颈。方便我们找到一些影响到我们应用性能的代码。比如说某段代码相对其他代码而言，执行时间过长，它就能检测出来，那我们就能对症下药了。 1.3.1 第一种使用方式该工具和heap工具一样，也位于Android Device Monitor中。使用步骤如下： 打开Android Device Monitor，选中我们的app进程，然后按上面的“Start Method Profiling”按钮，如图。 点击带红点的按钮后，小红点变黑色，表示TraceView已经开始工作，然后我们就可以操作我们的APP，点击我们demo的按钮，开始阻塞任务。完成操作后点击我们已经变成黑色的“Start Method Profiling”按钮，停止TraceView，生成此操作的Trace，如图： PS：在实际的项目开发中，我们想检测某一个业务功能的性能，一般是先start trace，然后直接触发某个操作，最好是最小范围的操作，接着stop trace。最后拿到这个“最小操作范围”的trace来分析，跟踪我们的代码瓶颈 1.3.2 第二种使用方式除了上面针对某操作跟踪之外，我们还可以针对一段代码进行跟踪。 比如当我们怀疑某一段代码的性能时，我们可以直接监听这一段代码。 123// 开始监听......（需要被监听的代码段）......（需要被监听的代码段）android.os.Debug.startMethodTracing("xmgTest");android.os.Debug.stopMethodTracing();//结束监听 当代码执行完这一段时，会在sdcard目录下生成一个trace文件（如果按照先前的代码，那么该文件名为：xmgTest.trace）。为了顺利生成，我们需要在我们的程序中添加sd卡的访问权限。 123&lt;!-- 往Mainfest文件中添加SD卡写入权限和添加删除文件的权限 --&gt;&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;&lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/&gt; 在SD卡生成的trace文件如下图： 将trace文件导出到电脑上，我们可以在我们的DDMS打开，File-&gt;open file , 然后选择我们导出的trace文件。（DDMS会自动使用traceview.bat工具打开，sdk\tools\traceview.bat ） 打开后，结果界面将跟第一种使用方式相同，图略。 1.3.3 分析trace结果如先前的trace结果图片所示，traceView结果分为上下两半进行展示。 上面是时间轴面板 (Timeline Panel) 时间轴面板的左侧显示的是线程信息。时间轴面板的右侧黑色部分是显示执行时间段；白色是线程暂停时间段。时间轴面板的右侧鼠标放在上面会出现时间线纵轴，在顶部会显示当前时间线所执行的具体函数信息。 下面是分析面板(Profile Panel) 分析面板展示的是各个方法函数执行消耗时间性能的统计，点击一个函数，会出现两部分的数据，Parents和Children，分别表示父方法（当前被哪些方法调用）和子方法（当前调用哪些方法）。 下面列出了分析面板（Profile Panel）各参数的含义： 指标 说明 Name 该线程运行过程中所调用的函数名 Incl Cpu Time 某函数占用的CPU时间，包含内部调用其它函数的CPU时间 Excl Cpu Time 某函数占用的CPU时间，但不含内部调用其它函数所占用的CPU时间 Incl Real Time 某函数运行的真实时间（以毫秒为单位），内含调用其它函数所占用的真实时间 Excl Real Time 某函数运行的真实时间（以毫秒为单位），不含调用其它函数所占用的真实时间 Call+Recur Calls/Total 某函数被调用次数以及递归调用占总调用次数的百分比 Cpu Time/Call 某函数调用CPU时间与调用次数的比。相当于该函数平均执行时间 Real Time/Call 同CPU Time/Call类似，只不过统计单位换成了真实时间 通过分析我们每个函数消耗，就能分析出我们的“瓶颈”函数。 1.3.4 traceView举例例如我们的Demo，里面存在这样的代码： 123456789101112131415161718192021@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startTask(); &#125; &#125;);&#125;private void startTask() &#123; // 多次循环打Log for (int i=0;i&lt;1000;i++)&#123; for (int j=0;j&lt;1000;j++)&#123; String name="xmg"+i*j; Log.i("xmg", "my name is: "+name); &#125; &#125;&#125; startBlockTask函数内部有两重的for循环，多次循环打log。我们点击button触发事件后，得出这一段代码的TraceView如下图： 从上图的分析我们可以看出，序号为15的函数消耗了比较多的性能，它是除了UI绘制以外最大的性能消耗“钉子户”，耗时明显远高与其他函数，并且它的调用次数和递归调用次数异常。so，它就是我们的性能“瓶颈”，它的存在使我们的UI变卡，点击展开可以查看它的Parent函数： startBlockTask。根据这个，我们可以定位到我们需要优化的函数并做相应的优化。 1.4 更智能的性能分析工具leakCanary不再介绍，详情见内存优化 DDMSDDMS 的全称是Dalvik Debug Monitor Service，是Android 开发环境中的Dalvik 虚拟机调试监控服务 HierarchyViewerUI性能分析工具，分析布局文件的性能，层级嵌套 UI布局复杂程度及冗余分析，View嵌套的冗余层级 View的性能指标：测量、布局、绘制的渲染时间 1、invalidate Layout按钮invalidate()，强制刷新 2、requestLayout按钮requestLayout()，重新测量，布局 使用GPU过度绘制分析UI性能开发者选项中的GPU过度绘制工具（Show GPU Overdraw） 使用GPU呈现模式图及FPS考核UI性能开发者选项中的GPU呈现模式分析，Profile GPU Rendering Android Monitor TraceViewTraceView 简介Traceview 是Android 平台特有的数据采集和分析工具，它主要用于分析Android 中应用程序的hotspot（瓶颈）。Traceview 本身只是一个数据分析工具，而数据的采集则需要使用Android SDK 中的Debug 类或者利用DDMS 工具。二者的用法如下： 开发者在一些关键代码段开始前调用Android SDK 中Debug 类的startMethodTracing 函数，并在关键代码段结束前调用stopMethodTracing 函数。这两个函数运行过程中将采集运行时间内该应用所有线程（注意，只能是Java线程）的函数执行情况，并将采集数据保存到/mnt/sdcard/下的一个文件中。开发者然后需要利用SDK 中的Traceview工具来分析这些数据。 借助Android SDK 中的DDMS 工具。DDMS 可采集系统中某个正在运行的进程的函数调用信息。对开发者而言，此方法适用于没有目标应用源代码的情况。DDMS 工具中Traceview 的使用如下图所示。 观察CPU的执行情况，测试的进程中每个线程运行的时间线，线程中各个方法的调用信息（CPU使用时间、调用次数等） 可以方便的查看线程的执行情况，某个方法执行时间、调用次数、在总体中的占比等，从而定位性能点 一般Traceview可以定位两类性能问题 方法调运一次需要耗费很长时间导致卡顿 方法调运一次耗时不长，但被频繁调运导致累计时长卡顿 点击上图中所示按钮即可以采集目标进程的数据。当停止采集时，DDMS 会自动触发Traceview 工具来浏览采集数据 下面，我们通过一个示例程序介绍Traceview 的使用。 实例程序如下图所示：界面有4 个按钮，对应四个方法。 点击不同的方法会进行不同的耗时操作。 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends ActionBarActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void method1(View view) &#123; int result = jisuan(); System.out.println(result); &#125; private int jisuan() &#123; for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; return 1; &#125; public void method2(View view) &#123; SystemClock.sleep(2000); &#125; public void method3(View view) &#123; int sum = 0; for (int i = 0; i &lt; 1000; i++) &#123; sum += i; &#125; System.out.println("sum=" + sum); &#125; public void method4(View view) &#123; Toast.makeText(this, "" + new Date(), 0).show(); &#125; &#125; 我们分别点击按钮一次，要求找出最耗时的方法。点击前通过DDMS 启动Start Method Profiling 按钮。 然后依次点击4 个按钮，都执行后再次点击上图中红框中按钮，停止收集数据。 接下来我们开始对数据进行分析。 当我们停止收集数据的时候会出现如下分析图表。该图表分为2 大部分，上面分不同的行，每一行代表一个线程的执行耗时情况。main 线程对应行的的内容非常丰富，而其他线程在这段时间内干得工作则要少得多。图表的下半部分是具体的每个方法执行的时间情况。显示方法执行情况的前提是先选中某个线程。 我们主要是分析main 线程。 上面方法指标参数所代表的意思如下： 指标 说明 Name 该线程运行过程中所调用的函数名 Incl Cpu Time 某函数占用的CPU 时间，包含内部调用其它函数的CPU 时间 Excl Cpu Time 某函数占用的CPU 时间，但不含内部调用其它函数所占用的CPU 时间 Incl Real Time 某函数运行的真实时间（以毫秒为单位），包含调用其它函数所占用的真实时间 Excl Real Time 某函数运行的真实时间（以毫秒为单位），不含调用其它函数所占用的真实时间 Call+Recur Calls/Total 某函数被调用次数以及递归调用占总调用次数的百分比 Cpu Time/Call 某函数调用CPU 时间与调用次数的比。相当于该函数平均执行时间 Real Time/Call 同CPU Time/Call 类似，只不过统计单位换成了真实时间 我们为了找到最耗时的操作，那么可以通过点击Incl Cpu Time，让其按照时间的倒序排列。我点击后效果如下图： 通过分析发现：method1 最耗时，耗时2338 毫秒。 那么有了上面的信息我们可以进入我们的method1 方法查看分析我们的代码了 ###生成.trace文件 android.os.Debug类，其中重要的两个方法Debug.startMethodTracing()和Debug.stopMethodTracing()。这两个方法用来创建.trace文件，将从Debug.startMethodTracing()开始，到Debug.stopMethodTracing()结束，期间所有的调用过程保存在.trace文件中，包括调用的函数名称和执行的时间等信息。 ###dmtracedump 1dmtracedump -g result.png target.trace //结果png文件 目标trace文件 ##Allocation Tracker 追踪内存的分配，追踪内存对象的来源，通过这个工具我们可以很方便的知道代码分配了哪类对象、在哪个线程、哪个类、哪个文件的哪一行 运行DDMS，只需简单的选择应用进程并单击Allocation tracker 标签，就会打开一个新的窗口，单击“Start Tracing”按钮； 然后，让应用运行你想分析的代码。运行完毕后，单击“Get Allocations”按钮，一个已分配对象的列表就会出现第一个表格中。 单击第一个表格中的任何一项，在表格二中就会出现导致该内存分配的栈跟踪信息。通过allocation tracker，不仅知道分配了哪类对象，还可以知道在哪个线程、哪个类、哪个文件的哪一行。 ##Systrace Systrace其实有些类似Traceview，它是对整个系统进行分析 DDMS-&gt;Capture system wide trace using Android systrace Heap 内存监测工具，分析内存使用情况，查看当前内存快照，便于对比分析哪些对象有可能是泄漏了的 heap 工具可以帮助我们检查代码中是否存在会造成内存泄漏的地方。用heap 监测应用进程使用内存情况的步骤如下： 启动eclipse 后，切换到DDMS 透视图，并确认Devices 视图、Heap 视图都是打开的 点击选中想要监测的进程，比如system_process 进程 点击选中Devices 视图界面中最上方一排图标中的“Update Heap”图标 点击Heap 视图中的“Cause GC”按钮 此时在Heap 视图中就会看到当前选中的进程的内存使用量的详细情况 说明： 点击“Cause GC”按钮相当于向虚拟机请求了一次gc 操作 当内存使用信息第一次显示以后，无须再不断的点击“Cause GC”，Heap 视图界面会定时刷新，在对应用的不断的操作过程中就可以看到内存使用的变化 内存使用信息的各项参数根据名称即可知道其意思，在此不再赘述 如何才能知道我们的程序是否有内存泄漏的可能性呢。这里需要注意一个值：Heap 视图中部有一个Type叫做data object，即数据对象，也就是我们的程序中大量存在的类类型的对象。在data object 一行中有一列是“Total Size”，其值就是当前进程中所有Java 数据对象的内存总量，一般情况下，这个值的大小决定了是否会有内存泄漏。可以这样判断： 不断的操作当前应用，同时注意观察data object 的Total Size 值 正常情况下Total Size 值都会稳定在一个有限的范围内，也就是说由于程序中的的代码良好，没有造成对象不被垃圾回收的情况，所以说虽然我们不断的操作会不断的生成很多对象，而在虚拟机不断的进行GC 的过程中，这些对象都被回收了，内存占用量会会落到一个稳定的水平 反之如果代码中存在没有释放对象引用的情况，则data object 的Total Size 值在每次GC 后不会有明显的回落，随着操作次数的增多Total Size 的值会越来越大，直到到达一个上限后导致进程被kill 掉 此处以system_process 进程为例，在我的测试环境中system_process 进程所占用的内存的data object的Total Size 正常情况下会稳定在2.2~2.8 之间，而当其值超过3.55 后进程就会被kill 总之，使用DDMS 的Heap 视图工具可以很方便的确认我们的程序是否存在内存泄漏的可能性 ##Leakcanary Square出品，内存泄露监测神器，GitHub地址 ##Eclipse Memory Analyzer（MAT） 内存分析工具，这个工具分为Eclipse插件版和独立版两种，如果你是使用Eclipse开发的，那么可以使用插件版MAT，非常方便。如果你是使用Android Studio开发的，那么就只能使用独立版的MAT了 ###HPROF文件 HPROF文件是MAT能识别的文件，HPROF文件存储的是特定时间点，java进程的内存快照 点击Dump HPROF file按钮，生成HPROF文件，这个文件记录着我们应用程序内部的所有数据。但是目前MAT还是无法打开这个文件的，我们还需要将这个HPROF文件从Dalvik格式转换成J2SE格式，使用hprof-conv命令就可以完成转换工作 1hprof-conv dump.hprof converted-dump.hprof ###Histogram Histogram：列出内存中每个对象的名字、数量以及大小Shallow Heap：当前对象自己所占内存的大小，不包含引用关系的 析大内存的对象，分析对象的数量 ###Dominator Tree Dominator Tree：列出最大的对象以及其依赖存活的Object，并且我们可以分析对象之间的引用结构 Retained Heap 表示这个对象以及它所持有的其它引用（包括直接和间接）所占的总内存 在每一行的最左边都有一个文件型的图标，这些图标有的左下角带有一个红色的点，有的则没有。带有红点的对象就表示是可以被GC Roots访问到的，可以被GC Root访问到的对象都是无法被回收的。带红点的对象最右边都有写一个System Class，说明这是一个由系统管理的对象，并不是由我们自己创建并导致内存泄漏的对象 搜索大内存对象通向GC Roots的路径，因为内存占用越高的对象越值得怀疑 GC Roots reference chain(引用链)的起点,是一个在current thread(当前线程)的call stack(调用栈)上的对象（例如方法参数和局部变量），或者是线程自身或者是system class loader(系统类加载器)加载的类以及native code(本地代码)保留的活动对象。所以GC Roots是分析对象为何还存活于内存中的利器。 ##dumpsys meminfo命令 1adb shell dumpsys meminfo &lt;package_name|pid&gt; [-d] 命令后面带-d标志会打印出更多关于内存使用的信息1adb shell dumpsys meminfo com.google.android.apps.maps -d 12345678910111213141516171819202122232425262728293031323334353637C:\Users\AllenIverson&gt;adb shell dumpsys meminfo com.qq.googleplay -dApplications Memory Usage (kB):Uptime: 588545781 Realtime: 1460567078** MEMINFO in pid 19204 [com.qq.googleplay] ** Pss Private Private Swapped Heap Heap Heap Total Dirty Clean Dirty Size Alloc Free ------ ------ ------ ------ ------ ------ ------ Native Heap 0 0 0 0 20480 9524 10955 Dalvik Heap 23402 22936 0 0 40714 38963 1751 Dalvik Other 729 728 0 0 Stack 392 392 0 0 Other dev 5 0 4 0 .so mmap 1586 232 468 0 .apk mmap 281 0 52 0 .ttf mmap 262 0 248 0 .dex mmap 5500 0 5356 0 .oat mmap 2606 0 916 0 .art mmap 2350 924 800 0 Other mmap 1342 4 884 0 Unknown 7798 7748 0 0 TOTAL 46253 32964 8728 0 61194 48487 12706 Objects Views: 261 ViewRootImpl: 1 AppContexts: 3 Activities: 1 Assets: 4 AssetManagers: 4 Local Binders: 7 Proxy Binders: 16 Parcel memory: 5 Parcel count: 23 Death Recipients: 0 OpenSSL Sockets: 0 Dalvik isLargeHeap: false SQL MEMORY_USED: 0 PAGECACHE_OVERFLOW: 0 MALLOC_SIZE: 0 一般我们只需要关心Pss Total和Private Dirty两列数据，在某些情况下，Private Clean和Heap Alloc两列数据可能会提供你感兴趣的数据1adb shell dumpsys batterystats 电量状态 Lint工具 使用Lint进行资源及冗余UI布局等优化，Lint 有自动修复、提示建议和直接跳转到问题处的功能 集成到androidstudio，点击工具栏的Analysis -&gt; Inspect Code 内存抖动：短时间内有大量频繁的对象创建与释放操作 Lint是Android提供的一个静态扫描应用源码并找出其中的潜在问题的一个强大的工具 运行Lint：点击工具栏的Analysis -&gt; Inspect Code ##ProGuard 混淆代码，压缩和优化代码，apk瘦身 ##GC打印 当发生GC垃圾回收的时候，会在logcat打印日志 1I/art : Explicit concurrent mark sweep GC freed 104710(7MB) AllocSpace objects, 21(416KB) LOS objects, 33% free, 25MB/38MB, paused 1.230ms total 67.216ms Investigating Your RAM Usagehttp://android.xsoftlab.net/tools/debugging/debugging-memory.html]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>内存分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信朋友圈，QQ空间，微博等列表展示的功能实现]]></title>
    <url>%2F2017%2F05%2F16%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%88%97%E8%A1%A8%E5%B1%95%E7%A4%BA%E7%9A%84%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[内容摘要该控件能够应用于内容资讯展示的功能模块中，如：腾讯和新浪微博的微博列表，微信朋友圈及其它社交类应用的好友动态展示列表等；实现了类似腾讯微博的微博列表展示功能，包含微博文本内容，表情，图片，话题和用户可点超链接等（请参见如下效果图）。该功能在实际项目开发中非常常见，除微博应用外，微信的朋友圈，陌陌、QQ空间的好友动态等也都有类似功能 RecyclerView使用和嵌套问题 动态设置图片网格宽高 正则表达式的使用 Linkify实现自定义超链接 TextView富文本显示 点赞动画渐变动画效果 效果图 列表的item布局文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginBottom="5dp" android:background="@color/white" android:descendantFocusability="blocksDescendants" android:orientation="vertical"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="60dp" android:layout_marginTop="10dp" android:paddingLeft="10dp" android:paddingRight="10dp"&gt; &lt;ImageView android:id="@+id/iv_avatar" android:layout_width="45dp" android:layout_height="45dp" android:layout_centerVertical="true" android:background="#11000000" android:scaleType="centerCrop"/&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_centerVertical="true" android:layout_marginLeft="10dp" android:layout_toRightOf="@id/iv_avatar" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/tv_user" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="120dp" android:text="用户名" android:textColor="@color/black" android:textSize="16sp"/&gt; &lt;TextView android:id="@+id/tv_user_introduction" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="5dp" android:singleLine="true" android:text="用户相关介绍" android:textColor="@color/item_text_secondary" android:textSize="14sp"/&gt; &lt;/LinearLayout&gt; &lt;TextView android:id="@+id/tv_date" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentRight="true" android:layout_marginTop="5dp" android:text="0000-00-00" android:textColor="@color/item_text_secondary" android:textSize="14sp"/&gt; &lt;/RelativeLayout&gt; &lt;TextView android:id="@+id/tv_content" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginBottom="10dp" android:layout_marginLeft="10dp" android:layout_marginTop="5dp" android:text="这是微博内容...这是微博内容..." android:textColor="@color/item_text_main" android:textSize="16sp"/&gt; &lt;!--显示微博图片--&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv_weibo_images" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginBottom="10dp" android:layout_marginLeft="10dp" android:layout_marginRight="10dp" android:listSelector="@color/transparent" android:visibility="gone"/&gt; &lt;View android:layout_width="match_parent" android:layout_height="1px" android:background="@color/activity_bg"/&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="40dp" android:orientation="horizontal"&gt; &lt;FrameLayout android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:clickable="true"&gt; &lt;TextView android:id="@+id/tv_forward" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:drawableLeft="@drawable/selector_btn_share" android:textColor="@color/item_text_secondary" android:drawablePadding="5dp" android:gravity="center" android:text="0"/&gt; &lt;/FrameLayout&gt; &lt;FrameLayout android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:clickable="true"&gt; &lt;TextView android:id="@+id/tv_comment" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:drawableLeft="@drawable/selector_btn_comment" android:textColor="@color/item_text_secondary" android:drawablePadding="5dp" android:gravity="center" android:text="0"/&gt; &lt;/FrameLayout&gt; &lt;LinearLayout android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" android:clickable="true"&gt; &lt;CheckBox android:id="@+id/cb_like" android:layout_width="40dp" android:layout_height="40dp" android:layout_gravity="center" android:button="@color/transparent" android:checked="false" android:drawableLeft="@drawable/selector_btn_prize" android:drawablePadding="5dp" android:background="@color/transparent" android:textColor="@color/item_text_secondary" android:gravity="center"/&gt; &lt;TextView android:id="@+id/tv_like" android:text="0" android:textColor="@color/item_text_secondary" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; item中的RecyclerView用于显示0-9张图片，根据服务器返回的图片数量不同显示的行列数和图片的大小也不同，需要动态设置，由于这个列表是RecyclerView，item中也使用了RecyclerView，这就产生了RecyclerView的嵌套 id为tv_content的TextView用于显示内容，内容中包含了表情图片和超链接 json数据格式1234567891011121314151617181920212223242526&#123; "result":true, "weibo":[ &#123; "avatar":"avatar_01", "comment":5, "content":"我装作看不懂的样子[呲牙][偷笑][偷笑]，单身狗保重 [再见][再见] @冷笑话精选", "date":1489223423501, "forward":8, "imageUrls":[ "pic_1", "pic_2", "pic_3", "pic_4", "pic_5", "pic_6", "pic_7", "pic_8", "pic_9" ], "like":10, "user_introduction":"最冷笑话精选，每天分享笑话N枚，你的贴身开心果。", "username":"冷笑话精选" &#125; ]&#125; 对应的实体类 1234567891011121314151617public class WeChat &#123; public boolean result; public List&lt;WeiboEntity&gt; weibo; public static class WeiboEntity &#123; public String avatar; public int comment; public String content; public long date; public int forward; public int like; public String user_introduction; public String username; public List&lt;String&gt; imageUrls; &#125;&#125; 动态设置图片宫格数根据图片的数量，动态设置RecyclerView的列数和宽度 如果图片数量为0，则隐藏RecyclerView 如果图片数量为1，RecyclerView列数设为1列，宽度设为WRAP_CONTENT 如果图片数量为4，RecyclerView列数设为2列，宽度设为两个图片宫格的宽度 其它，RecyclerView列数设为3列，宽度设为MATCH_PARENT 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 刷新item布局中子控件的显示 @Override protected void onRefreshView(WeChat.WeiboBean bean, int position) &#123; // 显示用户名 tvUser.setText(bean.getUsername()); // 显示用户介绍 if (TextUtils.isEmpty(bean.getUser_introduction())) &#123; tvUserIntroduction.setVisibility(View.GONE); &#125; else &#123; tvUserIntroduction.setVisibility(View.VISIBLE); tvUserIntroduction.setText(bean.getUser_introduction()); &#125; // 显示头像 int imageResId = Global.getResId(context, bean.getAvatar()); ivAvatar.setBackgroundResource(imageResId); // 微博内容 // tvContent.setText(bean.getContent()); EmojiUtil.setText(tvContent, bean.getContent()); LinkifyUtil.addCustomLink(tvContent); LinkifyUtil.addCustomLink2(tvContent); // 发表时间 tvDate.setText(Global.formatDate(bean.getDate())); // 显示微博图片 int imageCount = bean.getImageUrls() == null ? 0 : bean.getImageUrls().size(); if (imageCount == 0) &#123; // 没有微博图片 rvWeiboImages.setVisibility(View.GONE); &#125; else &#123; // 有微博图片 rvWeiboImages.setVisibility(View.VISIBLE); imageAdapter.setDatas(bean.getImageUrls()); // 刷新图片显示 // 动态的指定图片宫格的宽高和RecyclerView的宽度 // 1张图片 -&gt; 1列 // 4张图片 -&gt; 2列 // 其它 -&gt; 3列 ViewGroup.LayoutParams param = rvWeiboImages.getLayoutParams(); if (imageCount == 1) &#123; layoutManager.setSpanCount(1); param.width = ViewGroup.LayoutParams.WRAP_CONTENT; &#125; else if (imageCount == 4) &#123; layoutManager.setSpanCount(2); // 两个图片宫格的宽度 param.width = Global.getGridWidth() * 2; &#125; else &#123; // 3列 layoutManager.setSpanCount(3); param.width = ViewGroup.LayoutParams.MATCH_PARENT; &#125; &#125; &#125; 动态设置图片的大小 1张图片，宫格的宽高为图片的宽高 其它情况，宫格的宽高为屏幕宽度的三分之一 1234567891011121314151617181920212223242526// 刷新item子控件的显示 @Override protected void onRefreshView(String imagePath, int position) &#123; // 动态设置图片宫格的宽高 // 1张图片 -&gt; 宫格的宽高为图片的宽高 // 其它情况 -&gt; 宫格的宽高为Global.getGridWidth() ViewGroup.LayoutParams param = super.itemView.getLayoutParams(); if (super.adapter.getItemCount() == 1) &#123; // 一张图片 // 图片资源id int imageResId = Global.getResId(context, imagePath); Bitmap bitmap = BitmapFactory.decodeResource( context.getResources(), imageResId); // 指定宫格的宽高为图片的宽高 param.width = bitmap.getWidth(); param.height = bitmap.getHeight(); // 显示图片 ivImage.setBackgroundResource(imageResId); &#125; else &#123; // 多张图片 // 显示宫格图片 int imageResId = Global.getResId(context, imagePath); ivImage.setBackgroundResource(imageResId); param.width = Global.getGridWidth(); // 指定宫格图片的宽 param.height = Global.getGridWidth(); &#125; &#125; TextView富文本显示显示文本中的表情，把文本中如[呲牙][偷笑][偷笑]的文字替换成表情图片，实现TextView的富文本显示（图文混排）。需要用正则去匹配文本中是否包含表情，匹配成功，表示文本中包含表情，用ImageSpan封装表情图片，再ImageSpan将设置给SpannableString，把文本中的表示表情的文字替换掉，最后将SpannableString设置给TextView即可。 正则参考： 123[高兴] \\[([A-Za-z\u4E00-\u9FA5]+)\\]@用户 \\@([A-Za-z0-9\u4E00-\u9FA5]+)#话题# \\#([A-Za-z0-9\u4E00-\u9FA5]+)\\# 123456789101112131415161718192021222324252627282930313233343536public class EmojiUtil &#123; /** 显示文本和表情 */ public static void setText(TextView textView, String text) &#123; Context context = textView.getContext(); Resources resources = context.getResources(); SpannableString ss = new SpannableString(text); // 正则表达式： [高兴] Pattern p = Pattern.compile("\\[([A-Za-z\u4E00-\u9FA5]+)\\]"); Matcher matcher = p.matcher(ss); while (matcher.find()) &#123; // 匹配到一个表情字符串 String emoji = matcher.group(); // 过滤非表情符，比如： [xxx] if (EMOJI_DATAS.containsKey(emoji)) &#123; // 是表情才处理 // System.out.println("----------" + emoji); // 指定了一张图片 Bitmap bitmap = BitmapFactory.decodeResource(resources, EMOJI_DATAS.get(emoji)); bitmap = Global.createBitmap(bitmap, Global.dp2px(20)); // 图片的宽高为20dp ImageSpan span = new ImageSpan(context, bitmap, ImageSpan.ALIGN_BOTTOM); int start = matcher.start(); int end = matcher.end(); ss.setSpan(span, start, end, 0); &#125; &#125; textView.setText(ss); &#125; private static final HashMap&lt;String, Integer&gt; EMOJI_DATAS = new HashMap&lt;String, Integer&gt;(); static &#123; EMOJI_DATAS.put("[微笑]", R.drawable.smiley_0); ... &#125;&#125; 让文字显示颜色1234567891011121314/** * 让某几个文字显示颜色 * @param string * @param color * @return */ private CharSequence showTextWithColor(String string,int color) &#123; SpannableString ss = new SpannableString(string); // BackgroundColorSpan 背景色 ForegroundColorSpan colorSpan = new ForegroundColorSpan(color); int end = string.indexOf("等"); ss.setSpan(colorSpan, 0, end, SpannableString.SPAN_INCLUSIVE_EXCLUSIVE); return ss; &#125; 让图片和文字一起显示123456789101112131415161718192021/** * 让图片和文字一起显示 * @param text * @param imageRes * @return */ private SpannableString showTextWithImage(String text,int imageRes)&#123; SpannableString ss = new SpannableString(text); Drawable drawable = getResources().getDrawable(imageRes); //设置边界// drawable.setBounds(0,0,drawable.getIntrinsicWidth(),drawable.getIntrinsicHeight()); drawable.setBounds(0,0,20,20); ImageSpan span = new ImageSpan(drawable); int start = text.indexOf("["); int end = text.indexOf("]")+1; ss.setSpan(span, start,end,SpannableString.SPAN_INCLUSIVE_EXCLUSIVE); return ss; &#125; 设置超链接12345// 让某段文字可以被点击并跳转超链接String text = "详情请点击&lt;a href='http://www.baidu.com'&gt;百度&lt;/a&gt;";Spanned spanned = Html.fromHtml(text);text3.setText(spanned);text3.setMovementMethod(LinkMovementMethod.getInstance());//设置可以点击超链接 让某段文字可以被点击并自定义点击的逻辑操作1234567// 让某段文字可以被点击并自定义点击的逻辑操作String string = "王二,小明,大兵等觉得很赞";SpannableString ss= new SpannableString(string);MyUrlSpan urlSpan= new MyUrlSpan(string.substring(0, string.indexOf(",")));ss.setSpan(urlSpan, 0, 2, SpannableString.SPAN_INCLUSIVE_EXCLUSIVE);text4.setText(ss);text4.setMovementMethod(LinkMovementMethod.getInstance()); 12345678910111213141516171819class MyUrlSpan extends URLSpan&#123; public MyUrlSpan(String url) &#123; super(url); &#125; @Override public void onClick(View widget) &#123; // 自定义点击的操作逻辑，默认实现是获取url，打开浏览器 Toast.makeText(MainActivity.this, getURL(), 0).show(); widget.clearFocus(); &#125; @Override public void updateDrawState(TextPaint ds) &#123; super.updateDrawState(ds); ds.setColor(Color.RED); // 设置文字颜色 ds.setUnderlineText(false); // 设置是否显示下划线 &#125;&#125; 自定义超链接关于TextView 网页，电话，邮箱的自动识别。设置android:autoLink=&quot;email|web|phone|map&quot;属性后，TextView 可自动识别电话、邮箱、网址、地图为超链接。 12345678&lt;TextView android:id="@+id/tv" android:layout_width="match_parent" android:layout_height="wrap_content" android:scrollbarStyle="insideOverlay" android:scrollbars="vertical" android:autoLink="email|web|phone|map" android:text=" 电话:13609000000,邮箱:815612738@163.com,网址:http://www.google.com " /&gt; 添加自定义超链接，把内容中如@冷笑话精选、#编程#、#讲故事#的文本显示为超链接，高亮显示并支持点击。先使用Linkify.MatchFilter 匹配过滤器过滤内容中的超链接，TextView在显示的内容要识别链接时，调用Linkify.addLinks() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class LinkifyUtil &#123; /** * 添加自定义超链接 */ public static void addCustomLink(TextView textView) &#123; // @用户: Pattern pattern = Pattern.compile("\\@([A-Za-z0-9\u4E00-\u9FA5]+)\\.?"); // http://www.qq.com/path?uid=1&amp;username=xx String scheme = "weibo://user?uid="; // 匹配过滤器 Linkify.MatchFilter matchFilter = new Linkify.MatchFilter() &#123; @Override public boolean acceptMatch(CharSequence s, int start, int end) &#123; String text = s.subSequence(start, end).toString(); // System.out.println("----text: " + text); if (text.endsWith(".")) &#123; // 邮箱，不需要匹配 return false; &#125; else &#123; return true; // 返回true会显示为超链接 &#125; &#125; &#125;; Linkify.TransformFilter transformFilter = null; Linkify.addLinks(textView, pattern, scheme, matchFilter, transformFilter); &#125; public static void addCustomLink2(TextView textView) &#123; // @用户: Pattern pattern = Pattern.compile("\\#([A-Za-z0-9\u4E00-\u9FA5]+)\\#"); // http://www.qq.com/path?uid=1&amp;username=xx String scheme = "weibo://topic?uid="; // 匹配过滤器 Linkify.MatchFilter matchFilter = new Linkify.MatchFilter() &#123; @Override public boolean acceptMatch(CharSequence s, int start, int end) &#123; String text = s.subSequence(start, end).toString(); System.out.println("----text: " + text); return true; &#125; &#125;; Linkify.TransformFilter transformFilter = new Linkify.TransformFilter() &#123; @Override public String transformUrl(Matcher match, String url) &#123; return match.group(1); &#125; &#125;; Linkify.addLinks(textView, pattern, scheme, matchFilter, transformFilter); &#125;&#125; 设置自定义的链接后，点击超链接后会出错。 因为没有找到Activity可以处理发起的Intent, 需要定义两个Activity来接收意图中的参数。 当点击超链接的时候，会调起/启动一个与Linkify.addLinks()方法中的scheme对应的Activity 1234567891011121314151617181920public class TopicActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // weibo://user?uid=@冷笑话精选 Uri uri = getIntent().getData(); String topic = uri.getQueryParameter("uid"); TextView textView = new TextView(this); textView.setGravity(Gravity.CENTER); textView.setTextColor(Color.RED); textView.setText(topic); textView.setTextSize(20); setContentView(textView); &#125;&#125; 1234567891011121314151617181920public class UserActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // weibo://user?uid=@冷笑话精选 Uri uri = getIntent().getData(); String username = uri.getQueryParameter("uid"); TextView textView = new TextView(this); textView.setGravity(Gravity.CENTER); textView.setTextColor(Color.GRAY); textView.setText(username); textView.setTextSize(20); setContentView(textView); &#125;&#125; 在清单文件中配置以上Activity，给Activity设置action、category、data 123456789101112131415&lt;!--点击用户链接时，要调起该Activity--&gt;&lt;activity android:name=".ui.activity.UserActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:scheme="weibo" android:host="user"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=".ui.activity.TopicActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:scheme="weibo" android:host="topic"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 点赞动画在MainActivity的布局文件中，有一个TextView，是用来执行点赞后的+1的动画（向上平移，透明度变小，放大）。 该控件开始时隐藏，执行点赞动画时，注意不是列表项中的控件执行动画。 123456789101112// WeiboHolder.javacbLike.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked) &#123; // 获取当前点击控件相对于窗口的所在位置 int[] locations = new int[2]; tvLike.getLocationInWindow(locations); ((MainActivity) context).animateUp(locations); &#125; &#125;&#125;); 12345678910111213141516public void animateUp(int[] locations) &#123; // 减去状态栏高度24dp int currentY = locations[1] - Global.dp2px(24); tvLike.setVisibility(View.VISIBLE); tvLike.setTranslationX(locations[0]); tvLike.setTranslationY(currentY); tvLike.setScaleY(1); tvLike.setScaleX(1); tvLike.setAlpha(1f); // 往上移动30dp int top = currentY - Global.dp2px(30); tvLike.animate().alpha(0).translationY(top) .setInterpolator(new DecelerateInterpolator()) .scaleX(1.2f).scaleY(1.2f).setDuration(1000);&#125; 代码：https://github.com/JackChan1999/WeChatDemo]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitBook使用教程]]></title>
    <url>%2F2017%2F05%2F01%2Fgitbook%2FGitBook%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[各大站长平时除了写博客外，可以使用 gitbook 将一系列的博客专栏整理成电子书出版。这样既方便各大网友阅读，还可以带来新的离线阅读功能。 在以前我们只能靠出版社，或者编写 word 文档，来实现。然而有了 gitbook 之后，一切都变得那么简单了。今天就为大家分享一下，如果在 Windows 系统上安装 gitbook，进行电子书的编写和发布。 1. GitBook Editor最简单的方式就是使用GitBook编辑器，没有什么难度，后面的教程主要针对命令行的方式。 PS：GitBook的book页面默认没有download按钮的 需要到设置中打开，打开后再次publish生效 1.1 同步GitHub 1.2 更新失败，无法转换成pdf/mobi/epub格式 1.3 Token12git config --global gitbook.user usernamegit config --global gitbook.token yourtoken 2. 安装 nodejs首先我们需要做的是安装 Nodejs。大家可以到 Nodejs 的官网进行下载。下载完成后，执行双击进行运行安装。安装完成后，打开 cmd 命令行，输入 node -v 查看安装的 nodejs 的相关版本信息。 也可以在安装目录中找到 node.exe 文件，打开输入 node -v 查看安装的 nodejs 的相关版本信息。 3. nodejs 镜像配置nodejs 安装完成后，我们就可以开始安装 gitbook 了。但是在安装之前，我们还需要配置一下 nodejs 插件安装的下载镜像地址。因为默认的镜像地址是在国外，需要翻墙才可以访问，因此我们需要设置国内的镜像地址。国内的我推荐大家使用阿里巴巴的镜像地址 http://registry.npm.taobao.org 。执行下面的命令，进行配置。 1npm config set registry http://registry.npm.taobao.org 除了上面的方法外，我们也可以在用户主目录下编辑 .npmrc 文件，添加一行 registry=http://registry.npm.taobao.org 保存就可以了。用户的主目录一般在 C:\Users\Administrator ，具体随你的操作系统系统盘而定。 4. 全局安装 gitbook现在我们可以开始安装全局的 gitbook 了。执行 npm install gitbook-cli -g 命令，进行安装。安装的过程中，由于需要下载安装包，因此大家需要等待一定的时间，具体时长取决于你的网速和硬件配置。 安装完成后，我们可以执行 gitbook -v 查看安装的版本信息。 5. gitbook 常用的命令安装完成了后，我们就可以开始编写内容，进行电子书发布了。具体的操作，大家可以参考《GitBook简明教程》进行学习。我这里给大家推荐3种最常用的命令 12345678910111213gitbook init //初始化目录文件gitbook help //列出gitbook所有的命令gitbook --help //输出gitbook-cli的帮助信息gitbook build //生成静态网页gitbook serve //生成静态网页并运行服务器gitbook build --gitbook=2.0.1 //生成时指定gitbook的版本, 本地没有会先下载gitbook ls //列出本地所有的gitbook版本gitbook ls-remote //列出远程可用的gitbook版本gitbook fetch 标签/版本号 //安装对应的gitbook版本gitbook update //更新到gitbook的最新版本gitbook uninstall 2.0.1 //卸载对应的gitbook版本gitbook build --log=debug //指定log的级别gitbook builid --debug //输出错误信息 gitbook12345678910111213141516171819202122C:\Users\AllenIverson\Desktop\gitcourse&gt;gitbook Usage: gitbook [options] [command] Commands: ls List versions installed locally current Display currently activated version ls-remote List remote versions available for install fetch [version] Download and install a &lt;version&gt; alias [folder] [version] Set an alias named &lt;version&gt; pointing to &lt;folder&gt; uninstall [version] Uninstall a version update [tag] Update to the latest version of GitBook help List commands for GitBook * run a command with a specific gitbook version Options: -h, --help output usage information -v, --gitbook [version] specify GitBook version to use -d, --debug enable verbose error -V, --version Display running versions of gitbook and gitbook-cli gitbook serve123456789101112131415161718C:\Users\AllenIverson\Desktop\gitbook-test&gt;gitbook serveLive reload server started on port: 35729Press CTRL+C to quit ...info: 7 plugins are installedinfo: loading plugin &quot;livereload&quot;... OKinfo: loading plugin &quot;highlight&quot;... OKinfo: loading plugin &quot;search&quot;... OKinfo: loading plugin &quot;lunr&quot;... OKinfo: loading plugin &quot;sharing&quot;... OKinfo: loading plugin &quot;fontsettings&quot;... OKinfo: loading plugin &quot;theme-default&quot;... OKinfo: found 3 pagesinfo: found 0 asset filesinfo: &gt;&gt; generation finished with success in 1.9s !Starting server ...Serving book on http://localhost:4000 gitbook ls123456C:\Users\AllenIverson\Desktop\gitcourse&gt;gitbook lsGitBook Versions Installed: * 3.2.2Run &quot;gitbook update&quot; to update to the latest version. gitbook ls-remote12345678910111213141516C:\Users\AllenIverson\Desktop\gitcourse&gt;gitbook ls-remoteAvailable GitBook Versions: 4.0.0-alpha.5, 4.0.0-alpha.4, 4.0.0-alpha.3, 4.0.0-alpha.2, 4.0.0-alpha.1, 3.2.2, 3.2.1, 3.2.0, 3.2.0-pre.1, 3.2.0-pre.0, 3.1.1, 3.1.0, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-pre.15, 3.0.0-pre.14, 3.0.0-pre.13, 3.0.0-pre.12, 3.0.0-pre.11, 3.0.0-pre.10, 3.0.0-pre.9, 3.0.0-pre.8, 3.0.0-pre.7, 3.0.0-pre.6, 3.0.0-pre.5, 3.0.0-pre.4, 3.0.0-pre.3, 3.0.0-pre.2, 3.0.0-pre.1, 2.6.7, 2.6.6, 2.6.5, 2.6.4, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.2, 2.5.1, 2.5.0, 2.5.0-beta.7, 2.5.0-beta.6, 2.5.0-beta.5, 2.5.0-beta.4, 2.5.0-beta.3, 2.5.0-beta.2, 2.5.0-beta.1, 2.4.3, 2.4.2, 2.4.1, 2.4.0, 2.3.3, 2.3.2, 2.3.1, 2.3.0, 2.2.0, 2.1.0, 2.0.4, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-beta.5, 2.0.0-beta.4, 2.0.0-beta.3, 2.0.0-beta.2, 2.0.0-beta.1,2.0.0-alpha.9, 2.0.0-alpha.8, 2.0.0-alpha.7, 2.0.0-alpha.6, 2.0.0-alpha.5, 2.0.0-alpha.4, 2.0.0-alpha.3, 2.0.0-alpha.2,2.0.0-alpha.1Tags: latest : 3.2.2 pre : 4.0.0-alpha.5 gitbook -V123C:\Users\AllenIverson\Desktop\gitcourse&gt;gitbook -VCLI version: 2.3.0GitBook version: 3.2.2 gitbook pdf 1234567891011121314C:\Users\AllenIverson\Desktop\gitcourse&gt;gitbook pdfinfo: 7 plugins are installedinfo: 6 explicitly listedinfo: loading plugin &quot;highlight&quot;... OKinfo: loading plugin &quot;search&quot;... OKinfo: loading plugin &quot;lunr&quot;... OKinfo: loading plugin &quot;sharing&quot;... OKinfo: loading plugin &quot;fontsettings&quot;... OKinfo: loading plugin &quot;theme-default&quot;... OKinfo: found 3 pagesinfo: found 0 asset filesEbookError: Error during ebook generation: &apos;ebook-convert&apos; is not recognized as an internal or external command,operable program or batch file. 错误提示：ebook-convert不是内部或外部命令，原因是GitBook在生成PDF的过程中使用到calibre的转换功能，没有安装calibre或安装了calibre没有配置环境变量都会导致转换PDF失败12345678910111213C:\Users\AllenIverson\Desktop\gitcourse&gt;gitbook pdfinfo: 7 plugins are installedinfo: 6 explicitly listedinfo: loading plugin &quot;highlight&quot;... OKinfo: loading plugin &quot;search&quot;... OKinfo: loading plugin &quot;lunr&quot;... OKinfo: loading plugin &quot;sharing&quot;... OKinfo: loading plugin &quot;fontsettings&quot;... OKinfo: loading plugin &quot;theme-default&quot;... OKinfo: found 3 pagesinfo: found 2 asset filesinfo: &gt;&gt; generation finished with success in 8.6s !info: &gt;&gt; 1 file(s) generated 安装calibre后，转换成功。PS：安装calibre后需要重新启动命令行窗口 设置PDF输出格式book.json1234567891011121314151617181920212223242526272829303132333435363738&#123; "gitbook": "2.x.x", "title": "Go语言圣经", "description": "&lt;The Go Programming Language&gt;中文版", "language": "zh", "structure": &#123; "readme": "preface.md" &#125;, "pluginsConfig": &#123; "fontSettings": &#123; "theme": "white", "family": "msyh", "size": 2 &#125;, "plugins": [ "yahei", "katex", "-search" ] &#125;, "fontState": &#123; "size": "2", "family": "sans", "theme": "night" &#125;, "pdf": &#123; "pageNumbers": true, "fontFamily": "Arial", "fontSize": 12, "paperSize": "a4", "margin": &#123; "right": 62, "left": 62, "top": 56, "bottom": 56 &#125; &#125;&#125; Variable Description pdf.pageNumbers 是否添加页码，默认是true pdf.fontSize 字体大小，默认是12 pdf.fontFamily 字体，默认字体是Arial pdf.paperSize Paper size, options are &#39;a0&#39;, &#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;, &#39;a4&#39;, &#39;a5&#39;, &#39;a6&#39;, &#39;b0&#39;, &#39;b1&#39;, &#39;b2&#39;, &#39;b3&#39;, &#39;b4&#39;, &#39;b5&#39;, &#39;b6&#39;, &#39;legal&#39;, &#39;letter&#39; (default is a4) pdf.margin.top Top margin (default is 56) pdf.margin.bottom Bottom margin (default is 56) pdf.margin.right Right margin (default is 62) pdf.margin.left Left margin (default is 62) gitbook mobi12345678910111213C:\Users\AllenIverson\Desktop\gitcourse&gt;gitbook mobiinfo: 7 plugins are installedinfo: 6 explicitly listedinfo: loading plugin &quot;highlight&quot;... OKinfo: loading plugin &quot;search&quot;... OKinfo: loading plugin &quot;lunr&quot;... OKinfo: loading plugin &quot;sharing&quot;... OKinfo: loading plugin &quot;fontsettings&quot;... OKinfo: loading plugin &quot;theme-default&quot;... OKinfo: found 32 pagesinfo: found 34 asset filesinfo: &gt;&gt; generation finished with success in 26.0s !info: &gt;&gt; 1 file(s) generated gitbook epub12345678910111213C:\Users\AllenIverson\Desktop\gitcourse&gt;gitbook epubinfo: 7 plugins are installedinfo: 6 explicitly listedinfo: loading plugin &quot;highlight&quot;... OKinfo: loading plugin &quot;search&quot;... OKinfo: loading plugin &quot;lunr&quot;... OKinfo: loading plugin &quot;sharing&quot;... OKinfo: loading plugin &quot;fontsettings&quot;... OKinfo: loading plugin &quot;theme-default&quot;... OKinfo: found 32 pagesinfo: found 34 asset filesinfo: &gt;&gt; generation finished with success in 18.5s !info: &gt;&gt; 1 file(s) generated 6. calibre下载地址 ebook-convert123456789101112131415161718192021222324C:\Users\AllenIverson\Desktop\gitcourse&gt;ebook-convert用法: ebook-convert.exe input_file output_file [options]转换不同格式的电子书。input_file 表示输入文件，output_file 表示输出文件。这两者作为命令行参数必须指定到最前面。输出的电子书格式可由 output_file 的扩展名得到。同时 output_file 也可以是一种以 .EXT 为扩展名的特殊格式。在这种情况下，输出文件的名称则使用输入文件的名称。注意：文件名不能以连字号作为开头。如果 output_file 不含扩展名，那么它将被视为一个目录并将会在该目录下生成 HTML 格式的“开放式电子书(OEB)”。这些文件会被视为正常文件而被输出插件所识别。在指定输入和输出文件后，您可以自定义特定的转换选项。根据输入和输出文件的类型不同可用的转换选项也不同。如需获取针对输入和输出文件的帮助，请在命令行中输入 -h。对于转换系统的完整文档请查阅https://manual.calibre-ebook.com/conversion.html给 ebook-convert.exe 传有空格的参数时，请将参数包括在引号中。例如 &quot;C:\some path with spaces&quot;选项: --version 显示程序版本号并退出 -h, --help 显示此帮助信息并退出 --list-recipes 列出内建的订阅清单名。您可以通过如下命令创建基于内建订阅清单的电子书： ebook-convert &quot;Recipe Name.recipe&quot; output.epub ebook-convert –version123C:\Users\AllenIverson\Desktop\gitcourse&gt;ebook-convert --versionebook-convert.exe (calibre 2.81.0)Created by: Kovid Goyal &lt;kovid@kovidgoyal.net&gt; 使用 7. GitBook 编译，生成pdf报错最近在使用 GitBook 生成静态网页和pdf文件时，百度，谷歌了很久也没有类似的解决方案，最近发现是版本问题，我把我的相关经验分享给大家！ 在执行 gitbook build ，gitbook serve，gitbook pdf等命令均保持。报错了错误提示内容如下： 123456789101112131415161718info: 10 plugins are installedinfo: 9 explicitly listedinfo: loading plugin &quot;baidu&quot;... OKinfo: loading plugin &quot;donate&quot;... OKinfo: loading plugin &quot;sitemap&quot;... OKinfo: loading plugin &quot;highlight&quot;... OKinfo: loading plugin &quot;search&quot;... OKinfo: loading plugin &quot;lunr&quot;... OKinfo: loading plugin &quot;sharing&quot;... OKinfo: loading plugin &quot;fontsettings&quot;... OKinfo: loading plugin &quot;theme-default&quot;... OKinfo: found 24 pagesinfo: found 2 asset fileswarn: &quot;options&quot; property is deprecated, use config.get(key) insteadwarn: &quot;options.generator&quot; property is deprecated, use &quot;output.name&quot; insteaderror: error while generating page &quot;README.md&quot;:TypeError: this.contentPath is not a function 当然也有些网友的报错内容如下： 1234warn: &quot;options&quot; property is deprecated, use config.get(key) insteadwarn: &quot;page.progress&quot; property is deprecatedwarn: &quot;sections&quot; property is deprecated, use page.content insteadTypeError: Path must be a string. Received undefined 这种问题的原因是，gitbook的版本太低。大家执行 gitbook update 命令进行升级，升级到3.2.2版本即可。 也有网友反映，报一下的错： 1Error: Couldn&apos;t locate plugins &quot;baidu, donate&quot;, Run &apos;gitbook install&apos; to install plugins from registry. 这是提示插件没有安装的错误。大家执行 gitbook install 命令完成安装即可。 8. gitbook-convert把docx、xml、html、odt文档转成GitBook 安装1$ npm install gitbook-convert -g 常用命令 使用1$ gitbook-convert [options] &lt;file&gt; [export-directory] 9. 常用插件Gitbook 本身功能丰富，但同时可以使用插件来进行个性化定制。Gitbook 插件 里已经有100多个插件，可以在 book.json 文件的 plugins 和 pluginsConfig 字段添加插件及相关配置，添加后别忘了进行安装。 12345678910111213141516171819202122232425262728293031323334// book.json&#123; &quot;title&quot;: &quot;Webpack 中文指南&quot;, &quot;description&quot;: &quot;Webpack 是当下最热门的前端资源模块化管理和打包工具，本书大部分内容翻译自 Webpack 官网。&quot;, &quot;language&quot;: &quot;zh&quot;, &quot;plugins&quot;: [ &quot;disqus&quot;, &quot;github&quot;, &quot;editlink&quot;, &quot;prism&quot;, &quot;-highlight&quot;, &quot;baidu&quot;, &quot;splitter&quot;, &quot;sitemap&quot; ], &quot;pluginsConfig&quot;: &#123; &quot;disqus&quot;: &#123; &quot;shortName&quot;: &quot;webpack-handbook&quot; &#125;, &quot;github&quot;: &#123; &quot;url&quot;: &quot;https://github.com/zhaoda/webpack-handbook&quot; &#125;, &quot;editlink&quot;: &#123; &quot;base&quot;: &quot;https://github.com/zhaoda/webpack-handbook/blob/master/content&quot;, &quot;label&quot;: &quot;编辑本页&quot; &#125;, &quot;baidu&quot;: &#123; &quot;token&quot;: &quot;a9787f0ab45d5e237bab522431d0a7ec&quot; &#125;, &quot;sitemap&quot;: &#123; &quot;hostname&quot;: &quot;http://zhaoda.net/&quot; &#125; &#125;&#125; 12# 安装插件$ gitbook install ./ editlink内容顶部显示 编辑本页 链接。 ad在每个页面顶部和底部添加广告或任何自定义内容。 splitter在左侧目录和右侧内容之间添加一个可以拖拽的栏，用来调整两边的宽度。 image-captions抓取内容中图片的 alt 或 title 属性，在图片下面显示标题。 github在右上角显示 github 仓库的图标链接。 anchors标题带有 github 样式的锚点。 chart使用 C3.js 图表。 styles-sass使用 SASS 替换 CSS。 styles-less使用 LESS 替换 CSS。 ga添加 Google 统计代码。 disqus添加 disqus 评论插件。 sitemap生成站点地图。 latex-codecogs使用数学方程式。 mermaid使用流程图。 book-summary-scroll-position-saver自动保存左侧目录区域导航条的位置。 sharing默认的分享插件。 fontsettings默认的字体、字号、颜色设置插件。 search默认搜索插件。 tbfed-pagefooter自定义页脚，显示版权和最后修订时间。 prism基于 Prism 的代码高亮。 atoc插入 TOC 目录。 ace插入代码高亮编辑器。 highlight默认的代码高亮插件，通常会使用 prism 来替换。 github-buttons显示 github 仓库的 star 和 fork 按钮。 sectionx分离各个段落，并提供一个展开收起的按钮。 mcqx使用选择题。 include-codeblock通过引用文件插入代码。 fbqx使用填空题。 spoiler隐藏答案，当鼠标划过时才显示。 anchor-navigation锚点导航。 youtubex插入 YouTube 视频。 redirect页面跳转。 expandable-chapters收起或展开章节目录中的父节点。 baidu使用百度统计。 duoshuo使用多说评论。 jsfiddle插入 JSFiddle 组件。 jsbin插入 JSBin 组件。 开发插件最好先查看别人的插件是怎么做的，然后再看官方文档。 10. 配置在book.json中配置，键值对的形式 title 设置书本的标题 1"title" : "Gitbook Use" author 作者的相关信息 1"author" : "zhangjikai" description 书本的简单描述 1"description" : "记录Gitbook的配置和一些插件的使用" language Gitbook使用的语言, 版本2.6.4中可选的语言如下 1en, ar, bn, cs, de, en, es, fa, fi, fr, he, it, ja, ko, no, pl, pt, ro, ru, sv, uk, vi, zh-hans, zh-tw 配置使用简体中文 1"language" : "zh-hans" links 在左侧导航栏添加链接信息 12345"links" : &#123; "sidebar" : &#123; "Home" : "http://zhangjikai.com" &#125;&#125; styles 自定义页面样式， 默认情况下各generator对应的css文件 1234567"styles": &#123; "website": "styles/website.css", "ebook": "styles/ebook.css", "pdf": "styles/pdf.css", "mobi": "styles/mobi.css", "epub": "styles/epub.css"&#125; 例如使&lt;h1&gt; &lt;h2&gt;标签有下边框， 可以在website.css中设置 123h1 , h2&#123; border-bottom: 1px solid #EFEAEA;&#125; plugins 配置使用的插件 123&quot;plugins&quot;: [ &quot;disqus&quot;] 添加新插件之后需要运行gitbook install来安装新的插件 Gitbook默认带有5个插件： highlight search sharing font-settings livereload 如果要去除自带的插件， 可以在插件名称前面加- 123"plugins": [ "-search"] 11. 更多GitBook教程 GitBook 中文解說 - 2.4 gitbook-documentation gitbook-documentation]]></content>
      <categories>
        <category>gitbook</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2017%2F05%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 二叉查找树简介二叉查找树(Binary Search Tree)，又被称为二叉搜索树。 它是特殊的二叉树：对于二叉树，假设x为二叉树中的任意一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。那么，这棵树就是二叉查找树。如下图所示 在二叉查找树中： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值 任意节点的左、右子树也分别为二叉查找树 没有键值相等的节点（no duplicate nodes） 2. 二叉查找树的Java实现2.1 二叉查找树节点的定义1234567891011121314151617181920public class BSTree&lt;T extends Comparable&lt;T&gt;&gt; &#123; private BSTNode&lt;T&gt; mRoot; // 根结点 public class BSTNode&lt;T extends Comparable&lt;T&gt;&gt; &#123; T key; // 关键字(键值) BSTNode&lt;T&gt; left; // 左孩子 BSTNode&lt;T&gt; right; // 右孩子 BSTNode&lt;T&gt; parent; // 父结点 public BSTNode(T key, BSTNode&lt;T&gt; parent, BSTNode&lt;T&gt; left, BSTNode&lt;T&gt; right) &#123; this.key = key; this.parent = parent; this.left = left; this.right = right; &#125; &#125; ......&#125; BSTree是二叉树，它保护了二叉树的根节点mRoot；mRoot是BSTNode类型，而BSTNode是二叉查找树的节点，它是BSTree的内部类。BSTNode包含二叉查找树的几个基本信息： key – 它是关键字，是用来对二叉查找树的节点进行排序的。 left – 它指向当前节点的左孩子。 right – 它指向当前节点的右孩子。 parent – 它指向当前节点的父结点。 2.2 遍历这里讲解前序遍历、中序遍历、后序遍历3种方式。 2.2.1 前序遍历若二叉树非空，则执行以下操作： 访问根结点； 先序遍历左子树； 先序遍历右子树。 前序遍历代码 1234567891011private void preOrder(BSTNode&lt;T&gt; tree) &#123; if(tree != null) &#123; System.out.print(tree.key+" "); preOrder(tree.left); preOrder(tree.right); &#125;&#125;public void preOrder() &#123; preOrder(mRoot);&#125; 2.2.2 中序遍历若二叉树非空，则执行以下操作：(01) 中序遍历左子树；(02) 访问根结点；(03) 中序遍历右子树。 中序遍历代码 1234567891011private void inOrder(BSTNode&lt;T&gt; tree) &#123; if(tree != null) &#123; inOrder(tree.left); System.out.print(tree.key+" "); inOrder(tree.right); &#125;&#125;public void inOrder() &#123; inOrder(mRoot);&#125; 2.3 后序遍历若二叉树非空，则执行以下操作：(01) 后序遍历左子树；(02) 后序遍历右子树；(03) 访问根结点。 后序遍历代码 123456789101112private void postOrder(BSTNode&lt;T&gt; tree) &#123; if(tree != null) &#123; postOrder(tree.left); postOrder(tree.right); System.out.print(tree.key+" "); &#125;&#125;public void postOrder() &#123; postOrder(mRoot);&#125; 看看下面这颗树的各种遍历方式： 对于上面的二叉树而言， 前序遍历结果： 3 1 2 5 4 6 中序遍历结果： 1 2 3 4 5 6 后序遍历结果： 2 1 4 6 5 3 2.4 层序遍历所谓层序遍历(Levelorder Traversal)二叉树，是指从二叉树的第一层(根结点)开始，自上至下逐层遍历，在同一层中，则按从左到右的顺序对结点逐个访问。对于右图所示的二叉树，按层序遍历方式进行遍历所得到的结点序列为：A、B、C、D、E、F、G、H、I。 3. 二叉树的存储结构3.1 数组表示法二叉树的数组表示就是采用一组连续存储空间存储二叉树结点中的数据元素，利用数组下标来反映数据元素之间的关系。 对具有n个结点的完全二叉树按从上到下、自左向右的顺序连续给结点编号0、1、2、…、n-1。按此结点编号将二叉树中各结点中的数据元素顺序地存放于一个一维数组中，首先将根结点中的数据元素储存在数组的0号位置；对于二叉树中任一个结点，如果它的数据元素存储在数组的第i个位置，就把它的左、右孩子结点中的数据元素分别存放在数组的第2i+1个位置和第2i+2个位置。这样就得到了二叉树的一种数组表示法。 采用这种方法表示一般的二叉树时，空间利用效率低是一个主要的问题。当被表示的二叉树结构很不完整时，在数组中就会出现很多空位置，因此空间浪费就变得非常大。 用这种方法表示二叉树时，还有一个问题需要注意的是：必须处理结点不存在的情况。如果一个结点不存在，就必须在数组中相应位置设置一个特殊标志，指明在这个位置没有结点。 二叉树的二叉链表表示，对于大多数的应用来说是适合的。但是，在二叉链表中要想找出一个结点的双亲是比较困难的，必须通过二叉树的遍历才能实现。如果在应用中需要方便地找到任何一个结点的双亲，可以在结点中增加一个Parent域来指向该结点的双亲，二叉树的这种表示方法称为三叉链表。 3.2 链表表示法在二叉树的链表表示中，树中的每一个元素用一个结点表示，结点一般包括三个域，其结构如图(a)所示。其中，Data域用于存放数据元素的信息；leftChild域用于存放指向其左孩子结点的指针；rightChild域用于存放指向其右孩子结点的指针。二叉树的这种链表表示称为二叉链表。 4. 二叉树实现中序遍历是有序的二叉树(不重复)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251public class MyTree&#123; private Node root; // 根节点 private class Node &#123; Node parrent; // 父节点 Node left; // 左儿子 Node right; // 右儿子 Object data; public Node(Object data) &#123; this.data = data; &#125; &#125; /** * @param data * 传递的数据 * @return 父节点的值 */ private Node findParrent(Object data, Node currentNode) &#123; // 从根节点找 Node temp = currentNode; Node parrent = currentNode; // 循环找 while (temp != null) &#123; parrent = temp; // 比较 if (compare(data, temp.data)) &#123; // data 大于 当前节点 temp = temp.right; &#125; else &#123; // data 小于 当前节点 temp = temp.left; &#125; &#125; return parrent; &#125; public void update(Object oldData,Object newData)&#123; remove(oldData); add(newData); &#125; /** * 添加数据 * * @param data * 要添加的数据 */ public void add(Object data) &#123; // 判断该数据是否存在 if (contains(data)) return; // 1.把数据放到节点中 Node node = new Node(data); // 2.把节点链接到二叉树中 // 是否有根节点 if (root == null) &#123; root = node;// 保存到根节点中 &#125; else &#123; // 找位置,找父节点,比较父节点的值，小左边 大右边 Node parrent = findParrent(data, root); // 设置新增节点的父节点 node.parrent = parrent; // 比较 if (compare(data, parrent.data)) &#123; // 自己比父节点大 parrent.right = node; &#125; else &#123; // 自己比父节点小 parrent.left = node; &#125; &#125; &#125; /** * @param data * @return 是否包含该数据 */ public boolean contains(Object data) &#123; return null != find(data); &#125; private Node find(Object data) &#123; Node temp = root;// 从根节点找 while (temp != null) &#123; // 判断数据 if (temp.data.equals(data) &amp;&amp; temp.data.hashCode() == data.hashCode()) &#123; // 找到数据 break; &#125; else if (compare(data, temp.data)) &#123; // true data &gt; temp // 从右边找 temp = temp.right; &#125; else &#123; // false data &lt; temp // 从坐标边找 temp = temp.left; &#125; &#125; return temp; &#125; public void remove(Object data) &#123; // 1. 查找数据是否存在 Node temp = find(data); // 2. 存在：找到数据节点 if (temp != null) &#123; // 存在 // 3. 删除节点 // 1. 根节点 if (temp == root) &#123; // 11 没有儿子 if (temp.left == null &amp;&amp; temp.right == null) &#123; root = null; &#125; else if (temp.right == null) &#123; root = root.left; root.parrent = null; // 12 只有左儿子 &#125; else if (temp.left == null) &#123; // 13 只有右儿子 root = root.right; root.parrent = null; &#125; else &#123; // 14 两个儿子都有 // 保留左儿子 Node left = getLeft(temp); // left成为新的根节点 root = left; left.parrent = null; &#125; &#125; else &#123;// 2. 非根节点 if (temp.left == null &amp;&amp; temp.right == null) &#123; // 21 没有儿子 if (compare(temp.data, temp.parrent.data)) &#123; //在父节点右边 temp.parrent.right = null; &#125; else &#123; //在父节点左边 temp.parrent.left = null; &#125; &#125; else if (temp.right == null) &#123; // 22 只有左儿子 if (compare(temp.data, temp.parrent.data)) &#123; //在父节点右边 temp.parrent.right = temp.left; temp.left.parrent = temp.parrent; &#125; else &#123; //在父节点左边 temp.parrent.left = temp.left; temp.left.parrent = temp.parrent; &#125; &#125; else if (temp.left == null) &#123; // 23 只有右儿子 if (compare(temp.data, temp.parrent.data)) &#123; //在父节点右边 temp.parrent.right = temp.right; temp.right.parrent = temp.parrent; &#125; else &#123; //在父节点左边 temp.parrent.left = temp.right; temp.right.parrent = temp.parrent; &#125; &#125; else &#123; // 24 两个儿子都有 Node left = getLeft(temp); //上面还有父节点（爷爷） if (compare(left.data, temp.parrent.data)) &#123; //比爷爷节点大 temp.parrent.right = left; left.parrent = temp.parrent; &#125; else &#123; //比爷爷节点小 temp.parrent.left = left; left.parrent = temp.parrent; &#125; &#125; &#125; &#125; &#125; /** * @param node * 要删除的节点 * @return 左儿子节点 */ private Node getLeft(Node node) &#123; // 保留左儿子 Node left = node.left; // 处理右节点 Node rightNewParrent = findParrent(node.right.data, left); rightNewParrent.right = node.right;// 把删除节点的右节点放到删除节点的左儿子最右边 node.right.parrent = rightNewParrent; return left; &#125; /** * @param o1 * 第一个值 * @param o2 * 第二个值 * @return 如果o1 大于 o2 返回true 否则false */ public boolean compare(Object o1, Object o2) &#123; boolean res = false; // 判断o1 有没有实现比较器 if (o1 instanceof Comparable) &#123; Comparable c1 = (Comparable) o1; Comparable c2 = (Comparable) o2; if (c1.compareTo(c2) &gt; 0) &#123; res = true; &#125; else &#123; // 默认值就是false &#125; &#125; else &#123;// 传递的对象没有比较器 res = o1.toString().compareTo(o2.toString()) &gt; 0 ? true : false; &#125; return res; &#125; // 递归打印 public void print() &#123; print(root); &#125; public void print(Node node) &#123; if (node == null) &#123; return; &#125; else &#123; // 遍历 中序 print(node.left); System.out.println(node.data + ","); print(node.right); &#125; &#125;&#125; 1234567891011121314151617181920public class TestTreeApp&#123; public static void main(String[] args) &#123; MyTree trees = new MyTree(); int[] datas = &#123;55,33,44,88,66,99&#125;; for (int d : datas) &#123; trees.add(d); &#125; trees.print(); System.out.println(); //测试删除 trees.update(33,77); trees.print(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈夫曼树]]></title>
    <url>%2F2017%2F05%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 哈夫曼树的介绍Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。 定义：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。 这个定义里面涉及到了几个陌生的概念，下面就是一颗哈夫曼树，我们来看图解答。 1.1 路径和路径长度定义：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。 例子：100和80的路径长度是1，50和30的路径长度是2，20和10的路径长度是3。 1.2 结点的权及带权路径长度定义：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。 例子：节点20的路径长度是3，它的带权路径长度= 路径长度 权 = 3 20 = 60。 1.3 树的带权路径长度定义：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。 例子：示例中，树的WPL= 1100 + 2\80 + 320 + 3\10 = 100 + 160 + 60 + 30 = 350。 比较下面两棵树 上面的两棵树都是以{10, 20, 50, 100}为叶子节点的树。 左边的树WPL=210 + 220 + 250 + 2100 = 360 右边的树WPL=350 左边的树WPL &gt; 右边的树的WPL。你也可以计算除上面两种示例之外的情况，但实际上右边的树就是{10,20,50,100}对应的哈夫曼树。至此，应该堆哈夫曼树的概念有了一定的了解了，下面看看如何去构造一棵哈夫曼树。 2. 哈夫曼树的图文解析假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，哈夫曼树的构造规则为： 1. 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；2. 在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；3. 从森林中删除选取的两棵树，并将新树加入森林；4. 重复(02)、(03)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。 以{5,6,7,8,15}为例，来构造一棵哈夫曼树。 第1步：创建森林，森林包括5棵树，这5棵树的权值分别是5,6,7,8,15。第2步：在森林中，选择根节点权值最小的两棵树(5和6)来进行合并，将它们作为一颗新树的左右孩子(谁左谁右无关紧要，这里，我们选择较小的作为左孩子)，并且新树的权值是左右孩子的权值之和。即，新树的权值是11。 然后，将”树5”和”树6”从森林中删除，并将新的树(树11)添加到森林中。第3步：在森林中，选择根节点权值最小的两棵树(7和8)来进行合并。得到的新树的权值是15。 然后，将”树7”和”树8”从森林中删除，并将新的树(树15)添加到森林中。第4步：在森林中，选择根节点权值最小的两棵树(11和15)来进行合并。得到的新树的权值是26。 然后，将”树11”和”树15”从森林中删除，并将新的树(树26)添加到森林中。第5步：在森林中，选择根节点权值最小的两棵树(15和26)来进行合并。得到的新树的权值是41。 然后，将”树15”和”树26”从森林中删除，并将新的树(树41)添加到森林中。此时，森林中只有一棵树(树41)。这棵树就是我们需要的哈夫曼树！ 3. 哈夫曼树的基本操作哈夫曼树的重点是如何构造哈夫曼树。本文构造哈夫曼时，用到了以前介绍过的”(二叉堆)最小堆”。下面对哈夫曼树进行讲解。 基本定义12345678910111213141516171819202122232425262728293031public class HuffmanNode implements Comparable, Cloneable &#123; protected int key; // 权值 protected HuffmanNode left; // 左孩子 protected HuffmanNode right; // 右孩子 protected HuffmanNode parent; // 父结点 protected HuffmanNode(int key, HuffmanNode left, HuffmanNode right, HuffmanNode parent) &#123; this.key = key; this.left = left; this.right = right; this.parent = parent; &#125; @Override public Object clone() &#123; Object obj=null; try &#123; obj = (HuffmanNode)super.clone();//Object 中的clone()识别出你要复制的是哪一个对象。 &#125; catch(CloneNotSupportedException e) &#123; System.out.println(e.toString()); &#125; return obj; &#125; @Override public int compareTo(Object obj) &#123; return this.key - ((HuffmanNode)obj).key; &#125;&#125; HuffmanNode是哈夫曼树的节点类。 123456public class Huffman &#123; private HuffmanNode mRoot; // 根结点 ...&#125; Huffman是哈夫曼树对应的类，它包含了哈夫曼树的根节点和哈夫曼树的相关操作。 4. 构造哈夫曼树12345678910111213141516171819202122232425262728293031/* * 创建Huffman树 * * @param 权值数组 */public Huffman(int a[]) &#123; HuffmanNode parent = null; MinHeap heap; // 建立数组a对应的最小堆 heap = new MinHeap(a); for(int i=0; i&lt;a.length-1; i++) &#123; HuffmanNode left = heap.dumpFromMinimum(); // 最小节点是左孩子 HuffmanNode right = heap.dumpFromMinimum(); // 其次才是右孩子 // 新建parent节点，左右孩子分别是left/right； // parent的大小是左右孩子之和 parent = new HuffmanNode(left.key+right.key, left, right, null); left.parent = parent; right.parent = parent; // 将parent节点数据拷贝到"最小堆"中 heap.insert(parent); &#125; mRoot = parent; // 销毁最小堆 heap.destroy();&#125; 首先创建最小堆，然后进入for循环。每次循环时： 首先，将最小堆中的最小节点拷贝一份并赋值给left，然后重塑最小堆(将最小节点和后面的节点交换位置，接着将”交换位置后的最小节点”之前的全部元素重新构造成最小堆)； 接着，再将最小堆中的最小节点拷贝一份并将其赋值right，然后再次重塑最小堆； 然后，新建节点parent，并将它作为left和right的父节点； 接着，将parent的数据复制给最小堆中的指定节点。 在二叉堆中已经介绍过堆，这里就不再对堆的代码进行说明了。若有疑问，直接参考后文的源码。其它的相关代码，也Please RTFSC(Read The Fucking Source Code)！ 5. 哈夫曼树的完整源码哈夫曼树的节点类(HuffmanNode.java)1234567891011121314151617181920212223242526272829303132333435363738/** * Huffman节点类(Huffman.java的辅助类) * * @author skywang * @date 2014/03/27 */public class HuffmanNode implements Comparable, Cloneable &#123; protected int key; // 权值 protected HuffmanNode left; // 左孩子 protected HuffmanNode right; // 右孩子 protected HuffmanNode parent; // 父结点 protected HuffmanNode(int key, HuffmanNode left, HuffmanNode right, HuffmanNode parent) &#123; this.key = key; this.left = left; this.right = right; this.parent = parent; &#125; @Override public Object clone() &#123; Object obj=null; try &#123; obj = (HuffmanNode)super.clone();//Object 中的clone()识别出你要复制的是哪一个对象。 &#125; catch(CloneNotSupportedException e) &#123; System.out.println(e.toString()); &#125; return obj; &#125; @Override public int compareTo(Object obj) &#123; return this.key - ((HuffmanNode)obj).key; &#125;&#125; 哈夫曼树的实现文件(Huffman.java)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * Huffman树 * * @author skywang * @date 2014/03/27 */import java.util.List;import java.util.ArrayList;import java.util.Collections;public class Huffman &#123; private HuffmanNode mRoot; // 根结点 /* * 创建Huffman树 * * @param 权值数组 */ public Huffman(int a[]) &#123; HuffmanNode parent = null; MinHeap heap; // 建立数组a对应的最小堆 heap = new MinHeap(a); for(int i=0; i&lt;a.length-1; i++) &#123; HuffmanNode left = heap.dumpFromMinimum(); // 最小节点是左孩子 HuffmanNode right = heap.dumpFromMinimum(); // 其次才是右孩子 // 新建parent节点，左右孩子分别是left/right； // parent的大小是左右孩子之和 parent = new HuffmanNode(left.key+right.key, left, right, null); left.parent = parent; right.parent = parent; // 将parent节点数据拷贝到"最小堆"中 heap.insert(parent); &#125; mRoot = parent; // 销毁最小堆 heap.destroy(); &#125; /* * 前序遍历"Huffman树" */ private void preOrder(HuffmanNode tree) &#123; if(tree != null) &#123; System.out.print(tree.key+" "); preOrder(tree.left); preOrder(tree.right); &#125; &#125; public void preOrder() &#123; preOrder(mRoot); &#125; /* * 中序遍历"Huffman树" */ private void inOrder(HuffmanNode tree) &#123; if(tree != null) &#123; inOrder(tree.left); System.out.print(tree.key+" "); inOrder(tree.right); &#125; &#125; public void inOrder() &#123; inOrder(mRoot); &#125; /* * 后序遍历"Huffman树" */ private void postOrder(HuffmanNode tree) &#123; if(tree != null) &#123; postOrder(tree.left); postOrder(tree.right); System.out.print(tree.key+" "); &#125; &#125; public void postOrder() &#123; postOrder(mRoot); &#125; /* * 销毁Huffman树 */ private void destroy(HuffmanNode tree) &#123; if (tree==null) return ; if (tree.left != null) destroy(tree.left); if (tree.right != null) destroy(tree.right); tree=null; &#125; public void destroy() &#123; destroy(mRoot); mRoot = null; &#125; /* * 打印"Huffman树" * * key -- 节点的键值 * direction -- 0，表示该节点是根节点; * -1，表示该节点是它的父结点的左孩子; * 1，表示该节点是它的父结点的右孩子。 */ private void print(HuffmanNode tree, int key, int direction) &#123; if(tree != null) &#123; if(direction==0) // tree是根节点 System.out.printf("%2d is root\n", tree.key); else // tree是分支节点 System.out.printf("%2d is %2d's %6s child\n", tree.key, key, direction==1?"right" : "left"); print(tree.left, tree.key, -1); print(tree.right,tree.key, 1); &#125; &#125; public void print() &#123; if (mRoot != null) print(mRoot, mRoot.key, 0); &#125;&#125; 哈夫曼树对应的最小堆(MinHeap.java)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/** * 最小堆(Huffman.java的辅助类) * * @author skywang * @date 2014/03/27 */import java.util.ArrayList;import java.util.List;public class MinHeap &#123; private List&lt;HuffmanNode&gt; mHeap; // 存放堆的数组 /* * 创建最小堆 * * 参数说明： * a -- 数据所在的数组 */ protected MinHeap(int a[]) &#123; mHeap = new ArrayList&lt;HuffmanNode&gt;(); // 初始化数组 for(int i=0; i&lt;a.length; i++) &#123; HuffmanNode node = new HuffmanNode(a[i], null, null, null); mHeap.add(node); &#125; // 从(size/2-1) --&gt; 0逐次遍历。遍历之后，得到的数组实际上是一个最小堆。 for (int i = a.length / 2 - 1; i &gt;= 0; i--) filterdown(i, a.length-1); &#125; /* * 最小堆的向下调整算法 * * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。 * * 参数说明： * start -- 被下调节点的起始位置(一般为0，表示从第1个开始) * end -- 截至范围(一般为数组中最后一个元素的索引) */ protected void filterdown(int start, int end) &#123; int c = start; // 当前(current)节点的位置 int l = 2*c + 1; // 左(left)孩子的位置 HuffmanNode tmp = mHeap.get(c); // 当前(current)节点 while(l &lt;= end) &#123; // "l"是左孩子，"l+1"是右孩子 if(l &lt; end &amp;&amp; (mHeap.get(l).compareTo(mHeap.get(l+1))&gt;0)) l++; // 左右两孩子中选择较小者，即mHeap[l+1] int cmp = tmp.compareTo(mHeap.get(l)); if(cmp &lt;= 0) break; //调整结束 else &#123; mHeap.set(c, mHeap.get(l)); c = l; l = 2*l + 1; &#125; &#125; mHeap.set(c, tmp); &#125; /* * 最小堆的向上调整算法(从start开始向上直到0，调整堆) * * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。 * * 参数说明： * start -- 被上调节点的起始位置(一般为数组中最后一个元素的索引) */ protected void filterup(int start) &#123; int c = start; // 当前节点(current)的位置 int p = (c-1)/2; // 父(parent)结点的位置 HuffmanNode tmp = mHeap.get(c); // 当前(current)节点 while(c &gt; 0) &#123; int cmp = mHeap.get(p).compareTo(tmp); if(cmp &lt;= 0) break; else &#123; mHeap.set(c, mHeap.get(p)); c = p; p = (p-1)/2; &#125; &#125; mHeap.set(c, tmp); &#125; /* * 将node插入到二叉堆中 */ protected void insert(HuffmanNode node) &#123; int size = mHeap.size(); mHeap.add(node); // 将"数组"插在表尾 filterup(size); // 向上调整堆 &#125; /* * 交换两个HuffmanNode节点的全部数据 */ private void swapNode(int i, int j) &#123; HuffmanNode tmp = mHeap.get(i); mHeap.set(i, mHeap.get(j)); mHeap.set(j, tmp); &#125; /* * 新建一个节点，并将最小堆中最小节点的数据复制给该节点。 * 然后除最小节点之外的数据重新构造成最小堆。 * * 返回值： * 失败返回null。 */ protected HuffmanNode dumpFromMinimum() &#123; int size = mHeap.size(); // 如果"堆"已空，则返回 if(size == 0) return null; // 将"最小节点"克隆一份，将克隆得到的对象赋值给node HuffmanNode node = (HuffmanNode)mHeap.get(0).clone(); // 交换"最小节点"和"最后一个节点" mHeap.set(0, mHeap.get(size-1)); // 删除最后的元素 mHeap.remove(size-1); if (mHeap.size() &gt; 1) filterdown(0, mHeap.size()-1); return node; &#125; // 销毁最小堆 protected void destroy() &#123; mHeap.clear(); mHeap = null; &#125;&#125; 哈夫曼树的测试程序(HuffmanTest.java)123456789101112131415161718192021222324252627282930313233343536373839/** * Huffman树的测试程序 * * @author skywang * @date 2014/03/27 */public class HuffmanTest &#123; private static final int a[]= &#123;5,6,8,7,15&#125;; public static void main(String[] args) &#123; int i; Huffman tree; System.out.print("== 添加数组: "); for(i=0; i&lt;a.length; i++) System.out.print(a[i]+" "); // 创建数组a对应的Huffman树 tree = new Huffman(a); System.out.print("\n== 前序遍历: "); tree.preOrder(); System.out.print("\n== 中序遍历: "); tree.inOrder(); System.out.print("\n== 后序遍历: "); tree.postOrder(); System.out.println(); System.out.println("== 树的详细信息: "); tree.print(); // 销毁二叉树 tree.destroy(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>哈夫曼树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2017%2F05%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[1. 栈的介绍注意：本文所说的栈是数据结构中的栈，而不是内存模型中栈 栈（stack）是限定仅在表尾一端进行插入或删除操作的特殊线性表。对于栈来说, 允许进行插入或删除操作的一端称为栈顶（top）,而另一端称为栈底（bottom）。不含元素栈称为空栈，向栈中插入一个新元素称为入栈或压栈， 从栈中删除一个元素称为出栈或退栈。 假设有一个栈Ｓ＝（a1, a2, …, an), a1先进栈, an最后进栈。称a1为栈底元素, an为栈顶元素, 如图3.1所示。出栈时只允许在栈顶进行, 所以an先出栈, a1最后出栈。因此又称栈为后进先出（Last In First Out，LIFO）的线性表。 栈（stack），是一种线性存储结构，它有以下几个特点： 栈中数据是按照”后进先出（LIFO, Last In First Out）”方式进出栈的。 向栈中添加/删除数据时，只能从栈顶进行操作。 栈通常包括的三种操作：push、peek、pop。 push – 向栈中添加元素。 peek – 返回栈顶元素。 pop – 返回并删除栈顶元素的操作。 1.1 栈的示意图 栈中的数据依次是 30 –&gt; 20 –&gt; 10 1.2 出栈 出栈前：栈顶元素是30。此时，栈中的元素依次是 30 –&gt; 20 –&gt; 10出栈后：30出栈之后，栈顶元素变成20。此时，栈中的元素依次是 20 –&gt; 10 1.3 入栈 入栈前：栈顶元素是20。此时，栈中的元素依次是 20 –&gt; 10入栈后：40入栈之后，栈顶元素变成40。此时，栈中的元素依次是 40 –&gt; 20 –&gt; 10 2. 栈的Java实现JDK包中也提供了”栈”的实现，它就是集合框架中的Stack类。本部分给出2种Java实现 2.1 栈的数组实现数组实现的栈，能存储任意类型的数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * Java : 数组实现的栈，能存储任意类型的数据 */import java.lang.reflect.Array;public class GeneralArrayStack&lt;T&gt; &#123; private static final int DEFAULT_SIZE = 12; private T[] mArray; private int count; public GeneralArrayStack(Class&lt;T&gt; type) &#123; this(type, DEFAULT_SIZE); &#125; public GeneralArrayStack(Class&lt;T&gt; type, int size) &#123; // 不能直接使用mArray = new T[DEFAULT_SIZE]; mArray = (T[]) Array.newInstance(type, size); count = 0; &#125; // 将val添加到栈中 public void push(T val) &#123; mArray[count++] = val; &#125; // 返回“栈顶元素值” public T peek() &#123; return mArray[count-1]; &#125; // 返回“栈顶元素值”，并删除“栈顶元素” public T pop() &#123; T ret = mArray[count-1]; count--; return ret; &#125; // 返回“栈”的大小 public int size() &#123; return count; &#125; // 返回“栈”是否为空 public boolean isEmpty() &#123; return size()==0; &#125; // 打印“栈” public void PrintArrayStack() &#123; if (isEmpty()) &#123; System.out.printf("stack is Empty\n"); &#125; System.out.printf("stack size()=%d\n", size()); int i=size()-1; while (i&gt;=0) &#123; System.out.println(mArray[i]); i--; &#125; &#125; public static void main(String[] args) &#123; String tmp; GeneralArrayStack&lt;String&gt; astack = new GeneralArrayStack&lt;String&gt;(String.class); // 将10, 20, 30 依次推入栈中 astack.push("10"); astack.push("20"); astack.push("30"); // 将“栈顶元素”赋值给tmp，并删除“栈顶元素” tmp = astack.pop(); System.out.println("tmp="+tmp); // 只将“栈顶”赋值给tmp，不删除该元素. tmp = astack.peek(); System.out.println("tmp="+tmp); astack.push("40"); astack.PrintArrayStack(); // 打印栈 &#125;&#125; 运行结果： 123456tmp=30tmp=20stack size()=3402010 结果说明：GeneralArrayStack是通过数组实现的栈，而且GeneralArrayStack中使用到了泛型 2.2 栈StackJava的 Collection集合 中自带的”栈”(stack)的示例 12345678910111213141516171819202122232425262728293031import java.util.Stack;/** * Java : java集合包中的Stack的演示程序 */public class StackTest &#123; public static void main(String[] args) &#123; int tmp=0; Stack&lt;Integer&gt; astack = new Stack&lt;Integer&gt;(); // 将10, 20, 30 依次推入栈中 astack.push(10); astack.push(20); astack.push(30); // 将“栈顶元素”赋值给tmp，并删除“栈顶元素” tmp = astack.pop(); //System.out.printf("tmp=%d\n", tmp); // 只将“栈顶”赋值给tmp，不删除该元素. tmp = (int)astack.peek(); //System.out.printf("tmp=%d\n", tmp); astack.push(40); while(!astack.empty()) &#123; tmp = (int)astack.pop(); System.out.printf("tmp=%d\n", tmp); &#125; &#125;&#125; 运行结果： 123tmp=40tmp=20tmp=10 3. Stack详细介绍学完Vector了之后，接下来我们开始学习Stack。Stack很简单，它继承于Vector。学习方式还是和之前一样，先对Stack有个整体认识，然后再学习它的源码；最后再通过实例来学会使用它。内容包括： 第1部分 Stack介绍 第2部分 Stack源码解析(基于JDK1.6.0_45) 第3部分 Vector示例 3.1 Stack介绍Stack是栈。它的特性是：先进后出(FILO, First In Last Out)。 java工具包中的Stack是继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，Stack也是通过数组实现的，而非链表。当然，我们也可以将LinkedList当作栈来使用！在“Java 集合系列06之 Vector详细介绍(源码解析)和使用示例”中，已经详细介绍过Vector的数据结构，这里就不再对Stack的数据结构进行说明了。 3.2 Stack的继承关系1234567java.lang.Object↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.Vector&lt;E&gt; ↳ java.util.Stack&lt;E&gt;public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123;&#125; Stack和Collection的关系如下图 4. 栈4.1 栈的LinkedList实现1234567891011121314151617181920public class MyStack &#123; private LinkedList link; public MyStack() &#123; link = new LinkedList(); &#125; public void add(Object obj) &#123; link.addFirst(obj); &#125; public Object get() &#123; // return link.getFirst(); return link.removeFirst(); &#125; public boolean isEmpty() &#123; return link.isEmpty(); &#125;&#125; 4.2 栈的数组实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// stack.java// demonstrates stacks// to run this program: C&gt;java StackApp////////////////////////////////////////////////////////////////class StackX &#123; private int maxSize; // size of stack array private long[] stackArray; private int top; // top of stack//-------------------------------------------------------------- public StackX(int s) // constructor &#123; maxSize = s; // set array size stackArray = new long[maxSize]; // create array top = -1; // no items yet &#125;//-------------------------------------------------------------- public void push(long j) // put item on top of stack &#123; stackArray[++top] = j; // increment top, insert item &#125;//-------------------------------------------------------------- public long pop() // take item from top of stack &#123; return stackArray[top--]; // access item, decrement top &#125;//-------------------------------------------------------------- public long peek() // peek at top of stack &#123; return stackArray[top]; &#125;//-------------------------------------------------------------- public boolean isEmpty() // true if stack is empty &#123; return (top == -1); &#125;//-------------------------------------------------------------- public boolean isFull() // true if stack is full &#123; return (top == maxSize-1); &#125;//-------------------------------------------------------------- &#125; // end class StackX////////////////////////////////////////////////////////////////class StackApp &#123; public static void main(String[] args) &#123; StackX theStack = new StackX(10); // make new stack theStack.push(20); // push items onto stack theStack.push(40); theStack.push(60); theStack.push(80); while( !theStack.isEmpty() ) // until it's empty, &#123; // delete item from stack long value = theStack.pop(); System.out.print(value); // display it System.out.print(" "); &#125; // end while System.out.println(""); &#125; // end main() &#125; // end class StackApp//////////////////////////////////////////////////////////////// 4.3 栈实例1：单词逆序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// reverse.java// stack used to reverse a string// to run this program: C&gt;java ReverseAppimport java.io.*; // for I/O////////////////////////////////////////////////////////////////class StackX &#123; private int maxSize; private char[] stackArray; private int top;//-------------------------------------------------------------- public StackX(int max) // constructor &#123; maxSize = max; stackArray = new char[maxSize]; top = -1; &#125;//-------------------------------------------------------------- public void push(char j) // put item on top of stack &#123; stackArray[++top] = j; &#125;//-------------------------------------------------------------- public char pop() // take item from top of stack &#123; return stackArray[top--]; &#125;//-------------------------------------------------------------- public char peek() // peek at top of stack &#123; return stackArray[top]; &#125;//-------------------------------------------------------------- public boolean isEmpty() // true if stack is empty &#123; return (top == -1); &#125;//-------------------------------------------------------------- &#125; // end class StackX////////////////////////////////////////////////////////////////class Reverser &#123; private String input; // input string private String output; // output string//-------------------------------------------------------------- public Reverser(String in) // constructor &#123; input = in; &#125;//-------------------------------------------------------------- public String doRev() // reverse the string &#123; int stackSize = input.length(); // get max stack size StackX theStack = new StackX(stackSize); // make stack for(int j=0; j&lt;input.length(); j++) &#123; char ch = input.charAt(j); // get a char from input theStack.push(ch); // push it &#125; output = ""; while( !theStack.isEmpty() ) &#123; char ch = theStack.pop(); // pop a char, output = output + ch; // append to output &#125; return output; &#125; // end doRev()//-------------------------------------------------------------- &#125; // end class Reverser////////////////////////////////////////////////////////////////class ReverseApp &#123; public static void main(String[] args) throws IOException &#123; String input, output; while(true) &#123; System.out.print("Enter a string: "); System.out.flush(); input = getString(); // read a string from kbd if( input.equals("") ) // quit if [Enter] break; // make a Reverser Reverser theReverser = new Reverser(input); output = theReverser.doRev(); // use it System.out.println("Reversed: " + output); &#125; // end while &#125; // end main()//-------------------------------------------------------------- public static String getString() throws IOException &#123; InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; &#125;//-------------------------------------------------------------- &#125; // end class ReverseApp//////////////////////////////////////////////////////////////// 4.4 栈实例2：分隔符匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// brackets.java// stacks used to check matching brackets// to run this program: C&gt;java bracketsAppimport java.io.*; // for I/O////////////////////////////////////////////////////////////////class StackX &#123; private int maxSize; private char[] stackArray; private int top;//-------------------------------------------------------------- public StackX(int s) // constructor &#123; maxSize = s; stackArray = new char[maxSize]; top = -1; &#125;//-------------------------------------------------------------- public void push(char j) // put item on top of stack &#123; stackArray[++top] = j; &#125;//-------------------------------------------------------------- public char pop() // take item from top of stack &#123; return stackArray[top--]; &#125;//-------------------------------------------------------------- public char peek() // peek at top of stack &#123; return stackArray[top]; &#125;//-------------------------------------------------------------- public boolean isEmpty() // true if stack is empty &#123; return (top == -1); &#125;//-------------------------------------------------------------- &#125; // end class StackX////////////////////////////////////////////////////////////////class BracketChecker &#123; private String input; // input string//-------------------------------------------------------------- public BracketChecker(String in) // constructor &#123; input = in; &#125;//-------------------------------------------------------------- public void check() &#123; int stackSize = input.length(); // get max stack size StackX theStack = new StackX(stackSize); // make stack for(int j=0; j&lt;input.length(); j++) // get chars in turn &#123; char ch = input.charAt(j); // get char switch(ch) &#123; case '&#123;': // opening symbols case '[': case '(': theStack.push(ch); // push them break; case '&#125;': // closing symbols case ']': case ')': if( !theStack.isEmpty() ) // if stack not empty, &#123; char chx = theStack.pop(); // pop and check if( (ch=='&#125;' &amp;&amp; chx!='&#123;') || (ch==']' &amp;&amp; chx!='[') || (ch==')' &amp;&amp; chx!='(') ) System.out.println("Error: "+ch+" at "+j); &#125; else // prematurely empty System.out.println("Error: "+ch+" at "+j); break; default: // no action on other characters break; &#125; // end switch &#125; // end for // at this point, all characters have been processed if( !theStack.isEmpty() ) System.out.println("Error: missing right delimiter"); &#125; // end check()//-------------------------------------------------------------- &#125; // end class BracketChecker////////////////////////////////////////////////////////////////class BracketsApp &#123; public static void main(String[] args) throws IOException &#123; String input; while(true) &#123; System.out.print( "Enter string containing delimiters: "); System.out.flush(); input = getString(); // read a string from kbd if( input.equals("") ) // quit if [Enter] break; // make a BracketChecker BracketChecker theChecker = new BracketChecker(input); theChecker.check(); // check brackets &#125; // end while &#125; // end main()//-------------------------------------------------------------- public static String getString() throws IOException &#123; InputStreamReader isr = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(isr); String s = br.readLine(); return s; &#125;//-------------------------------------------------------------- &#125; // end class BracketsApp//////////////////////////////////////////////////////////////// 4.5 栈的链表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// linkStack.java// demonstrates a stack implemented as a list// to run this program: C&gt;java LinkStackApp////////////////////////////////////////////////////////////////class Link &#123; public long dData; // data item public Link next; // next link in list// ------------------------------------------------------------- public Link(long dd) // constructor &#123; dData = dd; &#125;// ------------------------------------------------------------- public void displayLink() // display ourself &#123; System.out.print(dData + " "); &#125; &#125; // end class Link////////////////////////////////////////////////////////////////class LinkList &#123; private Link first; // ref to first item on list// ------------------------------------------------------------- public LinkList() // constructor &#123; first = null; &#125; // no items on list yet// ------------------------------------------------------------- public boolean isEmpty() // true if list is empty &#123; return (first==null); &#125;// ------------------------------------------------------------- public void insertFirst(long dd) // insert at start of list &#123; // make new link Link newLink = new Link(dd); newLink.next = first; // newLink --&gt; old first first = newLink; // first --&gt; newLink &#125;// ------------------------------------------------------------- public long deleteFirst() // delete first item &#123; // (assumes list not empty) Link temp = first; // save reference to link first = first.next; // delete it: first--&gt;old next return temp.dData; // return deleted link &#125;// ------------------------------------------------------------- public void displayList() &#123; Link current = first; // start at beginning of list while(current != null) // until end of list, &#123; current.displayLink(); // print data current = current.next; // move to next link &#125; System.out.println(""); &#125;// ------------------------------------------------------------- &#125; // end class LinkList////////////////////////////////////////////////////////////////class LinkStack &#123; private LinkList theList;//-------------------------------------------------------------- public LinkStack() // constructor &#123; theList = new LinkList(); &#125;//-------------------------------------------------------------- public void push(long j) // put item on top of stack &#123; theList.insertFirst(j); &#125;//-------------------------------------------------------------- public long pop() // take item from top of stack &#123; return theList.deleteFirst(); &#125;//-------------------------------------------------------------- public boolean isEmpty() // true if stack is empty &#123; return ( theList.isEmpty() ); &#125;//-------------------------------------------------------------- public void displayStack() &#123; System.out.print("Stack (top--&gt;bottom): "); theList.displayList(); &#125;//-------------------------------------------------------------- &#125; // end class LinkStack////////////////////////////////////////////////////////////////class LinkStackApp &#123; public static void main(String[] args) &#123; LinkStack theStack = new LinkStack(); // make stack theStack.push(20); // push items theStack.push(40); theStack.displayStack(); // display stack theStack.push(60); // push items theStack.push(80); theStack.displayStack(); // display stack theStack.pop(); // pop items theStack.pop(); theStack.displayStack(); // display stack &#125; // end main() &#125; // end class LinkStackApp//////////////////////////////////////////////////////////////// 原文出处：http://www.cnblogs.com/skywang12345/p/3562239.html]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和链表]]></title>
    <url>%2F2017%2F05%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1. 概要线性表是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。本章先介绍线性表的几个基本组成部分：数组、单向链表、双向链表；随后给出双向链表的C、C++和Java三种语言的实现 2. 数组数组有上界和下界，数组的元素在上下界内是连续的。存储10,20,30,40,50的数组的示意图如下 数组的特点是：数据是连续的；随机访问速度快。 数组中稍微复杂一点的是多维数组和动态数组。对于C语言而言，多维数组本质上也是通过一维数组实现的。至于动态数组，是指数组的容量能动态增长的数组；对于C语言而言，若要提供动态数组，需要手动实现；而对于C++而言，STL提供了Vector；对于Java而言，Collection集合中提供了ArrayList和Vector。 3. 单向链表单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。 单链表的示意图如下： 表头为空，表头的后继节点是”节点10”(数据为10的节点)，”节点10”的后继节点是”节点20”(数据为10的节点) 3.1 单链表删除节点 删除”节点30”删除之前：”节点20” 的后继节点为”节点30”，而”节点30” 的后继节点为”节点40”。删除之后：”节点20” 的后继节点为”节点40”。 3.2 单链表添加节点 在”节点10”与”节点20”之间添加”节点15”添加之前：”节点10” 的后继节点为”节点20”。添加之后：”节点10” 的后继节点为”节点15”，而”节点15” 的后继节点为”节点20”。 单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。 4. 双向链表双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。 双链表的示意图如下： 表头为空，表头的后继节点为”节点10”(数据为10的节点)；”节点10”的后继节点是”节点20”(数据为10的节点)，”节点20”的前继节点是”节点10”；”节点20”的后继节点是”节点30”，”节点30”的前继节点是”节点20”；…；末尾节点的后继节点是表头。 4.1 双链表删除节点 删除”节点30”删除之前：”节点20”的后继节点为”节点30”，”节点30” 的前继节点为”节点20”。”节点30”的后继节点为”节点40”，”节点40” 的前继节点为”节点30”。删除之后：”节点20”的后继节点为”节点40”，”节点40” 的前继节点为”节点20”。 4.2 双链表添加节点 在”节点10”与”节点20”之间添加”节点15”添加之前：”节点10”的后继节点为”节点20”，”节点20” 的前继节点为”节点10”。添加之后：”节点10”的后继节点为”节点15”，”节点15” 的前继节点为”节点10”。”节点15”的后继节点为”节点20”，”节点20” 的前继节点为”节点15”。 5. Java实现双链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * Java 实现的双向链表。 * 注：java自带的集合包中有实现双向链表，路径是:java.util.LinkedList * * @author skywang * @date 2013/11/07 */public class DoubleLink&lt;T&gt; &#123; // 表头 private DNode&lt;T&gt; mHead; // 节点个数 private int mCount; // 双向链表“节点”对应的结构体 private class DNode&lt;T&gt; &#123; public DNode prev; public DNode next; public T value; public DNode(T value, DNode prev, DNode next) &#123; this.value = value; this.prev = prev; this.next = next; &#125; &#125; // 构造函数 public DoubleLink() &#123; // 创建“表头”。注意：表头没有存储数据！ mHead = new DNode&lt;T&gt;(null, null, null); mHead.prev = mHead.next = mHead; // 初始化“节点个数”为0 mCount = 0; &#125; // 返回节点数目 public int size() &#123; return mCount; &#125; // 返回链表是否为空 public boolean isEmpty() &#123; return mCount==0; &#125; // 获取第index位置的节点 private DNode&lt;T&gt; getNode(int index) &#123; if (index&lt;0 || index&gt;=mCount) throw new IndexOutOfBoundsException(); // 正向查找 if (index &lt;= mCount/2) &#123; DNode&lt;T&gt; node = mHead.next; for (int i=0; i&lt;index; i++) node = node.next; return node; &#125; // 反向查找 DNode&lt;T&gt; rnode = mHead.prev; int rindex = mCount - index -1; for (int j=0; j&lt;rindex; j++) rnode = rnode.prev; return rnode; &#125; // 获取第index位置的节点的值 public T get(int index) &#123; return getNode(index).value; &#125; // 获取第1个节点的值 public T getFirst() &#123; return getNode(0).value; &#125; // 获取最后一个节点的值 public T getLast() &#123; return getNode(mCount-1).value; &#125; // 将节点插入到第index位置之前 public void insert(int index, T t) &#123; if (index==0) &#123; DNode&lt;T&gt; node = new DNode&lt;T&gt;(t, mHead, mHead.next); mHead.next.prev = node; mHead.next = node; mCount++; return ; &#125; DNode&lt;T&gt; inode = getNode(index); DNode&lt;T&gt; tnode = new DNode&lt;T&gt;(t, inode.prev, inode); inode.prev.next = tnode; inode.next = tnode; mCount++; return ; &#125; // 将节点插入第一个节点处。 public void insertFirst(T t) &#123; insert(0, t); &#125; // 将节点追加到链表的末尾 public void appendLast(T t) &#123; DNode&lt;T&gt; node = new DNode&lt;T&gt;(t, mHead.prev, mHead); mHead.prev.next = node; mHead.prev = node; mCount++; &#125; // 删除index位置的节点 public void del(int index) &#123; DNode&lt;T&gt; inode = getNode(index); inode.prev.next = inode.next; inode.next.prev = inode.prev; inode = null; mCount--; &#125; // 删除第一个节点 public void deleteFirst() &#123; del(0); &#125; // 删除最后一个节点 public void deleteLast() &#123; del(mCount-1); &#125;&#125; 测试程序(DlinkTest.java)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * Java 实现的双向链表。 * 注：java自带的集合包中有实现双向链表，路径是:java.util.LinkedList * * @author skywang * @date 2013/11/07 */public class DlinkTest &#123; // 双向链表操作int数据 private static void int_test() &#123; int[] iarr = &#123;10, 20, 30, 40&#125;; System.out.println("\n----int_test----"); // 创建双向链表 DoubleLink&lt;Integer&gt; dlink = new DoubleLink&lt;Integer&gt;(); dlink.insert(0, 20); // 将 20 插入到第一个位置 dlink.appendLast(10); // 将 10 追加到链表末尾 dlink.insertFirst(30); // 将 30 插入到第一个位置 // 双向链表是否为空 System.out.printf("isEmpty()=%b\n", dlink.isEmpty()); // 双向链表的大小 System.out.printf("size()=%d\n", dlink.size()); // 打印出全部的节点 for (int i=0; i&lt;dlink.size(); i++) System.out.println("dlink("+i+")="+ dlink.get(i)); &#125; private static void string_test() &#123; String[] sarr = &#123;"ten", "twenty", "thirty", "forty"&#125;; System.out.println("\n----string_test----"); // 创建双向链表 DoubleLink&lt;String&gt; dlink = new DoubleLink&lt;String&gt;(); dlink.insert(0, sarr[1]); // 将 sarr中第2个元素 插入到第一个位置 dlink.appendLast(sarr[0]); // 将 sarr中第1个元素 追加到链表末尾 dlink.insertFirst(sarr[2]); // 将 sarr中第3个元素 插入到第一个位置 // 双向链表是否为空 System.out.printf("isEmpty()=%b\n", dlink.isEmpty()); // 双向链表的大小 System.out.printf("size()=%d\n", dlink.size()); // 打印出全部的节点 for (int i=0; i&lt;dlink.size(); i++) System.out.println("dlink("+i+")="+ dlink.get(i)); &#125; // 内部类 private static class Student &#123; private int id; private String name; public Student(int id, String name) &#123; this.id = id; this.name = name; &#125; @Override public String toString() &#123; return "["+id+", "+name+"]"; &#125; &#125; private static Student[] students = new Student[]&#123; new Student(10, "sky"), new Student(20, "jody"), new Student(30, "vic"), new Student(40, "dan"), &#125;; private static void object_test() &#123; System.out.println("\n----object_test----"); // 创建双向链表 DoubleLink&lt;Student&gt; dlink = new DoubleLink&lt;Student&gt;(); dlink.insert(0, students[1]); // 将 students中第2个元素 插入到第一个位置 dlink.appendLast(students[0]); // 将 students中第1个元素 追加到链表末尾 dlink.insertFirst(students[2]); // 将 students中第3个元素 插入到第一个位置 // 双向链表是否为空 System.out.printf("isEmpty()=%b\n", dlink.isEmpty()); // 双向链表的大小 System.out.printf("size()=%d\n", dlink.size()); // 打印出全部的节点 for (int i=0; i&lt;dlink.size(); i++) &#123; System.out.println("dlink("+i+")="+ dlink.get(i)); &#125; &#125; public static void main(String[] args) &#123; int_test(); // 演示向双向链表操作“int数据”。 string_test(); // 演示向双向链表操作“字符串数据”。 object_test(); // 演示向双向链表操作“对象”。 &#125;&#125; 运行结果 1234567891011121314151617181920----int_test----isEmpty()=falsesize()=3dlink(0)=30dlink(1)=20dlink(2)=10----string_test----isEmpty()=falsesize()=3dlink(0)=thirtydlink(1)=twentydlink(2)=ten----object_test----isEmpty()=falsesize()=3dlink(0)=[30, vic]dlink(1)=[20, jody]dlink(2)=[10, sky] 6. 双链表实现2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class MyDoubleLink implements Iterable&lt;Object&gt;&#123; private class Node&#123; public Node(Object data)&#123; this.data = data; &#125; Node next; Node prev; Object data; &#125; private Node head; private Node rear; public void add(Object data)&#123; Node node = new Node(data); if (head == null)&#123; head = node; rear = node; &#125; else &#123; rear.next = node; node.prev = rear; rear = node; &#125; &#125; public boolean contains(Object data)&#123; Node node = find(data); return node != null; &#125; public void print()&#123; Node temp = head; while(temp != null)&#123; System.out.print(temp.data + ","); temp = temp.next; &#125; System.out.println(); &#125; private Node find(Object data)&#123; Node node = head; while (node != null)&#123; if (node.data.equals(data) &amp;&amp; node.data.hashCode() == data.hashCode())&#123; break; &#125; else &#123; node = node.next; &#125; &#125; return node; &#125; public void remove(Object data)&#123; Node node = find(data); if (node != null)&#123; if (node == head &amp;&amp; node == rear)&#123;//只有一个节点 head = null; rear = null; &#125; else if (node == head)&#123; //头节点 head = head.next; head.prev = null; &#125; else if (node == rear)&#123; //尾节点 rear = rear.prev; rear.next = null; &#125; else &#123; //中间节点 node.prev.next = node.next; node.next.prev = node.prev; &#125; &#125; &#125; @Override public Iterator&lt;Object&gt; iterator() &#123; Iterator&lt;Object&gt; ite = new Iterator&lt;Object&gt;() &#123; private Node temp = head; @Override public boolean hasNext() &#123; return temp != null; &#125; @Override public Object next() &#123; // TODO Auto-generated method stub Object data = temp.data; temp = temp.next; return data; &#125; @Override public void remove() &#123; // TODO Auto-generated method stub &#125; &#125;; return ite; &#125; &#125; 6.1 测试双链表123456789101112131415161718192021222324252627public class Test &#123; public static class Instance&#123; public Instance(int i)&#123; &#125; public Instance()&#123; &#125; &#125; public static void main(String[] args) &#123; Instance in = new Instance()&#123; &#125;; MyDoubleLink datas = new MyDoubleLink(); datas.add("aaa"); datas.add("bbb"); datas.add("ccc"); datas.print(); datas.remove("ccc"); datas.print(); for (Object d : datas) &#123; System.out.println(d); &#125; &#125;&#125; 7. 双链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.util.Iterator;public class MyDoubleLink implements Iterable&lt;Object&gt;&#123; private class Node&#123; public Node(Object data)&#123; this.data = data; &#125; Node next; Node prev; Object data; &#125; private Node head; private Node rear; public void add(Object data)&#123; Node node = new Node(data); if (head == null)&#123; head = node; rear = node; &#125; else &#123; rear.next = node; node.prev = rear; rear = node; &#125; &#125; public boolean contains(Object data)&#123; Node node = find(data); return node != null; &#125; public void print()&#123; Node temp = head; while(temp != null)&#123; System.out.print(temp.data + ","); temp = temp.next; &#125; System.out.println(); &#125; private Node find(Object data)&#123; Node node = head; while (node != null)&#123; if (node.data.equals(data) &amp;&amp; node.data.hashCode() == data.hashCode())&#123; break; &#125; else &#123; node = node.next; &#125; &#125; return node; &#125; public void remove(Object data)&#123; Node node = find(data); if (node != null)&#123; if (node == head &amp;&amp; node == rear)&#123;//只有一个节点 head = null; rear = null; &#125; else if (node == head)&#123; //头节点 head = head.next; head.prev = null; &#125; else if (node == rear)&#123; //尾节点 rear = rear.prev; rear.next = null; &#125; else &#123; //中间节点 node.prev.next = node.next; node.next.prev = node.prev; &#125; &#125; &#125; @Override public Iterator&lt;Object&gt; iterator() &#123; Iterator&lt;Object&gt; ite = new Iterator&lt;Object&gt;() &#123; private Node temp = head; @Override public boolean hasNext() &#123; return temp != null; &#125; @Override public Object next() &#123; // TODO Auto-generated method stub Object data = temp.data; temp = temp.next; return data; &#125; @Override public void remove() &#123; // TODO Auto-generated method stub &#125; &#125;; return ite; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class TEst &#123; public static class Instance&#123; public Instance(int i)&#123; &#125; public Instance()&#123; &#125; &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Instance in = new Instance()&#123; &#125;; MyDoubleLink datas = new MyDoubleLink(); datas.add("aaa"); datas.add("bbb"); datas.add("ccc"); datas.print(); datas.remove("ccc"); datas.print(); for (Object d : datas) &#123; System.out.println(d); &#125; &#125;&#125; 7.1 单链表的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// linkList2.java// demonstrates linked list// to run this program: C&gt;java LinkList2App////////////////////////////////////////////////////////////////class Link &#123; public int iData; // data item (key) public double dData; // data item public Link next; // next link in list// ------------------------------------------------------------- public Link(int id, double dd) // constructor &#123; iData = id; dData = dd; &#125;// ------------------------------------------------------------- public void displayLink() // display ourself &#123; System.out.print("&#123;" + iData + ", " + dData + "&#125; "); &#125; &#125; // end class Link////////////////////////////////////////////////////////////////class LinkList &#123; private Link first; // ref to first link on list// ------------------------------------------------------------- public LinkList() // constructor &#123; first = null; // no links on list yet &#125;// ------------------------------------------------------------- public void insertFirst(int id, double dd) &#123; // make new link Link newLink = new Link(id, dd); newLink.next = first; // it points to old first link first = newLink; // now first points to this &#125;// ------------------------------------------------------------- public Link find(int key) // find link with given key &#123; // (assumes non-empty list) Link current = first; // start at 'first' while(current.iData != key) // while no match, &#123; if(current.next == null) // if end of list, return null; // didn't find it else // not end of list, current = current.next; // go to next link &#125; return current; // found it &#125;// ------------------------------------------------------------- public Link delete(int key) // delete link with given key &#123; // (assumes non-empty list) Link current = first; // search for link Link previous = first; while(current.iData != key) &#123; if(current.next == null) return null; // didn't find it else &#123; previous = current; // go to next link current = current.next; &#125; &#125; // found it if(current == first) // if first link, first = first.next; // change first else // otherwise, previous.next = current.next; // bypass it return current; &#125;// ------------------------------------------------------------- public void displayList() // display the list &#123; System.out.print("List (first--&gt;last): "); Link current = first; // start at beginning of list while(current != null) // until end of list, &#123; current.displayLink(); // print data current = current.next; // move to next link &#125; System.out.println(""); &#125;// ------------------------------------------------------------- &#125; // end class LinkList////////////////////////////////////////////////////////////////class LinkList2App &#123; public static void main(String[] args) &#123; LinkList theList = new LinkList(); // make list theList.insertFirst(22, 2.99); // insert 4 items theList.insertFirst(44, 4.99); theList.insertFirst(66, 6.99); theList.insertFirst(88, 8.99); theList.displayList(); // display list Link f = theList.find(44); // find item if( f != null) System.out.println("Found link with key " + f.iData); else System.out.println("Can't find link"); Link d = theList.delete(66); // delete item if( d != null ) System.out.println("Deleted link with key " + d.iData); else System.out.println("Can't delete link"); theList.displayList(); // display list &#125; // end main() &#125; // end class LinkList2App//////////////////////////////////////////////////////////////// 7.2 有序链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// sortedList.java// demonstrates sorted list// to run this program: C&gt;java SortedListApp////////////////////////////////////////////////////////////////class Link &#123; public long dData; // data item public Link next; // next link in list// ------------------------------------------------------------- public Link(long dd) // constructor &#123; dData = dd; &#125;// ------------------------------------------------------------- public void displayLink() // display this link &#123; System.out.print(dData + " "); &#125; &#125; // end class Link////////////////////////////////////////////////////////////////class SortedList &#123; private Link first; // ref to first item// ------------------------------------------------------------- public SortedList() // constructor &#123; first = null; &#125;// ------------------------------------------------------------- public boolean isEmpty() // true if no links &#123; return (first==null); &#125;// ------------------------------------------------------------- public void insert(long key) // insert, in order &#123; Link newLink = new Link(key); // make new link Link previous = null; // start at first Link current = first; // until end of list, while(current != null &amp;&amp; key &gt; current.dData) &#123; // or key &gt; current, previous = current; current = current.next; // go to next item &#125; if(previous==null) // at beginning of list first = newLink; // first --&gt; newLink else // not at beginning previous.next = newLink; // old prev --&gt; newLink newLink.next = current; // newLink --&gt; old currnt &#125; // end insert()// ------------------------------------------------------------- public Link remove() // return &amp; delete first link &#123; // (assumes non-empty list) Link temp = first; // save first first = first.next; // delete first return temp; // return value &#125;// ------------------------------------------------------------- public void displayList() &#123; System.out.print("List (first--&gt;last): "); Link current = first; // start at beginning of list while(current != null) // until end of list, &#123; current.displayLink(); // print data current = current.next; // move to next link &#125; System.out.println(""); &#125; &#125; // end class SortedList////////////////////////////////////////////////////////////////class SortedListApp &#123; public static void main(String[] args) &#123; // create new list SortedList theSortedList = new SortedList(); theSortedList.insert(20); // insert 2 items theSortedList.insert(40); theSortedList.displayList(); // display list theSortedList.insert(10); // insert 3 more items theSortedList.insert(30); theSortedList.insert(50); theSortedList.displayList(); // display list theSortedList.remove(); // remove an item theSortedList.displayList(); // display list &#125; // end main() &#125; // end class SortedListApp//////////////////////////////////////////////////////////////// 7.3 双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186// doublyLinked.java// demonstrates doubly-linked list// to run this program: C&gt;java DoublyLinkedApp////////////////////////////////////////////////////////////////class Link &#123; public long dData; // data item public Link next; // next link in list public Link previous; // previous link in list// ------------------------------------------------------------- public Link(long d) // constructor &#123; dData = d; &#125;// ------------------------------------------------------------- public void displayLink() // display this link &#123; System.out.print(dData + " "); &#125;// ------------------------------------------------------------- &#125; // end class Link////////////////////////////////////////////////////////////////class DoublyLinkedList &#123; private Link first; // ref to first item private Link last; // ref to last item// ------------------------------------------------------------- public DoublyLinkedList() // constructor &#123; first = null; // no items on list yet last = null; &#125;// ------------------------------------------------------------- public boolean isEmpty() // true if no links &#123; return first==null; &#125;// ------------------------------------------------------------- public void insertFirst(long dd) // insert at front of list &#123; Link newLink = new Link(dd); // make new link if( isEmpty() ) // if empty list, last = newLink; // newLink &lt;-- last else first.previous = newLink; // newLink &lt;-- old first newLink.next = first; // newLink --&gt; old first first = newLink; // first --&gt; newLink &#125;// ------------------------------------------------------------- public void insertLast(long dd) // insert at end of list &#123; Link newLink = new Link(dd); // make new link if( isEmpty() ) // if empty list, first = newLink; // first --&gt; newLink else &#123; last.next = newLink; // old last --&gt; newLink newLink.previous = last; // old last &lt;-- newLink &#125; last = newLink; // newLink &lt;-- last &#125;// ------------------------------------------------------------- public Link deleteFirst() // delete first link &#123; // (assumes non-empty list) Link temp = first; if(first.next == null) // if only one item last = null; // null &lt;-- last else first.next.previous = null; // null &lt;-- old next first = first.next; // first --&gt; old next return temp; &#125;// ------------------------------------------------------------- public Link deleteLast() // delete last link &#123; // (assumes non-empty list) Link temp = last; if(first.next == null) // if only one item first = null; // first --&gt; null else last.previous.next = null; // old previous --&gt; null last = last.previous; // old previous &lt;-- last return temp; &#125;// ------------------------------------------------------------- // insert dd just after key public boolean insertAfter(long key, long dd) &#123; // (assumes non-empty list) Link current = first; // start at beginning while(current.dData != key) // until match is found, &#123; current = current.next; // move to next link if(current == null) return false; // didn't find it &#125; Link newLink = new Link(dd); // make new link if(current==last) // if last link, &#123; newLink.next = null; // newLink --&gt; null last = newLink; // newLink &lt;-- last &#125; else // not last link, &#123; newLink.next = current.next; // newLink --&gt; old next // newLink &lt;-- old next current.next.previous = newLink; &#125; newLink.previous = current; // old current &lt;-- newLink current.next = newLink; // old current --&gt; newLink return true; // found it, did insertion &#125;// ------------------------------------------------------------- public Link deleteKey(long key) // delete item w/ given key &#123; // (assumes non-empty list) Link current = first; // start at beginning while(current.dData != key) // until match is found, &#123; current = current.next; // move to next link if(current == null) return null; // didn't find it &#125; if(current==first) // found it; first item? first = current.next; // first --&gt; old next else // not first // old previous --&gt; old next current.previous.next = current.next; if(current==last) // last item? last = current.previous; // old previous &lt;-- last else // not last // old previous &lt;-- old next current.next.previous = current.previous; return current; // return value &#125;// ------------------------------------------------------------- public void displayForward() &#123; System.out.print("List (first--&gt;last): "); Link current = first; // start at beginning while(current != null) // until end of list, &#123; current.displayLink(); // display data current = current.next; // move to next link &#125; System.out.println(""); &#125;// ------------------------------------------------------------- public void displayBackward() &#123; System.out.print("List (last--&gt;first): "); Link current = last; // start at end while(current != null) // until start of list, &#123; current.displayLink(); // display data current = current.previous; // move to previous link &#125; System.out.println(""); &#125;// ------------------------------------------------------------- &#125; // end class DoublyLinkedList////////////////////////////////////////////////////////////////class DoublyLinkedApp &#123; public static void main(String[] args) &#123; // make a new list DoublyLinkedList theList = new DoublyLinkedList(); theList.insertFirst(22); // insert at front theList.insertFirst(44); theList.insertFirst(66); theList.insertLast(11); // insert at rear theList.insertLast(33); theList.insertLast(55); theList.displayForward(); // display list forward theList.displayBackward(); // display list backward theList.deleteFirst(); // delete first item theList.deleteLast(); // delete last item theList.deleteKey(11); // delete item with key 11 theList.displayForward(); // display list forward theList.insertAfter(22, 77); // insert 77 after 22 theList.insertAfter(33, 88); // insert 88 after 33 theList.displayForward(); // display list forward &#125; // end main() &#125; // end class DoublyLinkedApp////////////////////////////////////////////////////////////////]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数组和链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2017%2F05%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1. 队列的介绍队列 (Queue)是另一种限定性的线性表，它只允许在表的一端插入元素，而在另一端删除元素，所以队列具有先进先出(Fist In Fist Out， 缩写为FIFO)的特性。在队列中，允许插入的一端叫做队尾(rear)，允许删除的一端则称为队头(front)。 在队列中插入一个新元素的操作简称为进队或入队，新元素进队后就成为新的队尾元素；从队列中删除一个元素的操作简称为出队或离队，当元素出队后，其后继元素就成为新的队头元素 假设队列为q=(a1，a2，…，an)，那么a1就是队头元素，an则是队尾元素。队列中的元素是按照a1，a2，…，an的顺序进入的， 退出队列也必须按照同样的次序依次出队，也就是说，只有在a1，a2，…，an-1都离开队列之后，an才能退出队列。 队列（Queue），是一种线性存储结构。它有以下几个特点： 队列中数据是按照”先进先出（FIFO, First-In-First-Out）”方式进出队列的。 队列只允许在”队首”进行删除操作，而在”队尾”进行插入操作。 队列通常包括的两种操作：入队列 和 出队列。 1.1 队列的示意图 队列中有10，20，30共3个数据。 1.2 出队列 出队列前：队首是10，队尾是30。出队列后：出队列(队首)之后。队首是20，队尾是30。 1.3 入队列 入队列前：队首是20，队尾是30。入队列后：40入队列(队尾)之后。队首是20，队尾是40。 2. 队列的顺序存储结构队列的顺序存储结构称为顺序队列。顺序队列可以利用一个一维数组和两个指针来实现。一维数组用来存储当前队列中的所有元素，两个指针front和rear分别指向当前队列的队首元素和队尾元素，分别称为队首指针和队尾指针。 3. 队列的链接存储结构队列的链接存储结构是用一个单链表存放队列元素的。队列的链接存储结构称为链队列。由于队列只允许在表尾进行插入操作、在表头进行删除操作，因此，链队需设置两个指针：队头指针front和队尾指针rear，分别指向单链表的第一个结点(表的头结点)和最后一个结点(队尾结点)。 4. 队列的Java实现JDK包Queue中的也提供了”队列”的实现。JDK中的Queue接口就是”队列”，它的实现类也都是队列，用的最多的是LinkedList 4.1 队列的数组实现数组实现的队列，能存储任意类型的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Java : 数组实现“队列”，只能存储int数据 */public class ArrayQueue &#123; private int[] mArray; private int mCount; public ArrayQueue(int sz) &#123; mArray = new int[sz]; mCount = 0; &#125; // 将val添加到队列的末尾 public void add(int val) &#123; mArray[mCount++] = val; &#125; // 返回“队列开头元素” public int front() &#123; return mArray[0]; &#125; // 返回“栈顶元素值”，并删除“栈顶元素” public int pop() &#123; int ret = mArray[0]; mCount--; for (int i=1; i&lt;=mCount; i++) mArray[i-1] = mArray[i]; return ret; &#125; // 返回“栈”的大小 public int size() &#123; return mCount; &#125; // 返回“栈”是否为空 public boolean isEmpty() &#123; return size()==0; &#125; public static void main(String[] args) &#123; int tmp=0; ArrayQueue astack = new ArrayQueue(12); // 将10, 20, 30 依次推入栈中 astack.add(10); astack.add(20); astack.add(30); // 将“栈顶元素”赋值给tmp，并删除“栈顶元素” tmp = astack.pop(); System.out.printf("tmp=%d\n", tmp); // 只将“栈顶”赋值给tmp，不删除该元素. tmp = astack.front(); System.out.printf("tmp=%d\n", tmp); astack.add(40); System.out.printf("isEmpty()=%b\n", astack.isEmpty()); System.out.printf("size()=%d\n", astack.size()); while (!astack.isEmpty()) &#123; System.out.printf("size()=%d\n", astack.pop()); &#125; &#125;&#125; 运行结果 1234567tmp=10tmp=20isEmpty()=falsesize()=3size()=20size()=30size()=40 结果说明：ArrayQueue是通过数组实现的队列，而且ArrayQueue中使用到了泛型，因此它支持任意类型的数据。 4.2 队列的LinkedList实现Java的 Collection集合 中自带的”队列”(LinkedList)的示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.Stack;/** * 用“栈”实现队列 */public class StackList&lt;T&gt; &#123; // 向队列添加数据时：(01) 将“已有的全部数据”都移到mIn中。 (02) 将“新添加的数据”添加到mIn中。 private Stack&lt;T&gt; mIn = null; // 从队列获取元素时：(01) 将“已有的全部数据”都移到mOut中。(02) 返回并删除mOut栈顶元素。 private Stack&lt;T&gt; mOut = null; // 统计计数 private int mCount = 0; public StackList() &#123; mIn = new Stack&lt;T&gt;(); mOut = new Stack&lt;T&gt;(); mCount = 0; &#125; private void add(T t) &#123; // 将“已有的全部数据”都移到mIn中 while (!mOut.empty()) mIn.push(mOut.pop()); // 将“新添加的数据”添加到mIn中 mIn.push(t); // 统计数+1 mCount++; &#125; private T get() &#123; // 将“已有的全部数据”都移到mOut中 while (!mIn.empty()) mOut.push(mIn.pop()); // 统计数-1 mCount--; // 返回并删除mOut栈顶元素 return mOut.pop(); &#125; private int size() &#123; return mCount; &#125; private boolean isEmpty() &#123; return mCount==0; &#125; public static void main(String[] args) &#123; StackList slist = new StackList(); // 将10, 20, 30 依次推入栈中 slist.add(10); slist.add(20); slist.add(30); System.out.printf("isEmpty()=%b\n", slist.isEmpty()); System.out.printf("size()=%d\n", slist.size()); while(!slist.isEmpty()) &#123; System.out.printf("%d\n", slist.get()); &#125; &#125;&#125; 运行结果 1234567tmp=10tmp=20isEmpty()=falsesize()=3tmp=20tmp=30tmp=40 4.3 队列的数组实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// Queue.java// demonstrates queue// to run this program: C&gt;java QueueApp////////////////////////////////////////////////////////////////class Queue &#123; private int maxSize; private long[] queArray; private int front; private int rear; private int nItems;//-------------------------------------------------------------- public Queue(int s) // constructor &#123; maxSize = s; queArray = new long[maxSize]; front = 0; rear = -1; nItems = 0; &#125;//-------------------------------------------------------------- public void insert(long j) // put item at rear of queue &#123; if(rear == maxSize-1) // deal with wraparound rear = -1; queArray[++rear] = j; // increment rear and insert nItems++; // one more item &#125;//-------------------------------------------------------------- public long remove() // take item from front of queue &#123; long temp = queArray[front++]; // get value and incr front if(front == maxSize) // deal with wraparound front = 0; nItems--; // one less item return temp; &#125;//-------------------------------------------------------------- public long peekFront() // peek at front of queue &#123; return queArray[front]; &#125;//-------------------------------------------------------------- public boolean isEmpty() // true if queue is empty &#123; return (nItems==0); &#125;//-------------------------------------------------------------- public boolean isFull() // true if queue is full &#123; return (nItems==maxSize); &#125;//-------------------------------------------------------------- public int size() // number of items in queue &#123; return nItems; &#125;//-------------------------------------------------------------- &#125; // end class Queue////////////////////////////////////////////////////////////////class QueueApp &#123; public static void main(String[] args) &#123; Queue theQueue = new Queue(5); // queue holds 5 items theQueue.insert(10); // insert 4 items theQueue.insert(20); theQueue.insert(30); theQueue.insert(40); theQueue.remove(); // remove 3 items theQueue.remove(); // (10, 20, 30) theQueue.remove(); theQueue.insert(50); // insert 4 more items theQueue.insert(60); // (wraps around) theQueue.insert(70); theQueue.insert(80); while( !theQueue.isEmpty() ) // remove and display &#123; // all items long n = theQueue.remove(); // (40, 50, 60, 70, 80) System.out.print(n); System.out.print(" "); &#125; System.out.println(""); &#125; // end main() &#125; // end class QueueApp//////////////////////////////////////////////////////////////// 4.4 队列的链表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// linkQueue.java// demonstrates queue implemented as double-ended list// to run this program: C&gt;java LinkQueueApp////////////////////////////////////////////////////////////////class Link &#123; public long dData; // data item public Link next; // next link in list// ------------------------------------------------------------- public Link(long d) // constructor &#123; dData = d; &#125;// ------------------------------------------------------------- public void displayLink() // display this link &#123; System.out.print(dData + " "); &#125;// ------------------------------------------------------------- &#125; // end class Link////////////////////////////////////////////////////////////////class FirstLastList &#123; private Link first; // ref to first item private Link last; // ref to last item// ------------------------------------------------------------- public FirstLastList() // constructor &#123; first = null; // no items on list yet last = null; &#125;// ------------------------------------------------------------- public boolean isEmpty() // true if no links &#123; return first==null; &#125;// ------------------------------------------------------------- public void insertLast(long dd) // insert at end of list &#123; Link newLink = new Link(dd); // make new link if( isEmpty() ) // if empty list, first = newLink; // first --&gt; newLink else last.next = newLink; // old last --&gt; newLink last = newLink; // newLink &lt;-- last &#125;// ------------------------------------------------------------- public long deleteFirst() // delete first link &#123; // (assumes non-empty list) long temp = first.dData; if(first.next == null) // if only one item last = null; // null &lt;-- last first = first.next; // first --&gt; old next return temp; &#125;// ------------------------------------------------------------- public void displayList() &#123; Link current = first; // start at beginning while(current != null) // until end of list, &#123; current.displayLink(); // print data current = current.next; // move to next link &#125; System.out.println(""); &#125;// ------------------------------------------------------------- &#125; // end class FirstLastList////////////////////////////////////////////////////////////////class LinkQueue &#123; private FirstLastList theList;//-------------------------------------------------------------- public LinkQueue() // constructor &#123; theList = new FirstLastList(); &#125; // make a 2-ended list//-------------------------------------------------------------- public boolean isEmpty() // true if queue is empty &#123; return theList.isEmpty(); &#125;//-------------------------------------------------------------- public void insert(long j) // insert, rear of queue &#123; theList.insertLast(j); &#125;//-------------------------------------------------------------- public long remove() // remove, front of queue &#123; return theList.deleteFirst(); &#125;//-------------------------------------------------------------- public void displayQueue() &#123; System.out.print("Queue (front--&gt;rear): "); theList.displayList(); &#125;//-------------------------------------------------------------- &#125; // end class LinkQueue////////////////////////////////////////////////////////////////class LinkQueueApp &#123; public static void main(String[] args) &#123; LinkQueue theQueue = new LinkQueue(); theQueue.insert(20); // insert items theQueue.insert(40); theQueue.displayQueue(); // display queue theQueue.insert(60); // insert items theQueue.insert(80); theQueue.displayQueue(); // display queue theQueue.remove(); // remove items theQueue.remove(); theQueue.displayQueue(); // display queue &#125; // end main() &#125; // end class LinkQueueApp//////////////////////////////////////////////////////////////// 4.5 优先级队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// priorityQ.java// demonstrates priority queue// to run this program: C&gt;java PriorityQApp////////////////////////////////////////////////////////////////class PriorityQ &#123; // array in sorted order, from max at 0 to min at size-1 private int maxSize; private long[] queArray; private int nItems;//------------------------------------------------------------- public PriorityQ(int s) // constructor &#123; maxSize = s; queArray = new long[maxSize]; nItems = 0; &#125;//------------------------------------------------------------- public void insert(long item) // insert item &#123; int j; if(nItems==0) // if no items, queArray[nItems++] = item; // insert at 0 else // if items, &#123; for(j=nItems-1; j&gt;=0; j--) // start at end, &#123; if( item &gt; queArray[j] ) // if new item larger, queArray[j+1] = queArray[j]; // shift upward else // if smaller, break; // done shifting &#125; // end for queArray[j+1] = item; // insert it nItems++; &#125; // end else (nItems &gt; 0) &#125; // end insert()//------------------------------------------------------------- public long remove() // remove minimum item &#123; return queArray[--nItems]; &#125;//------------------------------------------------------------- public long peekMin() // peek at minimum item &#123; return queArray[nItems-1]; &#125;//------------------------------------------------------------- public boolean isEmpty() // true if queue is empty &#123; return (nItems==0); &#125;//------------------------------------------------------------- public boolean isFull() // true if queue is full &#123; return (nItems == maxSize); &#125;//------------------------------------------------------------- &#125; // end class PriorityQ////////////////////////////////////////////////////////////////class PriorityQApp &#123; public static void main(String[] args) &#123; PriorityQ thePQ = new PriorityQ(5); thePQ.insert(30); thePQ.insert(50); thePQ.insert(10); thePQ.insert(40); thePQ.insert(20); while( !thePQ.isEmpty() ) &#123; long item = thePQ.remove(); System.out.print(item + " "); // 10, 20, 30, 40, 50 &#125; // end while System.out.println(""); &#125; // end main()//------------------------------------------------------------- &#125; // end class PriorityQApp//////////////////////////////////////////////////////////////// 4.6 队列的应用6个人围成圈数数，数到3的人退出，问最后退出的人是谁？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyQueue&#123; private Object datas[]; private int pushIndex;//入队的下标 private int popIndex; //出队的下标 private int counts;//记录数据的个数 public MyQueue(int size)&#123; datas = new Object[size]; &#125; public MyQueue()&#123; this(10); &#125; public boolean isEmpty()&#123; return counts == 0; &#125; public String toString()&#123; StringBuilder mess = new StringBuilder(); for (int i = popIndex; i &lt;= counts; i++) &#123; mess.append(datas[i % datas.length] + ","); &#125; return mess + ""; &#125; public boolean isFull()&#123; return counts == datas.length; &#125; /** * 入队列 * @param data */ public void push(Object data) &#123; if (isFull()) &#123; return; &#125; datas[pushIndex++ % datas.length] = data; counts++; &#125; public Object popup()&#123; Object data = datas[popIndex++ % datas.length]; counts--; return data; &#125;&#125; 123456789101112131415161718192021222324public class TestApp&#123; public static void main(String[] args) &#123; //初始化队列 MyQueue queue = new MyQueue(6); //六个人入队 for (int i = 0;i &lt; 6; i++) &#123; queue.push(i + 1); &#125; //数数 int counts = 0;//计数器 while (!queue.isEmpty()) &#123; Object d = queue.popup(); counts++; //判断 if (counts % 3 == 0) &#123; System.out.println(d); &#125; else &#123; queue.push(d);//再放进队列 &#125; &#125; &#125;&#125; 4.7 循环队列 原文出处：http://www.cnblogs.com/skywang12345/p/3562279.html]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2017%2F05%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 冒泡排序冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。 它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！ 相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处 1234567891011121314151617181920212223/* * 冒泡排序基本概念是： * 依次比较相邻的两个数，将小数放在前面，大数放在后面。 * 即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。 * 然后比较第2个数和第3个数，将小数放前，大数放后，如此继续， * 直至比较最后两个数，将小数放前，大数放后。至此第一趟结束， * 将最大的数放到了最后。在第二趟：仍从第一对数开始比较 * （因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数）， * 将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的）， * 第二趟结束，在倒数第二的位置上得到一个新的最大数 * （其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。 */public void bubbleSort(int[] arr)&#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = 0; j &lt; arr.length-1-i; j++) &#123; if (array[j] &gt; array[j+1])&#123; int temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125;&#125; 下面以数列{20,40,30,10,60,50}为例，演示它的冒泡排序过程 我们先分析第1趟排序当i=5,j=0时，a[0]a[2]。此时，交换a[1]和a[2]的值；交换之后，a[1]=30，a[2]=40。当i=5,j=2时，a[2]&gt;a[3]。此时，交换a[2]和a[3]的值；交换之后，a[2]=10，a[3]=40。当i=5,j=3时，a[3]a[5]。此时，交换a[4]和a[5]的值；交换之后，a[4]=50，a[3]=60。 于是，第1趟排序完之后，数列{20,40,30,10,60,50}变成了{20,30,10,40,50,60}。此时，数列末尾的值最大。 根据这种方法：第2趟排序完之后，数列中a[5…6]是有序的。第3趟排序完之后，数列中a[4…6]是有序的。第4趟排序完之后，数列中a[3…6]是有序的。第5趟排序完之后，数列中a[1…6]是有序的。 第5趟排序之后，整个数列也就是有序的了 1.1 冒泡排序的时间复杂度和稳定性1.1.1 冒泡排序时间复杂度冒泡排序的时间复杂度是O(N2)。假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次！因此，冒泡排序的时间复杂度是O(N2)。 1.1.2 冒泡排序稳定性冒泡排序是稳定的算法，它满足稳定算法的定义。算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class BubbleSort &#123; /* * 冒泡排序 * * 参数说明： * a -- 待排序的数组 * n -- 数组的长度 */ public static void bubbleSort1(int[] a, int n) &#123; int i,j; for (i=n-1; i&gt;0; i--) &#123; // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) &#123; if (a[j] &gt; a[j+1]) &#123; // 交换a[j]和a[j+1] int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; &#125; &#125; &#125; &#125; /* * 冒泡排序(改进版) * * 参数说明： * a -- 待排序的数组 * n -- 数组的长度 */ public static void bubbleSort2(int[] a, int n) &#123; int i,j; int flag; // 标记 for (i=n-1; i&gt;0; i--) &#123; flag = 0; // 初始化标记为0 // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) &#123; if (a[j] &gt; a[j+1]) &#123; // 交换a[j]和a[j+1] int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; flag = 1; // 若发生交换，则设标记为1 &#125; &#125; if (flag==0) break; // 若没发生交换，则说明数列已有序。 &#125; &#125; public static void main(String[] args) &#123; int i; int[] a = &#123;20,40,30,10,60,50&#125;; System.out.printf("before sort:"); for (i=0; i&lt;a.length; i++) System.out.printf("%d ", a[i]); System.out.printf("\n"); bubbleSort1(a, a.length); //bubbleSort2(a, a.length); System.out.printf("after sort:"); for (i=0; i&lt;a.length; i++) System.out.printf("%d ", a[i]); System.out.printf("\n"); &#125;&#125; 2. 选择排序从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处 1234567891011121314151617/* * 选择排序基本思路： * 把第一个元素依次和后面的所有元素进行比较。 * 第一次结束后，就会有最小值出现在最前面。 * 依次类推 */public void selectSort(int[] arr)&#123; for (int i = 0; i &lt; arr.length-1; i++) &#123; for (int j = i+1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[i])&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125;&#125; 3. 插入排序排序思想：第二个数据依次往前比较，如果发现比自己大，该数据往后瞬移，否则该数据插入找到数据的后面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/* * 插入排序基本思想 * 将n个元素的数列分为已有序和无序两个部分，如插入排序过程示例下所示： * &#123;&#123;a1&#125;，&#123;a2，a3，a4，…，an&#125;&#125; * &#123;&#123;a1⑴，a2⑴&#125;，&#123;a3⑴，a4⑴ …，an⑴&#125;&#125; * &#123;&#123;a1(n-1），a2(n-1) ，…&#125;,&#123;an(n-1)&#125;&#125; * 每次处理就是将无序数列的第一个元素与有序数列的元素从后往前逐个进行比较， * 找出插入位置，将该元素插入到有序数列的合适位置中。 */public class AlogrithmApp&#123; /** * @param number * @return 1 到nubmer的和 */ public static int sum(int number) &#123; if (number &lt; 1) &#123; throw new RuntimeException("number must &gt; 0"); &#125; if (number == 1) &#123; return 1; &#125; else &#123; return number + sum(number - 1); &#125; &#125; private static int counts = 0; public static void moveNumber(int panNum, char a, char b, char c) &#123; counts++; if (panNum != 1) &#123; moveNumber(panNum - 1, a, c, b); moveNumber(panNum - 1, b, a, c); &#125; &#125; public static void move(int panNum, char a, char b, char c) &#123; if (panNum == 1) &#123; System.out.println("盘：" + panNum + " 从 " + a + " 柱移动 " + c + " 柱"); &#125; else &#123; move(panNum - 1, a, c, b); System.out.println("盘：" + panNum + " 从 " + a + " 柱移动 " + c + " 柱"); move(panNum - 1, b, a, c); &#125; &#125; /** * @param args */ public static void main(String[] args) &#123; /*moveNumber(30, 'a', 'b', 'c'); System.out.println(counts);*/ int datas[] = new int[100000]; //初始化数据 initData(datas); //打印数据 //printData(datas); //插入排序 quickSort(datas, 0, datas.length-1); System.out.println(System.currentTimeMillis()); insertSort(datas); //排序后打印 //printData(datas); System.out.println(System.currentTimeMillis()); &#125; public static void selectSort(int[] datas) &#123; for (int i = 0; i &lt; datas.length - 1; i++) &#123; int minIndex = i;// 最小数据的下标 for (int j = i + 1; j &lt; datas.length; j++) &#123; if (datas[minIndex] &gt; datas[j]) &#123; minIndex = j; &#125; &#125; int temp = datas[i]; datas[i] = datas[minIndex]; datas[minIndex] = temp; &#125; &#125; /** * 初始化数据 * * @param datas */ public static void initData(int datas[]) &#123; for (int i = 0; i &lt; datas.length; i++) &#123; // 随机1到100的值 datas[i] = (int) (Math.random() * 100) + 1; &#125; &#125; /** * 打印数据 * * @param datas */ public static void printData(int datas[]) &#123; for (int i = 0; i &lt; datas.length; i++) &#123; System.out.print(datas[i] + ","); &#125; System.out.println(); &#125; public static void bubbleSort(int datas[]) &#123; int j = 0; // 冒泡的次数 int i = 0; // 每次冒泡的比较 for (j = datas.length - 1; j &gt; 0; j--) &#123; for (i = 0; i &lt; j; i++) &#123; if (datas[i] &gt; datas[i + 1]) &#123; int temp = datas[i]; datas[i] = datas[i + 1]; datas[i + 1] = temp; &#125; &#125; &#125; &#125; public static void insertSort(int datas[]) &#123; int j = 0; // 第二个数据开始插入的下标 int i = 0;// 插入的次数 for (i = 1; i &lt; datas.length; i++) &#123; int temp = datas[i]; for (j = i - 1; j &gt;= 0; j--) &#123; if (datas[j] &gt; temp) &#123; datas[j + 1] = datas[j]; &#125; else &#123; break; &#125; &#125; // 判断 j == -1 或者 就是第一个小于等于temp数据的位置 datas[j + 1] = temp; &#125; &#125; /** * 快速排序 * * @param datas */ public static void quickSort(int datas[], int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; else &#123; int middle = findMiddle(datas, start, end); quickSort(datas, start, middle - 1); quickSort(datas, middle + 1, end); &#125; &#125; private static int findMiddle(int datas[], int start, int end) &#123; int temp = datas[end];// 参照物 int left = start - 1; int right = end; while (true) &#123; // 1.从左边依次找数据，找到第一个比参照大的数据 while (++left &lt; end &amp;&amp; datas[left] &lt;= temp); if (left == end) &#123; //参照物是最大值 break; &#125; // 2.从右边依次找数据，找到第一个比参数小的数据 while (--right &gt;= start &amp;&amp; datas[right] &gt;= temp); // 3. 比较是否出现交叉（left 和 right） if (left &lt; right) &#123; // 4. 如果没有交叉，交换左右指针位置的数据 int d = datas[left]; datas[left] = datas[right]; datas[right] = d; &#125; else &#123; // 5. 如果出现交叉，交换左指针和参照物的值，结束 int d = datas[left]; datas[left] = datas[end]; datas[end] = d; break; &#125; &#125; return left; &#125;&#125; 4. 快速排序快速排序(Quick Sort)使用分治法策略。它的基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序流程： 从数列中挑出一个基准值。 将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。 递归地把”基准值前面的子数列”和”基准值后面的子数列”进行排序。 选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.itcast;/* * 快速排序： * 一趟快速排序的算法是： * 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； * 2）以第一个数组元素作为关键数据，赋值给key，即 key=A[0]； * 3）从j开始向前搜索，即由后开始向前搜索（j=j-1即j--）， * 找到第一个小于key的值A[j]，A[i]与A[j]交换； * 4）从i开始向后搜索，即由前开始向后搜索（i=i+1即i++）， * 找到第一个大于key的A[i]，A[i]与A[j]交换； * 5）重复第3、4、5步，直到 I=J； * (3,4步是在程序中没找到时候j=j-1，i=i+1，直至找到为止。 * 找到并交换的时候i， j指针位置不变。 * 另外当i=j这过程一定正好是i+或j-完成的最后令循环结束。） */public class QuickSort &#123; public static void sort(int[] data) &#123; quickSort(data, 0, data.length - 1); &#125; private static void quickSort(int[] data, int i, int j) &#123; int pivotIndex = (i + j) / 2; // swap SortTest.swap(data, pivotIndex, j); int k = partition(data, i - 1, j, data[j]); SortTest.swap(data, k, j); if ((k - i) &gt; 1) quickSort(data, i, k - 1); if ((j - k) &gt; 1) quickSort(data, k + 1, j); &#125; /** * @param data * @param i * @param j * @return */ private static int partition(int[] data, int l, int r, int pivot) &#123; do &#123; while (data[++l] &lt; pivot) ; while ((r != 0) &amp;&amp; data[--r] &gt; pivot) ; SortTest.swap(data, l, r); &#125; while (l &lt; r); SortTest.swap(data, l, r); return l; &#125;&#125; 12345678910111213141516171819202122232425262728293031/** * 快速排序 * * 参数说明： * a -- 待排序的数组 * l -- 数组的左边界(例如，从起始位置开始排序，则l=0) * r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1) */public static void quickSort(int[] a, int l, int r) &#123; if (l &lt; r) &#123; int i, j, x; i = l; j = r; x = a[i]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &gt; x) j--; // 从右向左找第一个小于x的数 if (i &lt; j) a[i++] = a[j]; while (i &lt; j &amp;&amp; a[i] &lt; x) i++; // 从左向右找第一个大于x的数 if (i &lt; j) a[j--] = a[i]; &#125; a[i] = x; quickSort(a, l, i - 1); /* 递归调用 */ quickSort(a, i + 1, r); /* 递归调用 */ &#125;&#125; 下面以数列a={30,40,60,10,20,50}为例，演示它的快速排序过程 上图只是给出了第1趟快速排序的流程。在第1趟中，设置x=a[i]，即x=30。(01) 从”右 –&gt; 左”查找小于x的数：找到满足条件的数a[j]=20，此时j=4；然后将a[j]赋值a[i]，此时i=0；接着从左往右遍历。(02) 从”左 –&gt; 右”查找大于x的数：找到满足条件的数a[i]=40，此时i=1；然后将a[i]赋值a[j]，此时j=4；接着从右往左遍历。(03) 从”右 –&gt; 左”查找小于x的数：找到满足条件的数a[j]=10，此时j=3；然后将a[j]赋值a[i]，此时i=1；接着从左往右遍历。(04) 从”左 –&gt; 右”查找大于x的数：找到满足条件的数a[i]=60，此时i=2；然后将a[i]赋值a[j]，此时j=3；接着从右往左遍历。(05) 从”右 –&gt; 左”查找小于x的数：没有找到满足条件的数。当i&gt;=j时，停止查找；然后将x赋值给a[i]。此趟遍历结束！ 按照同样的方法，对子数列进行递归遍历。最后得到有序数组！ 4.1 快速排序的时间复杂度和稳定性4.1.2 快速排序稳定性快速排序是不稳定的算法，它不满足稳定算法的定义。算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 4.1.3 快速排序时间复杂度快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。这句话很好理解：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？至少lg(N+1)次，最多N次。(01) 为什么最少是lg(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。(02) 为什么最多是N次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。 5. 堆排序 堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征， 使得在当前无序区中选取最大（或最小）关键字的记录变得简单 5.1 用大根堆排序的基本思想 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个 记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]， 且满足R[1..n-1].keys≤R[n].key 由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。 然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换， 由此得到新的无序区R[1..n-2]和有序区R[n-1..n]， 且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。 直到无序区只有一个元素为止。 5.2 大根堆排序算法的基本操作 初始化操作：将R[1..n]构造为初始堆 每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换， 然后将新的无序区调整为堆（亦称重建堆） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package cn.itcast;public class HeapSort &#123; public static void sort(int[] data) &#123; MaxHeap h = new MaxHeap(); h.init(data); for (int i = 0; i &lt; data.length; i++) h.remove(); System.arraycopy(h.queue, 1, data, 0, data.length); &#125; private static class MaxHeap &#123; void init(int[] data) &#123; this.queue = new int[data.length + 1]; for (int i = 0; i &lt; data.length; i++) &#123; queue[++size] = data[i]; fixUp(size); &#125; &#125; private int size = 0; private int[] queue; public int get() &#123; return queue[1]; &#125; public void remove() &#123; SortTest.swap(queue, 1, size--); fixDown(1); &#125; // fixdown private void fixDown(int k) &#123; int j; while ((j = k &lt;&lt; 1) &lt;= size) &#123; if (j &lt; size &amp;&amp; queue[j] &lt; queue[j + 1]) j++; if (queue[k] &gt; queue[j]) // 不用交换 break; SortTest.swap(queue, j, k); k = j; &#125; &#125; private void fixUp(int k) &#123; while (k &gt; 1) &#123; int j = k &gt;&gt; 1; if (queue[j] &gt; queue[k]) break; SortTest.swap(queue, j, k); k = j; &#125; &#125; &#125;&#125; 6. 归并排序1234567891011121314151617181920212223242526272829303132333435363738394041package cn.itcast;/* * 归并操作(merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。 * 如设有数列&#123;6，202，100，301，38，8，1&#125; * 初始状态： [6] [202] [100] [301] [38] [8] [1] 比较次数 * i=1 [6 202 ] [ 100 301] [ 8 38] [ 1 ] 3 * i=2 [ 6 100 202 301 ] [ 1 8 38 ] 4 * i=3 [ 1 6 8 38 100 202 301 ] 4 */public class MergeSort &#123; public static void sort(int[] data) &#123; int[] temp = new int[data.length]; mergeSort(data, temp, 0, data.length - 1); &#125; private static void mergeSort(int[] data, int[] temp, int l, int r) &#123; int mid = (l + r) / 2; if (l == r) return; mergeSort(data, temp, l, mid); mergeSort(data, temp, mid + 1, r); for (int i = l; i &lt;= r; i++) &#123; temp[i] = data[i]; &#125; int i1 = l; int i2 = mid + 1; for (int cur = l; cur &lt;= r; cur++) &#123; if (i1 == mid + 1) data[cur] = temp[i2++]; else if (i2 &gt; r) data[cur] = temp[i1++]; else if (temp[i1] &lt; temp[i2]) data[cur] = temp[i1++]; else data[cur] = temp[i2++]; &#125; &#125;&#125; 7. 希尔排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.itcast;/* * 希尔排序：先取一个小于n的整数d1作为第一个增量， * 把文件的全部记录分成（n除以d1）个组。所有距离为d1的倍数的记录放在同一个组中。 * 先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序， * 直至所取的增量dt=1(dt&lt;dt-l&lt;…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。 */public class ShellSort &#123; public static void sort(int[] data) &#123; for (int i = data.length / 2; i &gt; 2; i /= 2) &#123; for (int j = 0; j &lt; i; j++) &#123; insertSort(data, j, i); &#125; &#125; insertSort(data, 0, 1); &#125; /** * @param data * @param j * @param i */ private static void insertSort(int[] data, int start, int inc) &#123; for (int i = start + inc; i &lt; data.length; i += inc) &#123; for (int j = i; (j &gt;= inc) &amp;&amp; (data[j] &lt; data[j - inc]); j -= inc) &#123; SortTest.swap(data, j, j - inc); &#125; &#125; &#125;&#125;/* * 属于插入类排序,是将整个无序列分割成若干小的子序列分别进行插入排序 * 排序过程：先取一个正整数d1&lt;n，把所有序号相隔d1的数组元素放一组， * 组内进行直接插入排序；然后取d2&lt;d1，重复上述分组和排序操作；直至di=1， 即所有记录放进一个组中排序为止 * 初始：d=5 49 38 65 97 76 13 27 49 55 04 * 49 13 |-------------------| * 38 27 |-------------------| * 65 49 |-------------------| * 97 55 |-------------------| * 76 04 |-------------------| * 一趟结果 13 27 49 55 04 49 38 65 97 76 * d=3 13 27 49 55 04 49 38 65 97 76 * 13 55 38 76 |------------|------------|------------| * 27 04 65 |------------|------------| * 49 49 97 |------------|------------| * 二趟结果 13 04 49* 38 27 49 55 65 97 76 * d=1 13 04 49 38 27 49 55 65 97 76 * |----|----|----|----|----|----|----|----|----| 三趟结果 * 04 13 27 38 49 49 55 65 76 97 */ 12345678910111213141516171819202122232425262728package cn.itcast;import java.util.Arrays;public class SortTest &#123; public static void main(String[] args) &#123; int[] arr = &#123; 2, 5, 3, 1, 4 &#125;; System.out.println("排序前：" + Arrays.toString(arr)); // InsertSort.sort(arr); // BubbleSort.sort(arr); // SelectionSort.sort(arr); // ShellSort.sort(arr); // QuickSort.sort(arr); // MergeSort.sort(arr); // HeapSort.sort(arr); System.out.println("排序后：" + Arrays.toString(arr)); &#125; /* * 交换数组中的两个元素 */ public static void swap(int[] data, int i, int j) &#123; int temp = data[i]; data[i] = data[j]; data[j] = temp; &#125;&#125; 7. 面试中的排序算法总结]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android安全加密：消息摘要Message Digest]]></title>
    <url>%2F2017%2F05%2F01%2F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%2FAndroid%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%EF%BC%9A%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81MessageDigest%2F</url>
    <content type="text"><![CDATA[Android安全加密专题文章索引 Android安全加密：对称加密 Android安全加密：非对称加密 Android安全加密：消息摘要Message Digest Android安全加密：数字签名和数字证书 Android安全加密：Https编程 1. 常见算法MD5、SHA、CRC 等 2. 使用场景 对用户密码进行md5 加密后保存到数据库里 软件下载站使用消息摘要计算文件指纹，防止被篡改 数字签名（后面知识点） 百度云，360网盘等云盘的妙传功能用的就是sha1值 Eclipse和Android Studio开发工具根据sha1值来判断v4，v7包是否冲突 据说银行的密码使用的就是MD5加密（因为MD5具有不可逆性） 病毒查杀，把每个病毒文件或apk进行MD5后得到一个特征码，拿着特征码去跟病毒数据库对比，特征码一致说明该文件是病毒 Git版本控制也使用到了sha1 例如软件下载站数据指纹：http://dev.mysql.com/downloads/installer/ Git计算校验Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。SHA-1 哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 3. 使用步骤12345678//常用算法：MD5、SHA、CRCMessageDigest digest = MessageDigest.getInstance("MD5");byte[] result = digest.digest(content.getBytes());//消息摘要的结果一般都是转换成16 进制字符串形式展示String hex = Hex.encode(result);//MD5 结果为16 字节（128 个比特位）、转换为16 进制表示后长度是32 个字符//SHA 结果为20 字节（160 个比特位）、转换为16 进制表示后长度是40 个字符System.out.println(hex); 消息摘要后的结果是固定长度，无论你的数据有多大，哪怕是只有一个字节或者是一个G 的文件，摘要后的结果都是固定长度。 经常听到有人问这样的问题，MD5 摘要后结果到底是多少位？有的人说是16 位，有的说是128 位，有的说是32 位。到底是多长，这个时候我们就要明白，16 位指的是字节位数，128 位指的是比特位，32 位指的结果转换成16 进制展示的字符位数。 4. 数字摘要原理 用每个byte去和11111111（0xff）做与运算并且得到的是int类型的值 byte &amp; 11111111 把int 类型转成 16进制并返回String类型 不满八个二进制位就补全 12345678910111213//获取实例MessageDigest digest = MessageDigest.getInstance("MD5");digest.update(key.getBytes());byte[] bytes = digest.digest(key.getBytes());StringBuilder sb = new StringBuilder();for (int i = 0; i &lt; bytes.length; i++) &#123; String hex = Integer.toHexString(bytes[i]&amp;0xff); if (hex.length() == 1)&#123; sb.append("0"); &#125; sb.append(hex);&#125;String hexstring = sb.toString(); 1234567891011121314151617181920212223242526272829303132333435public class MD5Utils &#123; public static String encode(String pwd) &#123; // MessageDigest 消息摘要 try &#123; MessageDigest digester = MessageDigest.getInstance("MD5"); // 加密，将要加密的字符串转换成字节数组 byte[] digest = digester.digest(pwd.getBytes()); StringBuffer buffer = new StringBuffer(); // 0000-0101 // 1111-1111 // 0000-0101 for (byte b : digest) &#123; // 0xff 表示低8 位 int number = b &amp; 0xff; // int 32 位一个int 是四个字节一个字节8 位 // 任何一个值&amp; 等于0 // &amp; 1 = 1 String hexString = Integer.toHexString(number); if (hexString.length() == 1) &#123; buffer.append("0" + hexString); &#125; else &#123; buffer.append(hexString); &#125; &#125; System.out.println("密码长度---" + buffer.toString().length()); System.out.println("密码---" + buffer.toString()); return buffer.toString(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return ""; &#125;&#125; 6. MD5解密网站http://www.cmd5.com/ 为了提高MD5 加密的安全性，减少密文被反向解密的可能性，应尽量将密码的长度设置的长一些，另外也可以将密码进行多次加密，这样可以保护用户的隐私安全]]></content>
      <categories>
        <category>安全加密</category>
      </categories>
      <tags>
        <tag>消息摘要</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android安全加密：数字签名和数字证书]]></title>
    <url>%2F2017%2F05%2F01%2F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%2FAndroid%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%EF%BC%9A%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E5%92%8C%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[Android安全加密专题文章索引 Android安全加密：对称加密 Android安全加密：非对称加密 Android安全加密：消息摘要Message Digest Android安全加密：数字签名和数字证书 Android安全加密：Https编程 1. 数字签名1.1 概述数字签名是非对称加密与数字摘要的组合应用 1.2 应用场景 校验用户身份（使用私钥签名，公钥校验，只要用公钥能校验通过，则该信息一定是私钥持有者发布的） 校验数据的完整性（用解密后的消息摘要跟原文的消息摘要进行对比） 1.3 签名过程“发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要,然后用自己的私人密钥对这个摘要进行加密，这个加密后的摘要将作为报文的数字签名和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再用发送方的公用密钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该数字签名是发送方的。 数字签名有两种功效：一是能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。二是数字签名能确定消息的完整性。因为数字签名的特点是它代表了文件的特征，文件如果发生改变，数字摘要的值也将发生变化。不同的文件将得到不同的数字摘要。一次数字签名涉及到一个哈希函数、发送者的公钥、发送者的私钥。 1.4 使用步骤123456789101112131415161718192021//获取signature 对象，初始化算法：MD2withRSA, MD5withRSA, or SHA1withRSASignature signature = Signature.getInstance("MD5withRSA");//创建私钥（从磁盘上读取）PrivateKey privateKey = (PrivateKey)SerializableUtil.readObject("heima.privateKey");//使用私钥进行初始化signature.initSign(privateKey);//传入需要签名的数据signature.update(content.getBytes());//执行签名byte[] sign = signature.sign();//创建公钥（从磁盘上读取）PublicKey publicKey = (PublicKey) SerializableUtil.readObject("heima.publicKey");//使用公钥进行初始化signature.initVerify(publicKey);//传入需要校验的数据（即上面的原文）signature.update(content.getBytes());//执行校验boolean verify = signature.verify(sign); 1.5 总结数字签名一般不单独使用，基本都是用在数字证书里实现SSL 通信协议。下面将学习的数字证书就是基于数字签名技术实现的。 2. 数字证书2.1 概述数字证书就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet 上验证通信实体身份的方式，数字证书不是数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。它是由权威机构——CA 机构，又称为证书授权（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份。 2.2 应用场景 交易者身份的确定性、不可否认性、不可修改性 对应用进行签名认证（例如Android 的apk） 2.3 数字证书格式 数字证书的格式普遍采用的是X.509V3 国际标准，一个标准的X.509 数字证书包含以下一些内容： 证书的版本信息 证书的序列号，每个证书都有一个唯一的证书序列号 证书所使用的签名算法 证书的发行机构名称，命名规则一般采用X.500 格式 证书的有效期，通用的证书一般采用UTC 时间格式，它的计时范围为1950-2049 证书所有人的名称，命名规则一般采用X.500 格式 证书所有人的公开密钥 证书发行者对证书的签名 2.4 数字证书原理 数字证书是安全领域里的终极武器，SSL 通信协议里最核心的东西就是数字证书。他涉及到前面提到的所有知识：对称加密、非对称加密、消息摘要、数字签名等。 数字证书可以通过java 自带的KeyTool 工具生成，生成后的数字证书一般保管在KeyStore 里。KeyStore可以叫做秘钥仓库。 秘钥仓库可以保管3 种类型的数据：KeyStore.PrivateKeyEntry（非对称机密里的私钥）、KeyStore.SecretKeyEntry （对称加密里的秘钥）、KeyStore.TrustedCertificateEntry（受信任的证书） 2.5 KeyTool工具路径：jre\bin\keytool.exe 常用命令：生成keypair 12keytool -genkeypairkeytool -genkeypair -alias lisi（后面部分是为证书指定别名，否则采用默认的名称为mykey） 看看keystore 中有哪些项目： 12keytool -list 或keytool -list -vkeytool -exportcert -alias lisi -file lisi.cer 生成可打印的证书： 1keytool -exportcert -alias lisi -file lisi.cer –rfc 显示数字证书文件中的证书信息： 1keytool -printcert -file lisi.cer 直接双击lisi.cer，用window 系统的内置程序打开lisi.cer 2.6 Android的keystore相关知识debug 签名路径：user.android\debug.keystore debug.keystore 的别名（alias）及密码:别名：androiddebugkey，密码：android 签名命令(jdk1.6)： 1jarsigner -verbose -keystore debug.keystore -signedjar 1signed.apk 1.apk androiddebugkey 签名命令(jdk1.7)： 12jarsigner -verbose -keystore debug.keystore -signedjar 1signed.apk 1.apk androiddebugkey -digestalgSHA1 -sigalg MD5withRSA 优化命令： 1zipalign -v 4 1signed.apk 1signedaligned.apk 验证签名是否成功： 1jarsigner -verify 1signed.apk 2.7 补充签名证书由权威颁发机构颁发给服务器或者个人用于证明自己身份的东西，默认客户端都是信任的。主要目的是用来加密和保证数据的完整性和不可抵赖性例如根证书机构Symantec 颁发给百度的就是签名证书，是受信任的。 自签名证书由服务器自己颁发给自己，用于证明自己身份的东西，非权威颁发机构发布，默认客户端都是不信任的，主要目的是用来加密和保证数据的完整性和不可抵赖性,与签名证书相同.例如中铁集团（SRCA）办法给12306 的证书就是自签名证书，自己给自己颁发的。 3. Android签名机制3.1 什么是签名？Android要求所有已安装的应用程序都使用数字证书做数字签名，数字证书的私钥由开发者持有。Android使用数字证书作为标识应用程序开发者的一种方式，并在应用程序之间建立信任的关系，证书并不用来控制用户能否安装那个应用程序，证书不需要有证书认证中心签名，完全可以使用自签名证书（seft-signed certificates） 没有正确签名的应用，Android系统不会安装或运行，此规则适用于任何地方运行的Android系统，不管是在模拟器还是在真实设备上。因为这个原因，在真机或模拟器上运行或调试应用前，必须为其设置好签名。 3.2 为什么需要签名？开发Android的人很多，完全可以把包名，类名起成同样的名字，这时候如何区分？签名可以区分开发商或者恶意的开发者可以通过相同的包名混淆替换已安装应用。签名可以保证相同包名但是签名不同的包不被替换。 应用如果使用一种key签名，另外一个key签名的文件将无法安装或覆盖老的版本。防止已安装的应用被恶意的第三方覆盖或替换。签名可以防止交易抵赖 3.3 Android签名机制在Android 系统中，所有安装到系统的应用程序都必有一个数字证书，此数字证书用于标识应用程序的作者和在应用程序之间建立信任关系。 Android 系统要求每一个安装进系统的应用程序都是经过数字证书签名的，数字证书的私钥则保存在程序开发者的手中。 Android 将数字证书用来标识应用程序的作者和在应用程序之间建立信任关系，不是用来决定最终用户可以安装哪些应用程序。 这个数字证书并不需要权威的数字证书签名机构认证(CA)，它只是用来让应用程序包自我认证的。 同一个开发者的多个程序尽可能使用同一个数字证书，这可以带来以下好处。 有利于程序升级，当新版程序和旧版程序的数字证书相同时，Android 系统才会认为这两个程序是同一个程序的不同版本。如果新版程序和旧版程序的数字证书不相同，则Android 系统认为他们是不同的程序，并产生冲突，会要求新程序更改包名。 有利于程序的模块化设计和开发。Android 系统允许拥有同一个数字签名的程序运行在一个进程中，Android程序会将他们视为同一个程序。所以开发者可以将自己的程序分模块开发，而用户只需要在需要的时候下载适当的模块 在签名时，需要考虑数字证书的有效期 数字证书的有效期要包含程序的预计生命周期，一旦数字证书失效，持有改数字证书的程序将不能正常升级。 如果多个程序使用同一个数字证书，则该数字证书的有效期要包含所有程序的预计生命周期。 Android Market 强制要求所有应用程序数字证书的有效期要持续到2033 年10 月22 日以后。 Android 数字证书包含以下几个要点 所有的应用程序都必须有数字证书，Android 系统不会安装一个没有数字证书的应用程序 Android 程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证 如果要正式发布一个Android ，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt 插件或者ant 工具生成的调试证书来发布 数字证书都是有有效期的，Android 只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能 3.4 Android签名过程 创建证书 3.5 Android APP 升级流程 签名冲突： 如果两个应用程序, 包名相同, 但是签名不同, 就无法覆盖安装 正式签名： 有效期比较长，一般大于25年 需要设置密码 正式发布应用时，必须用正式签名来打包 测试签名(debug.keystore) 有效期是1年，很短 有默认的别名，密码，alias=android，密码是androiddebugkey 在Android Studio中直接运行项目是,系统默认采用此签名文件 如果正式签名丢失了怎么办? 修改包名，发布，会发现有两个手机卫士，用户会比较纠结 请用户先删掉原来的版本，再进行安装，用户会流失 作为一名有经验的开发人员，请不要犯这种低级错误]]></content>
      <categories>
        <category>安全加密</category>
      </categories>
      <tags>
        <tag>数字签名和数字证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android安全加密：非对称加密]]></title>
    <url>%2F2017%2F05%2F01%2F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%2FAndroid%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%EF%BC%9A%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[Android安全加密专题文章索引 Android安全加密：对称加密 Android安全加密：非对称加密 Android安全加密：消息摘要Message Digest Android安全加密：数字签名和数字证书 Android安全加密：Https编程 1. 介绍与对称加密算法不同，非对称加密算法需要两个密钥：公钥（publickey）和私钥（privatekey）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 简单理解为：加密和解密是不同的钥匙 2. 常见算法RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等，其中支付宝使用的就是RSA算法 3. RSA 算法原理质因数、欧拉函数、模反元素原理很复杂，只需要知道内部是基于分解质因数和取模操作即可 4. 使用步骤123456789101112131415//1，获取cipher 对象Cipher cipher = Cipher.getInstance("RSA");//2，通过秘钥对生成器KeyPairGenerator 生成公钥和私钥KeyPair keyPair = KeyPairGenerator.getInstance("RSA").generateKeyPair();//使用公钥进行加密，私钥进行解密（也可以反过来使用）PublicKey publicKey = keyPair.getPublic();PrivateKey privateKey = keyPair.getPrivate();//3,使用公钥初始化密码器cipher.init(Cipher.ENCRYPT_MODE, publicKey);//4，执行加密操作byte[] result = cipher.doFinal(content.getBytes());//使用私钥初始化密码器cipher.init(Cipher.DECRYPT_MODE, privateKey);//执行解密操作byte[] deResult = cipher.doFinal(result); 5. 注意点1234//一次性加密数据的长度不能大于117 字节private static final int ENCRYPT_BLOCK_MAX = 117;//一次性解密的数据长度不能大于128 字节private static final int DECRYPT_BLOCK_MAX = 128; 6. 分批操作123456789101112131415161718192021222324252627282930/*** 分批操作** @param content 需要处理的数据* @param cipher 密码器（根据cipher 的不同，操作可能是加密或解密）* @param blockSize 每次操作的块大小，单位为字节* @return 返回处理完成后的结果* @throws Exception*/ public static byte[] doFinalWithBatch(byte[] content, Cipher cipher, int blockSize) throwseption &#123; int offset = 0;//操作的起始偏移位置 int len = content.length;//数据总长度 byte[] tmp;//临时保存操作结果 ByteArrayOutputStream baos = new ByteArrayOutputStream(); //如果剩下数据 while (len - offset &gt; 0) &#123; if (len - offset &gt;= blockSize) &#123; //剩下数据还大于等于一个blockSize tmp = cipher.doFinal(content, offset, blockSize); &#125;else &#123; //剩下数据不足一个blockSize tmp = cipher.doFinal(content, offset, len - offset); &#125; //将临时结果保存到内存缓冲区里 baos.write(tmp); offset = offset + blockSize; &#125; baos.close(); return baos.toByteArray(); &#125; 7. 非对称加密用途身份认证一条加密信息若能用A 的公钥能解开，则该信息一定是用A 的私钥加密的，该能确定该用户是A。 陌生人通信A 和B 两个人互不认识，A 把自己的公钥发给B，B 也把自己的公钥发给A，则双方可以通过对方的公钥加密信息通信。C 虽然也能得到A、B 的公钥，但是他解不开密文。 秘钥交换A 先得到B 的公钥，然后A 生成一个随机秘钥，例如13245768，之后A 用B 的公钥加密该秘钥，得到加密后的秘钥，例如dxs#fd@dk，之后将该密文发给B，B 用自己的私钥解密得到123456，之后双方使用13245768 作为对称加密的秘钥通信。C 就算截获加密后的秘钥dxs#fd@dk，自己也解不开，这样A、B 二人能通过对称加密进行通信。 8. 总结非对称加密一般不会单独拿来使用，他并不是为了取代对称加密而出现的，非对称加密速度比对称加密慢很多，极端情况下会慢1000 倍，所以一般不会用来加密大量数据，通常我们经常会将对称加密和非对称加密两种技术联合起来使用，例如用非对称加密来给称加密里的秘钥进行加密（即秘钥交换）。]]></content>
      <categories>
        <category>安全加密</category>
      </categories>
      <tags>
        <tag>非对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android安全加密：对称加密]]></title>
    <url>%2F2017%2F05%2F01%2F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%2FAndroid%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%EF%BC%9A%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[Android安全加密专题文章索引 Android安全加密：对称加密 Android安全加密：非对称加密 Android安全加密：消息摘要Message Digest Android安全加密：数字签名和数字证书 Android安全加密：Https编程 1. 凯撒密码1.1 概述凯撒密码作为一种最为古老的对称加密体制，在古罗马的时候都已经很流行，他的基本思想是：通过把字母移动一定的位数来实现加密和解密。明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3 的时候，所有的字母A 将被替换成D，B 变成E，由此可见，位数就是凯撒密码加密和解密的密钥。 例如：字符串”ABC”的每个字符都右移3 位则变成”DEF”，解密的时候”DEF”的每个字符左移3 位即能还原，如下图所示： 1.2 准备知识1234567 //字符转换成ASCII码数值 char charA = 'a'; int intA = charA; //char 强转为int 即得到对应的ASCII 码值，’a’的值为97//ASCII 码值转成charint intA = 97;//97 对应的ASCII 码’a’char charA = (char) intA; //int 值强转为char 即得到对应的ASCII 字符，即'a' 1.3 凯撒密码的简单代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 加密 * @param input 数据源（需要加密的数据） * @param key 秘钥，即偏移量 * @return 返回加密后的数据 */public static String encrypt(String input, int key) &#123; //得到字符串里的每一个字符 char[] array = input.toCharArray(); for (int i = 0; i &lt; array.length; ++i) &#123; //字符转换成ASCII 码值 int ascii = array[i]; //字符偏移，例如a-&gt;b ascii = ascii + key; //ASCII 码值转换为char char newChar = (char) ascii; //替换原有字符 array[i] = newChar; //以上4 行代码可以简写为一行 //array[i] = (char) (array[i] + key); &#125; //字符数组转换成String return new String(array);&#125;/** * 解密 * @param input 数据源（被加密后的数据） * @param key 秘钥，即偏移量 * @return 返回解密后的数据 */public static String decrypt(String input, int key) &#123; //得到字符串里的每一个字符 char[] array = input.toCharArray(); for (int i = 0; i &lt; array.length; ++i) &#123; //字符转换成ASCII 码值 int ascii = array[i]; //恢复字符偏移，例如b-&gt;a ascii = ascii - key; //ASCII 码值转换为char char newChar = (char) ascii; //替换原有字符 array[i] = newChar; //以上4 行代码可以简写为一行 //array[i] = (char) (array[i] - key); &#125; //字符数组转换成String return new String(array);&#125; 代码输出结果 1.4 破解凯撒密码：频率分析法凯撒密码加密强度太低，只需要用频度分析法即可破解。 在任何一种书面语言中，不同的字母或字母组合出现的频率各不相同。而且，对于以这种语言书写的任意一段文本，都具有大致相同的特征字母分布。比如，在英语中，字母E 出现的频率很高，而X 则出现得较少。 英语文本中典型的字母分布情况如下图所示： 1.5 破解流程 统计密文里出现次数最多的字符，例如出现次数最多的字符是是’h’。 计算字符’h’到’e’的偏移量，值为3，则表示原文偏移了3 个位置。 将密文所有字符恢复偏移3 个位置。 注意点：统计密文里出现次数最多的字符时，需多统计几个备选，因为最多的可能是空格或者其他字符，例如下图出现次数最多的字符’#’是空格加密后的字符，’h’才是’e’偏移后的值。 解密时要多几次尝试，因为不一定出现次数最多的字符就是我们想要的目标字符，如下图，第二次解密的结果才是正确的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/** * 频率分析法破解凯撒密码 */public class FrequencyAnalysis &#123; //英文里出现次数最多的字符 private static final char MAGIC_CHAR = 'e'; //破解生成的最大文件数 private static final int DE_MAX_FILE = 4; public static void main(String[] args) throws Exception &#123; //测试1，统计字符个数 //printCharCount("article1_en.txt"); //加密文件 //int key = 3; //encryptFile("article1.txt", "article1_en.txt", key); //读取加密后的文件 String artile = file2String("article1_en.txt"); //解密（会生成多个备选文件） decryptCaesarCode(artile, "article1_de.txt"); &#125; public static void printCharCount(String path) throws IOException&#123; String data = file2String(path); List&lt;Entry&lt;Character, Integer&gt;&gt; mapList = getMaxCountChar(data); for (Entry&lt;Character, Integer&gt; entry : mapList) &#123; //输出前几位的统计信息 System.out.println("字符'" + entry.getKey() + "'出现" + entry.getValue() + "次"); &#125; &#125; public static void encryptFile(String srcFile, String destFile, int key) throws IOException &#123; String artile = file2String(srcFile); //加密文件 String encryptData = MyEncrypt.encrypt(artile, key); //保存加密后的文件 string2File(encryptData, destFile); &#125; /** * 破解凯撒密码 * @param input 数据源 * @return 返回解密后的数据 */ public static void decryptCaesarCode(String input, String destPath) &#123; int deCount = 0;//当前解密生成的备选文件数 //获取出现频率最高的字符信息（出现次数越多越靠前） List&lt;Entry&lt;Character, Integer&gt;&gt; mapList = getMaxCountChar(input); for (Entry&lt;Character, Integer&gt; entry : mapList) &#123; //限制解密文件备选数 if (deCount &gt;= DE_MAX_FILE) &#123; break; &#125; //输出前几位的统计信息 System.out.println("字符'" + entry.getKey() + "'出现" + entry.getValue() + "次"); ++deCount; //出现次数最高的字符跟MAGIC_CHAR的偏移量即为秘钥 int key = entry.getKey() - MAGIC_CHAR; System.out.println("猜测key = " + key + "， 解密生成第" + deCount + "个备选文件" + "\n"); String decrypt = MyEncrypt.decrypt(input, key); String fileName = "de_" + deCount + destPath; string2File(decrypt, fileName); &#125; &#125; //统计String里出现最多的字符 public static List&lt;Entry&lt;Character, Integer&gt;&gt; getMaxCountChar(String data) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); char[] array = data.toCharArray(); for (char c : array) &#123; if(!map.containsKey(c)) &#123; map.put(c, 1); &#125;else&#123; Integer count = map.get(c); map.put(c, count + 1); &#125; &#125; //输出统计信息 /*for (Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + "出现" + entry.getValue() + "次"); &#125;*/ //获取获取最大值 int maxCount = 0; for (Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123; //不统计空格 if (/*entry.getKey() != ' ' &amp;&amp; */entry.getValue() &gt; maxCount) &#123; maxCount = entry.getValue(); &#125; &#125; //map转换成list便于排序 List&lt;Entry&lt;Character, Integer&gt;&gt; mapList = new ArrayList&lt;Map.Entry&lt;Character,Integer&gt;&gt;(map.entrySet()); //根据字符出现次数排序 Collections.sort(mapList, new Comparator&lt;Entry&lt;Character, Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;Character, Integer&gt; o1, Entry&lt;Character, Integer&gt; o2) &#123; return o2.getValue().compareTo(o1.getValue()); &#125; &#125;); return mapList; &#125; public static String file2String(String path) throws IOException &#123; FileReader reader = new FileReader(new File(path)); char[] buffer = new char[1024]; int len = -1; StringBuffer sb = new StringBuffer(); while ((len = reader.read(buffer)) != -1) &#123; sb.append(buffer, 0, len); &#125; return sb.toString(); &#125; public static void string2File(String data, String path)&#123; FileWriter writer = null; try &#123; writer = new FileWriter(new File(path)); writer.write(data); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if (writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 2. 对称加密2.1 概述加密和解密都使用同一把秘钥，这种加密方法称为对称加密，也称为单密钥加密。简单理解为：加密解密都是同一把钥匙。凯撒密码就属于对称加密，他的字符偏移量即为秘钥。 2.2 对称加密常用算法AES、DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK 等。 DES 全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1976 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。 3DES 也叫Triple DES，是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用三次DES 加密算法。由于计算机运算能力的增强，原版DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。 AES 高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael 加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001 年11 月26 日发布于FIPS PUB 197，并在2002 年5 月26 日成为有效的标准。2006 年，高级加密标准已然成为对称密钥加密中最流行的算法之一。 2.3 DES 算法简介DES 加密原理（对比特位进行操作，交换位置，异或等等，无需详细了解） 准备知识Bit 是计算机最小的传输单位。以0 或1 来表示比特位的值例如数字3 对应的二进制数据为：00000011 代码示例 1234int i = 97;String bit = Integer.toBinaryString(i);//输出：97 对应的二进制数据为： 1100001System.out.println(i + "对应的二进制数据为： " + bit); ###Byte 与Bit 区别 数据存储是以“字节”（Byte）为单位，数据传输是大多是以“位”（bit，又名“比特”）为单位，一个位就代表一个0 或1（即二进制），每8 个位（bit，简写为b）组成一个字节（Byte，简写为B），是最小一级的信息单位。 Byte 的取值范围： 12//byte 的取值范围：-128 到127System.out.println(Byte.MIN_VALUE + "到" + Byte.MAX_VALUE); 即10000000 到01111111 之间，一个字节占8 个比特位 二进制转十进制图示： 任何字符串都可以转换为字节数组 12String data = "1234abcd";byte[] bytes = data.getBytes();//内容为：49 50 51 52 97 98 99 100 上面数据49 50 51 52 97 98 99 100 对应的二进制数据（即比特位为）： 0011000100110010001100110011010001100001011000100110001101100100 将他们间距调大一点，可看做一个矩阵 之后可对他们进行各种操作，例如交换位置、分割、异或运算等，常见的加密方式就是这样操作比特位的，例如下图的IP 置换以及S-Box 操作都是常见加密的一些方式： IP置换： S-BOX置换： DES加密过程图解（流程很复杂，只需要知道内部是操作比特位即可）： 对称加密应用场景 本地数据加密（例如加密android 里SharedPreferences 里面的某些敏感数据） 网络传输：登录接口post 请求参数加密{username=lisi,pwd=oJYa4i9VASRoxVLh75wPCg==} 加密用户登录结果信息并序列化到本地磁盘(将user 对象序列化到本地磁盘，下次登录时反序列化到内存里) 网页交互数据加密（即后面学到的Https） DES算法代码实现12345678//1,得到cipher 对象（可翻译为密码器或密码系统）Cipher cipher = Cipher.getInstance("DES");//2，创建秘钥SecretKey key = KeyGenerator.getInstance("DES").generateKey();//3，设置操作模式（加密/解密）cipher.init(Cipher.ENCRYPT_MODE, key);//4，执行操作byte[] result = cipher.doFinal("黑马".getBytes()); ###AES 算法代码实现 用法同上，只需把”DES”参数换成”AES”即可。 ###使用Base64 编码加密后的结果 12byte[] result = cipher.doFinal("黑马".getBytes());System.out.println(new String(result)); 输出结果： 加密后的结果是字节数组，这些被加密后的字节在码表（例如UTF-8 码表）上找不到对应字符，会出现乱码，当乱码字符串再次转换为字节数组时，长度会变化，导致解密失败，所以转换后的数据是不安全的。 使用Base64 对字节数组进行编码，任何字节都能映射成对应的Base64 字符，之后能恢复到字节数组，利于加密后数据的保存于传输，所以转换是安全的。同样，字节数组转换成16 进制字符串也是安全的。 密文转换成Base64 编码后的输出结果： 密文转换成16 进制编码后的输出结果： Java 里没有直接提供Base64 以及字节数组转16 进制的Api，开发中一般是自己手写或直接使用第三方提供的成熟稳定的工具类（例如apache 的commons-codec）。 Base64字符映射表 对称加密的具体应用方式1、生成秘钥并保存到硬盘上，以后读取该秘钥进行加密解密操作，实际开发中用得比较少 123456789101112//生成随机秘钥SecretKey secretKey = KeyGenerator.getInstance("AES").generateKey();//序列化秘钥到磁盘上FileOutputStream fos = new FileOutputStream(new File("heima.key"));ObjectOutputStream oos = new ObjectOutputStream(fos);oos.writeObject(secretKey);//从磁盘里读取秘钥FileInputStream fis = new FileInputStream(new File("heima.key"));ObjectInputStream ois = new ObjectInputStream(fis);Key key = (Key) ois.readObject(); 2、使用自定义秘钥（秘钥写在代码里） 1234567891011//创建密钥写法1KeySpec keySpec = new DESKeySpec(key.getBytes());SecretKey secretKey = SecretKeyFactory.getInstance(ALGORITHM).generateSecret(keySpec);//创建密钥写法2//SecretKey secretKey = new SecretKeySpec(key.getBytes(), KEY_ALGORITHM);Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);cipher.init(Cipher.DECRYPT_MODE, secretKey);//得到key 后，后续代码就是Cipher 的写法，此处省略... 注意事项把秘钥写在代码里有一定风险，当别人反编译代码的时候，可能会看到秘钥，android 开发里建议用JNI 把秘钥值写到C 代码里，甚至拆分成几份，最后再组合成真正的秘钥 算法/工作模式/填充模式初始化cipher 对象时，参数可以直接传算法名：例如： 1Cipher c = Cipher.getInstance("DES"); 也可以指定更详细的参数，格式：”algorithm/mode/padding” ，即”算法/工作模式/填充模式” 1Cipher c = Cipher.getInstance("DES/CBC/PKCS5Padding"); 密码块工作模式块密码工作模式(Block cipher mode of operation)，是对于按块处理密码的加密方式的一种扩充，不仅仅适用于AES，包括DES, RSA 等加密方法同样适用。 填充模式填充(Padding)，是对需要按块处理的数据，当数据长度不符合块处理需求时，按照一定方法填充满块长的一种规则。 具体代码：123456789101112131415//秘钥算法private static final String KEY_ALGORITHM = "DES";//加密算法：algorithm/mode/padding 算法/工作模式/填充模式private static final String CIPHER_ALGORITHM = "DES/ECB/PKCS5Padding";//秘钥private static final String KEY = "12345678";//DES 秘钥长度必须是8 位或以上//private static final String KEY = "1234567890123456";//AES 秘钥长度必须是16 位//初始化秘钥SecretKey secretKey = new SecretKeySpec(KEY.getBytes(), KEY_ALGORITHM);Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);//加密cipher.init(Cipher.ENCRYPT_MODE, secretKey);byte[] result = cipher.doFinal(input.getBytes()); 注意：AES、DES 在CBC 操作模式下需要iv 参数12345//AES、DES 在CBC 操作模式下需要iv 参数IvParameterSpec iv = new IvParameterSpec(key.getBytes());//加密cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv); 3. 总结DES 安全度在现代已经不够高，后来又出现的3DES 算法强度提高了很多，但是其执行效率低下，AES算法加密强度大，执行效率高，使用简单，实际开发中建议选择AES 算法。实际android 开发中可以用对称加密（例如选择AES 算法）来解决很多问题，例如： 做一个管理密码的app，我们在不同的网站里使用不同账号密码，很难记住，想做个app 统一管理，但是账号密码保存在手机里，一旦丢失了容易造成安全隐患，所以需要一种加密算法，将账号密码信息加密起来保管，这时候如果使用对称加密算法，将数据进行加密，秘钥我们自己记在心里，只需要记住一个密码。需要的时候可以还原信息。 android 里需要把一些敏感数据保存到SharedPrefrence 里的时候，也可以使用对称加密，这样可以在需要的时候还原。 请求网络接口的时候，我们需要上传一些敏感数据，同样也可以使用对称加密，服务端使用同样的算法就可以解密。或者服务端需要给客户端传递数据，同样也可以先加密，然后客户端使用同样算法解密。]]></content>
      <categories>
        <category>安全加密</category>
      </categories>
      <tags>
        <tag>对称加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android安全加密：Https编程]]></title>
    <url>%2F2017%2F05%2F01%2F%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%2FAndroid%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%EF%BC%9AHttps%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Android安全加密专题文章索引 Android安全加密：对称加密 Android安全加密：非对称加密 Android安全加密：消息摘要Message Digest Android安全加密：数字签名和数字证书 Android安全加密：Https编程 概述SSL(Secure Sockets Layer 安全套接层)，为网景公司(Netscape)所研发，用以保障在Internet 上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。一般通用之规格为40 bit 之安全标准，美国则已推出128 bit 之更高安全标准，但限制出境。只要3.0 版本以上之I.E.或Netscape 浏览器即可支持SSL。 TLS（Transport Layer Security 传输层安全），用于在两个通信应用程序之间提供保密性和数据完整性。TLS 是SSL 的标准化后的产物，有1.0 ，1.1 ，1.2 三个版本，默认使用1.0。TLS1.0 和SSL3.0 几乎没有区别，事实上我们现在用的都是TLS，但因为历史上习惯了SSL 这个称呼。 SSL 通信简单图示： SSL 通信详细图示： 当请求使用自签名证书的网站数据时，例如请求12306 的客运服务页面：https://kyfw.12306.cn/otn/，则会报下面的错误，原因是客户端的根认证机构不能识别该证书错误信息：unable to find valid certification path to requested target 解决方案1一个证书可不可信，是由TrustManager 决定的，所以我们只需要自定义一个什么都不做的TrustManager即可，服务器出示的所有证书都不做校验，一律放行。 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) throws Exception &#123;//协议传输层安全TLS(transport layer secure)SSLContext sslContext = SSLContext.getInstance("TLS");//创建信任管理器（TrustManager 负责校验证书是否可信）TrustManager[] tm = new TrustManager[]&#123;new EmptyX509TrustManager()&#125;;//使用自定义的信任管理器初始化SSL 上下文对象sslContext.init(null, tm, null);//设置全局的SSLSocketFactory 工厂（对所有ssl 链接都产生影响）HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory()); //URL url = new URL("https://www.baidu.com"); URL url = new URL("https://kyfw.12306.cn/otn/"); HttpsURLConnection conn = (HttpsURLConnection) url.openConnection(); InputStream in = conn.getInputStream(); System.out.println(Util.inputstream2String(in)); &#125; /** * 自定义一个什么都不做的信任管理器，所有证书都不做校验，一律放行 */ private static class EmptyX509TrustManager implements X509TrustManager&#123; @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123; &#125; @Override public X509Certificate[] getAcceptedIssuers() &#123; return null; &#125;&#125; 解决方案212306 服务器出示的证书是中铁集团SRCA 给他颁发的，所以SRCA 的证书是能够识别12306 的证书的，所以只需要把SRCA 证书导入系统的KeyStore 里，之后交给TrustManagerFactory 进行初始化，则可把SRCA 添加至根证书认证机构，之后校验的时候，SRCA 对12306 证书校验时就能通过认证。 这种解决方案有两种使用方式：一是直接使用SRCA.cer 文件，二是使用改文件的RFC 格式数据，将其写在代码里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//12306 证书的RFC 格式（注意要记得手动添加两个换行符） private static final String CERT_12306_RFC = "-----BEGIN CERTIFICATE-----\n"+"MIICmjCCAgOgAwIBAgIIbyZr5/jKH6QwDQYJKoZIhvcNAQEFBQAwRzELMAkGA1UEBhMCQ04xKTAn"+"BgNVBAoTIFNpbm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMB4X"+"DTA5MDUyNTA2NTYwMFoXDTI5MDUyMDA2NTYwMFowRzELMAkGA1UEBhMCQ04xKTAnBgNVBAoTIFNp"+"bm9yYWlsIENlcnRpZmljYXRpb24gQXV0aG9yaXR5MQ0wCwYDVQQDEwRTUkNBMIGfMA0GCSqGSIb3"+"DQEBAQUAA4GNADCBiQKBgQDMpbNeb34p0GvLkZ6t72/OOba4mX2K/eZRWFfnuk8e5jKDH+9BgCb2"+"9bSotqPqTbxXWPxIOz8EjyUO3bfR5pQ8ovNTOlks2rS5BdMhoi4sUjCKi5ELiqtyww/XgY5iFqv6"+"D4Pw9QvOUcdRVSbPWo1DwMmH75It6pk/rARIFHEjWwIDAQABo4GOMIGLMB8GA1UdIwQYMBaAFHle"+"tne34lKDQ+3HUYhMY4UsAENYMAwGA1UdEwQFMAMBAf8wLgYDVR0fBCcwJTAjoCGgH4YdaHR0cDov"+"LzE5Mi4xNjguOS4xNDkvY3JsMS5jcmwwCwYDVR0PBAQDAgH+MB0GA1UdDgQWBBR5XrZ3t+JSg0Pt"+"x1GITGOFLABDWDANBgkqhkiG9w0BAQUFAAOBgQDGrAm2U/of1LbOnG2bnnQtgcVaBXiVJF8LKPaV"+"23XQ96HU8xfgSZMJS6U00WHAI7zp0q208RSUft9wDq9ee///VOhzR6Tebg9QfyPSohkBrhXQenvQ"+"og555S+C3eJAAVeNCTeMS3N/M5hzBRJAoffn3qoYdAO1Q8bTguOi+2849A=="+"-----END CERTIFICATE-----\n"; public static void main(String[] args) throws Exception &#123; // 使用传输层安全协议TLS(transport layer secure) SSLContext sslContext = SSLContext.getInstance("TLS"); //使用SRCA.cer 文件的形式//FileInputStream certInputStream = new FileInputStream(new File("srca.cer"));//也可以通过RFC 字符串的形式使用证书ByteArrayInputStream certInputStream = newByteArrayInputStream(CERT_12306_RFC.getBytes());// 初始化keyStore，用来导入证书KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());//参数null 表示使用系统默认keystore，也可使用其他keystore（需事先将srca.cer 证书导入keystore 里）keyStore.load(null);//通过流创建一个证书Certificate certificate = CertificateFactory.getInstance("X.509").generateCertificate(certInputStream);// 把srca.cer 这个证书导入到KeyStore 里，别名叫做srcakeyStore.setCertificateEntry("srca", certificate);// 设置使用keyStore 去进行证书校验TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());trustManagerFactory.init(keyStore);//用我们设定好的TrustManager 去做ssl 通信协议校验，即证书校验sslContext.init(null, trustManagerFactory.getTrustManagers(), null);HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());URL url = new URL("https://kyfw.12306.cn/otn/");HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();InputStream in = conn.getInputStream();System.out.println(Util.inputstream2String(in));&#125; Android 里的https 请求：把scra.cer 文件考到assets 或raw 目录下，或者直接使用证书的RFC 格式，接下来的做法和java工程代码一样 12345678910111213141516171819202122232425262728//ByteArrayInputStream in = new ByteArrayInputStream("rfc".getBytes());CertificateFactory cf = CertificateFactory.getInstance("X.509");InputStream caInput = new BufferedInputStream(new FileInputStream("load-der.crt"));Certificate ca;try &#123; ca = cf.generateCertificate(caInput); System.out.println("ca=" + ((X509Certificate) ca).getSubjectDN());&#125; finally &#123; caInput.close();&#125;String keyStoreType = KeyStore.getDefaultType();KeyStore keyStore = KeyStore.getInstance(keyStoreType);keyStore.load(null, null);keyStore.setCertificateEntry("ca", ca);String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);tmf.init(keyStore);SSLContext context = SSLContext.getInstance("TLS");context.init(null, tmf.getTrustManagers(), null);URL url = new URL("https://certs.cac.washington.edu/CAtest/");HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();urlConnection.setSSLSocketFactory(context.getSocketFactory());InputStream in = urlConnection.getInputStream();copyInputStreamToOutputStream(in, System.out); 双向证书验证1234567891011121314151617CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());keyStore.load(null);SSLContext sslContext = SSLContext.getInstance("TLS");TrustManagerFactory trustManagerFactory = TrustManagerFactory. getInstance(TrustManagerFactory.getDefaultAlgorithm());trustManagerFactory.init(keyStore);//初始化keystoreKeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());clientKeyStore.load(getAssets().open("client.bks"), "123456".toCharArray());KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());keyManagerFactory.init(clientKeyStore, "123456".toCharArray());sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom()); Nogotofail网络流量安全测试工具，Google的开源项目：https://github.com/google/nogotofail Android安全加密专题总结以上学习所有内容，对称加密、非对称加密、消息摘要、数字签名等知识都是为了理解数字证书工作原理而作为一个预备知识。数字证书是密码学里的终极武器，是人类几千年历史总结的智慧的结晶，只有在明白了数字证书工作原理后，才能理解Https 协议的安全通讯机制。最终才能在SSL 开发过程中得心应手。 另外，对称加密和消息摘要这两个知识点是可以单独拿来使用的。 数字证书使用到了以上学习的所有知识 对称加密与非对称加密结合使用实现了秘钥交换，之后通信双方使用该秘钥进行对称加密通信。 消息摘要与非对称加密实现了数字签名，根证书机构对目标证书进行签名，在校验的时候，根证书用公钥对其进行校验。若校验成功，则说明该证书是受信任的。 Keytool 工具可以创建证书，之后交给根证书机构认证后直接使用自签名证书，还可以输出证书的RFC格式信息等。 数字签名技术实现了身份认证与数据完整性保证。 加密技术保证了数据的保密性，消息摘要算法保证了数据的完整性，对称加密的高效保证了数据处理的可靠性，数字签名技术保证了操作的不可否认性。 通过以上内容的学习，我们要能掌握以下知识点： 基础知识：bit 位、字节、字符、字符编码、进制转换、io 知道怎样在实际开发里怎样使用对称加密解决问题 知道对称加密、非对称加密、消息摘要、数字签名、数字证书是为了解决什么问题而出现的 了解SSL 通讯流程 实际开发里怎样请求Https 的接口]]></content>
      <categories>
        <category>安全加密</category>
      </categories>
      <tags>
        <tag>Https编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 系列教程文章索引]]></title>
    <url>%2F2017%2F05%2F01%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%2FRxJava%2F</url>
    <content type="text"><![CDATA[原文出处：http://blog.chengyunfeng.com/?p=983#ixzz4KbVlRYbJ Intro To RxJava 系列教程一共四个部分，第一部分介绍了为什么要使用 RxJava以及 RxJava的关键概念： RxJava 教程第一部分：入门之 Why Rx RxJava 教程第一部分：入门之 关键的类 RxJava 教程第一部分：入门之 生命周期管理 给初学者的 RxJava2.0 系列教程 （1~8） 给 Android 开发者的 RxJava 详解 如果看完第一部分对于为什么要使用 RxJava 和 何时使用 RxJava 还不太明白的，可以参考 RxJava 前传： RxJava 前传 1 RxJava 前传 2 RxJava 前传 3 通过第一部分，可以了解到 RxJava 其实主要应用了观察者模式的理念。在 RxJava 中主要干4件事：一、Observable 用来生产数据并把数据丢给观察者；二、Observer 用来处理 Observable 生产的数据；三、在数据从生产者到消费者的过程中，数据可以被再加工；四、可以指定在那个线程中加工数据和消费数据。 注意上面的数据不仅仅是指普通的模型数据（比如 一个数据库中对应的表），可以是任意的事件类型，只要是和时间相关的类型都可以。比如，点击UI 上的一个按钮触发的事件；访问 URL 地址返回的内容；访问数据库返回的数据 等。 文章第二部分主要介绍了对数据流（事件流）的一些常用的处理函数。 RxJava 教程第二部分：事件流基础之 创建数据流 RxJava 教程第二部分：事件流基础之 过滤数据 RxJava 教程第二部分：事件流基础之 检查数据 RxJava 教程第二部分：事件流基础之 聚合 RxJava 教程第二部分：事件流基础之 转换数据流 这部分设计到如何创建一个数据流，也就是如何把传统的数据或者事件转换为 RxJava 的 Observable，比如把网络请求返回结果的功能封装为 Observable、把点击按钮的点击事件封装成 Observable 。然后就是对数据流中数据的处理，比如 一个按钮点击事件，如果用户对一个按钮快速的连续点击（国内的测试同学喜欢这么干），则在某个时间范围内，你可能只希望处理第一次点击事件，后续的点击事件都给丢弃了；这个点击按钮每一次点击都可以看做事件流中的一个事件，然后你可以使用一些过滤操作函数来把不符合要求的事件过滤掉，只处理你想要的数据。除了过滤操作以外，还可以检查数据是否满足某一个测试条件、也可以把数据流中的所有数据聚合起来、如果源来的数据流中的数据在你代码中无法直接使用，则你还可以把数据流中的数据转换为另外一种类型。 文章第三部分则介绍了对数据流更高级的处理函数。 RxJava 教程第三部分：驯服数据流之 副作用 RxJava 教程第三部分：驯服数据流之 避免 monad RxJava 教程第三部分：驯服数据流之 高级错误处理强调内容 RxJava 教程第三部分：驯服数据流之 组合数据流 RxJava 教程第三部分：驯服数据流之 时间平移 RxJava 教程第三部分：驯服数据流之 hot &amp; cold Observable RxJava 教程第三部分：驯服数据流之 自定义操作函数 如何在传统遗留代码中使用 RxJava以及数据流中的错误处理。还介绍了如何把多个数据流合并起来、如果推迟数据流中数据的发射。如果 RxJava 中提供的操作函数集合还不能满足你的要求，你还可以自定义操作函数。 文章最后一部分介绍了多线程相关的概念和如何在并发环境下使用。 RxJava 教程第四部分：并发 之线程调度 RxJava 教程第四部分：并发 之测试 RxJava 教程第四部分：并发 之意外情况处理 RxJava 教程第四部分：并发 之数据流发射太快如何办 通常情况下，生产数据的源头可能需要比较长的时间去执行，比如请求一个网址，获取返回的内容。可以通过 RxJava 提供的方法把耗时的请求放到另外一个线程中执行。另外把数据从一种类型转换为另外一种类型的过程可能也是很耗时的，同样也可以指定每个操作函数在那个线程执行。还介绍了 如果生产数据的源，生产数据的速度很快，而消费者无法及时的处理这些数据该肿么办。 看完本系列教程，可以发现 RxJava 本质上只是提供了一个处理数据流的框架。 可以这样打个比方，有个生产肥皂的机器 （Observable），该机器每隔10秒生产一块肥皂（原始的数据），后面还有一个机器用来在肥皂上面印上公司 logo （操作函数，把一种数据转换为另外一种数据），在后面还有一个机器用来把肥皂放到盒子中包装起来（同样也是一个操作函数），最后有个工人（消费者）把每盒肥皂装箱打包。 而 RxJava 的方便之处就是把这个流程中的处理给简化了，并且可以像使用 Builder 模式一样串联调用，使代码看起来更加优雅。再加上还可以指定每个操作函数执行的线程，使多线程处理更加方便。 就拿前面提到的用户快速狂按一个按钮的情况来说，在原生 Android 系统里面是不认为这种情况为 bug， 比如使用原生的 Android 系统，在vpn设置界面快速点击两次添加 vpn的按钮，则可以看到添加 vpn 的对话框会打开两个，关闭一个还有另外一个存在。正常用户不会这样操作系统，就算用户这样操作了，多打开一个同样的界面其实影响也不大，用户关闭即可。 而国内的测试同学经常会测试这个情况，大家通常情况下都是在 View onClick 的时候记录下点击的时间，然后在 onClick 中比较前一次点击的时间和当前的时间，如果这个时间小于一个值（比如 1秒）就认为这次点击是无效的。添加了一个变量用来记录时间并且每次点击都要比较，只是为了处理快速点击的情况。如果使用 RxJava 则就非常简单了： 1RxView.clicks(button).throttleFirst(500, TimeUnit.MILLISECONDS).subscribe(…); 只处理 500ms 内的第一次点击。 一旦你掌握了 RxJava，发现使用 Rx 的方式来思考问题和解决问题写出的代码是如此的优雅。]]></content>
      <categories>
        <category>响应式编程</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义控件]]></title>
    <url>%2F2017%2F05%2F01%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Android中Canvas绘图基础详解 Android Paint、Canvas、Matrix使用讲解(一、Paint) Android Paint之 setXfermode PorterDuffXfermode 讲解 Canvas开篇之drawBitmap方法讲解 Android 手把手教您自定义ViewGroup（一） Android 自定义View (一) Android 自定义View (二) 进阶 Android 自定义View (三) 圆环交替 等待效果 Android 自定义View (四) 视频音量调控 Android 深入理解Android中的自定义属性 Android ViewDragHelper完全解析 自定义ViewGroup神器 Android 自定义控件实战 Android LayoutInflater原理分析，带你一步步深入了解View(一) Android视图绘制流程完全解析，带你一步步深入了解View(二) Android视图状态及重绘流程分析，带你一步步深入了解View(三) Android自定义View的实现方法，带你一步步深入了解View(四) Android自定义控件三部曲文章索引 自定义View：测量measure，布局layout，绘制draw 自定义控件 滑动开关 自定义ViewPager 粘性控件 侧滑删除 视差特效 侧边栏SlidingMenu 3D画廊 Gallery 流式布局FlowLayout 水波纹Ripple 旋转菜单 下拉刷新 侧滑面板 快速索引 轮播图/广告条 等比例显示控件 下拉选择框Spinner 旋转菜单 下拉选择 下拉刷新 滑动开关 轮播图 广告条 侧边栏SlidingMenu 水波纹 自定义ViewPager 快速索引 粘性控件 视差特效 侧滑面板 侧拉删除 等比例显示控件 流式布局FlowLayout 3D画廊 自定义吐司12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class AddressTost implements OnTouchListener &#123; private WindowManager mWM; private Context mContext; private WindowManager.LayoutParams mParams; private TextView mLocation; private TextView mView; public AddressTost(Context context) &#123; this.mContext = context; mWM = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); mParams = new WindowManager.LayoutParams(); WindowManager.LayoutParams params = mParams; params.height = WindowManager.LayoutParams.WRAP_CONTENT; params.width = WindowManager.LayoutParams.WRAP_CONTENT; params.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE // | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE //需要toast 有触摸事件 | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON; params.format = PixelFormat.TRANSLUCENT; // params.windowAnimations = // com.android.internal.R.style.Animation_Toast; // params.type = WindowManager.LayoutParams.TYPE_TOAST;//土司天生没有触摸事件 params.type = WindowManager.LayoutParams.TYPE_PRIORITY_PHONE;//换成电话的类型 /** * 展示号码归属地显示 */ public void show(String location) &#123; mLocation = (TextView) view.findViewById(R.id.tv_location); mView = new TextView(mContext); // 设置归属地的颜色 mView.setBackgroundColor(Color.RED); // 设置归属地的位置 mLocation.setText(location); mWM.addView(mView, mParams); &#125; /** * 隐藏号码归属地 */ public void hide() &#123; // 隐藏土司 if (mView!= null) &#123; // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn't yet added, so let's try not to crash. if (mView.getParent() != null) &#123; // if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + // this); mWM.removeView(mView); &#125; view = null; &#125; &#125;&#125; 自定义对话框12345678910111213141516171819202122232425public class AddressDialog extends Dialog &#123; private Window window; private OnItemClickListener mOnItemClickListener; //把我们自己的样式传给父类 //屏蔽父类里面的样式 public AddressDialog(Context context) &#123; super(context, R.style.AddressDialogStyle); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); setContentView(R.layout.dialog_address_style); window = getWindow(); //获取到当前窗体的样式 LayoutParams params = window.getAttributes(); params.gravity = Gravity.BOTTOM; // | Gravity.CENTER_HORIZONTAL; //设置窗体的属性 window.setAttributes(params); &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础入门]]></title>
    <url>%2F2017%2F05%2F01%2Fjava%2FJava%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Java基础入门笔记 十年生死两茫茫，不思量，自难忘，华年短暂，陈辞岁月悠悠伤，满腔热血已芜荒，展未来，后生强，战战兢兢，如履薄冰心彷徨，青丝化雪、鬓角成霜，已是英雄迟暮，人生怎慷慨激昂？ GitHub托管主页https://github.com/JackChen1999/Java-basic-introduction 请读者点击Star进行关注并支持！ 在线阅读https://alleniverson.gitbooks.io/java-basic-introduction/content Java基础入门专栏http://blog.csdn.net/column/details/15370.html 目录 序言 第1章 Java开发入门 Java概述 JDK、JRE、JVM的区别与联系 第2章 Java编程基础 Java语法基础-1 Java语法基础-2 基本数据类型包装类 阿里巴巴Java开发手册 Google Java编程风格指南 详细介绍JAVA和C++区别 第3章 面向对象 数组工具类 文档注释 面向对象 Object类 单例设计模式 封装 继承 多态 抽象类与接口 内部类 异常 第4章 常见对象 String类 正则表达式 字符串格式化 第5章 多线程 多线程 线程池 volatile关键字解析 HandlerThread Callable和Future Java程序死锁问题原理及解决方案 线程锁技术 定时器、互斥、同步通信技术 线程范围内共享数据 多个线程之间共享数据的方式探讨 使用JDK5中同步技术的3个面试题 同步工具类 原子类 集合及concurrent并发包总结 JDK8对并发的新支持 阻塞队列 Java并发工具包concurrent用户指南 第6章 集合框架 集合框架 集合框架工具类 Java集合类型详解 第7章 IO流 IO流之File类 IO流之字节流和字符流 常用IO流 NIO AIO NIO和AIO 第8章 网络编程 网络编程 写给那些让我糊里糊涂的HTTP、TCP、UDP、Socket 第9章 反射机制 类加载器 反射1 反射2 注解1 注解2 注解3 编译时注解 依赖注入 动态代理1 动态代理2 第10章 新特性 JDK新特性 泛型 你应该更新的Java知识 你应该更新的Java知识之常用程序库1 你应该更新的Java知识之常用程序库2 你应该更新的Java知识之Observer Google Guava官方教程 关注我 Email：&#56;&#49;&#x35;&#x37;&#x31;&#50;&#55;&#x33;&#x39;&#x40;&#113;&#113;&#x2e;&#x63;&#x6f;&#109; CSDN博客：Allen Iverson 新浪微博：AndroidDeveloper GitHub：JackChan1999 GitBook：alleniverson 个人博客：JackChan 如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作！ 微信赞赏支持 支付宝赞赏支持]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发常用开源框架]]></title>
    <url>%2F2017%2F05%2F01%2Fopen%2F%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Android开源框架系列 Android开源项目 Android开发常用开源框架2 Android开发常用开源框架3 2017年伊始，你需要尝试的25个Android第三方库 Android开发常用第三方平台 免费的计算机编程类中文书籍 free-programming-books Mark！Android最佳的开源库集锦 移动开发周刊：Android最佳的开源库集锦 GitHub Top 100的Android开源库 Android 开源项目分类汇总 GitHub Android Libraries Top 100 简介 Android 学习资料收集 awesome-android-ui Awesome-MaterialDesign awesome-android Andriod-collect-blogs 计算机常用基础算法 开源框架https://github.com/JackChan1999/Android_Open_Project 目录 Android开发常用框架 android-open-project 开源项目 快速开发框架 工具集 2017年伊始，你需要尝试的25个Android第三方库 第三方开发平台 图片处理 网络请求 响应式编程 性能优化 图表 二维码 动画 多媒体 缓存 事件总线 数据库 依赖注入 热修复 Log日志 UI控件 TextView UI控件第1季 utils project 后台处理 Awesome-MaterialDesign Square&amp; JakeWharton 框架名称 功能描述 Picasso 一个强大的图片下载与缓存的库 OkHttp Square出品，一个Http与Http/2的客户端 Retrofit Square出品，类型安全的Http客户端 ButterKnife 将Android视图和回调方法绑定到字段和方法上 sqlbrite 一个响应式的数据查询框架 keywhiz 一个隐私管理分配系统，能很好地与SOA配合 LeakCanary 内存泄漏检测工具 javapoet 动态生成Java源码 phrase 字符串格式化 dagger 依赖注入框架 Flow Flow 将一个应用分成一个逻辑上的 Screen组合，Screen不是任何形式的特殊的库对象，而是一个被创造来代表我们应用视图的普通java对象（POJO） Mortar Mortar是一个专注拖拽和依赖注入的库，Mortar 用以下几个不同的部分将一个应用分为可组合的模块：Blueprints, Presenters and a boatload of custom Views RxBinding 可以实现数据层与View层的绑定，当数据发生变化，View会自动更新UI RxAndroid RxJava的扩展, 优雅地处理异步请求 timber 对Android的Log类进行封装后的一个Log工具 ViewPagerIndicator Paging indicator widgets compatible with the ViewPager DiskLruCache Java实现基于LRU的磁盘缓存 Otto Otto 是 Square 公司出的一个事件库 (pub/sub 模式), 用来简化应用程序组件之间的通讯, otto 修改自 Google 的 Guava 库, 专门为 Android 平台进行了优化, 与上面介绍的 EventBus 相比, 两个库各有各的优点, 完全取决于我们自己项目的需求来选择它们哪一个 javapoet A Java API for generating .java source files 动态生成Java源码 阿里巴巴 项目名称 功能描述 freeline Freeline 是 Android 平台上的秒级编译方案，Instant Run 的替代品，也可以从 Freeline 官方主页来获取更多的信息。Freeline 由蚂蚁聚宝 Android 团队开发，它可以充分利用缓存文件，在几秒钟内迅速地对代码的改动进行编译并部署到设备上，有效地减少了日常开发中的大量重新编译与安装的耗时。Freeline能够为Android开发者节省很多喝杯咖啡的时间 weex A framework for building Mobile cross-platform UI fastjson A fast JSON parser/generator for Java Dubbo Dubbo is a distributed, high performance RPC framework enpowering applications with service import/export capabilities AndFix AndFix is a library that offer hot-fix for Android App. dexposed dexposed enable ‘god’ mode for single android application. #小米开源项目| 项目名称 | 功能描述 || :————————————— | :————- || Notes | 小米便签社区开源版 || FileExplorer | MIUI文件管理器社区开源版 || SoundRecorder | MIUI录音机社区开源版 | #Google开源项目| 项目名称 | 功能描述 || :————————————— | :————————————— || GCM | Google Cloud Messaging 消息推送 || iosched： | Google I/O Android App || android-topeka | Google官方给出的material design应用指南 || android-UniversalMusicPlayer | Google官方给出的m音乐播放器，支持Android phones, tablets, Auto, Wear and Cast devices || ExoPlayer | An extensible media player for Android || guava | Google Core Libraries for Java 6+ || flexbox-layout | FlexboxLayout is a library project which brings the similar capabilities of CSS Flexible Box Layout Module to Android. || guice | 轻量级的依赖注入框架 || gson | A Java serialization/deserialization library that can convert Java Objects into JSON and back. || protobuf | Protocol Buffers - Google’s data interchange format || material-design-icons | Material Design icons by Google || auto | Auto 是 Java 生成器源代码集合，包括：AutoFactory - 兼容 JSR-330 的工厂；AutoService - ServiceLoader 的 Provider-configuration 文件；AutoValue - Java 1.6+ 的不可变 value-type 代码生成；Common - Helper 实用工具，用来编写注释处理器 || android-architecture | A collection of samples to discuss and showcase different architectural tools and patterns for Android apps | ##android-topeka ##android-UniversalMusicPlayer ##ExoPlayer An extensible media player for Android Streaming media with ExoPlayer - Google I/O 2016 ##guava ##flexbox-layout 1. 图片加载，缓存，处理 框架名称 功能描述 Android Universal Image Loader 一个强大的加载，缓存，展示图片的库，已过时 Picasso 一个强大的图片下载与缓存的库 Fresco 一个用于管理图像和他们使用的内存的库 Glide 一个图片加载和缓存的库，使用的App有：网易新闻 GlidePalette Android Lollipop Palette is now easy to use with Glide PicassoPalette Android Lollipop Palette is now easy to use with Picasso ! Picasso-transformations 一个为Picasso提供多种图片变换的库 Glide-transformations 一个为Glide提供多种图片变换的库 Picasso是著名的开源组织Square出品的图片处理框架，使用的比较多 Glide是Google的员工基于Picasso开发，优化的，Android官网推荐使用的图片处理框架 Fresco是Facebook开源的图片处理框架，真正做到了三级缓存，功能强大，强烈推荐使用 Android Universal Image Loader是一个老牌的图片处理框架，但是在2015年的9月份已经停止更新维护，所以不推荐使用 2. 图片裁剪 框架名称 功能描述 uCrop Image Cropping Library for Android，使用的App有：薄荷，哔哩哔哩 android-crop 图片裁剪，使用的App有：网易新闻，芒果TV cropper 图片裁剪开源框架 Android-Image-Cropper Image Cropping Library for Android, optimized for Camera / Gallery PhotoCropper Android 大图片裁剪终极解决方案 android-cropimage CropImage Activity from Gallery.apk packaged as a reusable Android library PhotoCrop A Library which can be used to crop images in Android similar to Facebook and Telegram，使用的App有：快手 uCrop android-crop Android-Image-Cropper PhotoCropper PhotoCrop 3. 图片选择 框架名称 功能描述 MultiImageSelector 图片选择，使用的App有：薄荷 BGAPhotoPicker-Android Android 图片选择、预览、九宫格图片控件、拖拽排序九宫格图片控件 TakePhoto 轻量级Android照片处理框架 RxGalleryFinal Android图片单选/多选、拍照、裁剪、压缩。视频选择和录制。GalleryFinal boxing 一个多媒体选择器库，B站出品。可以选择一张或者多张图片，提供预览和裁剪功能。同样支持gif图，选择视频和图像压缩功能。 boxing MultiImageSelector BGAPhotoPicker-Android TakePhoto RxGalleryFinal 4. 图片转换，压缩，滤镜 框架名称 功能描述 Android-gpuimage 一个开源的基于GPU的图像处理库，提供各种各样的图像处理滤镜，并且支持照相机和摄像机的实时滤镜，使用的App有：快手 photoview 使用的App有：薄荷,网易新闻 circleimageview 圆形图片，使用的App有：薄荷 RoundedImageView 圆形图片，使用的App有：薄荷 SelectableRoundedImageView Android ImageView that supports different radii on each corner android-gif-drawable gif图片，使用的App有：网易新闻，快手 Luban 可能是最接近微信朋友圈的图片压缩算法 Compressor Compressor is a lightweight and powerful android image compression library Android-gpuimage circleimageview RoundedImageView SelectableRoundedImageView) 5. 高斯模糊，毛玻璃，图片模糊 框架名称 功能描述 android-stackblur Android StackBlur is a library that can perform a blurry effect on a Bitmap based on a gradient or radius, and return the result. The library is based on the code of Mario Klingemann. Blurry Blurry is an easy blur library for Android blurkit-android The missing Android blurring library. Fast blur-behind layout that parallels iOS. BlurView Dynamic iOS-like blur of underlying Views for Android ImageBlurring Android blurring image(bitmap) by java and jni android-stackblur Blurry blurkit-android BlurView ImageBlurring 缓存 框架名称 功能描述 LruCache Android原生API，内存缓存 DiskLruCache Java实现基于LRU的磁盘缓存 ASimpleCache 一个为android制定的轻量级的开源缓存框架 base-diskcache Android 缓存库，融合了DiskLruCache和ASimpleCache 网络请求 框架名称 功能描述 httpclient apache开源的网络请求框架，已过时 AsyncHttpClient 基于httpclient封装，已过时 OkHttp Square出品，一个Http与Http/2的客户端 Retrofit Square出品，类型安全的Http客户端 Volley Google推出的Android异步网络请求框架和图片加载框架，使用的App有：网易新闻 从Android 6.0 开始，Google删除了apache的开源网络请求框架httpclient，所以基于httpclient的AsyncHttpClient也不推荐使用了 Volley适合那些请求频繁但数据量不大的场景，不适用于大数据的请求，比如下载文件 Android 6.0 后，Android开始使用OkHttp，而Retrofit是一个网络代理框架，可以更简单的使用OkHttp 网络解析 框架名称 功能描述 Gson 一个Java序列化/反序列化库，可以将JSON和java对象互相转换 Jackson Jackson可以轻松地将Java对象转换成json对象和xml文档，同样也可以将json、xml转换成Java对象 Fastjson Java上一个快速的JSON解析器/生成器 HtmlPaser 一种用来解析单个独立html或嵌套html的方式 Jsoup 一个以最好的DOM，CSS和jQuery解析html的库 数据库 框架名称 功能描述 OrmLite JDBC和Android的轻量级ORM java包 Sugar 用超级简单的方法处理Android数据库 GreenDAO 一种轻快地将对象映射到SQLite数据库的ORM解决方案，使用的App有：薄荷，京东 ActiveAndroid 以活动记录方式为Android SQLite提供持久化 SQLBrite SQLiteOpenHelper 和ContentResolver的轻量级包装 android-database-sqlcipher 数据库加密 storio Beautiful API for SQLiteDatabase and ContentResolver realm-java 移动数据库，高性能数据库：一个SQLite和ORM的替换品 ObjectBox 相信不少人都用过GreenDao和EventBus，这两库都是greenrobot公司出品。ObjectBox也是该公司出品。GreenDao号称是最快的与SQLite的对象关系映射（ORM）。但是自从2011年以来，公司声称发现了许多的缺陷，有很多问题影响了性能。所以开发出另外一套性能最好且易用的NoSQL数据库，优于其他数据库5-15倍的性能。 依赖注入 框架名称 功能描述 ButterKnife 将Android视图和回调方法绑定到字段和方法上 Dagger2 一个Android和java快速依赖注射器 AndroidAnotations 快速安卓开发。易于维护 RoboGuice Android平台的Google Guice 已退役 guice Google开发的依赖注入框架 图表Chart 框架名称 功能描述 WilliamChart 创建图表的Android库 HelloCharts 兼容到API8的Android图表库，使用的App有：薄荷 MPAndroidChart 一个强大的Android图表视图/图形库，使用的App有：春雨医生 后台处理 框架名称 功能描述 Tape 一个轻快的，事务性的，基于文件的FIFO的库 Android Priority Job Queue 一个专门为Android轻松调度任务的工作队列 事件总线 框架名称 功能描述 EventBus 安卓优化的事件总线，简化了活动、片段、线程、服务等的通信，使用的App有：薄荷 Otto 一个基于Guava的增强的事件总线 HermesEventBus 一个基于EventBus的、能在进程间发送和接收event的库，在IPC或者插件开发中非常有用 响应式编程 框架名称 功能描述 RxJava JVM上的响应式扩展 RxJavaJoins 为RxJava提供Joins操作 RxAndroid Android上的响应式扩展，在RxJava基础上添加了Android线程调度 RxBinding 提供用RxJava绑定Android UI的API Agera Android上的响应式编程 RxLifecycle Lifecycle handling APIs for Android apps using RxJava Log框架 框架名称 功能描述 Logger 简单，漂亮，强大的Android日志工具 Hugo 在调试版本上注解的触发方法进行日志记录 Timber 一个小的，可扩展的日志工具 测试框架 框架名称 功能描述 Mockito Java编写的Mocking单元测试框架 Robotium Android UI 测试 Robolectric Android单元测试框架 Android自带很多测试工具：JUnit，Monkeyrunner，UiAutomator，Espresso等 调试框架 框架名称 功能描述 Stetho 调试Android应用的桥梁，使得可以利用Chrome开发者工具进行调试 性能优化 框架名称 功能描述 LeakCanary 内存泄漏检测工具 BlockCanary 轻松找出Android App界面卡顿元凶 ACRA Android应用程序崩溃报告 Google Guava Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I/O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。 google protobuf 由google开发，并且在google内部使用。Protobuf的作用和xml、json是一回事，但他是二进制格式，性能好、效率高。ProtoBuf开发者指南 热修复 框架名称 功能描述 tinker 腾讯开源的一个热修复框架 AndFix alibaba热修复框架 dexposed alibaba热修复框架 二维码 框架名称 功能描述 Zxing 一个二维码开源框架 barcodescanner 使用的App有：薄荷 BGAQRCode-Android 扫描二维码、扫描条形码、相册获取图片后识别、生成带 Logo 二维码、支持微博微信 QQ 二维码扫描样式 zxing-android-embedded 使用的App有：春雨医生，芒果TV 多媒体 框架名称 功能描述 ijkplayer Bilibili开源的视频播放器 DanmakuFlameMaster Android开源弹幕引擎·烈焰弹幕使，使用的App有：网易新闻 Vitamio 一款全能多媒体开发框架，全面支持硬件解码与 GPU 渲染 FFmpeg 一个基于C语言的多媒体开源框架 百度媒体云 基于百度视频处理、人脸识别、语音等技术媒体相关的整体解决方案 ExoPlayer Google开源的视频播放器 KSYStreamer_Android金山云Android采集推流SDK(Livestream SDK)，支持内置/自定义美颜(Beauty Filter)、美声(Beauty Voice)、软硬编(Software/Hardware Encoder) 、网络自适应(Network Auto Adapt)、混音(Voice Mixer)、混响(Reverb)、画中画(PIP)、连麦(RTC)、动态贴纸(Sticker) #KSYMediaPlayer_Android金山云Android播放SDK（KSYUN Live Streaming player SDK），支持RTMP HTTP-FLV HLS 协议（supporting RTMP HTTP-FLV HLS protocol），直播延时2-3秒（Living delay 2 or 3 seconds），supporting jitter control，software&amp;hardware decode #KSYLive_AndroidAndroid播放&amp;推流融合版本[Android Play and LiveStreaming SDK] 直播延时2-3秒（Living delay 2 or 3 seconds），supporting jitter control，software&amp;hardware decode, 支持内置/自定义美颜(Beauty Filter)、美声(Beauty Voice)、软硬编(Software/Hardware Encoder) 、网络自适应(Network Auto Adapt)、混音(Voice Mixer)、混响(Reverb)、画中画(PIP) #KSYMediaPlayer_Android 金山云Android播放SDK（KSYUN Live Streaming player SDK），支持RTMP HTTP-FLV HLS 协议（supporting RTMP HTTP-FLV HLS protocol），直播延时2-3秒（Living delay 2 or 3 seconds），supporting jitter control，software&amp;hardware decode #MD360Player4AndroidAndroid上全景视频渲染的库 汉语转拼音 框架名称 功能描述 pinyin4j https://github.com/belerweb/pinyin4j TinyPinyin 适用于Java和Android的快速、低内存占用的汉字转拼音库。 PinyinSearchLibrary The library of PinyinSearch,a Java Library which provide data parsing methods, data matching method and so on for T9 search and Qwerty search.PinyinSearch = T9Search + QwertySearch com.pinyin4android 唯品会使用 下载 框架名称 功能描述 MultiThreadDownload 使用的App有：薄荷 FileDownloader Android 文件下载引擎，稳定、高效、灵活、简单易用 RxDownload 基于RxJava和Retrofit打造的下载工具, 支持多线程下载和断点续传, 智能判断是否支持断点续传等功能 file-downloader 安卓上轻量级Http/Https文件下载框架，我的目标是让安卓文件下载越简单越好，尽可能以最简洁明了的方式完成复杂需求。 动画 框架名称 功能描述 facebook:rebound A Java library that models spring dynamics and adds real world physics to your app ViewAnimator A fluent Android animation library Material-Animations Android Transition animations explanation with examples AndroidViewAnimations Cute view animation collection. ListViewAnimations An Android library which allows developers to easily add animations to ListView items recyclerview-animators An Android Animation library which easily add itemanimator to RecyclerView items. RecyclerViewItemAnimators An Android library which provides simple Item animations to RecyclerView items AnimationEasingFunctions Android Animation Easing Functions. Let’s make animation more real! BaseAnimation BaseAnimation收集网络Android相关动画集合，自定义控件等，近200多种源码 FragmentAnimations 3D animations for support-v4 Fragment transition. AnimatedEditText Androids EditText that animates the typed text. EditText is extended to create AnimatedEditText and a PinEntryEditText. ViewPagerTransforms Library containing common animations needed for transforming ViewPager scrolling for Android v13+ lottie-android Render After Effects animations natively on Android and iOS Android选择器类库包括日期时间选择器、单项选择器、地址选择器、颜色选择器、文件目录选择器、数字选择器、星座选择器等 框架名称 功能描述 material-calendarview material design 风格的日历控件使用的App有：薄荷 MaterialDateTimePicker Pick a date or time on Android in style，使用的App有：薄荷 android-times-square Standalone Android widget for picking a single date from a calendar view. AndroidPicker 安卓选择器类库，包括日期时间选择器、单项选择器、地址选择器、颜色选择器、文件目录选择器、数字选择器、星座选择器等。 Android-PickerView 仿iOS的PickerView控件，有时间选择和选项选择并支持一二三级联动效果 WheelPicker Simple and fantastic wheel view in realistic effect for android. Android-FilePicker Photopicker and document picker for android NumberPickerView another NumberPicker with more flexible attributes on Android platform Android-PickerView-Library Simple PickerView for Android RajawaliRajawali是一个用于Android应用的3D引擎，基于 OpenGL ES 2.0。它可以用于普通的应用程序，以及实时壁纸。使用的App有：网易新闻 ##aspectjAspectJ是一个面向切面的框架，它扩展了Java语言。使用的App有：网易新闻 Apache Thrift可伸缩的跨语言服务开发框架，使用的App有：网易新闻 ##Fabric SDKhttps://realm.io/cn/news/oredev-ty-smith-building-android-sdks-fabric/?utm_source=tuicool&amp;utm_medium=referral ##GNU TroveTrove 是一个快速、轻量级 Collection 类的集合。Trove 提供所有标准 java.util Collections 类的更快的版本以及能够直接在原语（primitive）（例如包含 int 键或值的 Map 等）上操作的 Collections 类的版本。使用的App有：网易新闻 ##Java-WebSocket简单的说，websocket就是用来做网页聊天以及手机推送用的。使用的App有薄荷 以前不管使用HTTP轮询或使用TCP长连接等方式制作在线聊天系统，都有天然缺陷，随着Html5的兴起，其中有一个新的协议WebSocket protocol，可实现浏览器与服务器全双工通信(full-duplex)，它可以做到：浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。这个新的协议的特点正好适合这种在线即时通信。 现很多网站为了实现即时通讯，所用的技术都是轮询(polling)。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客服端的浏览器。这种传统的HTTP request 的模式带来很明显的缺点 – 浏览器需要不断的向服务器发出请求，然而HTTP request 的header是非常长的，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽。 而最比较新的技术去做轮询的效果是Comet – 用了AJAX。但这种技术虽然可达到全双工通信，但依然需要发出请求。 在 WebSocket API，浏览器和服务器只需要要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。 ##org.eclipse.mat内存分析。使用的App有薄荷，网易新闻 ##CommonAdapter 使用的App有：薄荷 ##Android-Best-Practices ##JKeyboardPanelSwitchAndroid键盘面板冲突 布局闪动处理方案 起源，之前在微信工作的时候，为了给用户带来更好的基础体验，做了很多尝试，踩了很多输入法的坑，特别是动态调整键盘高度，二级页面是透明背景，魅族早期的Smart bar等, 后来逐一完善了，考虑到拥抱开源，看业界还是有很多应用存在类似问题。就有了这个repo 使用的App有：薄荷 ##美洽最快连接你与顾客 美洽，在线客服软件的漂亮之选 MeiqiaSDK-Android https://github.com/Meiqia/MeiqiaSDK-Android 使用的App有：薄荷 ##logger使用的App有：薄荷 ##DeepLinkDispatch最常见的应用就是在网页中跳转到App的某个页面，电商类应用可是都用了的。根据data跳转不同的页面 使用的App有：京东 ##Crouton Context sensitive notifications for Android ##Bolts-Android 一个底层库集合 ##com.arcsoft.livebroadcast ##ReLinkerRelink是一个加载Android so文件(shared library)的一个库。 在Android平台上加载本地库的危险性 ##kik CHAT ON KIK Kik lets you connect with friends,groups and the world around youthrough chat. And now, you canchat with bots too. ##nanohttpd 嵌入式HTTP服务器 ，NanoHTTPD是一个免费、轻量级的(只有一个Java文件) HTTP服务器,可以很好地嵌入到Java程序中。支持 GET, POST, PUT, HEAD 和 DELETE 请求，支持文件上传，占用内存很小。可轻松定制临时文件使用和线程模型。 ##i-jettyjetty经过交叉编译移植到android平台的web服务器软件，它可以部署web网站 ##com.googlecode.mp4parser ##Spartacom.hp.hpl.sparta：XML、DOM、XPath解析器，http://sparta-xml.sourceforge.net/ ##JRegexJRegex：jregex：正则表达式库 ##NativeSubprocess 唯品会使用 NativeSubprocess 是一个可以让你在android 程序中创建linux子进程并执行你的java代码的so库。由于市面上典型的内存清理工具只清理apk 包关联的进程，而不会处理linux原生进程，所以NativeSubprocess 可以做什么您懂的！ ##androidqueryAndroid-Query（AQuery）是一个轻量级的开发包，用于实现 Android 上的异步任务和操作 UI 元素，可让 Android 应用开发更简单、更容易，也更有趣。 唯品会使用，https://github.com/androidquery/androidquery ##MarsDaemon进程常驻，进程保活 唯品会使用 https://github.com/Marswin/MarsDaemon ##SA-iSecuritySA-iSecurity 客户端安全输入系统，唯品会使用 ##口碑推荐平台TapReasonTapReason提供了一款无广告的App增长解决方案。他们的广告是最值得信赖的，因为这些广告都是来自于好友或同事的推荐。唯品会使用 ##ImageViewZoomAndroid ImageView widget with zoom and pan capabilities，春雨医生使用 ##LayoutCastCast android code and resource changes to the running application through ADB.Android SDK sucks. It’s so slow to build and run which waste me a lot of time every day. 把代码和资源文件的改动直接同步到手机上，应用不需要重启。省去了编译运行漫长的等待，比较适合真机调试的时候使用。 ##Joda-Time JodaTime 提供了一组Java类包用于处理包括ISO8601标准在内的date和time。可以利用它把JDK Date和Calendar类完全替换掉，而且仍然能够提供很好的集成。 Joda-Time主要的特点包括： 易于使用:Calendar让获取”正常的”的日期变得很困难，使它没办法提供简单的方法，而Joda-Time能够 直接进行访问域并且索引值1就是代表January。 易于扩展：JDK支持多日历系统是通过Calendar的子类来实现，这样就显示的非常笨重而且事实 上要实现其它日历系统是很困难的。Joda-Time支持多日历系统是通过基于Chronology类的插件体系来实现。 提供一组完整的功能：它打算提供 所有关系到date-time计算的功能．Joda-Time当前支持6种日历系统，而且在将来还会继续添加。有着比JDK Calendar更好的整体性能等等。 https://github.com/JodaOrg/joda-time ##msgpack MessagePack是一个基于二进制高效的对象序列化Library用于跨语言通信。它可以像JSON那样，在许多种语言之间交换结构对象；但是它比JSON更快速也更轻巧。 比Google Protocol Buffers还要快4倍 https://github.com/msgpack/msgpack-java ##scribejava ScribeJava 是一个简单的 Java 实现的 OAuth/OAuth2 库。 ##LogbackLogback是由log4j创始人Ceki Gülcü设计的又一个开源日志组件。logback当前分成三个模块：logback-core,logback- classic和logback-access。 ##frame-video-view No more issues with VideoView ##JakeWharton scalpel Jake Wharton，Android开发领域传奇一般的存在，熟悉Android开发的同学应该都听说过，即便没有，也应该会经常用到他主导或参与贡献的开源 项目，他在GitHub上开源了多个Android兼容性、依赖注入相关的知名项目，目前就职Square, 也参与贡献了Square公司开源的诸如Retrofit, okhttp等热门项目。 Jake大神喜欢以刀命名自己的项目，可能他觉得这能很好的表达它们作为开发利器的犀利程度，不过没准他也很喜欢中国武侠小说呢。 他最有名的两把刀，一把是Dagger, 匕首，一个依赖注入框架，用来解耦开发中各模块依赖的，最早由他开发与维护，后来转给Google维护；另一把是同样大名鼎鼎的ButterKnife， 黄油刀，有了它，你再也不用写findViewById了，以后有机会给大家详细介绍它们。 今天的主角是它们不那么知名的小兄弟，Scalpel，这把非常酷炫实用的解剖刀。 他其实就是实现了一个三维效果的界面布局层次展示，不需要手机连接开发设备，只需要简单几行代码将其集成到你的应用中，即可开启酷炫之旅，它提供的功能包括： 通过setLayerInteractionEnabled(boolean)可开启与关闭此功能。 通过setDrawViews(boolean)可控制是否绘制View, 也就是说它可以仅仅是个简单的布局线框图，也可以是色彩丰富的真实效果图。 通过setDrawIds(boolean)可控制是否显示各控件的Id, 你就能知道你自己正在调试的那个控件到底在哪了？ 通过setChromeColor，setChromeShadowColor可自定义线框图的颜色，随你喜欢。 ##material-camerahttps://github.com/afollestad/material-camera ##hawkAndroid的安全、简单Key-Value存储 bugsnagBugsnag crash reporting for Android apps ，Bugsnag exception reporter for Android goldengateAn Android annotation processor for generating type safe javascript bindings (Bridges) Helpshiftslf4jSLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。 Nuwa热修复Nuwa, pure java implementation, can hotfix your android application. Android 热修复Nuwa的原理及Gradle插件源码解析 megvii人脸识别RadiusNetworkshttp://www.radiusnetworks.com/ https://github.com/RadiusNetworks Swiper 开源，免费，强大的移动端触摸滑动插件 Swiper常用于移动端网站的内容触摸滑动 Swiper3依然拥有progress，这是制作3D切换效果的利器 在Swiper上加些小动画，制作高大上的展示 NettyNetty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 也就是说，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。 “快速”和“简单”并不用产生维护性或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。 ##cheesesquare：Demos the new Android Design library ##FBReaderJ FBReaderJ是一个Android 平台上的电子书阅读器。这是一个Java版的FBReader图书阅读器的克隆。 FBReaderJ支持多种电子书格式： oeb ， epub ，和fb2 。直读从zip、tar和gzip等格式 ##hawtdispatch HawtDispatch is a small ( less than 100k ) thread pooling and NIO handling framework API modeled after the libdispatch API. libdispatch is the API that Apple created to power the Grand Central Dispatch (GCD) technology in OS X. It allows you to more easily develop multi-threaded applications which can more easily scale to take advantage of all the processing cores on your machine. At the same time, its development model simplifies solving many of the problems that plague multi-threaded NIO development. ##ZeroMQ 一个轻量级消息内核 ##autobahn-androidWebSocket &amp; WAMP in Java for Android RobotiumRobotium 是一款国外的Android自动化测试框架，主要针对Android平台的应用进行黑盒自动化测试，它提供了模拟各种手势操作（点击、长 按、滑动等）、查找和断言机制的API，能够对各种控件进行操作。Robotium结合Android官方提供的测试框架达到对应用程序进行自动化的测 试。另外，Robotium 4.0版本已经支持对WebView的操作。Robotium 对Activity，Dialog，Toast，Menu 都是支持的。 One Step &amp; Big Bang 锤子科技的一小步，智能手机进化的一大步 什么是一步（One Step）？通过拖拽完成将信息发送至应用或联系人的动作，节省了在不同应用之间切换的诸多步骤，第一次打通了手持设备中应用间的边界 进一步了解 One Step 什么是大爆炸（Big Bang）？用拇指大面积按压屏幕中的文字，Big Bang 会将你按住的那一段文字全部“炸”开并且按照语义智能拆分成易于选取的独立的字和词，由你随心所欲地选择，并可直接搜索、分享和复制。Big Bang 开创性地解决了在手机这样的小屏幕上难于处理文字的弊端 进一步了解 Big Bang]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>开源框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发常用第三方平台]]></title>
    <url>%2F2017%2F05%2F01%2Fopen%2F%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[1. 性能监测 平台名称 说明 LeakCanary square出品的检测内存泄露 博睿bonree 领先的应用性能管理服务提供商,性能监测,移动监测…平台 听云 国内权威的应用性能监控平台 2. 移动支付 平台名称 说明 支付宝 阿里巴巴支付平台 微信支付 微信支付平台 银联支付 中国银联手机支付平台 tenpay QQ财付通 umpay 联动优势支付平台 MMBilling 中国移动应用内计费SDK Ping++ 使用的App有：薄荷 3. 即时通讯 平台名称 说明 MIPUSH 小米推送，用的最多最稳定的推送服务之一 个推 手机推送服务 JPush 极光推送 百度推送 百度推送服务 MQTT MQTT协议，似乎和推送有关系 环信 信鸽 4. 语音平台 平台名称 说明 讯飞SDK 科大讯飞语音SDK 百度语音识别 百度语音识别SDK mobvoi 移动语音搜索 云知声 云知声语音处理 5. 统计分析 平台名称 说明 友盟统计 用的较多的分析统计工具 Flurry 国外流行的统计工具 百度移动统计 百度开发者中心 Cobub Razor 移动统计分析工具 google analytics google统计 lotuseed 莲子统计 Localytics 国外统计分析工具 comscore 国外的统计工具 6. 测试平台 平台名称 说明 百度云测 360代码卫士 腾讯Bugly 云测Testin Crashlytics 7. 分享平台 平台名称 说明 ShareSDK App分享库 facebook-android-sdk Facebook SDK 腾讯微信 腾讯微信SDK weiboSDK 新浪微博SDK qweibo Q版微博 t4j 网易微博开放平台 yixin 易信开放平台 人人SDK 人人网SDK 翼聊 中国电信天翼开放平台 evernote Evernote API 有道云笔记SDK 印象笔记有道云笔记SDK 8. 多媒体 平台名称 说明 CC视频 视频云平台 Vitamio 多媒体开发框架 leptonica 图像处理库 tesseract-ocr 图像OCR库 aacdecoder-android Android上的Audio (AAC) 解码器 百度媒体云 videolan Vplayer 9. 地图定位 平台名称 说明 百度定位 百度地图SDK 百度地图 百度地图SDK amap 高德地图API 图吧SDK 图吧地图API MapABC MapABC地图SDK 10. 广告平台 平台名称 说明 友盟SDK 友盟统计、自动更新、用户反馈、社会化组件 多盟 多盟平台 百度移动联盟 百度广告联盟 google ads google广告 AdChina 易传媒广告平台 AdsMogo 芒果移动广告平台 Adwo 安沃移动广告平台 mobisage 艾德思奇移动广告平台 Miaozhen 秒针第三方广告平台 AdMaster admaster广告平台 易积分 易积分移动广告平台 inmobi 国外的广告平台 点信传媒 广告平台 有米广告 万普世纪 Punchbox inmobi APPSDK APPSDK移动广告平台长期致力于为中国的开发者提供广告资源、用户资源，并提供应用优化和发展规划建议为开发者创造价值，是我们最大的价值 11. 云服务器 平台名称 说明 bmob 数据库，服务器平台，短信验证，邮件验证，第三方支付 阿里云 阿里巴巴的云服务 腾讯云 腾讯的云服务 七牛云 国内领先的企业级公有云服务商 leancloud 野狗实时后端云 12. 安全加密 平台名称 说明 爱加密 邦邦加密 360加密 13. Crashlytics一个错误代码报告分析服务https://www.zhihu.com/question/20750459http://try.crashlytics.com/使用的App有：网易新闻 14. 个信手机资讯推送广告领导者，个信是个推旗下智能场景入口级营销平台；个信孕育个推，又始于个推。使用的App有：网易新闻 15. MediaV聚胜万合16. 魔窗MagicWindow使用的App有：薄荷，http://www.magicwindow.cn/ 一键唤醒App内指定页与一般链接点击“打开App”后只能达到首页完全不同，魔窗的mLink直接把用户送达至App内的指定相关页面。 什么是mLink?企业级深度链接（Deeplink）解决方案，让App能像Web一样通过URL进行任意内容的分发、管理和一链直达 。 场景还原（Deferred Deeplink）大幅提升未安装App人群的转化率每个新用户打开App都停留在首页已经过时！mLink为您App的用户带来所见即所得的体验，在新用户首次使用App时直达想看的相关内容页，大幅提升用户参与度和转化率！ 17. CocosPlay手机页游最佳解决方案！ 18. AppsFlyer - 移动应用跟踪与归因分析移动应用跟踪与归因分析平台帮助应用开发者、品牌商和广告代理商跟踪并优化各自的用户获取渠道。 成为移动归因分析的标杆，AppsFlyer 是移动广告归因与分析领域的市场领导者，能够帮助营销人员准确找到自身定位、优化广告支出并增加其投资回报 19. Twitter Fabric20. mAppTracker-移动用户流量审计]]></content>
      <categories>
        <category>open</category>
      </categories>
      <tags>
        <tag>第三方平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb开发概述]]></title>
    <url>%2F2017%2F05%2F01%2Fjavaweb%2FJavaWeb%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1. Web概述WEB，在英语中web即表示网页的意思，它用于表示Internet主机上供外界访问的资源。javaweb：使用java技术开发web页面。供浏览器访问的项目 Internet上供外界访问的Web资源分为： 静态web资源（如html 页面）：指web页面中供人们浏览的数据始终是不变的，静态的，不同的人在不同的时间来访问时都是相同的内容 动态web资源：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。 静态web资源开发技术：Html、CSS、javaScript 常用动态web资源开发技术： JSP/Servlet、ASP、PHP等 在Java中，动态web资源开发技术统称为Javaweb，我们课程的重点也是教大家如何使用Java技术开发动态的web资源，即动态web页面。 2. WEB服务器Web服务器的作用是接收客户端的请求，给客户端作出响应。学习web开发，需要先安装一台web服务器，然后再在web服务器中开发相应的web资源，供用户使用浏览器访问。 注意：这里所说的服务器不是指服务器硬件资源，而是指服务器软件。 实验说明： 在本地计算机上随便创建一个web页面，大家可以访问到吗？ 启动tomcat服务器，把web页面放在tomcat服务器中，用户就可以访问了。 这说明什么问题？ 不管什么web资源，想被远程计算机访问，都必须有一个与之对应的网络通信程序，当用户来访问时，这个网络通信程序读取web资源数据，并把数据发送给来访者。 WEB服务器就是这样一个程序，它用于完成底层网络通迅。使用这些服务器，用户只需要关注web资源怎么编写，而不需要关心资源如何发送到客户端手中，从而极大的减轻了开发者的开发工作量。 3. 常见WEB服务器 Tomcat（Apache）：当前应用最广的JavaWeb服务器 JBoss（Redhat红帽）：支持JavaEE，应用比较广；EJB容器 GlassFish（Orcale）：Oracle开发JavaWeb服务器，应用不是很广 Resin（Caucho）：支持JavaEE，应用越来越广 Weblogic（Orcale）：要钱的！支持JavaEE，适合大型项目 Websphere（IBM）：要钱的！支持JavaEE，适合大型项目 3.1 WebLogicWebLogic是BEA公司的产品，是目前应用最广泛的Web服务器，支持J2EE规范，而且不断的完善以适应新的开发要求，启动界面如图 3.2 WebSphere另一个常用的Web服务器是IBM公司的WebSphere，支持J2EE规范，启动界面如图 3.3 Tomcat在小型的应用系统或者有特殊需要的系统中，可以使用一个免费的Web服务器：Tomcat，该服务器支持全部JSP以及Servlet规范，启动界面如图 Tomcat服务器由Apache提供，开源免费。由于Sun和其他公司参与到了Tomcat的开发中，所以最新的JSP/Servlet规范总是能在Tomcat中体现出来。当前最新版本是Tomcat8，我们课程中使用Tomcat7。Tomcat7支持Servlet3.0，而Tomcat6只支持Servlet2.5！ 4. JavaEE概述java的大方向就是JavaEE，JavaEE不仅仅是socket编程，具体包括13中核心技术。 JAVAEE的核心API与组件 JAVAEE平台由一整套服务（Services）、应用程序接口（APIs）和协议构成，它对开发基于Web的多层应用提供了功能支持，下面对JAVAEE中的13种技术规范进行简单的描述(限于篇幅，这里只进行简单的描述)： 4.1 JDBC(Java Database Connectivity) JDBC API为访问不同的数据库提供了一种统一的途径，象ODBC一样，JDBC对开发者屏蔽了一些细节问题，另外，JDCB对数据库的访问也具有平台无关性。 4.2 JNDI(Java Name and Directory Interface)JNDI API被用于执行名字和目录服务。它提供了一致的模型来存取和操作企业级的资源如DNS和LDAP，本地文件系统，或应用服务器中的对象。 4.3 EJB(Enterprise JavaBean) JAVAEE技术之所以赢得媒体广泛重视的原因之一就是EJB。它们提供了一个框架来开发和实施分布式商务逻辑，由此很显著地简化了具有可伸缩性和高度复杂的企业级应用的开发。EJB规范定义了EJB组件在何时如何与它们的容器进行交互作用。容器负责提供公用的服务，例如目录服务、事务管理、安全性、资源缓冲池以及容错性。但这里值得注意的是，EJB并不是实现JAVAEE的唯一途径。正是由于JAVAEE的开放性，使得有的厂商能够以一种和EJB平行的方式来达到同样的目的。 4.4 RMI(Remote Method Invoke) 正如其名字所表示的那样，RMI协议调用远程对象上方法。它使用了序列化方式在客户端和服务器端传递数据。RMI是一种被EJB使用的更底层的协议。 4.5 Java IDL/CORBA 在Java IDL的支持下，开发人员可以将Java和CORBA集成在一起。他们可以创建Java对象并使之可在CORBA ORB中展开, 或者他们还可以创建Java类并作为和其它ORB一起展开的CORBA对象的客户。后一种方法提供了另外一种途径，通过它Java可以被用于将你的新的应用和旧的系统相集成。 4.6 JSP(Java Server Pages) JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端所请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。 4.7Java Servlet Servlet是一种小型的Java程序，它扩展了Web服务器的功能。作为一种服务器端的应用，当被请求时开始执行，这和CGI Perl脚本很相似。Servlet提供的功能大多与JSP类似，不过实现的方式不同。JSP通常是大多数HTML代码中嵌入少量的Java代码，而servlets全部由Java写成并且生成HTML。 4.8 XML(Extensible Markup Language) XML是一种可以用来定义其它标记语言的语言。它被用来在不同的商务过程中共享数据。 XML的发展和Java是相互独立的，但是，它和Java具有的相同目标正是平台独立性。通过将Java和XML的组合，您可以得到一个完美的具有平台独立性的解决方案。 4.9 JMS(Java Message Service) JMS是用于和面向消息的中间件相互通信的应用程序接口(API)。它既支持点对点的域，有支持发布/订阅(publish/subscribe)类型的域，并且提供对下列类型的支持：经认可的消息传递,事务型消息的传递，一致性消息和具有持久性的订阅者支持。JMS还提供了另 一种方式来对您的应用与旧的后台系统相集成。 4.10、JTA(Java Transaction Architecture) JTA定义了一种标准的API，应用系统由此可以访问各种事务监控。 4.11、JTS(Java Transaction Service) JTS是CORBA OTS事务监控的基本的实现。JTS规定了事务管理器的实现方式。该事务管理器是在高层支持Java Transaction API (JTA)规范，并且在较底层实现OMG OTS specification的Java映像。JTS事务管理器为应用服务器、资源管理器、独立的应用以及通信资源管理器提供了事务服务。 4.12 JavaMail JavaMail是用于存取邮件服务器的API，它提供了一套邮件服务器的抽象类。不仅支持SMTP服务器，也支持IMAP服务器。 4.13 JAF(JavaBeans Activation Framework)JavaMail利用JAF来处理MIME编码的邮件附件。MIME的字节流可以被转换成Java对象，或者转换自Java对象。大多数应用都可以不需要直接使用JAF 5. Tomcat服务器5.1 Tomcat 的下载与安装下载地址：http://tomcat.apache.org/ 安装目录不能包含中文和空格 JAVA_HOME环境变量指定Tomcat运行时所要用的jdk所在的位置，注意，配到目录就行了，不用指定到bin 端口占用问题：netstat -ano命令查看端口占用信息 Catalina_Home环境变量：startup.bat启动哪个tomcat由此环境变量指定，如果不配置则启动当前tomcat，推荐不要配置此环境变量 5.2 Tomcat 的目录层次结构 bin–存放tomcat启动关闭所用的批处理文件 conf–tomcat的配置文件，最终要的是server.xml lib–tomcat运行所需jar包 logs–tomcat运行时产生的日志文件 temp–tomcat运行时使用的临时目录，不需要我们关注 webapps–web应用所应存放的目录 work–tomcat工作目录，后面学jsp用到 5.3 启动和关闭Tomcat在启动Tomcat之前，我们必须要配置环境变量： JAVA_HOME：必须先配置JAVA_HOME，因为Tomcat启动需要使用JDK CATALANA_HOME：如果是安装版，那么还需要配置这个变量，这个变量用来指定Tomcat的安装路径，例如：F:\apache-tomcat-7.0.42 启动：进入%CATALANA_HOME%\bin目录，找到startup.bat，双击即可 关闭：进入%CATALANA_HOME%\bin目录，找到shutdown.bat，双击即可 startup.bat会调用catalina.bat，而catalina.bat会调用setclasspath.bat，setclasspath.bat会使用JAVA_HOME环境变量，所以我们必须在启动Tomcat之前把JAVA_HOME配置正确。 启动问题：点击startup.bat后窗口一闪即消失：检查JAVA_HOME环境变量配置是否正确； 5.4 配置端口号打开%CATALANA_HOME%\conf\server.xml文件 http默认端口号为80，也就是说在URL中不给出端口号时就表示使用80端口。当然你也可以修改为其它端口号。 当把端口号修改为80后，在浏览器中只需要输入：http://localhost就可以访问Tomcat主页了 6. 虚似主机一个真实主机可以运行多个网站，对于浏览器来说访问这些网站感觉起来就像这些网站都运行在自己的独立主机中一样，所以，我们可以说这里的每一个网站都运行在一个虚拟主机上，一个网站就是一个虚拟主机 6.1 配置虚似主机如需在WEB服务器中配置一个网站，需使用Host元素进行配置 在server.xml中&lt;Engine&gt;标签下配置&lt;Host&gt;,其中name属性指定虚拟主机名，appBase指定虚拟主机所在的目录 只在servlet.xml中配置Hosts，还不能是其他人通过虚拟主机名访问网站，还需要在DNS服务器上注册一把，我们可以使用hosts文件模拟这个过程 默认虚拟主机：在配置多个虚拟主机的情况下，如果浏览器使用ip地址直接访问网站时，该使用哪个虚拟主机响应呢？可以在&lt;Engine&gt;标签上设置defaultHost来指定1&lt;Host name=”site1” appBase=”c:\app”&gt;&lt;/Host&gt; 配置的主机(网站)要想被外部访问，必须在DNS服务器或windows系统中注册 由于浏览器访问地址时,需要将地址翻译成对应的ip才能找到服务器,这其中翻译的过程是由dns服务器来实现的.我们在做实验的时候没有办法去修改dns服务器,此时可以使用hosts文件模拟dns的功能,从而完成实验 缺省虚拟主机：如果来访者是通过ip来访问,这个时候服务器无法辨别当前要访问的是哪台虚拟主机中的资源,此时访问缺省虚拟主机。缺省虚拟主机可以在server.xml中engin标签上通过defaultHost属性进行配置 6.2 访问过程 7. WEB应用程序WEB应用程序指供浏览器访问的程序，通常也简称为web应用，是为了提供某一特定功能而按照一定方式组织起来的web资源的组合。 一个web应用由多个静态web资源和动态web资源组成，如 html、css、js文件 Jsp文件、java程序、支持jar包、 配置文件 一个web应用所使用的web资源我们通常使用目录进行组织，这个目录我们通常称为 web应用所在的目录 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射。 web资源不能直接交给虚拟主机，需要按照功能组织用目录成一个web应用再交给虚拟主机管理 7.1 web应用的目录结构 静态资源和JSP文件都可以直接放置在web应用的目录下,直接放在web应用下的内容,浏览器可以直接访问到 WEB-INF：可以没有，但是最好有，如果有则一定要保证他的目录结构是完整的。放置在WEB-INF目录下的所有资源浏览器没有办法直接进行访问 classes：动态web资源运行时的class文件要放在这个目录下lib：动态web资源运行时所依赖的jar包要放在这个目录下web.xml：整个web应用的配置文件,配置主页/Servlet的映射/过滤器监听器的配置都需要依赖这个文件进行 7.2 web.xml文件的作用 某个web资源配置为web应用首页 将servlet程序映射到某个url地址上 为web应用配置监听器 为web应用配置过滤器 但凡涉及到对web资源进行配置，都需要通过web.xml文件 7.3 web应用的虚拟目录映射在server.xml的&lt;Host&gt;标签下配置&lt;Context path=”虚拟路径” docBase=”真实路径”&gt;如果path=””则这个web应用就被配置为了这个虚拟主机的默认web应用 在tomcat/conf/引擎名/虚拟主机名 之下建立一个.xml文件，其中文件名用来指定虚拟路径，如果是多级的用#代替/表示，文件中配置&lt;Context docBase=”真实目录”&gt;，如果文件名起为ROOT.xml则此web应用为默认web应用 直接将web应用放置到虚拟主机对应的目录下，如果目录名起为ROOT则此web应用为默认web应用 如果三处都配置默认，web应用则server.xml &gt; config/…/xx.xml &gt; webapps 7.4 其它问题 打war包，方式一：jar -cvf news.war * 方式二：直接用压缩工具压缩为zip包，该后缀为.war 通用context和通用web.xml，所有的&lt;Context&gt;都继承子conf/context.xml,所有的web.xml都继承自conf/web.xml reloadable让tomcat自动加载更新后的web应用，当java程序修改后不用重启，服务器自动从新加载，开发时设为true方便开发，发布时设为false，提高性能 Tomcat管理平台，可以在conf/tomcat-users.xml下配置用户名密码及权限 8. Tomcat体系架构 9. WEB开发的前景9.1 软件开发的两种架构：C/S和B/S 9.2 C/S B/S之争 讲到这个地方，很多同学就没劲了，为什么呢？搞半天就是做网站哟，没点意思。所以这里特意讲下web开发的前景，免得有些同学像菜鸟一样，以为自己很懂，其实啥都不懂，说些傻话。要讲web开发前景，首先要强调一点，你学javaweb，开发的是程序，别人通过浏览器，访问的是你写的程序，程序为用户完成服务后，再把结果通过写到浏览器中显示，思想不要停留在90年代，以为通过浏览器看到的都是网页。要注意，将来网站都是用来提供服务的，像你们思想中的网页，只有网站提供的一种服务而已。 再者，要讲web开发前景，就不得不提软件开发的两种架构之争了，一种是c/s架构，一种是b/s架构。 何为b/s架构呢？（浏览器/服务器架构）就是指数据和程序都在服务器端，客户端通过浏览器访问程序并获取数据。这种架构的最大好处就是服务器端程序一旦修改，所有客户端访问的都最新的程序，开发人员只管维护服务器就行了，不用管客户端维护的事。这种架构的最大缺点就是，由于客户端都是使用浏览器来访问服务器程序的，数据最终显示在浏览器中，浏览器有多强，数据就能显示成什么样式，数据的显示样式最终由浏览器决定。由于这种特性，所以b/s架构很少用来开发一些对显示有特殊要求的程序，例如游戏，现在的浏览器很难做到把数据显示成一个人，拿着一把刀，到处找人PK，并且还不卡。 何为c/s架构呢？就是指程序运行在客户机上，数据在服务器上。这种架构有一个很大的毛病，就是程序一旦修改，需要更新所有的客户机程序，客户机多，维护的工作量相当恐怖。这种架构的优点是：由于数据的计算在客户机上，服务器的压力小，并且由于数据的显示也由程序员自己编写gui程序完成，显示不受限制。所以c/s架构适合用于开发像游戏这样的程序。 但是，随着网络带宽的不断提升，云计算概念的提出，浏览器只要足够强大，c/s架构立马就会被淘汰，不仅c/s架构会被淘汰，软件最终都会消失、操作系统都可以没有，最终将会是b/s架构的天下，也就是浏览器+搜索引擎的天下。所有现在桌面软件提供的功能，最后都由网站提供，也就是说，将来打开电脑就是一个浏览器，想要什么服务，通过搜索引擎一找，就可以在网上找到相应的服务，用就是了。所以web开发人员是现在最流行的岗位。]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb开发入门]]></title>
    <url>%2F2017%2F05%2F01%2Fjavaweb%2FJavaWeb%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JavaWeb开发笔记 十年生死两茫茫，不思量，自难忘，华年短暂，陈辞岁月悠悠伤，满腔热血已芜荒，展未来，后生强，战战兢兢，如履薄冰心彷徨，青丝化雪、鬓角成霜，已是英雄迟暮，人生怎慷慨激昂？ GitHub托管https://github.com/JackChen1999/JavaWeb 请读者点击Star进行关注并支持！ 在线阅读https://alleniverson.gitbooks.io/javaweb/content 目录 1. JavaScript 2. XML解析器 3. JavaWeb开发入门 4. Http协议 5. HTTP协议详解 6. HTTP响应报文与工作原理详解 7. Servlet 8. 请求和响应 9. Cookie和Session 10. MySQL数据库 11. MySQL数据库：SQL语句 12. MySQL数据库：完整性约束 13. 用JDBC操作数据库 14. JDBC之数据库连接池 15. JDBC之事务 16. 上传下载文件 17. 酷炫的文件上传技术 18. JavaMail邮件开发 19. 过滤器Filter 20. AJAX 21. JSP入门 22. JSTL标签库 23. MVC设计模式 24. 在线支付 25. Jquery 关注我 Email：&#x38;&#49;&#x35;&#x37;&#x31;&#50;&#55;&#51;&#x39;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109; CSDN博客：Allen Iverson 新浪微博：AndroidDeveloper GitHub：JackChan1999 GitBook：alleniverson 个人博客：JackChan 如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作！ 微信赞赏支持 支付宝赞赏支持]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式]]></title>
    <url>%2F2017%2F05%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java设计模式Sunny在CSDN技术博客中陆续发表了100多篇与设计模式学习相关的文章，涵盖了七个面向对象设计原则和24个设计模式（23个GoF设计模式 + 简单工厂模式），为了方便大家学习，现将所有文章的进行了整理，方便大家下载阅读，希望能给各位带来帮助！ 在线阅读 PDF、Mobi、ePub下载 源码下载 PPT课件下载 本书编辑 作者：刘伟 刘伟(Sunny)，中南大学计算机应用技术博士，国家认证系统分析师（2005年），国家认证系统架构设计师（2009年，全国第四名），高级程序员，数据库系统工程师，MCSE，MCDBA，CASI专业顾问与企业内训讲师。具有十多年软件开发、项目管理及教育培训经验，曾在NIIT（印度国家信息技术学院）担任高级讲师，主持和参与30多个软件项目的开发工作，并给国内多家公司提供软件开发、软件设计等培训服务，现主要致力于软件工程、数据挖掘等领域的教学、推广和研究工作。技术专长：软件架构、设计模式、UML、OOAD、数据挖掘等。已出版设计模式书籍四本：《设计模式》（清华大学出版社，2011年）、《设计模式实训教程》（清华大学出版社，2012年）、《设计模式的艺术——软件开发人员内功修炼之道》（清华大学出版社，2013年）、《C#设计模式》（清华大学出版社，2013年）。架构师之家www.chinasa.info站长。E-mail:weiliu_china@126.com，微博地址：http://weibo.com/csusunny 更多干货，请关注：http://blog.csdn.net/axi295309066 目录 前言 UML建模技术 深入浅出UML类图 从招式与内功谈起——设计模式概述 面向对象设计原则 工厂三兄弟之简单工厂模式 工厂三兄弟之工厂方法模式 工厂三兄弟之抽象工厂模式 确保对象的唯一性——单例模式 对象的克隆——原型模式 复杂对象的组装与创建——建造者模式 不兼容结构的协调——适配器模式 处理多维度变化——桥接模式 树形结构的处理——组合模式 扩展系统功能——装饰模式 深入浅出外观模式 实现对象的复用——享元模式 设计模式之代理模式 请求的链式处理——职责链模式 请求发送者与接收者解耦——命令模式 自定义语言的实现——解释器模式 遍历聚合对象中的元素——迭代器模式 协调多个对象之间的交互——中介者模式 撤销功能的实现——备忘录模式 对象间的联动——观察者模式 处理对象的多种状态及其相互转换——状态模式 算法的封装与切换——策略模式 模板方法模式深度解析 操作复杂对象结构——访问者模式 设计模式与足球 多人联机射击游戏中的设计模式应用 设计模式综合实例分析之数据库同步系统 23 种设计模式设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。本文将介绍23种设计模式。 创建型模式 5种单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式 结构型模式 7种适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式 行为型模式 11种策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 GitHub托管https://github.com/JackChen1999/DesignPattern 请读者点击Star进行关注并支持！ 在线阅读https://alleniverson.gitbooks.io/design-pattern/content 设计模式 前言 迈出从3K到1W的重要一步——掌握设计模式 设计模式中类的关系 谈一谈自己对依赖、关联、聚合和组合之间区别的理解 设计模式六大原则 单一职责原则 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 开闭原则 面向对象六大原则1 面向对象六大原则2 软件设计之高内聚低耦合 23种设计模式 单例模式1 单例模式2 单例模式3 单例模式讨论篇：单例模式与垃圾回收 工厂方法模式 抽象工厂模式 建造者模式 Builder构造者设计模式 原型模式 创建类模式总结篇 模版方法模式 中介者模式 观察者模式1 观察者模式2 访问者模式 访问者模式讨论篇：java的动态绑定与双分派 命令模式 责任连模式 策略模式 迭代器模式 解释器模式 备忘录模式 适配器设计模式 享元模式 装饰者模式 Android源码设计模式分析 单例模式1 单例模式2 简单工厂模式 抽象工厂模式 工厂方法模式 Builder模式1 Builder模式2 外观模式 模板方法1 模板方法2 策略模式 代理模式 迭代器模式 适配器模式 ListView的适配器模式 ListView的观察者模式 责任链模式 命令模式 桥接模式 原型模式1 原型模式2 MVC、MVP、MVVM设计模式的比较]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FAndroid%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Android 开源项目源码解析android-open-project-analysis 这是一个协作项目，最终多数开源库原理解析会在这里分享出来 Android源码设计模式分析项目android_design_patterns_analysis 该项目通过分析Android系统中的设计模式来提升大家对设计模式的理解，从源码的角度来剖析既增加了对Android系统本身的了解，也从优秀的设计中领悟模式的实际运用以及它适用的场景，避免在实际开发中的生搬硬套。 Android知名开源库简单实现以及设计分析simple-android-opensource-framework 该项目通过分析并实现Android平台知名开源框架的简单版本来提升自我，并达到深入理解各大开源库的核心原理的目的。稳定、强大的开源库一般都较为复杂，比如Universal-ImageLoader，因此简版开源库不需要完全按照原版来实现，只需要把核心架构、原理实现，并且做到可运用到实际项目中即可。在实现开源库简版的同时，作者需要写一系列文章来剖析它的实现原理以及为什么要这么设计，在提升自我的同时将框架的设计与实现、领悟分享给他人，希望大家在提升自我的同时对行业做出一些贡献。 Android SDK 源码解析AndroidSdkSourceAnalysis android sdk 源码解析——旨在帮助Android开发者更好的学习Android！我们只是一群普通的程序员，但是，我们热爱分享，想热热闹闹的玩点有意义的事！如果你也想陪我们一起愉快的玩耍，欢迎加入我们！Issues认领分析文章！ PDF、Mobi、ePub下载 Android源码分析.pdf 在线阅读 GitHub托管 目录 前言 Android源码分析 公共技术点 公共技术点之Java反射 公共技术点之Java注解 公共技术点之Java动态代理 公共技术点之View绘制流程 公共技术点之View事件传递 公共技术点之Android动画基础 Android源码分析 第1期 AsyncTask源码分析 Binder源码分析 BottomSheets源码解析 CompoundButton源码分析 CoordinatorLayout源码分析 FloatingActionButton源码解析 LruCache源码解析 Scroller源码解析 SearchView源码解析 SwipeRefreshLayout TabLayout源码解析 TextView源码解析 ViewDragHelper源码解析 Android源码分析 第2期 Bundle源码解析 Handler源码解析 LayoutInflater源码解析 LocalBroadcastManager源码解析 MediaPlayer源码分析 NavigationView源码解析 NestedScrolling事件机制源码解析 NestedScrollView源码解析 ScrollView源码解析 Service源码解析 SharePreferences源码解析 SQLiteOpenHelper源码解析 TextInputLayout源码解析 Android源码分析 第3期 Android Lock Pattern 源码解析 Android Universal Image Loader 源码分析 android-Ultra-Pull-To-Refresh 源码解析 BaseAdapterHelper 源码分析 CalendarListView 源码解析 CircularFloatingActionMenu Cling 源码解析 Dagger 源码解析 DiscreteSeekBar 源码解析 DynamicLoadApk 源码解析 EventBus 源码解析 HoloGraphLibrary 源码解析 PagerSlidingTabStrip 源码解析 PhotoView 源码解析 Side Menu.Android 源码解析 SlidingMenu 源码解析 ViewPagerindicator 源码解析 Volley源码解析 xUtils 源码解析 Android源码设计模式分析 第4期 面向对象六大原则 Android设计模式源码解析之单例模式 Android设计模式源码解析之适配器模式 Android设计模式源码解析之桥接模式 Android设计模式源码解析之Builder模式 Android设计模式源码解析之责任链模式 Android设计模式源码解析之命令模式 Android设计模式源码解析之外观模式 Android设计模式源码解析之迭代器模式 Android设计模式源码解析之原型模式 Android设计模式源码解析之代理模式 Android设计模式源码解析之策略模式 Android设计模式源码解析之模板方法模式]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础入门]]></title>
    <url>%2F2017%2F05%2F01%2Fpython%2FPython%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Python基础入门 十年生死两茫茫，不思量，自难忘，华年短暂，陈辞岁月悠悠伤， 满腔热血已芜荒，展未来，后生强，战战兢兢，如履薄冰心彷徨， 青丝化雪、鬓角成霜，已是英雄迟暮，人生怎慷慨激昂？ GitHub托管主页https://github.com/JackChan1999/Python2-Course 请读者点击Star进行关注并支持！ 在线阅读https://alleniverson.gitbooks.io/python2-course/content/ 目录 前言 Python学习之路 Python简介 安装Python Python解释器 第一个Python程序 使用文本编辑器 输入和输出 Python基础 数据类型和变量 字符串和编码 使用list和tuple 条件判断和循环 使用dict和set 时间和日期 函数 定义函数 调用函数 函数的参数 递归函数 高级特性 切片 迭代 列表生成式 生成器 函数式编程 高阶函数 map和reduce filter sorted 返回函数 匿名函数 装饰器 偏函数 模块 安装第三方模块 使用模块 使用future 常用内建模块 常用第三方模块 面向对象编程 类和实例 访问限制 继承和多态 获取对象信息 面向对象高级编程 使用slots property 多重继承 定制类 使用元类 错误、调试和测试 错误处理 调试 单元测试 文档测试 IO编程 文件读写 操作文件和目录 序列化 进程和线程 多进程 多线程 分布式进程 ThreadLocal 正则表达式 常用内建模块 collections base64 struct itertools XML HTMLParser 常用第三方模块 PIL 图形界面 网络编程 TCP、IP简介 TCP编程 UDP编程 电子邮件 SMTP发送邮件 POP3收取邮件 访问数据库 使用SQLite 使用MySQL 使用SQLAlchemy Web开发 HTML简介 HTTP协议简介 WSGI接口 使用Web框架 使用模块 协程 gevent 应用案例剖析 网络抓包 实战 搭建开发环境 编写数据库模块 编写ORM 编写Model 编写Web框架 添加配置文件 编写MVC 构建前端 编写API 用户注册和登录 编写日志创建页 编写日志列表页 提升开发效率 完成Web App 部署Web App 编写移动App 关注我 Email：&#56;&#49;&#53;&#x37;&#49;&#x32;&#55;&#x33;&#x39;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d; CSDN博客：Allen Iverson 新浪微博：AndroidDeveloper GitHub：JackChan1999 GitBook：alleniverson 个人博客：JackChan 如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作！ 微信赞赏支持 支付宝赞赏支持]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thinking in Java (Java 编程思想)]]></title>
    <url>%2F2017%2F05%2F01%2Fjava%2FThinking%20in%20Java%2F</url>
    <content type="text"><![CDATA[Thinking in Java (Java 编程思想)本书来自网络，全科-不安分的码农整理成电子书，支持PDF，ePub，Mobi格式，方便大家下载阅读。 阅读地址 下载地址 github地址 GitBook 第13章没有编辑，觉得没有意义，Java的GUI现在应用少，有时间再编辑好 目录 前言 写在前面的话 引言 第1章 对象入门 1.1 抽象的进步 1.2 对象的接口 1.3 实现方案的隐藏 1.4 方案的重复使用 1.5 继承：重新使用接口 1.6 多形对象的互换使用 1.7 对象的创建和存在时间 1.8 违例控制：解决错误 1.9 多线程 1.10 永久性 1.11 Java和因特网 1.12 分析和设计 1.13 Java还是C++ 第2章 一切都是对象 2.1 用句柄操纵对象 2.2 所有对象都必须创建 2.3 绝对不要清除对象 2.4 新建数据类型：类 2.5 方法、自变量和返回值 2.6 构建Java程序 2.7 我们的第一个Java程序 2.8 注释和嵌入文档 2.9 编码样式 2.10 总结 2.11 练习 第3章 控制程序流程 3.1 使用Java运算符 3.2 执行控制 3.3 总结 3.4 练习 第4章 初始化和清除 4.1 用构建器自动初始化 4.2 方法过载 4.3 清除：收尾和垃圾收集 4.4 成员初始化 4.5 数组初始化 4.6 总结 4.7 练习 第5章 隐藏实施过程 5.1 包：库单元 5.2 Java访问指示符 5.3 接口与实现 5.4 类访问 5.5 总结 5.6 练习 第6章 类再生 6.1 合成的语法 6.2 继承的语法 6.3 合成与继承的结合 6.4 到底选择合成还是继承 6.5 protected 6.6 累积开发 6.7 上溯造型 6.8 final关键字 6.9 初始化和类装载 6.10 总结 6.11 练习 第7章 多形性 7.1 上溯造型 7.2 深入理解 7.3 覆盖与过载 7.4 抽象类和方法 7.5 接口 7.6 内部类 7.7 构建器和多形性 7.8 通过继承进行设计 7.9 总结 7.10 练习 第8章 对象的容纳 8.1 数组 8.2 集合 8.3 枚举器（反复器） 8.4 集合的类型 8.5 排序 8.6 通用集合库 8.7 新集合 8.8 总结 8.9 练习 第9章 违例差错控制 9.1 基本违例 9.2 违例的捕获 9.3 标准Java违例 9.4 创建自己的违例 9.5 违例的限制 9.6 用finally清除 9.7 构建器 9.8 违例匹配 9.9 总结 9.10 练习 第10章 Java IO系统 10.1 输入和输出 10.2 增添属性和有用的接口 10.3 本身的缺陷：RandomAccessFile 10.4 File类 10.5 IO流的典型应用 10.6 StreamTokenizer 10.7 Java 1.1的IO流 10.8 压缩 10.9 对象序列化 10.10 总结 10.11 练习 第11章 运行期类型鉴定 11.1 对RTTI的需要 11.2 RTTI语法 11.3 反射：运行期类信息 11.4 总结 11.5 练习 第12章 传递和返回对象 12.1 传递句柄 12.2 制作本地副本 12.3 克隆的控制 12.4 只读类 12.5 总结 12.6 练习 第13章 创建窗口和程序片 第14章 多线程 14.1 反应灵敏的用户界面 14.2 共享有限的资源 14.3 堵塞 14.4 优先级 14.5 回顾runnable 14.6 总结 14.7 练习 第15章 网络编程 15.1 机器的标识 15.2 套接字 15.3 服务多个客户 15.4 数据报 15.5 一个Web应用 15.6 Java与CGI的沟通 15.7 用JDBC连接数据库 15.8 远程方法 15.9 总结 15.10 练习 第16章 设计范式 16.1 范式的概念 16.2 观察器范式 16.3 模拟垃圾回收站 16.4 改进设计 16.5 抽象的应用 16.6 多重派遣 16.7 访问器范式 16.8 RTTI真的有害吗 16.9 总结 16.10 练习 第17章 项目 17.1 文字处理 17.2 方法查找工具 17.3 复杂性理论 17.4 总结 17.5 练习 附录A 使用非JAVA代码 附录B 对比C++和Java 附录C Java编程规则 附录D 性能 附录E 关于垃圾收集的一些话 附录F 推荐读物 关注我 Email：&#x38;&#49;&#53;&#55;&#x31;&#x32;&#x37;&#51;&#x39;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#x6d; CSDN博客：Allen Iverson 新浪微博：AndroidDeveloper GitHub：JackChan1999 GitBook：alleniverson 个人博客：JackChan 如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作！ 微信赞赏支持 支付宝赞赏支持]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android下的Linux]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FAndroid%E4%B8%8B%E7%9A%84Linux%2F</url>
    <content type="text"><![CDATA[1. Android目录结构 data app：用户安装的应用 data：应用的专属文件夹 system：系统的配置信息，注册表文件 anr：anr异常的记录信息 dev：devices的缩写 存放设备所对应的文件 mnt：mount的缩写 挂载在系统上的设备：sdcard，u盘 proc：硬件配置，状态信息 cpuinfo、meminfo sbin：system bin 系统重要的二进制执行文件 adbd：服务器的adb进程 system： app：存放系统应用，默认不能删除 bin：Android中可执行的linux指令文件 etc：host：主机名和ip地址的映射 fonts：Android中自带的字体 framework：存放谷歌提供的java api lib：核心功能的类库，C/C++文件 media/audio：存放Android的音效文件 tts：语音发声引擎，默认不支持中文 usr：用户设备的配置信息，键盘编码和按键编码的映射 xbin：是专为开发人员准备的二进制指令 2. Android下的Linux指令 su：superuser 切换到超级用户 rm：remove，删除文件 rm 文件名 ls：列出目录下的所有文件和文件夹 ls -l：查看文件的详细信息 ls -a：查看隐藏文件 cd：切换到某个目录 cat：查看文件内容 cat 文件名 不要cat二进制可执行文件 mv：move 修改文件名 mv 原文件名 新文件名 mkdir：创建文件夹 mkdir 文件夹名字 rmdir：删除文件夹 rmdir 文件夹名字 touch：创建新文件 touch 文件名 chmod：change mode，切换文件访问权限 chmod 777 文件名 echo：回显数据；重定向数据 echo 数据 &gt; 文件名 sleep：睡眠几秒 df：显示指定目录的容量 id：打印当前用户的id uid=0：root uid=1000：system uid=2000：shell uid=10000+：一般应用程序的id ps：列出系统中运行的所有进程 kill：杀死指定pid的进程 kill pid chown：change owner，修改拥有者 chown 0.0 文件名 mount：挂载文件系统 mount -o remount rw /：挂载当前目录为可读可写权限 mount -o remount rw /system：重新挂载指定目录 3. Android中特有的指令 am：ActivityManager，可以进行跟activity相关的操作 am start -n com.itheima.createfile/com.itheima.createfile.MainActivity：开启指定Activity am kill com.itheima.createfile：结束非前台进程 am force-stop com.itheima.createfile：结束进程 pm：PackageManager pm disable 包名：冻结指定应用 pm enable 包名：解冻指定应用 monkey -p com.itheima.createfile 1000：自动点击指定应用1000次 4. 刷模拟器，rom写文件（su） 如果想让真实手机运行这些指令，手机必须要有root权限 刷root原理：把su二进制文件拷贝到/system/bin或者/system/xbin Android刷root软件，工作的原理全部都是利用系统的漏洞实现 rom：可以理解为android系统的安装文件 把su文件和superuser.apk写入img文件 执行su指令 1Runtime.getRuntime().exec("su"); 5. 小案例：冻结解冻应用 冻结和解冻指定的应用 12RootTools.sendShell("pm disable " + package, 300000);RootTools.sendShell("pm enable " + package, 300000); 6. 小案例：零权限读取用户隐私数据 直接修改短信数据库访问权限 12345678910RootTools.sendShell("chmod 777 data/data/com.android.providers.telephony/databases/mmssms.db", 300000);SQLiteDatabase db = SQLiteDatabase.openDatabase("data/data/com.android.providers.telephony/databases/mmssms.db", null, SQLiteDatabase.OPEN_READONLY);Cursor cursor = db.query("sms", new String[]&#123;"body", "address"&#125;, null, null, null, null, null);while(cursor.moveToNext())&#123; String body = cursor.getString(0); String address = cursor.getString(1); System.out.println(body + ";" + address);&#125;RootTools.sendShell("chmod 660 data/data/com.android.providers.telephony/databases/mmssms.db", 300000); 7. 静默安装 为什么有静默安装的需求 正规应用。电子市场，方便用户静默安装 流氓软件。后台偷偷下载安装。 自动下载应用，然后静默安装 12345678//静默安装RootTools.sendShell("pm install sdcard/flowstat.apk", 30000);//打开RootTools.sendShell("am start -n com.jijian.flowstat/com.jijian.flowstat.TrafficWidgetSetting", 30000);//卸载应用RootTools.sendShell("pm uninstall com.jijian.flowstat", 30000);//删除下载的apk包RootTools.sendShell("rm sdcard/flowstat.apk", 30000); 8. 修改字体 把ttf文件刷进img中 Android系统默认的中文字体为DroidSansFallBack.ttf 用你想使用的字体ttf文件替换掉这个文件即可 9. 修改开机动画 从真机中得到bootanimation.zip 把bootanimation.zip放入system/media目录下 10. 删除锁屏密码 删除data/system下的key文件 文本密码为password.key 手势密码为gesture.key]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用指令]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FLinux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux常用指令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122131. 查看目录下有什么文件/目录 &gt; ls //list列出目录的文件信息 &gt; ls -l 或ll //list -list以“详细信息”查看目录文件 &gt; ls -a //list -all查看目录“全部”(包括隐藏文件)文件 &gt; ls -al //list -all list 查看目录“全部”(包括隐藏文件)文件,以“详细信息”展示 &gt; ls 目录 //查看指定目录下有什么文件 &gt; ls -i //查看文件索引号码2. 进行目录切换 &gt; cd dirname //进行目录切换 &gt; cd .. //向上级目录切换 &gt; cd ~ 或 cd //直接切换到当前用户对应的家目录3. 查看完整的操作位置 &gt; pwd4. 用户切换 &gt; su - 或 su - root //向root用户切换 &gt; exit //退回到原用户 &gt; su 用户名 //普通用户切换 多次使用su指令，会造成用户的“叠加”： (su和exit最好匹配使用) jinnan---&gt;root---&gt;jinnan---&gt;root---&gt;jinnan5. 查看当前用户是谁 &gt; whoami6. 图形界面 与 命令界面 切换 root用户可以切换 &gt;# init 3 &gt;# init 57. 查看一个指令对应的执行程序文件在哪 &gt; which 指令8. 目录相关操作 1) 创建目录 make directory &gt; mkdir 目录名字 &gt; mkdir -p newdir/newdir/newdir //递归方式创建多个连续目录 //新的多级目录数目如果大于等于2个，就要使用-p参数 mkdir dir/newdir //不用-p参数 mkdir -p dir/newdir/newdir //使用-p参数 mkdir -p newdir/newdir/newdir //使用-p参数 2) 移动目录(文件和目录) move &gt; mv dir1 dir2 //把dir1移动到dir2目录下 &gt; mv dir1/dir2 dir3 //把dir2移动到dir3目录下 &gt; mv dir1/dir2 dir3/dir4 //把dir2移动到dir4目录下 &gt; mv dir1/dir2 ./ //把dir2移动到当前目录下 3) 改名字 (文件和目录) &gt; mv dir1 newdir //修改dir1的名字为newdir mv是“移动” 和 “改名字” 合并的指令 &gt; mv dir1 ./newdir //dir1移动到当前目录下 并改名字为newdir &gt; mv dir1/dir2 dir3 //dir2移动到dir3目录下， 并改名字为“原名” &gt; mv dir1/dir2 dir3/newdir //dir2移动到dir3目录下，并改名字为“newdir” &gt; mv dir1/dir2 dir3/dir4 //dir2移动到dir4目录下， 并改名字为“原名” &gt; mv dir1/dir2 dir3/dir4/newdir //dir2移动到dir4目录下， 并改名字为“newdir” 4) 复制(改名字)(文件和目录) copy ① 文件的复制 &gt; cp file1 dir/newfile2 //file1被复制一份到dir目录下，并改名字为“newfile2” &gt; cp file1 dir //file1被复制一份到dir目录下，并改名字为“原名” &gt; cp dir1/filea dir2/newfile //filea被复制一份到dir2目录下，并改名字为“newfile” ② 目录的复制(需要设置-r[recursive递归]参数，无视目录的层次) &gt; cp -r dir1 dir2 //dir1被复制到dir2目录下,并改名字为&quot;原名&quot; &gt; cp -r dir1/dir2 dir3/newdir //dir2被复制到dir3目录下,并改名字为&quot;newdir&quot; &gt; cp -r dir1/dir2 dir3/dir4 //dir2被复制到dir4目录下,并改名字为&quot;原名&quot; &gt; cp -r dir1/dir2 dir3/dir4/newdir //dir2被复制到dir4目录下,并改名字为&quot;newdir&quot; &gt; cp -r dir1 ../../newdir //dir1被复制到上两级目录下,并改名字为&quot;newdir&quot; ⑤ 删除(文件和目录)remove &gt; rm 文件 &gt; rm -r 目录 //-r[recursive递归]递归方式删除目录 &gt; rm -rf 文件/目录 //-r force 递归强制方式删除文件 force强制，不需要额外的提示 rm -rf /9. 文件操作 1) 查看文件内容 cat filename //打印文件内容到输出终端 more filename //通过敲回车方式逐行查看文件的各个行内容 //默认从第一行开始查看 //不支持回看 //q 退出查看 less //通过“上下左右”键查看文件的各个部分内容 //支持回看 //q 退出查看 head -n filename //查看文件的前n行内容 tail -n filename //查看文件的最末尾n行内容 wc filename //查看文件的行数 2) 创建文件 &gt; touch dir1/filename &gt; touch filename 3) 给文件追加内容 &gt; echo 内容 &gt; 文件名称 //把“内容”以[覆盖写]方式追加给“文件” &gt; echo 内容 &gt;&gt; 文件名称 //把“内容”以[追加]形式写给“文件” (如果文件不存在会创建文件)10. 用户操作 配置文件：/etc/passwd 1) 创建用户 user add &gt;# useradd &gt;# useradd liming //创建liming用户，同时会创建一个同名的组出来 &gt;# useradd -g 组别编号 username //把用户的组别设置好，避免创建同名的组出来 &gt;# useradd -g 组编号 -u 用户编号 -d 家目录 username 2) 修改用户 user modify &gt;# usermod -g 组编号 -u 用户编号 -d 家目录 -l 新名字 username (修改家目录时需要手动创建之) 3) 删除用户 user delete &gt;# userdel username &gt;# userdel -r username //删除用户同时删除其家目录 4) 给用户设置密码，使其登录系统 &gt; passwd 用户名11. 组别操作 配置文件： /etc/group 1) 创建组 group add &gt;# groupadd music &gt;# groupadd movie &gt;# groupadd php 2) 修改组 group modify &gt;# groupmod -g gid -n 新名字 groupname 3) 删除组 group delete &gt;# groupdel groupname //组下边如果有用户存在，就禁止删除12. 查看指令可设置的参数 &gt; man 指令13. 给文件设置权限 1) 字母相对方式设置权限 // 针对一个组别设置权限，其他组别权限没有变化，称为“相对方式”权限设置 chmod指令 chmod u+rwx filename //给filename文件的主人增加“读、写、执行”权限 chmod g-rx filename //给filename文件的同组用户 删除“读、执行”权限 chmod u+/-rwx,g+/-rwx,o+/-rwx filename 说明： ① 每个单元&quot;+&quot; &quot;-&quot;只能使用一个 ② 可以同时给一个组或多个组设置权限，组别之间使用&quot;,&quot;分割 ③ 每个单元的权限可以是&quot;rwx&quot;中的一个或多个 &gt;chmod u+w,g-rx,o+rw filename //给filename文件主人增加写权限，同组删除读、执行权限，其他组增加读、写权限 &gt;chmod u+w,u-x filename //给filename文件主人“增加写权限”同时“删除执行权限” chmod +/-rwx filename //无视具体组别，统一给全部的组设置权限 &gt;chmod +rw filename //给filename全部用户增加“读、写”权限 2) 数字绝对方式设置权限 r读:4 w写:2 x执行:1 0: 没有权限 1：执行 2：写 3：写、执行 4：读 5：读、执行 6：读、写 7：读、写、执行 chmod ABC filename //ABC分别代表主人、同组、其他组用户的数字权限 &gt;chmod 753 filename //主人读、写、执行；同组读、执行；其他组写、执行 问：字母相对 和 数字绝对 方式权限设置取舍？ 答：修改的权限相对“比较少”的时候使用“字母”方式 相反，权限变动“非常多”的时候就使用“数字”方式14. 在文件中查找内容 grep 被搜寻内容 文件 &gt; grep hello passwd //在passwd文件中搜索hello内容 //会把hello所在行的内容都打印到终端显示15. 计算文件占据磁盘空间大小 &gt; du -h 文件(目录)16. 文件查找 find 查找目录 选项 选项值 选项 选项值 ... 1) -name选项 根据名字进行查找 &gt; find / -name passwd[完整名称] //&quot;递归遍历&quot;系统全部目录，寻找名称等于&quot;passwd&quot;的文件 &gt; find / -name &quot;pas*&quot;[模糊查找] //在系统全部目录，模糊查找一个名字是“pas”开始的文件 &gt; find / -name &quot;*er*&quot; //文件名字有出现“er”字样即可，不要位置 2) 限制查找的目录层次 -maxdepth -mindepth -maxdepth 限制查找的最深目录 -mindepth 限制查找的最浅目录 &gt; find / -maxdepth 4 -name passwd &gt; find / -maxdepth 4 -mindepth 3 -name passwd 3) 根据大小为条件进行文件查找 -size +/-数字 +号表示大小大于某个范围 -号表示大小小于某个范围 大小单位： -size 5 //单位是“512字节” 5*512字节 -size 10c //单位是“字节” 10字节 -size 3k //单位是“千字节” 3*1024字节 -size 6M //单位是“1024*千字节” 6M兆字节 &gt; find ./ -size 14c //在当前目录查找大小等于14字节的文件 &gt; find / -size +50M //在系统全部目录里边查找大小大于50M的文件 Linux-根目录介绍/binbinary 二进制许多“指令”对应的可“执行程序文件”目录ls pwd init等等 /sbinsuper binary 超级的 二进制许多“指令”对应的可“执行程序文件”目录该目录文件对应指令都是”root”用户可以执行的指令例如：init /usrunix system resource (unix系统资源文件目录)该目录类似win系统的 C:/Program files 目录该目录经常用于安装各种软件 软件安装完毕会形成对应的指令，该指令对应的可执行程序文件就存放在以下目录/usr/bin许多“指令”对应的可“执行程序文件”目录/usr/sbinroot用户执行的指令 对应的 可“执行程序文件”目录 /devdevice 系统硬件设备目录(linux系统所有的硬件都通过文件表示)例如：/dev/cdrom是光驱 /dev/sda 是第一块scsi硬盘 /home用户的”家目录”给系统每增加一个“普通用户”的同时，都会在该目录为该用户设置一个文件目录代表该用户的“家目录”，用户后期使用系统的时候会首先进入其家目录家目录名字默认与当前用户名字一致用户对家目录拥有绝对最高的权限。 /root该目录是root管理员的家目录，root用户登录系统后首先进入该目录 /proc内存映射目录，该目录可以查看系统的相关硬件信息 /varvariable 可变的、易变的该目录存储的文件经常会发生变动(增加、修改、删除)经常用于部署项目程序文件/var/www/shop/var/www/book /boot系统启动核心目录，用于存储系统启动文件 /etc系统主要配置文件目录 例如/etc/passwd 用于存储用户信息的文件/etc/group 用于存储组别信息的文件 /liblibrary系统资源文件类库目录 /selinuxsecure enhanced linux 安全增强型linux对系统形成保护会对给系统安装软件时有干扰作用 window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{},"image":{"viewList":["fbook","twi","linkedin","qzone","tsina","douban","weixin","evernotecn"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?'];]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI与底层调用1]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FJNI%E4%B8%8E%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A81%2F</url>
    <content type="text"><![CDATA[1. JNI 简介1.1 什么是JNIJava Native Interface(JNI)，它允许Java 代码和其他语言写的代码进行交互。JNI 一开始是为了本地已编译语言，尤其是C 和C++而设计的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。 Java Native Interface，java本地接口，Native本地，当前系统用什么语言开发的那么 这种语言对于这个系统而言就是本地语言，android底层是linux linux是c/c++开发的 所以对于android来说 c/c++就是本地语言。JNI 可以看做是一个翻译 实现JAVA语言和本地语言之间的相互调用 1.2 为什么用JNI JNI 扩展了Java 虚拟机的能力,因为Java 不能直接和硬件交互, 不能开发驱动 Java 代码效率一般要低于C 代码，而Native code 效率高,因此在数学运算,实时渲染的游戏上以及音视频处理上都需要用Java 调用C 语言 复用C/C++代码，C 语言经过几十年的发展，已经形成了强大的类库(比如文件压缩，人脸识别opencv，7zip，ffmpeg 等)，这些类库我们没必要用java 语言重新实现一遍，通过JNI 直接调用这些类库即可 特殊的业务场景，比如电视、车载系统、微波炉等跟硬件直接相关的开发 java代码 不可以直接操作硬件 硬件的驱动基本都是C代码写的 如果想操作硬件必须得让java代码可以调用C，这个时候JNI就发挥作用了 可以扩展JAVA代码的性能 java代码安全性比较差 java-&gt;,class-&gt;. C安全性相对高一些 C编译之后直接生成机器码 机器码可以反汇编 汇编代码可以猜出C的源代码 伪代码 有些时候跟源代码有区别 比如登录先关 跟钱打交道的应用 可以通过JNI把加密的业务逻辑放到C里面实现 Java特点 跨平台 一处编译到处运行 通过虚拟机来实现的 java是解释型语言 效率相对比较低在要求效率的地方 java性能会差一些 大型3d游戏 c/c++ 音视频解码 JNI可以提升java的效率 复式投注 需要效率的时候可以通过JNI来调用C/C++来实现 c1972年 c++ java 1995年 ffmpeg音视频解码 opencv 图像处理 人脸识别 使用JNI可以让java代码调用 c/c++写的优秀开源项目，学习JNI目的是满足自己项目的需求 2. NDK 简介2.1 NDK 产生的背景Android 平台从诞生起，就已经支持C、C++开发。众所周知，Android 的SDK 基于Java 实现，这意味着基于Android SDK 进行开发的第三方应用都必须使用Java 语言。但这并不等同于“第三方应用只能使用Java”。在Android SDK 首次发布时，Google 就宣称其虚拟机Dalvik 支持JNI 编程方式，也就是第三方应用完全可以通过JNI 调用自己的C 动态库，即在Android 平台上，“Java+C”的编程方式是一直都可以实现的 不过，Google 也表示，使用原生SDK 编程相比Dalvik 虚拟机也有一些劣势，Android SDK 文档里，找不到任何JNI 方面的帮助。即使第三方应用开发者使用JNI 完成了自己的C 动态链接库（so）开发，但是so 如何和应用程序一起打包成apk 并发布？这里面也存在技术障碍。比如程序更加复杂，兼容性难以保障，无法访问Framework API，Debug 难度更大等。开发者需要自行斟酌使用 于是NDK 就应运而生了。NDK 全称是Native Development Kit NDK 的发布，使“Java+C”的开发方式终于转正，成为官方支持的开发方式。NDK 将是Android 平台支持C 开发的开端 2.2 为什么使用NDK 代码的保护。由于apk 的java 层代码很容易被反编译，而C/C++库反编译难度较大 可以方便地使用现存的开源库。大部分现存的开源库都是用C/C++代码编写的 提高程序的执行效率。将要求高性能的应用逻辑使用C 开发，从而提高应用程序的执行效率 便于移植。用C/C++写得库可以方便在其他的嵌入式平台上再次使用 2.3 NDK 简介2.3.1 NDK 是一系列工具的集合NDK 提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so 和java 应用一起打包成apk。NDK 集成了交叉编译器，并提供了相应的mk 文件隔离CPU、平台、ABI 等差异，开发人员只需要简单修改mk 文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so 2.3.2 NDK 提供了一份稳定、功能有限的API 头文件声明Google 明确声明该API 是稳定的，在后续所有版本中都稳定支持当前发布的API。从该版本的NDK中看出，这些API 支持的功能非常有限，包含有：C 标准库（libc）、标准数学库（libm）、压缩库（libz）、Log 库（liblog）。 3. NDK 的安装3.1 NDK 的下载NDK 的官方下载地址 3.2 将NDK 解压到一个不包含空格和中文的目录下本人将NDK 解压在D:\software\ndkr9\android-ndk-r9b 中 3.3 NDK 目录结构说明自定好组合控件之后，之前的activity_setting.xml 中的代码就可以进行简化，具体如下所示： build：该目录存放的使用NDK 的mk 脚本，mk 脚本指定了编译参数 docs：该目录存放的是NDK 的使用帮助文档 platforms：这里面存放的是与各个Android 版本相关的平台（x86，arm，mips）相关C 语言库和头文件 prebuilt：预编译工作目录 samples：存放的是演示程序 sources：存放的是NDK 工具链的C 语言源码 tests：测试相关的文件 toolchains：工具链，存放了三种架构的静态库等文件 ndk-build.cmd：Window 平台使用NDK 的命令 ndk-build：Linux 平台使用NDK 的命令 4. JNI 入门下面通过一个简单的JNI 案例来演示如何使用JNI 编程。 1）创建一个新的Android 工程《JNI 入门》，工程的最终目录结构如下图所示。 2）在MainActivity.java 类中定义一个native 方法 12//定义一个native 方法，意思是该方法的具体实现交给C 语言实现public native String helloC(); 3）在工程跟目录下创建一个文件夹jni，该目录名称是约定（约定优于配置）好的，不能是其他名字。4）在jni 目录下创建hello.c 源文件，文件名可以按照见名知意的规则来创建。hello.c 代码清单如下。 123456789#include&lt;stdio.h&gt;//引入头文件 //引入jni.h jni.h 文件里面定义了jni 的规范，jni.h 在ndk 的目录中找到，然后放到当前工程中的jni目录下即可#include&lt;jni.h&gt;//定义在MainActivity.java 类中的helloC 对应的C 语言函数jstring Java_com_itheima_jnihello_MainActivity_helloC(JNIEnv* env, jobject obj) &#123;char* str = "hello from C";//调用jni.h 中定义的创建字符串函数jstring string = (*(*env)).NewStringUTF(env, str);return string; Tips：上面的代码虽然简单但是关于jni.h 头文件和方法名必须单独说明。 jni.h 头文件位于NDK 安装目录下/platforms/android-*/(某平台)/usr/include 目录中，如下图 上面的某平台指CPU 的三种架构如下图。我们选择任意一架构皆可，但是对于手机来说CPU 用arm架构的最多，x86 次之，mips 架构最少。 JNI 中C 源文件方法名的命名规则 这里的命名规则指用于跟java 文件中native 方法对应的C 语言方法，而C 语言中的其他方法命名只要符合C 语言规则就行。 1jstring Java_com_itheima_jnihello_MainActivity_helloC(JNIEnv* env, jobject obj) jstring 是方法返回值类型，我们可以把jstring 看成是java 中String 跟C 语言中char*类型的一个中间转换类型，java 跟C 语言的数据类型是不一样的，他们之间要想互相调用就必须通过一种中介来实现，这个中介就是在jni.h 头文件中定义的。关于更多的转换类型，在本文档的第2 章会有更详细的说明。 方法名第一个字母必须是Java，首单词大写，然后下划线，然后是将该方法所在的包、类、方法用“”连接起来,比如com.itheima.jnihello.MainActivity 类中的helloC 方法，转变成C 语言中的方法名为Java_com_itheima_jnihello_MainActivity_helloC。 方法的形参有两个是必须的也就是不管java 中的方法是否有形参，但是C 语言中对应的方法必须有JNIEnv* env,和jobject obj，如果java 方法中还用其他形参，那么在C 语言中严格按照顺序排在jobject obj参数的后面即可。 上面的env 代表指向JVM 的指针，obj 是调用该方法的java 对象。 5）使用NDK 工具将hello.c 编译成hello.so 文件为了方便直接在控制台中使用NDK 工具的ndk-build.cmd 命令，我们首先将ndk-build.cmd 所在的目录设置成系统环境变量。环境变量配置好以后，在命令行中输入ndk-build.cmd 会有如下提示： 将当前目录切换到hello.c 所在的工程目录，这时候如果直接输入ndk-build.cmd 那么会出现如下异常： 出现这种错误时因为我们并没有告诉ndk 我们要将那个C 语言源代码编译成目标文件。为了告诉ndk 要将那个C 源文件编译成目标文件，我们需要在工程中的jni 目录中添加Android.mk 配置文件。 6）在当前工程的jni 目录下添加Android.mk 配置文件，该配置文件可以从ndk 安装目录的实例代码中拷贝，然后修改。 Android.mk 文件清单如下，我们只需要修改LOCAL_MODULE 和LOCAL_SRC_FILES 两个参数即可。LOCAL_MODULE 参数是指定编译后的目标文件的名称，其实编译好的目标文件名为libhello.so，LOCAL_SRC_FILES 指定了要编译的源文件。 12345LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := helloLOCAL_SRC_FILES := hello.cinclude $(BUILD_SHARED_LIBRARY) 7）在cmd 中，将当前目录切换到hello.c 所在目录，然后重新执行ndk-build.cmd 命令，这次成功编译，cmd 显示效果如下图所示。 查看项目目录结构，发现在libs 目录中多了两个文件夹armeabi 和x86，这两个文件夹下分别包含了一个libhello.so 动态链接库。这也代表着当前工程中的动态库支持arm 架构和x86 架构的cpu。 Tips：可能你的并没有同时生成这两个文件，是因为我的工程中引入了Application.mk 文件，因此你需要引入该文件。 Application.mk 文件清单：12# Build both ARMv5TE and ARMv7-A machine code.APP_ABI := armeabi x86 8）该清单其实只有一行内容，第一行是注释。APP_ABI 参数指定要生成的目标文件支持的平台都有哪些，默认是armeabi 如果想支持多个平台只需要空一格然后写出其他平台名字即可。在MainActivity.java 中调用C 语言 1234567891011121314151617public class MainActivity extends Activity &#123; //加载libhello.so 动态库，但是我们加载的时候必须去掉lib 和后缀 static&#123; System.loadLibrary("hello"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //定义一个native 方法，意思是该方法的具体实现交给C 语言实现 public native String helloC(); //点击按钮调用C 语言方法 public void click(View view)&#123; Toast.makeText(this, helloC(), 1).show(); &#125;&#125; 运行上面工程，效果如下： Tips：如果我们编译的arm 平台的so 文件，但是却部署到了x86 平台的模拟器上，那么运行的时候会报找不到libhello.so 的异常。 5. JNI 规范5.1 JNI 数据类型和数据结构1）基本数据类型JNI 基本类型和本地等效类型的对应表格如下： 2）引用类型，JNI 还包含了很多对应于不同Java 对象的引用类型，JNI 引用类型的组织层次如下图所示： 5.2 JNI 接口函数命名方式设置向导二SetUpActivity2.java 的代码逻辑如下所示，设置向导二的图形化界面如2-20 所示。 5.2.1 类型签名Java 虚拟机的类型签名如下： 类型签名 Java 类型 Z boolean B byte C char S short I int J long F float D double Lfully-qulitied-class; 全限定类 [type type[] 数组 (argtypes)rettype 方法类型 例如，Java 方法int feet(int n, String s,int [] arr)的类型签名如下： 1（ILJava/lang/String;[I）I 圆括号里面为参数，I 表示第一个参数int 型，LJava/lang/String;表示第二个参数为全限定Java.lang.String类型，[I 表示第三个参数为int 型的数组，圆括号后面为返回值类型，I 表示返回值为int 型。 5.2.2 一般函数的JNI 接口函数命名方式一般JNI 接口函数命名如下：Java包名类名_方法名。 例如：某工程下com/itheima 包下MainActivity 类的int getIntFromC()方法的C 语言实现函数命名如下：1jint Java_com_itheima_MainActivity_getIntFromC(JNIEnv* env,jobject obj) 其中，包名所包含的“/”应全部以下划线替代，其本地实现的参数和返回值也应转换为JNI 类型。 5.2.3 重载函数的JNI 接口函数命名方式重载函数的JNI 实现在一般函数的JNI 实现之外，还应添加上类型签名以作为同名函数之间的区别，其接口函数命名如下：Java包名类名方法名参数签名。 例如：某工程下com/itheima 包下MainActivity 类的int getIntFromC(int n, String s,int [] arr)方法的C 语言实现函数命名如下： 12jint Java_com_itheima_MainActivity_getIntFromC_ILJava_lang_String23I(JNIEnv* env, jobject obj, jint n, jstring s, jintarray arr) JNI 在函数命名时采用名字扰乱方案，以保证所有的Unicode 字符都能转换为有效的C 函数名，所有的“/”,无论是包名中的还是全限定类名中的，均使用“_”代替，用_0,„,_9 来代替转义字符，如下： 转义字符序列 表示 _0XXXX Unicode 字符XXXX _1 字符“_” _2 签名中的字符“；” _3 签名中的字符“[” 5.3 JNI 函数与API设置向导三SetUpActivity3.java 的代码逻辑如下所示，设置向导三的图形化界面如2-21 所示。在本文档中我们所主要需要关心的是C/C++数据类型与JNI 本地类型之间的转化过程，这个过程某些数据的转换需要使用JNIEnv 对象的一系列方法来完成。 5.3.1 jstring 转换为C 风格字符串1char* test = (char)(env)-&gt;GetStringUTFChars(env,jstring,NULL); 使用完毕后，应调用： 1(*env)-&gt;ReleaseStringUTFChars(env, jstring, test); 释放资源。 5.3.2 C 风格字符串转换为jstring123char charStr[50];jstring jstr;jstr = env -&gt; NewStringUTF(charStr); 5.3.3 C 语言中获取的一段char*的buffer 传递给Java在jni 中new 一个byte 数组，然后使用 1(*env)-&gt;SetByteArrayRegion(env, bytearray, 0, len, buffer) 操作将buffer 拷贝到数组中。这种方式主要是针对buffer 中存在“\0”的情况，如果以C 风格字符串的方式读入，就会损失“\0”之后的字符。 5.3.4 数组操作 JNI 函数 功能 GetArrayLength 返回数组中的元素数 NewObjectArray 创建一个指定长度的原始数据类型数组 GetObjectArrayElement 返回Object 数组的元素 SetObjectArrayElement 设置Object 数组的元素 GetObjectArrayRegion 将原始数据类型数组中的内容拷贝到预先分配好的内存缓存中 SetObjectArrayRegion 设置缓存中数组的值 ReleaseObjectArrayRegion 释放GetObjectArrayRegion 分配的内存 Tips：对int，char 等基本数据类型的数组操作，将相关Object 名称替换为对应基本数据类型名称即为相关函数。 数组操作的方法选择基于使用者的需求而定，如果使用者需要在内存中拷贝数组并对其进行操作那么一般使用GetObjectArrayRegion 和SetObjectArrayRegion 函数，否则一般使用SetObjectArrayElement 和GetObjectArrayElement 函数。 6. 案例-银行登录系统需求：假设银行的登陆模块是用C 语言来编写的，但是我们的Android 应用想登陆银行系统，那么就需要通过JNI 来实现了。 创建一个新Android 工程《建行客户端》，工程目录结构如下图。 在工程中创建jni 文件夹，然后将jni.h、Android.mk、Application.mk 从JNI 入门工程拷贝进去。在jni 目录下创建login.c 文件，在该文件中实现登录业务逻辑。代码清单如下。 123456789101112#include&lt;stdio.h&gt;//系统在查找投文件的时候""中的文件会去本地搜索，&lt;&gt;中的文件会去系统目录中搜索，因为jni.h 在当前目录中所以用""将jni.h 引起来，可以加快搜索速度#include"jni.h"int login(int card,int pwd)&#123; //真实的业务逻辑要复杂的多，这里只简单的返回银行卡号和密码号 return card+pwd;&#125;jint Java_com_itheima_ccb_MainActivity_login(JNIEnv* env,jobject obj,jint card,jint pwd)&#123; return login(card,pwd);&#125; 是用ndk 工具，将login.c 编译成动态库文件。编译前修改Android.mk 文件的LOCAL_SRC_FILES := login.c 编写在MainActivity.java 类12345678910111213141516171819public class MainActivity extends Activity &#123; static&#123; System.loadLibrary("login-jni"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public native int login(int card,int pwd); public void login(View view)&#123; EditText et_card = (EditText) findViewById(R.id.et_card); EditText et_pwd = (EditText) findViewById(R.id.et_pwd); int card = Integer.valueOf(et_card.getText().toString()); int pwd = Integer.valueOf(et_pwd.getText().toString()); int result = login(card, pwd); Toast.makeText(this, ""+result, 1).show(); &#125;&#125; 布局文件比较简单，这里就不再给出。运行上面的代码，运行结果如下： 7. CDT 插件的安装7.1 CDT 简介CDT 项目致力于为Eclipse 平台提供功能完全的C/C++ 集成开发环境（Integrated DevelopmentEnvironment，IDE）。CDT 是完全用Java 实现的开放源码项目（根据Common Public License 特许的），它作为Eclipse SDK 平台的一组插件。这些插件将C/C++ 透视图添加到Eclipse 工作台（Workbench）中，现在后者可以用许多视图和向导以及高级编辑和调试支持来支持C/C++ 开发。 7.2 CDT 的下载CDT 插件可以通过eclipse 的在线安装，但是受限于跨国家网络访问，一般不是很好用。因此这里我主要给大家说的是如何离线安装。 下载CDT 离线安装包。针对不同版本eclipse 的cdt 安装包如下，大家可以从我的百度网盘上直接下载。考虑到我们大部分都用的最新的ADT 因此建议选择8.5.0 版本的CDT。 cdt-8.5.0-for-Eclipse-Luna cdt-8.3.0-for-Eclipse-Kepler cdt-8.1.2-for-Eclipse-Juno 选择eclipse 的Help-&gt;Install New Software…，弹出如下对话框 点击Add 按钮，在弹出的对话框中输入Name。在Location 栏如果输入一个http 地址是让eclipse自动从网络上下载安装，这里我们点击Archive 按钮找到我们事先下载好的离线安装包。然后点击OK。 将CDT 所有的插件勾选上，同时将最下面的联网检查更新去掉勾选，然后点击Next，直到Finish。 安装好以后在File-&gt;New-&gt;Other 中会有C/C++选项，如下图。 在Open Perspective 中也多了C/C++视图可选项，如下图。 安装好以后，我们就可以在eclipse 中开发我们的C/C++工程了。不过对我们Android 开发人员来说用到的机会不是很多。就算是开发C/C++工程，大多数程序员也不会选择在eclipse 平台上进行开发。Eclipse更多的是专注于Java 语言项目的开发，比如JavaEE、Android。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>jni</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JNI与底层调用2]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FJNI%E4%B8%8E%E5%BA%95%E5%B1%82%E8%B0%83%E7%94%A82%2F</url>
    <content type="text"><![CDATA[JNI与底层调用1：http://blog.csdn.net/axi295309066/article/details/60758515JNI与底层调用2：http://blog.csdn.net/axi295309066/article/details/60778076C/C++在Android开发中的应用：http://blog.csdn.net/axi295309066/article/details/60954771 1. 掌握如何使用广播接收者拦截电话和短信在日常生活中，当手机丢失后，我们可以启动一系列的措施来获取丢失手机的位置信息，或者清楚丢失手机的数据来防止隐私数据泄露，本章就针对这些防盗保护措施进行讲解。 2. JNI 开发中常见错误2.1 动态库名称写错，或者不存在123static&#123; System.loadLibrary("hell0");&#125; 当我们在写上面代码的时候如果不小心将hello 写成了hell0。或者libhello.so 动态库不存在，那么系统启动时会报如下异常。 2.2 Android.mk 配置文件写错如果修改配置文件中的某个参数名称被写错，那么我们在调用ndk-build.cmd 命令的时候很可能报如下异常。出现这类异常，就需要我们检查我们的Android.mk 文件，看是否写错。 2.3 目标文件名画蛇添足导致的错误手机防盗界面会展示出一系列的信息，如用户设置的安全号码、手机防盗保护是否开启等信息，手机防盗界面LostFindActivity.java 的效果图如图3-5 所示。如果我们将Android.mk 中的目标文件名：LOCAL_MODULE := hello 写成了LOCAL_MODULE:=hello.so，那么当我们使用ndk 进行编译的时候会出现如下错误。 上面的异常告诉我们，LOCAL_MODULE 不能有文件拓展名。 2.4 源文件名写错如果我们将Android.mk 中的源文件名：LOCAL_SRC_FILES := hello.c 写成了LOCAL_SRC_FILES :=helo.c（少些了一个单词），那么当使用ndk 进行编译的时候会出现如下错误： 2.5 平台使用错误如果我们编译的时候用的是arm 平台，但是将目标文件运行在了x86 平台上，那么会产生如下错误。 如果想让我们编译的动态库既支持arm 平台又支持x86 平台，那么我们可以在工程中的jni 目录下添加Application.mk 文件。关于Application.mk 的配置在本人的上一个文档中有说明，这里就不再介绍。 2.6 C 语言中被Java 调用的方法名写错比如C 语言中的方法jstring Java_com_itheima_jnihello_MainActivity_helloC 把helloC 写成了heloC，那么将会报如下错误。 3. 自动生成JNI 头文件对于一些特殊的Java 方法名，我们很难写出其对应的JNI 方法名，比如：1public native String a_b__c_d(); 这时候我们可以通过我们的JDK 工具自动生成头文件。该工具位于JDK 中，如果我们给电脑配置JAVA_HOME 则可以直接在命令行中使用，使用法则很简单。如下图所示： 下面演示如何使用javah 工具生成我们MainActivity.java 中native 方法的头文件。将命令行控制台切换到我们MainActivity.class（注意：是.class 不是.java）所在目录。本人的目录如下： 执行javah 命令：javah com.itheima.jnihello.MainActivity，发现报了如下错误： Tips：出现上面的错误时因为我用的是jdk7 版本，jdk7 在编译MainActivity.class 类的时候会查找其所有的父类，但是在当前命令行中是不可能有MainActivity 类的父类路径的。有两种办法可以解决上述问题：1）改成jdk6 版本2）将native 方法定义在另外一个独立的类中本人在这里采用第二种方法来解决该问题，因此我创建一个类，将所有的native 方法都定义在该类中。 JNIMethod.java 代码清单如下： 1234package com.itheima.jnihello.jni;public class JNIMethod &#123;public native String a_b__c_d();&#125; 再次执行javah 命令：javah com.itheima.jnihello.jni.JNIMethod 这次发现没有报错，生成的头文件在如下位置： 打开生成的头文件，将生成的方法签名拷贝出来添加到我们的hello.c 源文件中即可。 4. JNI 的值传递本章我们通过一个案例来介绍几种常见的JNI 值传递场景。创建一个新的Android 工程《JNI 值传递》。在工程中创建com.itheima.jnipassdata.DataProvider 类。在该类中定义三个native 方法。代码清单如下： 123456789101112131415161718192021public class DataProvider &#123; /** * 模拟用C 语言计算一些负责算法 * @param x * @param y * @return */ public native int add(int x,int y); /** * 模拟用C 语言加密字符串 * @param str * @return */ public native String encideString(String str); /** * 模拟用C 语言进行一些图像算法 * @param colorArray * @return */ public native int[] changeColor(int[] colorArray);&#125; 使用javah 工具生成头文件 生成的头文件在相对于命令行的当前目录下。在工程中创建jni 目录，在改jni 目录中创建Hello.c 文件，将上一步生成的方法拷贝到Hello.c文件中，并实现里面的方法Hello.c 代码清单如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include "jni.h"//把java 的string 转化成c 的字符串char* Jstring2CStr(JNIEnv* env, jstring jstr)&#123; char* rtn = NULL; jclass clsstring = (*env)-&gt;FindClass(env,"java/lang/String"); //String jstring strencode = (*env)-&gt;NewStringUTF(env,"GB2312"); //"gb2312" jmethodID mid = (*env)-&gt;GetMethodID(env,clsstring, "getBytes", "(Ljava/lang/String;)[B"); //getBytes(Str); jbyteArray barr= (jbyteArray)(*env)-&gt;CallObjectMethod(env,jstr,mid,strencode); // String .getByte("GB2312"); jsize alen = (*env)-&gt;GetArrayLength(env,barr); jbyte* ba = (*env)-&gt;GetByteArrayElements(env,barr,JNI_FALSE); if(alen &gt; 0) &#123; rtn = (char*)malloc(alen+1); //"\0" memcpy(rtn,ba,alen); rtn[alen]=0; &#125; (*env)-&gt;ReleaseByteArrayElements(env,barr,ba,0); //释放内存空间 return rtn;&#125;jint Java_com_ithiema_jnipassdata_DataProvider_add (JNIEnv* env, jobject obj, jint x, jint y)&#123; return x+y;&#125;;jstring Java_com_ithiema_jnipassdata_DataProvider_encideString (JNIEnv * env, jobject obj, jstring jstr)&#123; char* str = Jstring2CStr(env,jstr); char* hello = "hello"; strcat(str,hello); //下面的两种写法是一样的效果 //return (*(*env)).NewStringUTF(env,str); return (*env)-&gt;NewStringUTF(env,str);&#125;;jintArray Java_com_ithiema_jnipassdata_DataProvider_changeColor (JNIEnv * env, jobject obj, jintArray jarray)&#123; int size = (*env)-&gt;GetArrayLength(env,jarray); int* arr = (*env)-&gt;GetIntArrayElements(env,jarray,0); int i; for(i=0;i&lt;size;i++)&#123; arr[i]+=10; &#125; return jarray;&#125; 使用NDK 工具将上面的C 代码编译成动态库文件，首先得在工程的jni 目录下添加Android.mk和Application.mk 文件在MainActivity 类中调用C 语言，MainActivity.java 代码清单如下。 1234567891011121314151617181920&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/iv" /&gt; &lt;Button android:layout_gravity="right" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="lomo" android:onClick="click" /&gt;&lt;/LinearLayout&gt; 布局文件比较简单，就不再给出。运行上面代码，效果图如下： 4.1 让C 语言输出Log 日志让我们的C 语言也能在LogCat 中输出一些信息是一个很简单但也很常见的实际需求。为了方便演示我们直接在本章节中创建的工程中演示如何让C 语言打印LogCat 日志。在Android.mk 中添加如下属性：LOCAL_LDLIBS := -llog，在C 源码头部引入如下头文件和宏定义 1234#include &lt;android/log.h&gt;#define LOG_TAG "System.out"#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__) 在C 代码中可以将LOGD（）或者LOGI（）函数当做C 语言中的printf（）函数使用。这里我将add 方法添加添加了一条日志输入 12345jint Java_com_ithiema_jnipassdata_DataProvider_add(JNIEnv* env, jobject obj, jint x, jint y)&#123;LOGI("x+y=%d",x+y);return x+y;&#125; 重新编译hello.so 动态库，既然我们修改了Android.mk 和C 源码文件，那么一定要记得重新使用NDK 编译C 语言为动态库，否则日志不会输入而且也不报异常。再次部署程序到模拟器，调用add 方法，发现在LogCat 中成功输出了如下信息： 5. 案例-调用美图秀秀的动态库在美图秀秀1.0 版本的时候程序员对其代码并没有加密以及反反编译等处理，因此我们可以将其apk反编译出来。里面关于图形的核心算法都是通过so 库来实现的，我们可以拿过来直接使用。声明：本文档中使用的美图秀秀只用于学习交流Android 技术，禁止用于其他目的！美图秀秀1.0 版本下载地址将下载好的mtxx.apk 进行反编译，将反编译好的资源作为原料备用。关于如何反编译美图秀秀请见本文档最后一章。 Tips：解压好的目录打开lib 包，发现只有armeabi 一个文件夹，说明该so 文件只能在arm 架构的CPU上运行。创建一个新的Android 工程《黑马美图秀秀》。将反编译好的libmtimage-jni.so 拷贝到工程的libs-&gt;armeab（i 该目录需要手动创建）目录下。通过反编译的 jar 包发现美图秀秀的 jni 方法都定义在 JNI.java类中，我们用jd-gui 工具将反编译的jar 包打开，找到JNI.java，然后拷贝其中的native 方法到我们的工程中。本人的工程目录结构如下所示： Tips：我们使用了美图秀秀的JNI 源码，那么我们的JNI.java 名字以及其所在的包名必须严格跟原美图秀秀保持一致，不然程序从so 动态库中是找不到目标方法的。原因很简单，因为C 中方法名是根据JNI.java 中的方法全限定名生成的。编写activity_main.xml 布局文件，布局文件清单如下： 1234567891011121314151617181920&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/iv" /&gt; &lt;Button android:layout_gravity="right" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="lomo" android:onClick="click" /&gt;&lt;/LinearLayout&gt; 在工程的res-&gt;drawable-hdpi 目录下放入一张图片。 编写MainActivity.java 代码，在改类中实现核心方法 1234567891011121314151617181920212223242526272829303132333435363738public class MainActivity extends Activity &#123; private ImageView iv; private Bitmap bitmap; static&#123; System.loadLibrary("mtimage-jni"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.beautiful); iv = (ImageView) findViewById(R.id.iv); iv.setImageBitmap(bitmap); &#125; public void click(View view)&#123; JNI jni = new JNI(); //获取Bitmap 的宽和高 int width = bitmap.getWidth(); int height = bitmap.getHeight(); //创建一个整型数组，存放每个像素点 int[] pixels = new int[width*height]; /** * 获取bitmap 的像素数组 * 第一个参数是int[] * 第二个参数是第获取一个像素的偏移量，这里是0，也就是从第一个像素开始获取 * 第三个参数每行获取多少个像素，当然bitmap 的宽度就是每行的像素个数 * 第四个参数、第五个参数分别是开始获取像素的x、y 坐标，这个坐标是相对于bitmap 本身来说的，因此是0,0 * 第六、七个参数分别是每行、每列获取像素的个数 */ bitmap.getPixels(pixels, 0, width, 0, 0, width, height); //调用美图秀秀API jni.StyleLomoB(pixels, width, height); //重新根据pixels 数组创建一个Bitmap 对象 Bitmap newBitmap = Bitmap.createBitmap(pixels, width, height, bitmap.getConfig()); iv.setImageBitmap(newBitmap); &#125;&#125; 运行上面打代码，效果如下：1）处理前 2）处理后 6. C 语言调用Java 代码之前我们学习的JNI 都是Java 代码调用C 代码，本章节中演示C 代码如何调用Java 代码。创建一个新的Android 工程《C 语言调用Java》，在工程中创建jni 目录，在改目录下放置Android.mk 和jni.h 文件（从老工程中拷贝）。工程目录结构如下： 编写DataProvider.java 文件，在该文件中编写native 方法，DataProvider.java 代码清单如下： 12345678910111213141516171819202122232425public class DataProvider &#123; //C 代码调用该方法发送短信 public void methodInJava()&#123; System.out.println("我是Java 中的方法，我被调用了"); SmsManager manager = SmsManager.getDefault(); manager.sendTextMessage("5556", null, "hello I'm from Java", null, null); &#125; //C 代码调用该方法传递一个字符串，获取一个字符串 public String methodInJava2(String str)&#123; return "hello:"+str; &#125; //C 代码调用一个空参返回值为void 的实例方法 public void methodInJava3()&#123; System.out.println("我是Java 中的方法3，我被调用了"); &#125; //C 语言调用静态方法 public static void methodInJava4()&#123; System.out.println("我是静态方法。被调用了。"); &#125; //定义四个native 方法，这些方法在MainActivity 中被调用，这些方法在C 代码中回调上面的Java 代码 public native void callCMethod(); public native String callCMethod2(String str); public native void callCMethod3(); public native void callCMethod4();&#125; 在jni 中创建calljava.c 文件，在该文件中实现调用java 的方法。代码清单如下 123456789101112131415161718192021222324252627282930#include &lt;jni.h&gt;#include &lt;stdio.h&gt;void Java_com_itheima_callJava_DataProvider_callCMethod(JNIEnv * env, jobject obj)&#123; //类似java 的反射，获取java 对象 jclass clazz = (*env)-&gt;FindClass(env,"com/itheima/callJava/DataProvider"); //根据方法签名获取目标方法 jmethodID methodID = (*env)-&gt;GetMethodID(env,clazz,"methodInJava","()V"); //调用目标方法 (*env)-&gt;CallVoidMethod(env,obj,methodID);&#125;jstring Java_com_itheima_callJava_DataProvider_callCMethod2(JNIEnv * env, jobject obj,jstring str)&#123; jclass clazz = (*env)-&gt;FindClass(env,"com/itheima/callJava/DataProvider"); jmethodID methodID = (*env)-&gt;GetMethodID(env,clazz,"methodInJava2","(Ljava/lang/String;)Ljava/lang/String; "); jstring jstr = (*env)-&gt;CallObjectMethod(env,obj,methodID,str); return jstr;&#125;void Java_com_itheima_callJava_MainActivity_callCMethod3(JNIEnv * env, jobject obj)&#123; jclass clazz = (*env)-&gt;FindClass(env,"com/itheima/callJava/DataProvider"); jmethodID methodID = (*env)-&gt;GetMethodID(env,clazz,"methodInJava3","()V"); jobject o = (*env)-&gt;AllocObject(env,clazz); (*env)-&gt;CallVoidMethod(env,o,methodID);&#125;void Java_com_itheima_callJava_DataProvider_callCMethod4(JNIEnv * env, jobject obj)&#123; jclass clazz = (*env)-&gt;FindClass(env,"com/itheima/callJava/DataProvider"); jmethodID methodID = (*env)-&gt;GetStaticMethodID(env,clazz,"methodInJava4","()V"); (*env)-&gt;CallStaticVoidMethod(env,clazz,methodID);&#125; 使用NDK 工具，将calljava.c 编译成动态库文件。（NDK 的使用在上一篇文档中有详细的介绍，这里就不再说明）在MainActivity.java 中调用C 语言，代码清单如下： 123456789101112131415161718192021222324public class MainActivity extends Activity &#123; static &#123; System.loadLibrary("calljava"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void click(View v) &#123; new DataProvider().callCMethod(); &#125; public void click2(View view) &#123; String result = new DataProvider().callCMethod2("ddd"); Toast.makeText(this, result, 1).show(); &#125; public void click3(View v) &#123; callCMethod3(); &#125; public void click4(View view) &#123; new DataProvider().callCMethod4(); &#125; public native void callCMethod3();&#125; 布局文件比较简单这里就不再给出。 7. 短信接收广播之锁屏用C++实现JNIC++语言是面向对象的编程语言，源于C 语言，部分语法通用。本章节中主要介绍如何使用C++完成简单的JNI 开发。创建一个新Android 工程《cpp 实现jni》，创建jni 包，在该包下创建JNI.java 文件，在该类中写naive方法。因为我们是C++项目，因此需要给当前工程添加native Support。右键点击项目，在弹出的对话框中选择Android Tools，然后选择Add native Support，弹出如下对话框： 这个名字是C++源文件名，因为没有实际的业务意义一次我们这里就随便输入一个了。在工程中创建com.itheima.cppjni.jni 包，在该包下创建JNI.java，JNI.java 代码清单如下： 123public class JNI &#123;public native void helloFormCPP();&#125; 使用javah 工具生成头文件，并将生成的头文件拷贝到工程根目录下的jni 目录中。 为了让编译器提示C++语言，我们需要给工程添加C++库。右键点击工程，选择Properties，在弹出的对话框中选择C/C++ General-&gt;Paths And Symbols，弹出如下对话框： 点击图中红色框中的Add 按钮，在弹出的对话框（如下图）中点击File system,然后选择ndk 安装目录，选择如下目录：D:\software\ndkr9\android-ndk-r9b\platforms\android-19\arch-arm\usr\include 然后点击OK。 Tips：上面目录中红色的是本人的ndk 所在目录，大家找到自己的ndk 所在目录即可。然后随便选择一个platform 即可，但是推荐大家选择一个高版本的平台。在gaga.cpp 中引入上面生成的头文件。同时编辑gaga.cpp，代码清单如下： 123456#include &lt;jni.h&gt;#include "com_itheima_cppjni_jni_JNI.h"JNIEXPORT jstring JNICALL Java_com_itheima_cppjni_jni_JNI_helloFromCPP(JNIEnv * env, jobject obj)&#123;return env-&gt;NewStringUTF("gaga from cpp");&#125;; 编写MainActivity.java,在该方法中加载动态库123456789101112131415public class MainActivity extends Activity &#123; static&#123; System.loadLibrary("gaga"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void click(View view)&#123; JNI jni = new JNI(); String helloFromCPP = jni.helloFromCPP(); Toast.makeText(this, helloFromCPP, 1).show(); &#125;&#125; 将上面工程部署到一个arm 架构的模拟器上。在部署的时候观察控制台，发现控制台输出如下信息12345678910111213**** Build of configuration Default for project cpp 代码jni 开发****D:\software\ndkr9\android-ndk-r9b\ndk-build.cmd allC:\Users\thinkpad\workspace\cpp 代码jni 开发&gt;rem This is a Windows cmd.exe script used toinvoke the NDK-specific GNU Make executableC:\Users\thinkpad\workspace\cpp 代码jni 开发&gt;call&quot;D:\software\ndkr9\android-ndk-r9b\find-win-host.cmd&quot; NDK_WIN_HOSTAndroid NDK: WARNING: APP_PLATFORM android-19 is larger than android:minSdkVersion 8in ./AndroidManifest.xml[armeabi] Compile++ thumb: gaga &lt;= gaga.cpp [armeabi] StaticLibrary : libstdc++.a [armeabi] SharedLibrary : libgaga.so [armeabi] Install : libgaga.so =&gt; libs/armeabi/libgaga.so **** Build Finished **** Tips：通过控制台，我们发现当我们的工程添加本地支持以后，当我们在部署的时候eclipse 会自动的完成动态库的编译工作。而且我们还发现在生成动态之前先生成了libstdc++.a 静态库然后才生成了动态库。上面代码运行效果如下图所示： 8. 案例-锅炉压力监测需求：硬件设备可以监测锅炉的压力，监测代码逻辑是用C 语言编写。客户端用java 代码每一秒调用一次C 语言，以获取锅炉的压力值，然后将锅炉的压力值以动态柱形图的形式显示在手机客户端。 Tips：分析上面的需求，我们需要使用jni 技术让Java 和C 代码通信。在C 语言端我们可以调用随机函数模拟锅炉压力的动态变化。在Java 端，我们可以自定义一个View 对象显示我们的锅炉压力。创建一个Android 工程《JNI 锅炉压力检测》，在该工程中创建jni 目录，将Android.mk、jni.h 从其他工程中拷贝到该目录下。在jni 目录下创建一个C 源文件pressure.c，代码清单如下：12345678910#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//定义一个返回值为int 型的函数，返回一个100 以内的函数值rand()是C 语言的一个随机函数int getPressure()&#123;return rand()%100;&#125;jint Java_com_itheima_jniPressure_MainActivity_getPressure()&#123;return getPressure(); &#125; 将pressure.c 编译成动态库文件，在MainActivity 的同一个包目录下创建一个自定义控件类MyView 继承View 类。123456789101112131415161718192021222324252627282930313233343536public class MyView extends View &#123; int top = 100; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; Paint paint = new Paint(); public MyView(Context context) &#123; super(context); paint.setColor(Color.RED); paint.setTextSize(18); &#125; @Override protected void onDraw(Canvas canvas) &#123; /** * 绘制一个矩形区域 * 第一、二、三、四个参数分别代表绘图区域离画布左、上、右、下的距离。这四个参数确定了矩形的大小也确定了 */ canvas.drawRect(60, top, 90, 150, paint); canvas.drawText("当前压力值："+(150-top),60, 170, paint ); super.onDraw(canvas); &#125; //根据压力转换成绘图区域的top 值 public void setPressure(int pressure)&#123; top = 150-pressure; if (pressure&lt;30) &#123; paint.setColor(Color.GREEN); &#125;else if (pressure&lt;60) &#123; paint.setColor(Color.YELLOW); &#125;else &#123; paint.setColor(Color.RED); &#125; &#125;&#125; 编写MainActivity.java 代码，在该代码中实现Java 端的核心方法。1234567891011121314151617181920212223242526272829303132public class MainActivity extends Activity &#123; //加载动态库 static &#123; System.loadLibrary("pressure"); &#125; //声明一个Timer 和TimerTask,用于定时任务的处理 private Timer timer; private TimerTask task; private MyView view; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //创建自定义控件对象 view = new MyView(this); //将自定义控件对象作为显示对象，而没有使用布局文件 setContentView(view); //创建定时任务 timer = new Timer(); task = new TimerTask() &#123; @Override public void run() &#123; view.setPressure(getPressure()); //通过子线程通知控件重绘 view.postInvalidate(); &#125; &#125;; //每500 毫秒执行一次，第二个参数是延时执行，这里为0 也就是第一次会立即执行 timer.schedule(task, 0, 500); &#125; //调用native 方法，获取压力值 public native int getPressure();&#125; 将上面工程部署到arm 架构的模拟器上。运行结果如下图所示。 9. 案例-监听应用程序的卸载需求：当我们的apk 安装在Android 手机上后，我们可以在其后台开启个C 语言编写的死循环，C 语言编程的程序跟我们的应用不在同一个进程中，因此当我们的应用软件被卸载的时候，C 语言可以监测到。监测原理就是访问/data/data/{包名}文件是否存在，如果不存在显然是被删除了。 Tips：考虑到我们上面的案例跟这个案例使用的知识点差不多，都是使用Java 语言调用C 语言。因此这里就不再一步一步的演示如何创建工程。这里只给出核心的C 语言代码。本人工程目录结构如下所示： 这里只给出listen.c 源文件清单，核心方法是这个文件实现的。在MainActivity.java 中加载该动态库，并在onCreate 方法中调用我们的C 语言函数即可。listen.c 代码清单如下所示： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;jni.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/inotify.h&gt;#include &lt;sys/stat.h&gt;#include &lt;android/log.h&gt;#define LOG_TAG "System.out"#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)void Java_com_itheima_jniuninstall_MainActivity_listen( JNIEnv * env, jobject obj) &#123; pid_t pid = fork(); //叉子 if (pid == 0) &#123; //当前是分叉出来的进程。 int isStop = 1; while (isStop) &#123; //监视当前应用程序的包名文件夹是否存在如果不存在了就是被卸载了。 FILE* file; //文件的指针 file = fopen("/data/data/com.itheima.jniuninstall", "r"); if (file == NULL) &#123; //被卸载了。 LOGI("uninstalled\n"); //开启一个网页了。 // int execlp(char *pathname, char *arg0, arg1, .., NULL); execlp("am","am","start","-a","android.intent.action.VIEW","-d","http://www.baid. com",NULL); isStop = 0; &#125; else &#123; //没有被卸载 LOGI("haha huode henhao \n"); &#125; //让线程休眠2 秒在C 语言中是秒为单位的不是毫秒 sleep(2); &#125; &#125;&#125; Tips：上面的execlp 函数用于调用本地系统（Android 系统）命令打开一个浏览器，访问一个指定的URL。但是经过我的测试发现在低版本模拟器（2.3）上该功能可是使用但是在高版本模拟器（4.3）上不可以使用。 10. 安卓逆向助手有一款叫安卓逆向助手软件反编译apk 十分方便。这里给大家介绍的反编译方法就是基于这款软件的。安卓逆向助手下载地址 Android逆向助手是一功能强大的逆向辅助软件。该软件可以帮助用户来进行apk反编译打包签名；dex/jar互转替换提取修复；so反编译；xml、txt加密；字符串编码等等，操作简单，只需要直接将文件拖放到源和目标文件。 将下载好的rar 包解压缩以后目录结构如下（内置的广告被我删除后的） Tips：lib 目录存放都是用java 写的核心反编译逻辑，必须跟exe 文件放在同一个目录下。 打开Android 逆向助手.exe，如下图所示： 选择源文件，并且选择（也是默认的选择）反编译apk，我们找到mtxx.apk 的路径，然后点击操作。在mtxx.apk 目录下生成了一个mtxx 文件夹，打开该文件，目录结构如下图所示： 在上面操作后打开lib 目录可以找到美图秀秀的动态库文件，但是我们还需要找到其java 代码。显然美图秀秀用smali 算法反编译了。那么我们接着下一步。 在Android 逆向助手.exe 中打开源文件，选择提取dex 点击执行。 这时候在目标文件夹下生成了dex 文件 最后在Android 逆向助手.exe 中选择dex 转jar 选项。在源文件中选择上一步生成的classes.dex 文件，然后点击执行（这个过程大概需要几秒的等待时间）。这时候该软件会自动将我们生成的jar 文件用jd-gui工具打开。打开效果如下所示： 11. jadxjadx是新一代反编译大杀器，github地址。Android开发(/学习)有时候需要用到反编译工具，Window上有很多工具，而Mac上则不多，这里稍微介绍一下Mac上可用的反编译工具Jadx. 11.1 准备clone 仓库，编译1234mkdir jadxgit clone https://github.com/skylot/jadx.gitcd jadx./gradlew dist #这个需要稍微等待一下 开始反编译，等完毕后，可以开始了，我就介绍个最简单最常用的用法 把apk改成zip，解压zip获取class.dex文件，将class.dex文件放到jadx目录下1234cd build/jadx/bin/jadx -d out class.dex # 反编译后放入out文件夹下(如果out不存在它会自动创建)#orbin/jadx-gui class.dex # 会反编译，并且使用gui打开 OK，就这样，后续还可以配置环境变量，更加方便 12. 更多Android反编译工具12.1 Classyshark轻松查看apk内部每个包的方法数，用了哪些开源库，同样拿知乎开刀做例子 12.2 smalideasmali代码调试插件，你以为没有拿到安卓Java源码就不能调试了吗？图样图森破了吧 12.3IDA ProIDA Pro，逆向大利器，不管你是smali还是so文件，照样动态调试你 12.4 Android Killer下载地址1 下载地址2 使用指南集Apk反编译、Apk打包、Apk签名，编码互转， ADB通信（应用安装-卸载-运行-设备文件管理）等特色功能于一 身，支持logcat日志输出，语法高亮， 基于关键字（支持单行代码或多行代码段）项目内搜索， 可自定义外部工具；吸收融汇多种工具功能与特点， 打造一站 式逆向工具操作体验，大大简化了用户在 安卓应用/游戏修改过程中的各类繁琐工作。 12.5 SmaliViewer下载地址 使用指南是一款免费的APK分析软件，无论从分析的深度还是广度来看，都是一款能够满足用户需求的产品，使您在APK分析的过程中，更加得心应手。 12.6 EnjarifyEnjarify 是一个用 Python 写的， Google 官方开源的可以将 Dalvik 字节码转换为 Java 字节码的工具。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>jni</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和C++在Android开发中的应用]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FC%E5%92%8CC%2B%2B%E5%9C%A8Android%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 前言1.1 Android SDK介绍Android是基于Linux内核的一个手机操作系统，谷歌提供了开发包（Android SDK），程序员可以通过开发包开发Android App(应用程序)。Android SDK提供Java语言接口，因此Android应用是使用Java开发的。 1.2 使用纯Java开发App的缺点在某些场合下，使用纯Java开发Android应用程序不完美，比如： 有高性能算法，Java语言无法满足 有跨平台需求，希望将App移植到iOS 已有代码的重用 1.3 引入NDK早在Android 1.6(2009年)时，google就提供了NDK（native development kit），NDK包括了一套Android的交叉编译环境和开发库，利用它可以编写C/C++程序，并编译成Android环境下使用的动态库，Java代码通过Jni规范，调用C/C++写的动态库。 目前最新的Android Studio 2.2中，集成了C/C++开发环境，开发人员在使用C/C++更加简单了。 2. 课程内容NDK中文官方开发技术文档地址 下载配置NDKNDK下载地址 配置NDK 如果不配置NDK路径，会报NDK没有配置错误 JNI开发HelloWorld把 Include C++ support的勾打上 选择C++11和Toolchain Default均可，C++11有更多的新特性和功能 点击Finish后，进入工程目录，如图所示，除了java文件夹外多了一个cpp文件夹，cpp就是存放c和c++代码的文件夹 配置NDK开发环境中遇到的坑Failed to find CMake 什么，CMake是什么鬼，原来，在Android Studio 2.2 后，NDK开发更加人性化了，使用了CMake，一款外部构建工具，可与 Gradle 搭配使用来构建原生库。如果您只计划使用 ndk-build，则不需要此组件。还有LLDB，一种调试程序，Android Studio 使用它来调试原生代码。 点击Install CMake and sync project，提示如下错误 1234Gradle sync failed: Failed to find CMake.Install from Android Studio under File/Settings/Appearance &amp; Behavior/System Settings/Android SDK/SDK Tools/CMake.Expected CMake executable at D:\android-sdk\cmake\bin\cmake.exe.Consult IDE log for more details (Help | Show Log) 原来是我使用了代理，因为之前Google的链接需要翻墙才能够使用，所以配置了某代理，但是该代理不管用，在设置中把代理去掉即可。在Google在中国开了发布会后，Google的链接可以使用了，Android开发官网也可以上了，而且翻译了大量的技术文档，方便了英语不太好的同学 打开 SDK Manager，安装上CMake和LLDB 更多更详细的NDK开发文档，请看Android官方中文文档向您的项目添加 C 和 C++ 代码 2.3 Android Java代码调用C++代码Java部分代码 123456789101112131415161718public class Jni &#123; static &#123; System.loadLibrary("bc-lib"); // libbc-lib.so &#125; private static Jni obj = new Jni(); private Jni()&#123;&#125; public static Jni instance()&#123; return obj; &#125; // native接口 public native boolean Login(String username, String password, String type); public native boolean Reg(String username, String password, String mobile, String email, String id); public native boolean LocationChange(double lng, double lat); public native boolean StartOrder(double lng1, double lat1, double lng2, double lat2);&#125; C++部分代码 1234567891011121314151617181920212223242526272829303132JNIEXPORT jboolean JNICALL Java_cn_xueguoliang_hc_Jni_Login (JNIEnv *env, jobject /* Jni object */, jstring jUsername, jstring jPassword, jstring type)&#123; return (jboolean)User::instance()-&gt;Login(j2c(env, jUsername), j2c(env, jPassword), j2c(env, type));&#125; JNIEXPORT jboolean JNICALL Java_cn_xueguoliang_hc_Jni_Reg (JNIEnv *env, jobject /* Jni object */, jstring jUsername, jstring jPassword, jstring mobile, jstring email, jstring id)&#123; return (jboolean)User::instance()-&gt;Reg( j2c(env, jUsername), j2c(env, jPassword), j2c(env, mobile), j2c(env, email), j2c(env, id));&#125; JNIEXPORT jboolean JNICALL Java_cn_xueguoliang_hc_Jni_LocationChange (JNIEnv *, jobject, jdouble lng, jdouble lat)&#123; User::instance()-&gt;LocationChange(lng, lat); return (jboolean)true;&#125; JNIEXPORT jboolean JNICALL Java_cn_xueguoliang_hc_Jni_StartOrder (JNIEnv *, jobject, jdouble lng1, jdouble lat1, jdouble lng2, jdouble lat2)&#123; return (jboolean)Order::instance()-&gt;start(lng1, lat1, lng2, lat2);&#125; 2.4 C++代码调用Java代码Java代码 123456789101112131415161718public class Jni &#123; static &#123; System.loadLibrary("native-lib"); &#125; private static Jni obj = new Jni(); public static Jni instance() &#123; return obj; &#125; public native void HelloWorld(); void callByCpp() &#123; Log.e("JniCallback", "hello java"); &#125;&#125; C++代码 12345678910111213extern "C"voidJava_com_example_xueguoliang_test_Jni_HelloWorld( JNIEnv* env, jobject This ) &#123; std::string hello = "Hello from C++"; jclass jniClass = env-&gt;FindClass("com/example/xueguoliang/test/Jni"); jmethodID jmethodID1 = env-&gt;GetMethodID(jniClass, "callByCpp", "()V"); env-&gt;CallVoidMethod(This, jmethodID1); return;&#125; 2.5 Java和C++字符串转换12345678910111213141516171819202122232425262728293031jstring c2j(JNIEnv* env, string cstr)&#123; return env-&gt;NewStringUTF(cstr.c_str());&#125; string j2c(JNIEnv* env, jstring jstr)&#123; string ret; jclass stringClass = env-&gt;FindClass("java/lang/String"); jmethodID getBytes = env-&gt;GetMethodID(stringClass, "getBytes", "(Ljava/lang/String;)[B"); // 把参数用到的字符串转化成java的字符 jstring arg = c2j(env, "utf-8"); jbyteArray jbytes = (jbyteArray)env-&gt;CallObjectMethod(jstr, getBytes, arg); // 从jbytes中，提取UTF8格式的内容 jsize byteLen = env-&gt;GetArrayLength(jbytes); jbyte* JBuffer = env-&gt;GetByteArrayElements(jbytes, JNI_FALSE); // 将内容拷贝到C++内存中 if(byteLen &gt; 0) &#123; char* buf = (char*)JBuffer; std::copy(buf, buf+byteLen, back_inserter(ret)); &#125; // 释放 env-&gt;ReleaseByteArrayElements(jbytes, JBuffer, 0); return ret;&#125; 2.6 javah和javapjavah用于生成native接口定义，比如 1javah -d ../cpp/ com.example.xueguoliang.test.Jni javap用于生成java函数的签名，比如 1javap -s Jni]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>jni</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uri、URL、UriMatcher、ContentUris详解]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FUri%E3%80%81URL%E3%80%81UriMatcher%E3%80%81ContentUris%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. URI：统一资源标识符URI是统一资源标识符，是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。URI由包括确定语法和相关协议的方案所定义。由是三个组成部分：访问资源的命名机制、存放资源的主机名、资源自身的名称，由路径表示。 1.1 URI的使用方法 schema：用来说明一个ContentProvider 控制哪些数据。”content://“ authority：主机名或授权，它定义了是哪个ContentProvider 提供这些数据 path：路径，URI 下的某一个Item。 ID：通常定义Uri 时使用”#”号占位符代替, 使用时替换成对应的数字content://com.itheima.provider/person/#：#表示数据id（#代表任意数字）content://com.itheima.provider/person/：来匹配任意文本。 为系统的每一个资源给其一个名字，比方说通话记录。 1、每一个ContentProvider都拥有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。 2、Android所提供的ContentProvider都存放在android.provider包中。 将其分为A，B，C，D 4个部分： A：标准前缀，用来说明一个Content Provider控制这些数据，无法改变的；”content://“ B：URI 的标识，它定义了是哪个Content Provider提供这些数据。对于第三方应用程序，为了保证URI标识的唯一性，它必须是一个完整的、小写的 类名。这个标识在 元素的 authorities属性中说明：一般是定义该ContentProvider的包.类的名称;”content://hx.android.text.myprovider” C：路径，不知道是不是路径，通俗的讲就是你要操作的数据库中表的名字，或者你也可以自己定义，记得在使用的时候保持一致就ok了；”content://hx.android.text.myprovider/tablename” D：如果URI中包含表示需要获取的记录的ID；则就返回该id对应的数据，如果没有ID，就表示返回全部； “content://hx.android.text.myprovider/tablename/#” #表示数据id 通用资源标志符（Universal Resource Identifier, 简称”URI”）。Uri代表要操作的数据，Android上可用的每种资源 - 图像、视频片段等都可以用Uri来表示。 URI一般由三部分组成： 访问资源的命名机制。 存放资源的主机名。 资源自身的名称，由路径表示。 Android的Uri由以下三部分组成： “content://“、数据的路径、标示ID(可选)举些例子，如： 所有联系人的Uri： content://contacts/people 某个联系人的Uri: content://contacts/people/5 所有图片Uri: content://media/external 某个图片的Uri：content://media/external/images/media/4 1.2 URI常用方法 方法 说明 withAppendedPath() 追加路径 encode() fromFile() 从一个文件新建一个uri parse() 解析uri getScheme() 获取uri中的schema部分 getLastPathSegment() 我们很经常需要解析Uri，并从Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为UriMatcher 和ContentUris 。 虽然这两类不是非常重要，但是掌握它们的使用，会便于我们的开发工作。下面就一起看一下这两个类的作用。 2. UriMatcherUriMatcher 类主要用于匹配Uri。使用方法如下首先第一步，初始化： 1UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); 第二步注册需要的Uri: 12matcher.addURI("com.yfz.Lesson", "people", PEOPLE); matcher.addURI("com.yfz.Lesson", "person/#", PEOPLE_ID); 第三部，与已经注册的Uri进行匹配: 12345678910111213141516171819202122Uri uri = Uri.parse("content://" + "com.yfz.Lesson" + "/people"); int match = matcher.match(uri); switch (match) &#123; case PEOPLE: return "vnd.android.cursor.dir/people"; case PEOPLE_ID: return "vnd.android.cursor.item/people"; default: return null; &#125; Uri uri = Uri.parse("content://" + "com.yfz.Lesson" + "/people");int match = matcher.match(uri); switch (match) &#123; case PEOPLE: return "vnd.android.cursor.dir/people"; case PEOPLE_ID: return "vnd.android.cursor.item/people"; default: return null; &#125; match方法匹配后会返回一个匹配码Code，即在使用注册方法addURI时传入的第三个参数。上述方法会返回”vnd.android.cursor.dir/person”. 总结: 常量 UriMatcher.NO_MATCH 表示不匹配任何路径的返回码 # 号为通配符 * 号为任意字符 另外说一下，官方SDK说明中关于Uri的注册是这样写的： 12345678910111213141516171819private static final UriMatcher sURIMatcher = new UriMatcher(); static &#123; sURIMatcher.addURI("contacts", "/people", PEOPLE); sURIMatcher.addURI("contacts", "/people/#", PEOPLE_ID); sURIMatcher.addURI("contacts", "/people/#/phones", PEOPLE_PHONES); sURIMatcher.addURI("contacts", "/people/#/phones/#", PEOPLE_PHONES_ID); sURIMatcher.addURI("contacts", "/people/#/contact_methods", PEOPLE_CONTACTMETHODS); sURIMatcher.addURI("contacts", "/people/#/contact_methods/#", PEOPLE_CONTACTMETHODS_ID); sURIMatcher.addURI("contacts", "/deleted_people", DELETED_PEOPLE); sURIMatcher.addURI("contacts", "/phones", PHONES); sURIMatcher.addURI("contacts", "/phones/filter/*", PHONES_FILTER); sURIMatcher.addURI("contacts", "/phones/#", PHONES_ID); sURIMatcher.addURI("contacts", "/contact_methods", CONTACTMETHODS); sURIMatcher.addURI("contacts", "/contact_methods/#", CONTACTMETHODS_ID); sURIMatcher.addURI("call_log", "/calls", CALLS); sURIMatcher.addURI("call_log", "/calls/filter/*", CALLS_FILTER); sURIMatcher.addURI("call_log", "/calls/#", CALLS_ID); &#125; 这个说明估计已经是Google官方没有更新，首先是初始化方法，没有传参，那么现在初始化时，实际是必须传参的。 可以看一下Android2.2的源码，无参数的构造方法已经是private的了。 另外就是addURI这个方法，第二个参数开始时不需要”/“， 否则是无法匹配成功的。 方法 说明 addURI(String authority, String path, int code) code：表示匹配成功以后的返回值 match() 匹配uri 3. ContentUrisContentUris 类用于获取Uri路径后面的ID部分 1、为路径加上ID: withAppendedId(uri, id)比如有这样一个Uri 1Uri uri = Uri.parse("content://com.yfz.Lesson/people") 通过withAppendedId方法，为该Uri加上ID 1Uri resultUri = ContentUris.withAppendedId(uri, 10); 最后resultUri为: content://com.yfz.Lesson/people/10 2、从路径中获取ID: parseId(uri) 12Uri uri = Uri.parse("content://com.yfz.Lesson/people/10") long personid = ContentUris.parseId(uri); 最后personid 为 :10 附上实验的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Lesson_14 extends Activity &#123; private static final String AUTHORITY = "com.yfz.Lesson"; private static final int PEOPLE = 1; private static final int PEOPLE_ID = 2; //NO_MATCH表示不匹配任何路径的返回码 private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH); static &#123; sURIMatcher.addURI(AUTHORITY, "people", PEOPLE); //这里的#代表匹配任意数字，另外还可以用*来匹配任意文本 sURIMatcher.addURI(AUTHORITY, "people/#", PEOPLE_ID); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Logger.d("------ Start Activity !!! ------"); Uri uri1 = Uri.parse("content://" + AUTHORITY + "/people"); Logger.e("Uri:" + uri1); Logger.d("Match 1" + getType(uri1)); Uri uri2 = Uri.parse("content://" + AUTHORITY + "/people" + "/2"); Logger.e("Uri:" + uri2); Logger.d("Match 2" + getType(uri2)); //拼接Uri Uri cUri = ContentUris.withAppendedId(uri1, 15); Logger.e("Uri:" + cUri); //获取ID long id = ContentUris.parseId(cUri); Logger.d("Uri ID: " + id); &#125; private String getType(Uri uri) &#123; int match = sURIMatcher.match(uri); switch (match) &#123; case PEOPLE: return "vnd.android.cursor.dir/person"; case PEOPLE_ID: return "vnd.android.cursor.item/person"; default: return null; &#125; &#125; &#125; ContentUris 是解析Uri 的一个工具类，可以将Uri 中的id 给解析出来 方法 说明 parseId(uri) 获取path中的数据 withAppendedId(uri, id) 使用ContentUris工具类将id追加到uri中，返回给客户 4. URL：统一资源定位符统一资源定位符也就是说根据URL能够定位到网络上的某个资源，它是指向互联网“资源”的指针。是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 每个URL都是URI，但不一定每个URI都是URL。这是因为URI还包括一个子类，即统一资源名称（URN），它命名资源但不指定如何定位资源。 比如百度URL即是http://www.baidu.com 5. URI、URL 和 URNURI 是统一资源标识符，而 URL 是统一资源定位符。因此，笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[即时通讯基础]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2F%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[即时通讯系列阅读 即时通讯基础 即时通讯：XMPP基础 即时通讯：XMPP项目实践-微聊 Smack类库最好的学习资料 1. 即时通讯简介即时通讯（Instant Messaging）是目前Internet 上最为流行的通讯方式，各种各样的即时通讯软件也层出不穷；服务提供商也提供了越来越丰富的通讯服务功能。不容置疑，Internet 已经成为真正的信息高速公路。从实际工程应用角度出发,以计算机网络原理为指导,结合当前网络中的一些常用技术,编程实现基于C/S 架构的网络聊天工具是切实可行的。 目前，中国市场上的企业级即时通信工具主要包括：信鸽、视高科技的视高可视协同办公平台、263EM、群英CC2010、通软联合的GoCom、腾讯公司的RTX、IBM 的Lotus Sametime、点击科技的GKE、中国互联网办公室的imo、中国移动的企业飞信、华夏易联的e-Link、擎旗的UcStar 等。相对于个人即时通信工具而言，企业级即时通信工具更加强调安全性、实用性、稳定性和扩展性 1.1 即时聊天的解决方案 socket：套接字，连接需要ip和端口，分为tcp和udp两种形式 xmpp：xmpp + openfire + asmack 1.2 常见协议 1.3 常见的术语 xmpp:基于xml的可拓展协议. jabber:xmpp的前身. openfire:支持xmpp的开源服务器 smack.jar:对xmpp协议封装.方便开发的jar包. spark.exe:基于xmpp的pc客户端; asmack.jar:smack.jar的精简版.专门针对android端开发 2. 基本概念和原理2.1 常用的网络通信协议TCP/IP：Transmission Control Protocol/Internet Protocol 的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet 最基本的协议、Internet 国际互联网络的基础，由网络层的IP 协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4 层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP 负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP 是给因特网的每一台联网设备规定一个地址。 UDP：UDP 协议全称是用户数据报协议，在网络中它与TCP 协议一样用于处理数据包，是一种无连接的协议。在OSI 模型中，在第四层——传输层，处于IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。UDP 协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天UDP 仍然不失为一项非常实用和可行的网络传输层协议。 TCP/IP 协议栈主要分为四层:应用层、传输层、网络层、数据链路层,每层都有相应的协议，如下图： 所谓的协议就是双方进行数据传输的一种格式。 2.2 TCP、UDP 特点对比TCP 协议是面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达)传输层协议。UDP 协议也是传输层协议，它是无连接，不保证可靠的传输层协议。 2.3 TCP 三次握手过程1、请求端(通常称为客户)发送一个SYN 段指明客户打算连接的服务器的端口，以及初始序号(ISN)2、服务器发回包含服务器的初始序号的SYN 报文段(报文段2)作为应答。同时，将确认序号设置为客户的ISN加1 以对客户的SYN 报文段进行确认。 TCP UDP 面向连接 面向非连接 可靠的连接 不可靠的连接 速度慢 速度快 大文件、重要的数据等 适合小数据、不重要 3、客户必须将确认序号设置为服务器的ISN 加1 以对服务器的SYN 报文段进行确认(报文段3)这三个报文段完成连接的建立。这个过程也称为三次握手(three-way handshake)。 上面的过程如下图所示： 2.4 即时通讯形式直接通讯两个不同客户端之间不经过服务器，直接通过网络进行数据的交互。常用的p2p 技术就是直接通讯的形式。 在线代理通讯一个客户端发送的消息先发送到服务器，服务器接收到消息后再发送给指定的另外一个客户端。QQ 的消息尤其是离线消息就是同在线代理的方式实现的。 离线代理通讯一个客户端发送消息给服务器，服务器存储在数据库中个，当另外一个客户端上线后在发送过去。 离线扩展通讯一个客户端发送消息给服务器，服务器通过邮件、短信等其他形式将消息发送给接收者。 3. ServerSocket 和Socket3.1 使用Java 完成简单的Socket 通信在Java 中Socket 可以理解为客户端或者服务器端的一个特殊的对象，这个对象有两个关键的方法，一个是getInputStream 方法，另一个是getOutputStream 方法。getInputStream 方法可以得到一个输入流，客户端的Socket对象上的getInputStream 方法得到的输入流其实就是从服务器端发回的数据流。GetOutputStream 方法得到一个输出流，客户端Socket 对象上的getOutputStream 方法返回的输出流就是将要发送到服务器端的数据流，（其实是一个缓冲区，暂时存储将要发送过去的数据）。 下面就让我们写一个简单的Demo 来演示Socket 是如何使用的。 建立服务器类服务类使用到的核心类的是ServerSocket。这里我们只需要建立一个Java Project 即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class IMServer &#123; private static ServerSocket serverSocket; private static BufferedReader reader; public static void main(String[] args) &#123; try &#123; serverSocket = new ServerSocket(7788); /** * 等待接收客户端连接进来，该方法是线程阻塞的 */ Socket accept = serverSocket.accept(); /** * 获取输入流，用于接收客户端发来的数据 */ InputStream inputStream = accept.getInputStream(); /** * 将字节输入流转化为字符输出流 */ reader = new BufferedReader(new InputStreamReader(inputStream)); /** * 打印数据 */ String tmp = null; while ((tmp = reader.readLine()) != null) &#123; System.out.println(tmp); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null) &#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 建立客户端类1234567891011121314151617181920212223242526272829303132333435363738public class IMClient &#123; private static Socket socket; private static BufferedWriter writer; /** * @param args */ public static void main(String[] args) &#123; try &#123; socket = new Socket("127.0.0.1", 7788); /** * 获取输出流 */ OutputStream outputStream = socket.getOutputStream(); writer = new BufferedWriter(new OutputStreamWriter(outputStream)); writer.write("hello wo shi wzy!" + new Date().getTime()); writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 在上面的代码中我们仅仅实现了一个最简单的服务器和客户端，服务器启动起来后只能接受到一次消息，然后就关闭了。如果想让服务器一直运行，应该通过死循环来处理不同的发送进来的消息。 4. Socket调试工具TCP/UDP Socket调试工具提供了TCP Server,TCP Client,UDP Server,UDP Client,UDP Group 五种Socket调试方案 4.1 TCP4.1.1 手机作为Client，PC作为Server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168public class MyClientActivity extends Activity &#123; private EditText mEditText = null; private Button connectButton = null; private Button sendButton = null; private TextView mTextView = null; private Socket clientSocket = null; private OutputStream outStream = null; private Handler mHandler = null; private ReceiveThread mReceiveThread = null; private boolean stop = true; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mEditText = (EditText) this.findViewById(R.id.edittext); mTextView = (TextView) this.findViewById(R.id.retextview); connectButton = (Button) this.findViewById(R.id.connectbutton); sendButton = (Button) this.findViewById(R.id.sendbutton); sendButton.setEnabled(false); // 连接按钮监听 connectButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub try &#123; // 实例化对象并连接到服务器 clientSocket = new Socket("172.27.35.1", 60000); &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; displayToast("连接成功！"); // 连接按钮使能 connectButton.setEnabled(false); // 发送按钮使能 sendButton.setEnabled(true); mReceiveThread = new ReceiveThread(clientSocket); stop = false; // 开启线程 mReceiveThread.start(); &#125; &#125;); // 发送数据按钮监听 sendButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub byte[] msgBuffer = null; // 获得EditTex的内容 String text = mEditText.getText().toString(); try &#123; // 字符编码转换 msgBuffer = text.getBytes("GB2312"); &#125; catch (UnsupportedEncodingException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; try &#123; // 获得Socket的输出流 outStream = clientSocket.getOutputStream(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; try &#123; // 发送数据 outStream.write(msgBuffer); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 清空内容 mEditText.setText(""); displayToast("发送成功！"); &#125; &#125;); // 消息处理 mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // 显示接收到的内容 mTextView.setText((msg.obj).toString()); &#125; &#125;; &#125; // 显示Toast函数 private void displayToast(String s) &#123; Toast.makeText(this, s, Toast.LENGTH_SHORT).show(); &#125; private class ReceiveThread extends Thread &#123; private InputStream inStream = null; private byte[] buf; private String str = null; ReceiveThread(Socket s) &#123; try &#123; // 获得输入流 this.inStream = s.getInputStream(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; @Override public void run() &#123; while (!stop) &#123; this.buf = new byte[512]; try &#123; // 读取输入数据（阻塞） this.inStream.read(this.buf); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 字符编码转换 try &#123; this.str = new String(this.buf, "GB2312").trim(); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; Message msg = new Message(); msg.obj = this.str; // 发送消息 mHandler.sendMessage(msg); &#125; &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (mReceiveThread != null) &#123; stop = true; mReceiveThread.interrupt(); &#125; &#125;&#125; 4.1.2 手机作为Server，PC作为Client 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191public class MyServerActivity extends Activity &#123; private TextView ipTextView = null; private EditText mEditText = null; private Button sendButton = null; private TextView mTextView = null; private OutputStream outStream = null; private Socket clientSocket = null; private ServerSocket mServerSocket = null; private Handler mHandler = null; private AcceptThread mAcceptThread = null; private ReceiveThread mReceiveThread = null; private boolean stop = true; /** Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); ipTextView = (TextView) this.findViewById(R.id.iptextview); mEditText = (EditText) this.findViewById(R.id.sedittext); sendButton = (Button) this.findViewById(R.id.sendbutton); sendButton.setEnabled(false); mTextView = (TextView) this.findViewById(R.id.textview); // 发送数据按钮监听 sendButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub byte[] msgBuffer = null; // 获得EditTex的内容 String text = mEditText.getText().toString(); try &#123; // 字符编码转换 msgBuffer = text.getBytes("GB2312"); &#125; catch (UnsupportedEncodingException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; try &#123; // 获得Socket的输出流 outStream = clientSocket.getOutputStream(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; try &#123; // 发送数据 outStream.write(msgBuffer); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 清空内容 mEditText.setText(""); displayToast("发送成功！"); &#125; &#125;); // 消息处理 mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 0: &#123; // 显示客户端IP ipTextView.setText((msg.obj).toString()); // 使能发送按钮 sendButton.setEnabled(true); break; &#125; case 1: &#123; // 显示接收到的数据 mTextView.setText((msg.obj).toString()); break; &#125; &#125; &#125; &#125;; mAcceptThread = new AcceptThread(); // 开启监听线程 mAcceptThread.start(); &#125; // 显示Toast函数 private void displayToast(String s) &#123; Toast.makeText(this, s, Toast.LENGTH_SHORT).show(); &#125; private class AcceptThread extends Thread &#123; @Override public void run() &#123; try &#123; // 实例化ServerSocket对象并设置端口号为7100 mServerSocket = new ServerSocket(60000); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; try &#123; // 等待客户端的连接（阻塞） clientSocket = mServerSocket.accept(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; mReceiveThread = new ReceiveThread(clientSocket); stop = false; // 开启接收线程 mReceiveThread.start(); Message msg = new Message(); msg.what = 0; // 获取客户端IP msg.obj = clientSocket.getInetAddress().getHostAddress(); // 发送消息 mHandler.sendMessage(msg); &#125; &#125; private class ReceiveThread extends Thread &#123; private InputStream mInputStream = null; private byte[] buf; private String str = null; ReceiveThread(Socket s) &#123; try &#123; // 获得输入流 this.mInputStream = s.getInputStream(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; @Override public void run() &#123; while (!stop) &#123; this.buf = new byte[512]; // 读取输入的数据(阻塞读) try &#123; this.mInputStream.read(buf); &#125; catch (IOException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; // 字符编码转换 try &#123; this.str = new String(this.buf, "GB2312").trim(); &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; Message msg = new Message(); msg.what = 1; msg.obj = this.str; // 发送消息 mHandler.sendMessage(msg); &#125; &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); if (mReceiveThread != null) &#123; stop = true; mReceiveThread.interrupt(); &#125; &#125;&#125; 4.2 UDP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165public class MainActivity extends Activity &#123; private static String TAG = "CallActivity"; private Handler handler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; // 播放声音 initBeepSound(); playBeepSoundAndVibrate(); Log.i(TAG, "reciever_msg"); String result = (String) msg.obj; System.out.println(result); tv_result.setText(result); &#125;; &#125;; private String ip; @Override protected void onCreate(Bundle savedInstanceState) &#123; // TODO super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ip = IpUtil.getIp(this); Toast.makeText(this, ip, Toast.LENGTH_LONG).show(); System.out.println("ip:" + ip); tv_result = (TextView) findViewById(R.id.tv_result); &#125; /** * 发送者 */ public void send(View v) &#123; new Thread() &#123; @Override public void run() &#123; try &#123; //1. 创建一个DatagramSocket对象 DatagramSocket socket = new DatagramSocket(5678); //2. 创建一个 InetAddress ， 相当于是地址,就是想要发送的ip地址 InetAddress serverAddress = InetAddress.getByName("172.27.35.1"); //3. 这是随意发送一个数据 String str = "来自android手机的问候"; //4. 转为byte类型 byte data[] = str.getBytes("GBK"); //5. 创建一个DatagramPacket 对象，并指定要讲这个数据包发送到网络当中的哪个地址，以及端口号 DatagramPacket pack = new DatagramPacket(data, data.length, serverAddress, 5678); //6. 调用DatagramSocket对象的send方法 发送数据 socket.send(pack); &#125; catch (SocketException e) &#123; Log.i(TAG, "error"); e.printStackTrace(); &#125; catch (UnknownHostException e) &#123; Log.i(TAG, "error"); e.printStackTrace(); &#125; catch (IOException e) &#123; Log.i(TAG, "error"); e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; /** * 接收者 * @param v */ public void receive(View v) &#123; new Thread() &#123; @Override public void run() &#123; // 执行完毕后给handler发送一个空消息 try &#123; // 1. 创建一个DatagramSocket对象，并指定监听的端口号/\ DatagramSocket socket = new DatagramSocket(5678); // 2. 创建一个byte数组用于接收 byte data[] = new byte[1024]; // 3. 创建一个空的DatagramPackage对象 DatagramPacket pack = new DatagramPacket(data, data.length); // 4. 使用receive方法接收发送方所发送的数据,同时这也是一个阻塞的方法 while (true) &#123; Log.i(TAG, "reciever_1"); socket.receive(pack); Log.i(TAG, "reciever_2"); // 5. 得到发送过来的数据 // String result = new String(pack.getData(), pack.getOffset(), pack.getLength(),"GBK"); String result = new String(pack.getData(), pack.getOffset(), pack.getLength()); Message msg = new Message(); msg.obj = result; handler.sendMessage(msg); Log.i(TAG, "sendmsg_1"); &#125; &#125; catch (UnknownHostException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); Log.i(TAG, "error"); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); Log.i(TAG, "error"); &#125; &#125; &#125;.start(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); &#125; // 播放声音 private static final float BEEP_VOLUME = 0.10f; private MediaPlayer mediaPlayer; private void initBeepSound() &#123; if (mediaPlayer == null) &#123; setVolumeControlStream(AudioManager.STREAM_MUSIC); mediaPlayer = new MediaPlayer(); mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC); mediaPlayer.setOnCompletionListener(beepListener); AssetFileDescriptor file = getResources().openRawResourceFd(R.raw.beep); try &#123; mediaPlayer.setDataSource(file.getFileDescriptor(), file.getStartOffset(), file.getLength()); file.close(); mediaPlayer.setVolume(BEEP_VOLUME, BEEP_VOLUME); mediaPlayer.prepare(); &#125; catch (IOException e) &#123; mediaPlayer = null; &#125; &#125; &#125; private void playBeepSoundAndVibrate() &#123; if (mediaPlayer != null) &#123; mediaPlayer.start(); &#125; // 震动 Vibrator mVibrator = (Vibrator) getApplication().getSystemService(Service.VIBRATOR_SERVICE); mVibrator.vibrate(2000); long[] pattern = &#123; 0, 100, 200, 100, 200 &#125;; mVibrator.vibrate(pattern, -1); &#125; private final OnCompletionListener beepListener = new OnCompletionListener() &#123; public void onCompletion(MediaPlayer mediaPlayer) &#123; mediaPlayer.seekTo(0); &#125; &#125;; // 退出提醒 private long exitTime; private TextView tv_result; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123; if ((System.currentTimeMillis() - exitTime) &gt; 2000) &#123; Toast.makeText(getApplicationContext(), "再按一次退出" + getResources().getString(R.string.app_name), Toast.LENGTH_SHORT).show(); exitTime = System.currentTimeMillis(); &#125; else &#123; finish(); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125;&#125; IpUtil.java1234567891011121314151617181920212223242526272829303132333435363738public class IpUtil &#123; /** * 获取手机ip * * @return */ public static String getLocalIpAddress() &#123; try &#123; for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) &#123; NetworkInterface intf = en.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress()) &#123; String ip = inetAddress.getHostAddress().toString(); System.out.println("getLocalIpAddressIP:"+ip); return ip; &#125; &#125; &#125; &#125; catch (SocketException ex) &#123; Log.e("ifo", ex.toString()); &#125; return ""; &#125; public static String getIp(Activity activity) &#123; WifiManager wifiManager = (WifiManager) activity.getSystemService(Context.WIFI_SERVICE); WifiInfo wifiInfo = wifiManager.getConnectionInfo(); int ipAddress = wifiInfo.getIpAddress(); // 格式化IP address，例如：格式化前：1828825280，格式化后：192.168.1.109 String ip = String.format("%d.%d.%d.%d", (ipAddress &amp; 0xff), (ipAddress &gt;&gt; 8 &amp; 0xff), (ipAddress &gt;&gt; 16 &amp; 0xff), (ipAddress &gt;&gt; 24 &amp; 0xff)); System.out.println("getIpIP:"+ip); return ip; &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>xmpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[即时通讯：XMPP项目实践-微聊]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2F%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%9AXMPP%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5-%E5%BE%AE%E8%81%8A%2F</url>
    <content type="text"><![CDATA[即时通讯系列阅读 即时通讯基础 即时通讯：XMPP基础 即时通讯：XMPP项目实践-微聊 Smack类库最好的学习资料 1. 项目简介做一个类似QQ 的通讯工具，要求有注册、登录、添加好友、添加分组、聊天、退出登录等功能。我用8 张运行效果图来展示我们将要实现的功能。 注意，服务器用的是Openfire，我们可以用Spark 作为另外一个客户端进行测试。闪屏页进来以后是登录界面，要求记住上次登陆的账号和密码，在界面的右下角有新用户按钮，点击后进入注册界面。注册只需要输入账号和密码即可。账号不能和其他人重复，否则注册不成功。 主界面是一个Activity 绑定3 个Fragment 实现，分别是消息、联系人、动态。 其中消息界面是一个ListView 展出了最近的联系人。点击其中的一个条目可以进入聊天界面。 联系人界面主要是一个ExpandableListView。ExpandableListView 列出了用户组，以及各个组中的好友。点击任意好友可以进入聊天界面。在ExpandableListView 上面有两个图标，分别是新朋友、新群组。点击新朋友弹出一个自定义对话框，在该对话框中输入对方好友的名称，等待对方同意了即可添加为好友。 点击新群组也弹出一个自定义对话框，在该对话框中输入分组名称，则可以创建一个分组。 如果好友不存则添加好友失败，如果分组不存在则创建分组失败。 动态界面主要展示了当前用户的信息，最下面有个退出按钮，点击后退出当前登录，并跳转到登录界面。 聊天界面是一个ListView，该ListView 的条目有两类布局，分别用来表示好友的消息和自己的消息。在最下方的输入框输入文本内容，然后点击发送可以将该消息发送给好友。好友有消息过来也可以直接显示在该界面。 2. 项目搭建1、下载asmak.jar，是个德国网站 asmack 的版本号从0.x 到现在的4.x 变化比较大。不通过版本差异也比较大。本次我写项目用的是0.8.x 的。 用的是13 年的版本。因为该api 在网上能查到的资料比较多。如果是下一次我再写这个项目我就决定用15 年发布的最新版本的了。 我想看看asmack 公司官网，吧asmack 去掉，想着就是贵公司的网址呢，却得到这样的界面。 2、给工程添加jar简单极了，只需把下载好的jar 包添加到Android 工程的libs 目录下即可。注意如果eclipse 没有自动将该包添加到环境变量中，我们需要手动添加一下。 3、项目目录结构图 3. 项目实现3.1 Spark 客户端的下载和安装闪屏界面新颖的闪屏界面，马老师，学习的目的，我借来用一用哈希望您不用太在意。 我要做的效果是闪屏等待3 秒，然后进入主界面。但是每次都让用户等待3 秒，对于急性子来讲估计会很抓狂。那怎么办呢，只要是这个界面用户触摸屏幕则立即进入主界面。布局太简单了，不给了。直接给代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 闪屏页面默认等待3s 触摸时直接进入主界面 * * @author wzy 2015-8-14 * */ public class SplashActivity extends Activity &#123; private static final long DURATION = 3000; /** * 保证变量的修改是可见的，但是无法保证变量的原子性 */ private volatile boolean isEntered = false; private Thread splashThread = new Thread(new Runnable() &#123; @Override public void run() &#123; SystemClock.sleep(DURATION); enter(); &#125; &#125;); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); splashThread.start(); &#125; private synchronized void enter() &#123; if (!isEntered) &#123; isEntered = true; startActivity(new Intent(SplashActivity.this, LoginActivity.class)); finish(); &#125; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; enter(); return true; &#125; &#125; 3.2 登录登录界面布局很简单。如果写不出来就没必要往下看了。登录的核心代码：mXmppConnection.login(name, pwd); activity_login.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/login_background" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/login_background" android:orientation="vertical" &gt; &lt;ImageView android:id="@+id/iv_touxiang" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_marginTop="40dp" android:contentDescription="@null" android:src="@drawable/login_image" /&gt; &lt;EditText android:id="@+id/et_name" android:layout_width="match_parent" android:layout_height="40dp" android:layout_marginLeft="5dp" android:layout_marginRight="5dp" android:layout_marginTop="30dp" android:background="#FFFFFF" android:hint="请输入账号" android:paddingLeft="5dp" android:textSize="20sp" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="#55AABBCC" /&gt; &lt;EditText android:id="@+id/et_pwd" android:layout_width="match_parent" android:layout_height="40dp" android:layout_marginLeft="5dp" android:layout_marginRight="5dp" android:background="#FFFFFF" android:hint="请输入密码" android:inputType="textPassword" android:paddingLeft="5dp" android:textSize="20sp" /&gt; &lt;Button android:id="@+id/btn_login" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="15dp" android:background="@color/title_layout" android:onClick="login" android:text="登录" android:textColor="#FFFFFF" android:textSize="20sp" /&gt; &lt;/LinearLayout&gt; &lt;Button android:id="@+id/register" android:layout_width="100dp" android:layout_height="40dp" android:layout_alignParentBottom="true" android:layout_alignParentRight="true" android:layout_marginRight="20dp" android:background="@drawable/register_user_btn" android:text="新用户" android:onClick="gotoRegist" android:textColor="@color/blue" android:textSize="16sp" /&gt;&lt;/RelativeLayout&gt; LoginActivity 和RegistActivity 都继承自BaseActivity。因此这里先把BaseActivity 的代码列出。 BaseActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161public class XmppConnectionManager &#123; private static XmppConnectionManager instance = null; //私有化构造函数 private XmppConnectionManager() &#123; &#125; /** * 获取该对象 * @return */ public static XmppConnectionManager getInstance() &#123; if (instance == null) &#123; instance = new XmppConnectionManager(); &#125; return instance; &#125; /** * 执行初始化脚本 * @return */ public XMPPConnection init() &#123; /** * 创建连接配置对象&lt;br&gt; * 第一个参数是Openfire 服务器地址&lt;br&gt; * 第二个参数是Openfire 服务器断开号，默认是5222&lt;br&gt; * 我们可以把这两个参数配置的清单文件中，也可以写死在代码中 */ ConnectionConfiguration connectionConfig = new ConnectionConfiguration(Const.XMPP_HOST,Const.XMPP_PORT); /** * 不使用SAL 安全验证 */ connectionConfig.setSASLAuthenticationEnabled(false); /** * 设置TLS 安全模式 */ connectionConfig.setSecurityMode(ConnectionConfiguration.SecurityMode.enabled); // 允许自动连接 connectionConfig.setReconnectionAllowed(true); // 允许登陆成功后更新在线状态 connectionConfig.setSendPresence(true); //设置为debug 模式，该模式可以在控制台看到接收和发送的xmpp 协议 connectionConfig.setDebuggerEnabled(true); // 收到好友邀请后同意添加为好友的模式，有三种，manual 表示需要经过同意,accept_all 表示不经同意自动 为好友，reject_all 拒绝加为好友邀请 Roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.accept_all); /** * 该配置时为了解决asmack 的一个bug 或者说弥补一个不足之处。不用细细追究。 */ configure(ProviderManager.getInstance()); //创建一个连接对象，参数为配置对象 XMPPConnection connection = new XMPPConnection(connectionConfig); return connection; &#125; public void configure(ProviderManager pm) &#123; // Private Data Storage pm.addIQProvider("query", "jabber:iq:private", new PrivateDataManager.PrivateDataIQProvider()); // Time try &#123; pm.addIQProvider("query", "jabber:iq:time", Class.forName("org.jivesoftware.smackx.packet.Time")); &#125; catch (ClassNotFoundException e) &#123; Log.w("TestClient", "Can't load class for org.jivesoftware.smackx.packet.Time"); &#125; // Roster Exchange pm.addExtensionProvider("x", "jabber:x:roster", new RosterExchangeProvider()); // Message Events pm.addExtensionProvider("x", "jabber:x:event", new MessageEventProvider()); // Chat State pm.addExtensionProvider("active", "http://jabber.org/protocol/chatstates", new ChatStateExtension.Provider()); pm.addExtensionProvider("composing", "http://jabber.org/protocol/chatstates", new ChatStateExtension.Provider()); pm.addExtensionProvider("paused", "http://jabber.org/protocol/chatstates", new ChatStateExtension.Provider()); pm.addExtensionProvider("inactive", "http://jabber.org/protocol/chatstates", new ChatStateExtension.Provider()); pm.addExtensionProvider("gone", "http://jabber.org/protocol/chatstates", new ChatStateExtension.Provider()); // XHTML pm.addExtensionProvider("html", "http://jabber.org/protocol/xhtml-im", new XHTMLExtensionProvider()); // Group Chat Invitations pm.addExtensionProvider("x", "jabber:x:conference", new GroupChatInvitation.Provider()); // Service Discovery # Items pm.addIQProvider("query", "http://jabber.org/protocol/disco#items", new DiscoverItemsProvider()); // Service Discovery # Info pm.addIQProvider("query", "http://jabber.org/protocol/disco#info", new DiscoverInfoProvider()); // Data Forms pm.addExtensionProvider("x", "jabber:x:data", new DataFormProvider()); // MUC User pm.addExtensionProvider("x", "http://jabber.org/protocol/muc#user", new MUCUserProvider()); // MUC Admin pm.addIQProvider("query", "http://jabber.org/protocol/muc#admin", new MUCAdminProvider()); // MUC Owner pm.addIQProvider("query", "http://jabber.org/protocol/muc#owner", new MUCOwnerProvider()); // Delayed Delivery pm.addExtensionProvider("x", "jabber:x:delay", new DelayInformationProvider()); // Version try &#123; pm.addIQProvider("query", "jabber:iq:version", Class.forName("org.jivesoftware.smackx.packet.Version")); &#125; catch (ClassNotFoundException e) &#123; // Not sure what's happening here. &#125; // VCard pm.addIQProvider("vCard", "vcard-temp", new VCardProvider()); // Offline Message Requests pm.addIQProvider("offline", "http://jabber.org/protocol/offline", new OfflineMessageRequest.Provider()); // Offline Message Indicator pm.addExtensionProvider("offline", "http://jabber.org/protocol/offline", new OfflineMessageInfo.Provider()); // Last Activity pm.addIQProvider("query", "jabber:iq:last", new LastActivity.Provider()); // User Search pm.addIQProvider("query", "jabber:iq:search", new UserSearch.Provider()); // SharedGroupsInfo pm.addIQProvider("sharedgroup", "http://www.jivesoftware.org/protocol/sharedgroup", new SharedGroupsInfo.Provider()); // JEP-33: Extended Stanza Addressing pm.addExtensionProvider("addresses", "http://jabber.org/protocol/address", new MultipleAddressesProvider()); // FileTransfer pm.addIQProvider("si", "http://jabber.org/protocol/si", new StreamInitiationProvider()); pm.addIQProvider("query", "http://jabber.org/protocol/bytestreams", new BytestreamsProvider()); // Privacy pm.addIQProvider("query", "jabber:iq:privacy", new PrivacyProvider()); pm.addIQProvider("command", "http://jabber.org/protocol/commands", new AdHocCommandDataProvider()); pm.addExtensionProvider("malformed-action", "http://jabber.org/protocol/commands", new AdHocCommandDataProvider.MalformedActionError()); pm.addExtensionProvider("bad-locale", "http://jabber.org/protocol/commands", new AdHocCommandDataProvider.BadLocaleError()); pm.addExtensionProvider("bad-payload", "http://jabber.org/protocol/commands", new AdHocCommandDataProvider.BadPayloadError()); pm.addExtensionProvider("bad-sessionid", "http://jabber.org/protocol/commands", new AdHocCommandDataProvider.BadSessionIDError()); pm.addExtensionProvider("session-expired","http://jabber.org/protocol/commands", new AdHocCommandDataProvider.SessionExpiredError()); &#125; &#125; LoginActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146import org.jivesoftware.smack.XMPPException;import com.itheima.qq.MainActivity;import com.itheima.qq.QQApplication;import com.itheima.qq.R;import android.content.Intent;import android.content.SharedPreferences;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.text.TextUtils;import android.view.View;import android.widget.EditText;import android.widget.Toast;import static android.app.Activity.RESULT_CANCELED;import static android.app.Activity.RESULT_OK;import static android.content.Context.MODE_PRIVATE;public class LoginActivity extends BaseActivity &#123; private EditText et_name; private EditText et_pwd; private String name; private String pwd; private SharedPreferences sp; private Handler handler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; switch (msg.what) &#123; case RESULT_OK: Toast.makeText(LoginActivity.this, msg.obj + " 登录成功", 0).show(); //获取自定义的Application，并将连接对象保存在Application 中 QQApplication application = (QQApplication) getApplication(); application.setXmppConnection(mXmppConnection); //进入主界面 Intent intent = new Intent(LoginActivity.this, MainActivity.class); startActivity(intent); //关闭登陆页面 finish(); break; case RESULT_CANCELED: Toast.makeText(LoginActivity.this, "登录失败。" + msg.obj, 0).show(); break; default: break; &#125; &#125;; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); sp = getSharedPreferences("config", MODE_PRIVATE); initView(); &#125; private void initView() &#123; et_name = (EditText) findViewById(R.id.et_name); et_pwd = (EditText) findViewById(R.id.et_pwd); // 如果sp 中记录有历史用户名和密码则填充到界面 String name = sp.getString("name", ""); String pwd = sp.getString("pwd", ""); if (!TextUtils.isEmpty(name)) &#123; et_name.setText(name); &#125; if (!TextUtils.isEmpty(pwd)) &#123; et_pwd.setText(pwd); &#125; &#125; /** * 登录Button 绑定的按钮事件 * * @param view */ public void login(View view) &#123; // 首先获取到用户输入的用户名和密码 name = et_name.getText().toString(); pwd = et_pwd.getText().toString(); // 保存到sp 中 Editor editor = sp.edit(); editor.putString("name", name); editor.putString("pwd", pwd); // 一定记得提交 editor.commit(); /** * 开启一个子线程进行登录，因为登录肯定要连接网络，网络操作必须在子线程中 */ new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //连接服务器 if (!mXmppConnection.isConnected()) &#123; mXmppConnection.connect(); &#125; &#125; catch (XMPPException e1) &#123; e1.printStackTrace(); Looper.prepare(); Toast.makeText(LoginActivity.this, "连接服务器失败。", 0).show(); Looper.loop(); return; &#125; try &#123; //登录，登录其实也是授权的过程 if (!mXmppConnection.isAuthenticated()) &#123; mXmppConnection.login(name, pwd);//登录的关键代码 &#125; //如果授权成功则发送handler 消息 if (mXmppConnection.isAuthenticated()) &#123; Message message = Message.obtain(); message.what = RESULT_OK; //通过连接获取当前登录的用户名 message.obj = mXmppConnection.getUser(); handler.sendMessage(message); &#125; &#125; catch (XMPPException e) &#123; e.printStackTrace(); Message message = Message.obtain(); message.what = RESULT_CANCELED; message.obj = e; handler.sendMessage(message); &#125; &#125; &#125;).start(); &#125; /** * 绑定的界面中button 事件&lt;br&gt; * 跳转到注册界面 * * @param view */ public void gotoRegist(View view) &#123; //跳转到注册界面 Intent registIntent = new Intent(this, RegistActivity.class); startActivity(registIntent); &#125;&#125; 在上面的代码中我们将登陆成功后获取的connection 对象设置到了Application 中，这里用到了自定义的Application，并且在清单文件中已经配置。 QQApplication.java 12345678910111213public class QQApplication extends Application &#123; private XMPPConnection mXmppConnection; @Override public void onCreate() &#123; super.onCreate(); &#125; public XMPPConnection getXmppConnection()&#123; return mXmppConnection; &#125; public void setXmppConnection(XMPPConnection xmppConnection)&#123; this.mXmppConnection = xmppConnection; &#125; &#125; AndroidManifest.xml123456789101112131415161718192021222324252627282930313233&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.itheima.qq" android:versionCode="1" android:versionName="1.0" &gt; &lt;uses-sdk android:minSdkVersion="8" android:targetSdkVersion="21" /&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; &lt;application android:name="com.itheima.qq.QQApplication" android:allowBackup="true" android:icon="@drawable/qq" android:label="@string/app_name" android:theme="@style/AppTheme" &gt; &lt;activity android:name="com.itheima.qq.activity.SplashActivity" android:label="@string/app_name" android:theme="@android:style/Theme.NoTitleBar.Fullscreen" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name="com.itheima.qq.MainActivity" /&gt; &lt;activity android:name="com.itheima.qq.activity.LoginActivity" /&gt; &lt;activity android:name="com.itheima.qq.activity.RegistActivity" /&gt; &lt;activity android:name="com.itheima.qq.activity.ChatActivity" /&gt; &lt;service android:name="com.itheima.qq.ChatService" /&gt; &lt;/application&gt;&lt;/manifest&gt; 清单文件中高亮显示的两个部分，因为需要连接服务器，因此需要联网权限。 3.3 注册注册功能核心代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//创建注册对象，用于封装注册参数 Registration registration = new Registration(); //设置注册属于设置属性，因此这里设置类型为set registration.setType(Type.SET); //设置用户名和密码 registration.setUsername(name); registration.setPassword(pwd); /** * 注册信息封装好之后其实就可以发送了可以直接调用&lt;br&gt; * mXmppConnection.sendPacket(registration);方法&lt;br&gt; * 但是上面的方法并没有返回值，注册是否成功我们不清楚&lt;br&gt; * 因此我们需要开启一个数据包收集器来手机服务返回的信息 * */ //定义一个数据包过滤器 /** * AndFilter 是一个组合过滤器，形参是可变参数，可以传递多种PacketFilter 的子类 &lt;br&gt; * 我们需要要过滤的原则是根据注册数据包的id 和数据包类型&lt;br&gt; * */ PacketFilter filter = new AndFilter(new PacketIDFilter(registration.getPacketID()), new PacketTypeFilter(IQ.class)); //创建一个数据包收集器，形参为数据包过滤器 PacketCollector collector = mXmppConnection.createPacketCollector(filter); // 这个api 并没有提供最简单的regist 方法。而是用了很负责的api，用户体验不佳。 mXmppConnection.sendPacket(registration); /** * 上面的代码已经发送过注册数据包了，接下来我们就可以收集服务器的返回值了&lt;br&gt; * 形参为网络超时时间默认5s */ Packet packet = collector.nextResult(SmackConfiguration.getPacketReplyTimeout()); /** * 将数据包强转为IQ，因为我们的过滤器已经限定了是IQ 类型的数据包才收集，因此我们 可以大胆的强转 */ IQ result = (IQ) packet; //收集到数据后就可以将收集器关闭了，不然可能把其他符合条件的数据也收集来了 collector.cancel(); //如果IQ 为空则代表请求失败这里代码我写的不太好了，应该先判断packet 是否为空， 不为空再强转，这样才能避免空指针 if (result == null) &#123; Message message = Message.obtain(); message.what = RESULT_CANCELED; handler.sendMessage(message); return; //如果返回的数据类型为IQ.Type.Result 则代表成功 &#125; else if (result.getType().equals(IQ.Type.RESULT)) &#123; Message message = Message.obtain(); message.what = RESULT_OK; handler.sendMessage(message); return; &#125; else &#123; Message message = Message.obtain(); //否则代表失败，那么我们就收集失败码 int errorCode = result.getError().getCode(); message.what = RESULT_CANCELED; //如果失败码是409，那么代表用户已经被注册 if (409 == errorCode) &#123; message.obj = "该用户名已经被注册，请换一个名字吧"; handler.sendMessage(message); return; &#125; else &#123; message.obj = result.getError(); handler.sendMessage(message); return; &#125; &#125;&#125; activity_regist.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/login_background" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/login_background" android:orientation="vertical" &gt; &lt;ImageView android:id="@+id/iv_touxiang" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:layout_marginTop="40dp" android:contentDescription="@null" android:src="@drawable/login_default_avatar" /&gt; &lt;EditText android:id="@+id/et_name" android:layout_width="match_parent" android:layout_height="40dp" android:layout_marginLeft="5dp" android:layout_marginRight="5dp" android:layout_marginTop="30dp" android:background="#FFFFFF" android:hint="请输入账号" android:paddingLeft="5dp" android:textSize="20sp" /&gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:background="#55AABBCC" /&gt; &lt;EditText android:id="@+id/et_pwd" android:layout_width="match_parent" android:layout_height="40dp" android:layout_marginLeft="5dp" android:layout_marginRight="5dp" android:background="#FFFFFF" android:hint="请输入密码" android:inputType="textPassword" android:paddingLeft="5dp" android:textSize="20sp" /&gt; &lt;Button android:id="@+id/btn_regist" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="15dp" android:background="@color/title_layout" android:onClick="regist" android:text="注册" android:textColor="#FFFFFF" android:textSize="20sp" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; RegistActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179import org.jivesoftware.smack.PacketCollector;import org.jivesoftware.smack.SmackConfiguration;import org.jivesoftware.smack.filter.AndFilter;import org.jivesoftware.smack.filter.PacketFilter;import org.jivesoftware.smack.filter.PacketIDFilter;import org.jivesoftware.smack.filter.PacketTypeFilter;import org.jivesoftware.smack.packet.IQ.Type;import org.jivesoftware.smack.packet.IQ;import org.jivesoftware.smack.packet.Packet;import org.jivesoftware.smack.packet.Registration;import com.itheima.qq.R;import android.content.SharedPreferences;import android.content.SharedPreferences.Editor;import android.os.Bundle;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.view.View;import android.widget.EditText;import android.widget.Toast;import static android.app.Activity.RESULT_CANCELED;public class RegistActivity extends BaseActivity &#123; private EditText et_name; private EditText et_pwd; private String name; private String pwd; private SharedPreferences sp; private static final int RESULT_NO_RESPONSE = 1; private Handler handler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; switch (msg.what) &#123; case RESULT_NO_RESPONSE: Toast.makeText(RegistActivity.this,"服务器未响应，请稍后再试", 0).show(); break; case RESULT_OK: Toast.makeText(RegistActivity.this, "注册成功", 0).show(); finish(); break; case RESULT_CANCELED: Toast.makeText(RegistActivity.this, "注册失败。" + msg.obj, 0).show(); break; default: break; &#125; &#125;; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_regist); sp = getSharedPreferences("config", MODE_PRIVATE); initView(); &#125; private void initView() &#123; //获取到注册名和密码 et_name = (EditText) findViewById(R.id.et_name); et_pwd = (EditText) findViewById(R.id.et_pwd); &#125; /** * 绑定注册按钮事件 * @param view */ public void regist(View view) &#123; //获取用户的数据 name = et_name.getText().toString(); pwd = et_pwd.getText().toString(); //保存到sp 中 Editor editor = sp.edit(); editor.putString("name", name); editor.putString("pwd", pwd); editor.commit(); //因为注册需要联网，因此放在子线程中 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //如果没有连接服务器则连接服务器 if (!mXmppConnection.isConnected()) &#123; mXmppConnection.connect(); &#125; &#125; catch (Exception e1) &#123; e1.printStackTrace(); Looper.prepare(); Toast.makeText(RegistActivity.this, "连接服务器失败。", 0).show(); Looper.loop(); return; &#125; try &#123; //创建注册对象，用于封装注册参数 Registration registration = new Registration(); //设置注册属于设置属性，因此这里设置类型为set registration.setType(Type.SET); //设置用户名和密码 registration.setUsername(name); registration.setPassword(pwd); /** * 注册信息封装好之后其实就可以发送了可以直接调用&lt;br&gt; * mXmppConnection.sendPacket(registration);方法&lt;br&gt; * 但是上面的方法并没有返回值，注册是否成功我们不清楚&lt;br&gt; * 因此我们需要开启一个数据包收集器来手机服务返回的信息 * */ //定义一个数据包过滤器 /** * AndFilter 是一个组合过滤器，形参是可变参数，可以传递多种PacketFilter 的子类 * 我们需要要过滤的原则是根据注册数据包的id 和数据包类型 * */ PacketFilter filter = new AndFilter(new PacketIDFilter(registration.getPacketID()),new PacketTypeFilter(IQ.class)); //创建一个数据包收集器，形参为数据包过滤器 PacketCollector collector = mXmppConnection.createPacketCollector(filter); // 这个api 并没有提供最简单的regist 方法。而是用了很负责的api，用户体验不佳。 mXmppConnection.sendPacket(registration); /** * 上面的代码已经发送过注册数据包了，接下来我们就可以收集服务器的返回值了 * 形参为网络超时时间默认5s */ Packet packet = collector.nextResult(SmackConfiguration.getPacketReplyTimeout()); /** * 将数据包强转为IQ，因为我们的过滤器已经限定了是IQ 类型的数据包才收集，因此我们 可以大胆的强转 */ IQ result = (IQ)packet; //收集到数据后就可以将收集器关闭了，不然可能把其他符合条件的数据也收集来了 collector.cancel(); //如果IQ 为空则代表请求失败这里代码我写的不太好了，应该先判断packet 是否为空， 不为空再强转，这样才能避免空指针 if (result==null) &#123; Message message = Message.obtain(); message.what = RESULT_CANCELED; handler.sendMessage(message); return; //如果返回的数据类型为IQ.Type.Result 则代表成功 &#125;else if (result.getType().equals(IQ.Type.RESULT)) &#123; Message message = Message.obtain(); message.what = RESULT_OK; handler.sendMessage(message); return; &#125;else &#123; Message message = Message.obtain(); //否则代表失败，那么我们就收集失败码 int errorCode = result.getError().getCode(); message.what = RESULT_CANCELED; //如果失败码是409，那么代表用户已经被注册 if (409==errorCode) &#123; message.obj = "该用户名已经被注册，请换一个名字吧"; handler.sendMessage(message); return; &#125;else &#123; message.obj = result.getError(); handler.sendMessage(message); return; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); Message message = Message.obtain(); message.what = RESULT_CANCELED; message.obj = e; handler.sendMessage(message); &#125; &#125; &#125;).start(); &#125;&#125; 3.4 主界面登录之后就进入主界面了。 activity_main.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="60dp" android:background="@color/title_layout" android:gravity="center" android:orientation="horizontal" &gt; &lt;TextView android:id="@+id/tv_title" style="@style/TitleStyle" android:padding="5dp" android:text="@string/title_message" /&gt; &lt;/LinearLayout&gt; &lt;FrameLayout android:id="@+id/fl_content" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" &gt; &lt;/FrameLayout&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="@dimen/activity_main_tab_height" android:gravity="center_horizontal" android:orientation="horizontal" &gt; &lt;View android:layout_width="match_parent" android:layout_height="1dp" android:layout_alignParentTop="true" android:background="#55000000" /&gt; &lt;RadioGroup android:layout_alignParentBottom="true" android:id="@+id/rg_group" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:gravity="center_horizontal" &gt; &lt;RadioButton android:id="@+id/session_rbn" android:layout_width="@dimen/message_icon_width" android:layout_height="@dimen/message_icon_height" android:layout_marginBottom="@dimen/activity_main_tab_margin_top_and_bottom" android:layout_marginTop="@dimen/activity_main_tab_margin_top_and_bottom" android:layout_marginRight="30dp" android:background="@drawable/message_icon" android:button="@null" /&gt; &lt;RadioButton android:id="@+id/contact_rbn" android:layout_width="@dimen/contact_icon_width" android:layout_height="@dimen/contact_icon_height" android:layout_marginBottom="@dimen/activity_main_tab_margin_top_and_bottom" android:layout_marginTop="@dimen/activity_main_tab_margin_top_and_bottom" android:background="@drawable/contact_icon" android:button="@null" /&gt; &lt;RadioButton android:id="@+id/dongtai_rbn" android:layout_width="@dimen/dongtai_icon_width" android:layout_height="@dimen/dongtai_icon_height" android:layout_marginBottom="@dimen/activity_main_tab_margin_top_and_bottom" android:layout_marginTop="@dimen/activity_main_tab_margin_top_and_bottom" android:background="@drawable/dongtai_icon" android:layout_marginLeft="30dp" android:button="@null" /&gt; &lt;/RadioGroup&gt; &lt;/RelativeLayout&gt;&lt;/LinearLayout&gt; MainActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import com.itheima.qq.fragment.ContactFragment;import com.itheima.qq.fragment.DongtaiFragment;import com.itheima.qq.fragment.SessionFrament;import android.content.Intent;import android.os.Bundle;import android.support.v4.app.FragmentActivity;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentTransaction;import android.widget.RadioButton;import android.widget.RadioGroup;import android.widget.RadioGroup.OnCheckedChangeListener;import android.widget.TextView;public class MainActivity extends FragmentActivity implements OnCheckedChangeListener &#123; public static final int COUNT = 3; private RadioButton session_rbn; private RadioButton contact_rbn; private RadioButton dongtai_rbn; private TextView title_tv; private RadioGroup radioGroup; private FragmentManager fragmentManager; private SessionFrament sessionFragment; private ContactFragment contactFragment; private static final String TAG_SESSION_FRAGMENT = "SessionFragment"; private static final String TAG_CONTACT_FRAGMENT = "ContactFragment"; private static final String TAG_DONGTAI_FRAGMENT = "DongtaiFragment"; private DongtaiFragment dongtaiFragment; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override protected void onResume() &#123; super.onResume(); //初始化控件 initView(); //初始化监听器监听切换Fragment 事件 initListener(); //初始化Fragment initData(); //开启聊天服务进程，监听聊天消息 startChatService(); &#125; private void initListener() &#123; radioGroup.setOnCheckedChangeListener(this); &#125; private void startChatService() &#123; Intent intent = new Intent(this, ChatService.class); startService(intent); &#125; private void initData() &#123; fragmentManager = getSupportFragmentManager(); sessionFragment = new SessionFrament(); contactFragment = new ContactFragment(); dongtaiFragment = new DongtaiFragment(); //默认选中消息Fragment radioGroup.check(R.id.session_rbn); &#125; private void initView() &#123; title_tv = (TextView) findViewById(R.id.tv_title); session_rbn = (RadioButton) findViewById(R.id.session_rbn); contact_rbn = (RadioButton) findViewById(R.id.contact_rbn); dongtai_rbn = (RadioButton) findViewById(R.id.dongtai_rbn); radioGroup = (RadioGroup) findViewById(R.id.rg_group); &#125; @Override public void onCheckedChanged(RadioGroup group, int checkedId) &#123; // 把其他选中状态取消 session_rbn.setChecked(checkedId == R.id.session_rbn); contact_rbn.setChecked(checkedId == R.id.contact_rbn); dongtai_rbn.setChecked(checkedId == R.id.dongtai_rbn); if (checkedId == R.id.session_rbn) &#123; title_tv.setText(getResources().getString(R.string.title_message)); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(R.id.fl_content, sessionFragment, TAG_SESSION_FRAGMENT); fragmentTransaction.commit(); &#125; else if (checkedId == R.id.contact_rbn) &#123; title_tv.setText(getResources().getString(R.string.title_contact)); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(R.id.fl_content, contactFragment, TAG_CONTACT_FRAGMENT); fragmentTransaction.commit(); &#125; else if (checkedId == R.id.dongtai_rbn) &#123; title_tv.setText(getResources().getString(R.string.title_dongtai)); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); fragmentTransaction.replace(R.id.fl_content, dongtaiFragment, TAG_DONGTAI_FRAGMENT); fragmentTransaction.commit(); &#125; &#125;&#125; 3.5 退出登录退出登录的功能是在动态中实现的。消息、联系人、动态都是Fragment 实现的。核心代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677if (xmppConnection.isConnected()) &#123; if (xmppConnection.isAuthenticated()) &#123; try &#123; xmppConnection.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); Looper.prepare(); Toast.makeText(application, "注销失败"+e, 0).show(); Looper.loop(); getActivity().finish(); return ; &#125; &#125; &#125; DongtaiFragment.java public class DongtaiFragment extends Fragment &#123; private TextView tv_name; private RelativeLayout rl_logout; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = initView(); return view; &#125; private View initView() &#123; View view = View.inflate(getActivity(), R.layout.fragment_dongtai2, null); SharedPreferences sp = getActivity().getSharedPreferences("config", Context.MODE_PRIVATE); String name = sp.getString("name", ""); tv_name = (TextView) view.findViewById(R.id.tv_name); rl_logout = (RelativeLayout) view.findViewById(R.id.rl_logout); if (!TextUtils.isEmpty(name)) &#123; tv_name.setText(name); &#125; rl_logout.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; final QQApplication application = (QQApplication) getActivity().getApplication(); final XMPPConnection xmppConnection = application.getXmppConnection(); new Thread(new Runnable() &#123; @Override public void run() &#123; if (xmppConnection.isConnected()) &#123; if (xmppConnection.isAuthenticated()) &#123; try &#123; xmppConnection.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); Looper.prepare(); Toast.makeText(application, "注销失败"+e, 0).show(); Looper.loop(); getActivity().finish(); return ; &#125; Looper.prepare(); Toast.makeText(application, "注销成功", 0).show(); getActivity().startActivity(new Intent(application, LoginActivity.class)); getActivity().finish(); Looper.loop(); &#125; &#125; &#125; &#125;).start(); &#125; &#125;); return view; &#125; &#125; 3.6 获取联系人功能联系人界面对应的是ContactFragment，这个界面包含了获取联系人，添加新朋友，添加新组群等三个功能。我先将上面三个功能的核心代码列出来，然后在把ContactFragment.java 代码给列出出来。获取到分组，然后每个分组里面有联系人。界面用的是一个ExpendableListView。 获取联系人核心代码：12345678910111213141516171819202122thread = new Thread(new Runnable() &#123; @Override public void run() &#123; FragmentActivity activity = getActivity(); if (activity==null) &#123; return ; &#125; QQApplication application = (QQApplication) activity.getApplication(); xmppConnection = application.getXmppConnection(); Roster roster = xmppConnection.getRoster(); Collection&lt;RosterGroup&gt; groups = roster.getGroups(); Iterator&lt;RosterGroup&gt; iterator = groups.iterator(); rosterGroups.clear(); while (iterator.hasNext()) &#123; RosterGroup rosterGroup = (RosterGroup) iterator.next(); rosterGroups.add(rosterGroup); &#125; handler.sendEmptyMessage(1); &#125; &#125;); 添加新朋友核心代码： 123456789public static boolean addUsers(Roster roster, String userName, String name, String groupName) &#123; try &#123; roster.createEntry(userName, name, new String[]&#123;groupName&#125;); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); Log.e("XmppUtils", "添加好友异常：" + e.getMessage()); &#125;&#125; 添加新群组核心代码：123456789public static RosterGroup addGroup(Roster roster, String groupName) &#123; try &#123; return roster.createGroup(groupName); &#125; catch (Exception e) &#123; e.printStackTrace(); Log.e("XmppUtils", "创建分组异常：" + e.getMessage()); return null; &#125; &#125; 联系人布局ragment_contact.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:id="@+id/rl_roster" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;LinearLayout android:id="@+id/ll_new_friend" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:gravity="center_horizontal" android:orientation="vertical"&gt; &lt;ImageView android:layout_width="40dp" android:layout_height="40dp" android:src="@drawable/new_friend"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="新朋友"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/ll_new_group" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_weight="1" android:gravity="center_horizontal" android:orientation="vertical"&gt; &lt;ImageView android:layout_width="40dp" android:layout_height="40dp" android:src="@drawable/new_group"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="新群组"/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width="match_parent" android:layout_height="0.5dp" android:background="@color/devide_line"/&gt; &lt;ExpandableListView android:id="@+id/lv_roster" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:cacheColorHint="#00000000" android:childDivider="@color/devide_line" android:groupIndicator="@null" android:listSelector="#00000000" /&gt;&lt;/LinearLayout&gt; 联系人代码ContactFragment.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318public class ContactFragment extends Fragment &#123; private ExpandableListView lv_roster; private MyAdapter adapter; private XMPPConnection xmppConnection; private ArrayList&lt;RosterGroup&gt; rosterGroups = new ArrayList&lt;RosterGroup&gt;(); private LinearLayout ll_new_friend; private LinearLayout ll_new_group; private Thread thread; private Handler handler = new Handler()&#123; @Override public void handleMessage(android.os.Message msg) &#123; if (msg.what==0) &#123; initData(); &#125;else if (msg.what==1) &#123; adapter.notifyDataSetChanged(); &#125; &#125; &#125;; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = initView(); initData(); return view; &#125; private View initView() &#123; View view = View.inflate(getActivity(), R.layout.fragment_contact, null); ll_new_friend = (LinearLayout) view.findViewById(R.id.ll_new_friend); ll_new_group = (LinearLayout) view.findViewById(R.id.ll_new_group); ll_new_friend.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; //创建一个自定义布局的Dialog AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = View.inflate(getActivity(), R.layout.dialog_new_friend, null); builder.setView(view); builder.setTitle("添加新朋友"); Button button = (Button) view.findViewById(R.id.btn_add); final EditText et_name = (EditText) view.findViewById(R.id.et_name); final AlertDialog dialog = builder.create(); dialog.setCanceledOnTouchOutside(false); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; String name = et_name.getText().toString(); addNewFriend(name,new AddListener() &#123; @Override public void onAddSuccess() &#123; handler.sendEmptyMessage(0); //添加成功后取消Dialog dialog.dismiss(); &#125; @Override public void onAddFailure(String msg) &#123; Looper.prepare(); Toast.makeText(getActivity(), "添加新朋友失败。"+msg, 0).show(); Looper.loop(); &#125; &#125;); &#125; &#125;); dialog.show(); &#125; &#125;); ll_new_group.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()); View view = View.inflate(getActivity(), R.layout.dialog_new_group, null); builder.setView(view); builder.setTitle("添加新群组"); final AlertDialog dialog = builder.create(); Button button = (Button) view.findViewById(R.id.btn_add); final EditText et_name = (EditText) view.findViewById(R.id.et_name); dialog.setCanceledOnTouchOutside(false); button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; String name = et_name.getText().toString(); addNewGroup(name,new AddListener() &#123; @Override public void onAddSuccess() &#123; dialog.dismiss(); handler.sendEmptyMessage(0); &#125; @Override public void onAddFailure(String message) &#123; Looper.prepare(); Toast.makeText(getActivity(), "添加新分组失败。"+message, 0).show(); Looper.loop(); &#125; &#125;); &#125; &#125;); dialog.show(); &#125; &#125;); lv_roster = (ExpandableListView) view.findViewById(R.id.lv_roster); lv_roster.setSmoothScrollbarEnabled(false); //点击子ListView 的条目，其实也就是点击联系人的时候跳转到聊天界面 lv_roster.setOnChildClickListener(new OnChildClickListener() &#123; @Override public boolean onChildClick(ExpandableListView parent, View v, int groupPosition, Int childPosition, long id) &#123; RosterGroup rosterGroup = rosterGroups.get(groupPosition); String user = new ArrayList&lt;&gt;(rosterGroup.getEntries()).get(childPosition).getUser(); Intent chatIntent = new Intent(getActivity(), ChatActivity.class); chatIntent.putExtra("user", user); startActivity(chatIntent); return true; &#125; &#125;); return view; &#125; public void initData() &#123; adapter = new MyAdapter(); lv_roster.setAdapter(adapter); //在子线程中请求联系人 thread = new Thread(new Runnable() &#123; @Override public void run() &#123; FragmentActivity activity = getActivity(); if (activity==null) &#123; return ; &#125; QQApplication application = (QQApplication) activity.getApplication(); xmppConnection = application.getXmppConnection(); //获取到花名册对象 Roster roster = xmppConnection.getRoster(); //获取到所有的分组 Collection&lt;RosterGroup&gt; groups = roster.getGroups(); Iterator&lt;RosterGroup&gt; iterator = groups.iterator(); rosterGroups.clear(); while (iterator.hasNext()) &#123; RosterGroup rosterGroup = (RosterGroup) iterator.next(); rosterGroups.add(rosterGroup); &#125; handler.sendEmptyMessage(1); &#125; &#125;); if (thread.isAlive()) &#123; return ; &#125;else &#123; thread.start(); &#125; &#125; //添加新朋友 private void addNewFriend(final String name,final AddListener listener) &#123; final Roster roster = xmppConnection.getRoster(); new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; if(!XmppUtils.searchUsers(xmppConnection, name))&#123; if (listener!=null) &#123; listener.onAddFailure(name+"不存在"); &#125; return ; &#125; //先判断该用户是否存在 XmppUtils.addGroup(roster, "我的好友");//先默认创建一个分组 XmppUtils.addUsers(roster,name+"@"+xmppConnection.getServiceName(), name,"我的好友"); if (listener!=null) &#123; listener.onAddSuccess(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if(listener!=null)&#123; listener.onAddFailure(e.toString()); &#125; &#125; &#125; &#125;).start(); &#125; //添加新群组 private void addNewGroup(final String name,final AddListener listener) &#123; final Roster roster = xmppConnection.getRoster(); new Thread(new Runnable() &#123; @Override public void run() &#123; RosterGroup group = XmppUtils.addGroup(roster, name); if(group==null)&#123; if (listener!=null) &#123; listener.onAddFailure("创建分组失败。"); &#125; &#125; try &#123; /** * 书写格式，注意书写格式！！！ */ RosterEntry rosterEntry = roster.getEntry("admin"); if (rosterEntry==null) &#123; rosterEntry = roster.getEntry("admin@"+xmppConnection.getServiceName()); &#125; if (rosterEntry!=null) &#123; group.addEntry(rosterEntry); if (listener!=null) &#123; listener.onAddSuccess(); &#125; &#125;else &#123; if (listener!=null) &#123; listener.onAddFailure("创建分组失败。"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if (listener!=null) &#123; listener.onAddFailure(e.toString()); &#125; &#125; &#125; &#125;).start(); &#125; class MyAdapter extends BaseExpandableListAdapter &#123; @Override public int getGroupCount() &#123; return rosterGroups.size(); &#125; @Override public int getChildrenCount(int groupPosition) &#123; RosterGroup rosterGroup = rosterGroups.get(groupPosition); //根据组群获取该群组下的联系人数量 return rosterGroup.getEntryCount(); &#125; @Override public Object getGroup(int groupPosition) &#123; return rosterGroups.get(groupPosition); &#125; @Override public Object getChild(int groupPosition, int childPosition) &#123; return rosterGroups.get(groupPosition).getEntries(); &#125; @Override public long getGroupId(int groupPosition) &#123; return groupPosition; &#125; @Override public long getChildId(int groupPosition, int childPosition) &#123; return groupPosition * 100000 + childPosition; &#125; @Override public boolean hasStableIds() &#123; return false; &#125; @Override public View getGroupView(int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) &#123; if (convertView == null) &#123; convertView = View.inflate(getActivity(), R.layout.list_item_roaster_group, null); &#125; ImageView iv_indicator = (ImageView) convertView.findViewById(R.id.iv_indicator); TextView tv_groupName = (TextView) convertView.findViewById(R.id.roast_group_name); TextView tv_roaster_count = (TextView) convertView.findViewById(R.id.tv_roaster_count); if (isExpanded) &#123; iv_indicator.setBackgroundResource(R.drawable.indicator_expanded); &#125; else &#123; iv_indicator.setBackgroundResource(R.drawable.indicator_unexpanded); &#125; RosterGroup rosterGroup = rosterGroups.get(groupPosition); String name = rosterGroup.getName(); tv_groupName.setText(name); int entryCount = rosterGroup.getEntryCount(); tv_roaster_count.setText(entryCount + ""); return convertView; &#125; @Override public View getChildView(int groupPosition, int childPosition, boolean isLastChild, View convertView, ViewGroup parent) &#123; if (convertView == null) &#123; convertView = View.inflate(getActivity(), R.layout.list_item_roster, null); &#125; TextView tv_name = (TextView) convertView.findViewById(R.id.tv_name); RosterGroup rosterGroup = rosterGroups.get(groupPosition); List&lt;RosterEntry&gt; list = new ArrayList&lt;RosterEntry&gt;(rosterGroup.getEntries()); RosterEntry rosterEntry = list.get(childPosition); String name = rosterEntry.getUser(); tv_name.setText(name); return convertView; &#125; @Override public boolean isChildSelectable(int groupPosition, int childPosition) &#123; return true; &#125; &#125;&#125; 3.7 聊天功能聊天界面是一个ListView，这个ListView 有两个布局一个是我发送的消息，另外一个是好友发送的消息。 聊天功能核心代码：123456789101112131415161718192021222324252627282930313233if (chatManager==null) &#123; //获取聊天管理器 chatManager = xmppConnection.getChatManager(); &#125; if (chat==null) &#123; //创建聊天，并制定消息监听器用于监听好友发送的消息 chat = chatManager.createChat(user, messageListener); &#125; chat.sendMessage(msg); private MessageListener messageListener = new MessageListener() &#123; @Override public void processMessage(Chat chat, Message message) &#123; String body = message.getBody(); if (TextUtils.isEmpty(body)) &#123; return ; &#125; com.itheima.qq.bean.Message message2 =new com.itheima.qq.bean.Message(); message2.setBody(body); message2.setTime(TimeUtils.getNowTimeString()); message2.setFrom(user); message2.setTo(xmppConnection.getUser()); dataList.add(message2); MessageDB.putMessage(message2); android.os.Message message3 = android.os.Message.obtain(); message3.what=2; handler.sendMessage(message3); &#125; &#125;; activity_chat.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="60dp" android:background="@color/title_layout" android:gravity="center" android:orientation="horizontal" &gt; &lt;TextView android:id="@+id/tv_title" style="@style/TitleStyle" android:padding="5dp" android:text="马化腾" /&gt; &lt;/LinearLayout&gt; &lt;ListView android:id="@+id/lv_chat" android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" &gt; &lt;/ListView&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="50dp" android:gravity="center_vertical" android:orientation="horizontal" &gt; &lt;ImageView android:layout_width="30dp" android:layout_height="30dp" android:layout_marginLeft="10dp" android:src="@drawable/chat_emo_normal" /&gt; &lt;ImageView android:layout_width="30dp" android:layout_height="30dp" android:layout_marginLeft="10dp" android:src="@drawable/chat_add_normal" /&gt; &lt;EditText android:id="@+id/et_msg" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_weight="1" android:background="#FFFFFF" android:padding="4dp" android:text="你好" /&gt; &lt;Button android:id="@+id/btn_send" android:layout_width="60dp" android:layout_height="35dp" android:layout_marginBottom="3dp" android:layout_marginLeft="3dp" android:layout_marginRight="3dp" android:layout_marginTop="3dp" android:background="@color/title_layout" android:text="发送" android:textColor="#FFFFFF" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; list_item_chat_me.xml 该布局是ListView 中“自己”发送消息时使用的布局。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/tv_time" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true" android:layout_marginLeft="10dp" android:text="12:32"/&gt; &lt;TextView android:id="@+id/tv_me_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginRight="10dp" android:layout_marginTop="20dp" android:layout_toLeftOf="@id/iv_touxiang" android:background="@drawable/fv_chat_content_r_normal" android:gravity="center_vertical" android:paddingRight="25dp" android:text="这是我发送的消息"/&gt; &lt;ImageView android:id="@+id/iv_touxiang" android:layout_width="50dp" android:layout_height="50dp" android:layout_alignParentRight="true" android:layout_centerVertical="true" android:src="@drawable/kkj"/&gt;&lt;/RelativeLayout&gt; list_item_chat_you.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;ImageView android:id="@+id/iv_touxiang" android:layout_width="50dp" android:layout_height="50dp" android:layout_centerVertical="true" android:src="@drawable/login_default_avatar"/&gt; &lt;TextView android:id="@+id/tv_you_msg" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="10dp" android:layout_marginTop="5dp" android:layout_toRightOf="@id/iv_touxiang" android:background="@drawable/fv_chat_content_l_normal" android:gravity="center_vertical" android:paddingLeft="23dp" android:text="这是我发送的消息"/&gt; &lt;TextView android:id="@+id/tv_time" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_alignParentRight="true" android:layout_centerVertical="true" android:layout_marginRight="10dp" android:text="12:32"/&gt;&lt;/RelativeLayout&gt; ChatActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221public class ChatActivity extends Activity implements OnClickListener &#123; private ListView lv_chat; private TextView tv_title; private EditText et_msg; private Button btn_send; private XMPPConnection xmppConnection; private String user; private ChatManager chatManager; private Chat chat; private MyAdapter adapter; private List&lt;com.itheima.qq.bean.Message&gt; dataList = new ArrayList&lt;com.itheima.qq.bean.Message&gt;(); private MessageListener messageListener = new MessageListener() &#123; @Override public void processMessage(Chat chat, Message message) &#123; String body = message.getBody(); if (TextUtils.isEmpty(body)) &#123; return ; &#125; com.itheima.qq.bean.Message message2 =new com.itheima.qq.bean.Message(); message2.setBody(body); message2.setTime(TimeUtils.getNowTimeString()); message2.setFrom(user); message2.setTo(xmppConnection.getUser()); dataList.add(message2); MessageDB.putMessage(message2); android.os.Message message3 = android.os.Message.obtain(); message3.what=2; handler.sendMessage(message3); &#125; &#125;; private Handler handler = new Handler()&#123; public void handleMessage(android.os.Message msg) &#123; switch (msg.what) &#123; case 0: Toast.makeText(ChatActivity.this, "消息发送失败"+msg.obj, 0).show(); break; case 1: adapter.notifyDataSetChanged(); Toast.makeText(ChatActivity.this, "发送成功", 0).show(); break; case 2: //接收到新消息 adapter.notifyDataSetChanged(); break; default: break; &#125; &#125;; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_chat); initView(); initData(); &#125; private void initData() &#123; Intent intent = getIntent(); user = intent.getStringExtra("user"); if (TextUtils.isEmpty(user)) &#123; Toast.makeText(this, "聊天对象为空", 0).show(); finish(); &#125; tv_title.setText(user); QQApplication application = (QQApplication)getApplication(); xmppConnection = application.getXmppConnection(); ArrayList&lt;com.itheima.qq.bean.Message&gt; messages = MessageDB.getMessagesIgnoreFromAndTo(xmppConnection.getUser(), user); if (messages!=null) &#123; dataList = messages; &#125; &#125; private void initView() &#123; lv_chat = (ListView) findViewById(R.id.lv_chat); tv_title = (TextView) findViewById(R.id.tv_title); et_msg = (EditText) findViewById(R.id.et_msg); btn_send = (Button) findViewById(R.id.btn_send); btn_send.setOnClickListener(this); adapter = new MyAdapter(); lv_chat.setAdapter(adapter); &#125; @Override public void onClick(View v) &#123; if(v.getId()==R.id.btn_send)&#123; String msg = et_msg.getText().toString(); sendMsg(msg); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (chat!=null) &#123; chat.removeMessageListener(messageListener); &#125; startService(new Intent(this, ChatService.class)); &#125; @Override protected void onPause() &#123; super.onPause(); if (TextUtils.isEmpty(user)) &#123; return; &#125; Session session = new Session(); session.setTime(TimeUtils.getNowTimeString()); com.itheima.qq.bean.Message message = dataList.get(dataList.size()-1); session.setFrom(message.getFrom()); session.setTo(message.getTo()); session.setMsg(message.getBody()); session.setUsr(user); SessionDB.updateSession(session ); &#125; @Override protected void onResume() &#123; super.onResume(); if (chatManager==null) &#123; chatManager = xmppConnection.getChatManager(); &#125; if (chat==null) &#123; chat = chatManager.createChat(user, messageListener); &#125; &#125; private void sendMsg(final String msg) &#123; if (TextUtils.isEmpty(msg)) &#123; Toast.makeText(this, "不能发送空消息", 0).show(); return ; &#125; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; chat.sendMessage(msg); com.itheima.qq.bean.Message message = new com.itheima.qq.bean.Message(); message.setBody(msg); message.setTime(TimeUtils.getNowTimeString()); message.setTo(user); message.setFrom(xmppConnection.getUser()); dataList.add(message); MessageDB.putMessage(message); //发送成功 android.os.Message message2 = android.os.Message.obtain(); message2.what = 1; handler.sendMessage(message2); &#125; catch (XMPPException e) &#123; e.printStackTrace(); android.os.Message message = android.os.Message.obtain(); message.what = 0; message.obj = e.toString(); handler.sendMessage(message); &#125; &#125; &#125;).start(); &#125; class MyAdapter extends BaseAdapter &#123; @Override public int getCount() &#123; return dataList.size(); &#125; @Override public Object getItem(int position) &#123; return dataList.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public int getViewTypeCount() &#123; return 2; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; com.itheima.qq.bean.Message message = dataList.get(position); if (message.getFrom().equals(xmppConnection.getUser())) &#123; //自己的消息 if (convertView==null) &#123; convertView = View.inflate(ChatActivity.this, R.layout.list_item_chat_me, null); &#125; TextView tv_me_msg = (TextView) convertView.findViewById(R.id.tv_me_msg); TextView tv_time = (TextView) convertView.findViewById(R.id.tv_time); tv_me_msg.setText(message.getBody()); tv_time.setText(message.getTime()); &#125;else &#123; //别人的消息 if (convertView==null) &#123; convertView = View.inflate(ChatActivity.this, R.layout.list_item_chat_you, null); &#125; TextView tv_you_msg = (TextView) convertView.findViewById(R.id.tv_you_msg); TextView tv_time = (TextView) convertView.findViewById(R.id.tv_time); tv_you_msg.setText(message.getBody()); tv_time.setText(message.getTime()); &#125; return convertView; &#125; &#125; &#125; 3.8 消息界面SessionFragment 布局就是一个ListView 十分的简单，因此就不给出了。 SessionFragment.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class SessionFrament extends Fragment &#123; private ListView lv_session; private ArrayList&lt;Session&gt; dataList = new ArrayList&lt;Session&gt;(); private MyAdapter adapter = new MyAdapter(); public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = initView(); initData(); return view; &#125; private View initView() &#123; View view = View.inflate(getActivity(), R.layout.fragment_session, null); lv_session = (ListView) view.findViewById(R.id.lv_session); return view; &#125; public void initData() &#123; lv_session.setAdapter(adapter); ArrayList&lt;Session&gt; sessions = SessionDB.getSessions(); if (sessions != null &amp;&amp; sessions.size() &gt; 0) &#123; dataList = sessions; adapter.notifyDataSetChanged(); &#125; lv_session.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; String user = dataList.get(position).getUsr(); Toast.makeText(getActivity(), user, 0).show(); Intent chatIntent = new Intent(getActivity(), ChatActivity.class); chatIntent.putExtra("user", user); startActivity(chatIntent); &#125; &#125;); &#125;; class MyAdapter extends BaseAdapter &#123; @Override public int getCount() &#123; return dataList.size(); &#125; @Override public Object getItem(int position) &#123; return dataList.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder viewHolder = null; if (convertView == null) &#123; viewHolder = new ViewHolder(); convertView = View.inflate(getActivity(), R.layout.list_item_session, null); viewHolder.tv_msg = (TextView) convertView.findViewById(R.id.tv_msg); viewHolder.tv_name = (TextView) convertView.findViewById(R.id.tv_name); viewHolder.tv_time = (TextView) convertView.findViewById(R.id.tv_time); convertView.setTag(viewHolder); &#125; else &#123; viewHolder = (ViewHolder) convertView.getTag(); &#125; Session session = dataList.get(position); viewHolder.tv_msg.setText(session.getMsg()); viewHolder.tv_time.setText(session.getTime()); // 到底是from 还是to viewHolder.tv_name.setText(session.getUsr()); return convertView; &#125; &#125; @Override public void onResume() &#123; super.onResume(); if(adapter!=null)&#123; adapter.notifyDataSetChanged(); &#125; SessionDB.setListener(new SessionListener() &#123; @Override public void onChange() &#123; if (adapter!=null) &#123; adapter.notifyDataSetChanged(); &#125; &#125; &#125;); &#125; static class ViewHolder &#123; TextView tv_name; TextView tv_time; TextView tv_msg; &#125;&#125; 3.9 启动服务监听消息当用户登录成功的时候在后台开启一个服务，用于监听主动发过来的消息。 ChatService.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class ChatService extends Service &#123; private static QQApplication application; private static NotificationManager notificationManager; private ChatManager chatManager; private MessageListener messageListener = new MessageListener() &#123; public void processMessage(Chat chat, Message message) &#123; if (TextUtils.isEmpty(message.getBody())) &#123; return ; &#125; Session session = new Session(); session.setMsg(message.getBody()); String from = message.getFrom(); if (from.endsWith("/Spark")) &#123; from = from.substring(0, from.length()-"/Spark".length()); &#125; session.setFrom(from); session.setTo(message.getTo()); session.setUsr(from); session.setTime(TimeUtils.getNowTimeString()); SessionDB.updateSession(session); com.itheima.qq.bean.Message message2 = new com.itheima.qq.bean.Message(); message2.setBody(message.getBody()); message2.setFrom(from); message2.setTo(message.getTo()); message2.setTime(TimeUtils.getNowTimeString()); MessageDB.putMessage(message2); android.os.Message msg = android.os.Message.obtain(); msg.obj = message; handler.sendMessage(msg); &#125; &#125;; private ChatManagerListener chatManagerListener = new ChatManagerListener() &#123; @Override public void chatCreated(Chat chat, boolean createdLocally) &#123; if (!createdLocally) &#123; chat.addMessageListener(messageListener); &#125; &#125; &#125;; private Handler handler = new Handler() &#123; public void handleMessage(android.os.Message msg) &#123; Notification notification = new Notification(R.drawable.kkj, "收到新消息", SystemClock.uptimeMillis()); notification.flags = Notification.FLAG_AUTO_CANCEL; Intent intent = new Intent(ChatService.this, ChatActivity.class); Message message = (Message)msg.obj; String from = message.getFrom(); if (from.endsWith("/Spark")) &#123; from = from.substring(0, from.length()-"/Spark".length()); &#125; intent.putExtra("user",from); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); PendingIntent pendingIntent = PendingIntent.getActivity(ChatService.this, 1,intent, PendingIntent.FLAG_UPDATE_CURRENT); notification.setLatestEventInfo(ChatService.this, "新消息", "请注意查收", pendingIntent); notificationManager.notify(2, notification); &#125;; &#125;; public IBinder onBind(Intent intent) &#123; return null; &#125; public void onCreate() &#123; super.onCreate(); application = (QQApplication) getApplication(); notificationManager = (NotificationManager) ChatService.this.getSystemService(Context.NOTIFICATION_SERVICE); &#125; public int onStartCommand(Intent intent, int flags, int startId) &#123; initListener(); return super.onStartCommand(intent, flags, startId); &#125; private void initListener() &#123; XMPPConnection xmppConnection = application.getXmppConnection(); if (xmppConnection==null) &#123; return; &#125; chatManager = xmppConnection.getChatManager(); Toast.makeText(this, "服务已经开启", 0).show(); chatManager.addChatListener(chatManagerListener); &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>xmpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[即时通讯：XMPP基础]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2F%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%EF%BC%9AXMPP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[即时通讯系列阅读 即时通讯基础 即时通讯：XMPP基础 即时通讯：XMPP项目实践-微聊 Smack类库最好的学习资料 1. XMPP 简介XMPP（Extensible Messaging and Presence Protocol）是一种基于标准通用标记语言的子集XML 的协议，它继承了在XML 环境中灵活的发展性。因此，基于XMPP 的应用具有超强的可扩展性。经过扩展以后的XMPP 可以通过发送扩展的信息来处理用户的需求，以及在XMPP 的顶端建立如内容发布系统和基于地址的服务等应用程序。 而且，XMPP 包含了针对服务器端的软件协议，使之能与另一个进行通话，这使得开发者更容易建立客户应用程序或给一个配好系统添加功能。 XMPP（可扩展消息处理现场协议）是基于可扩展标记语言（XML）的协议，它用于即时消息（IM）以及在线现场探测。它在促进服务器之间的准即时操作。这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。 XMPP 的前身是Jabber，一个开源形式组织产生的网络即时通信协议。XMPP 目前被IETF 国际标准组织完成了标准化工作。标准化的核心结果分为两部分；XMPP 其实就是用TCP 传的是XML 文件流。 xmpp特点 开放: XMPP协议是自由、开放、公开的，并且易于了解。 而且在客户端 、 服务器 、 组件 、 源码库等方面，都已经各自有多种实现。 标准: 互联网工程工作小组（ IETF ）已经将Jabber的核心XML流协议以XMPP之名，正式列为认可的实时通信及Presence技术。 而XMPP的技术规格已被定义在RFC 3920及RFC 3921 。 任何IM供应商在遵循XMPP协议下，都可与Google Talk实现连接。 证实可用: 第一个Jabber(现在XMPP)技术是Jeremie Miller在1998年开发的，现在已经相​​当稳定；数以百计的开发者为XMPP技术而努力。 今日的互联网上有数以万计的XMPP服务器运作着，并有数以百万计的人们使用XMPP实时传讯软件。 分散式: XMPP网络的架构和电子邮件十分相像；XMPP核心协议通信方式是先创建一个stream，XMPP以TCP传递XML数据流，没有中央主服务器。 任何人都可以运行自己的XMPP服务器，使个人及组织能够掌控他们的实时传讯体验。 安全: 任何XMPP协议的服务器可以独立于公众XMPP网络（例如在企业内部网络中），而使用SASL及TLS等技术的可靠安全性，已自带于核心XMPP技术规格中。 可扩展: XML 命名空间的威力可使任何人在核心协议的基础上建造定制化的功能；为了维持通透性，常见的扩展由XMPP标准基金会 。 弹性佳 XMPP除了可用在实时通信的应用程序，还能用在网络管理、内容供稿、协同工具、文件共享、游戏、远程系统监控等。 多样性: 用XMPP协议来建造及布署实时应用程序及服务的公司及开放源代码计划分布在各种领域；用XMPP技术开发软件，资源及支持的来源是多样的，使得使你不会陷于被“绑架”的困境。 下面给大家介绍XMPP 通信中最核心的三个XML 节（stanza）。这些节（stanza）有自己的作用和目标，通过组织不同的节（stanza），就能达到我们各种各样的通信目的。 123456789101112131415161718&lt;stream:stream&gt; &lt;iq id="roster1" type='get'&gt; &lt;query xmlns='jabber:iq:roster'/&gt; &lt;/iq&gt; &lt;message from='test_account@jabber.org' to='william_duan@jabber.org' type='chat'&gt; &lt;body&gt;Hello&lt;/body&gt; &lt;/message&gt; &lt;presence type='unavailable'/&gt;&lt;/stream:stream&gt; 在上面的xml 中，我们可以看到一些XMPP 节（stanza），包括&lt;iq&gt;，&lt;message&gt;以及&lt;presence&gt;。接下来就对这些节（stanza）做一个大致的了解。 1.1节的共通属性from表示节（stanza）的发送方，在发送节（stanza）时，一般来说不推荐设定，服务器会自动设定正确的值，如果设定了不正确的值，服务器将会拒收该节（stanza）信息。如果在客户端到服务器端的通信中接收的节（stanza）中没有该属性，会被默认解释为信息是由服务器发出的。如果在服务器到服务器的通信中接收的节（stanza）中没有本属性，则会被解释为一个error。 to表示节（stanza）的接收方。如果在客户端到服务器端的通信中没有设置本属性，服务器会默认解释为信息是发给自己的。 type指定节（stanza）的类型.每种节（stanza）都会有几种可能的设定值。所有的节（stanza）都会有一个error 类型，表明这个节（stanza）是一个error 回应，对这样的节（stanza）信息不需要进行回应。 id表示一个特定的请求。在节中，这个属性是必须要指定的，但是在其他两个节（stanza）中是一个可选属性。 1.2 iq节点iq 节（stanza）主要是用于Info/Query 模式的消息请求，他和Http 协议比较相似。可以发出get 以及set 请求，就如同http 中的GET 以及POST。iq 节点需要有回应，有get，set 两种请求以及result，error 两种回应。发送查询消息示例： 123&lt;iq from="william_duan@jabber.org/study" type="get" id="roster1"&gt; &lt;query xmlns="jabber:iq:roster"/&gt;&lt;/iq&gt; 上面xml 的意思是william_duan 查询自己的联系人列表。 接收到回应示例：如果请求错误：123456&lt;iq to="william_duan@jabber.org/study" type="error" id="roster1"&gt; &lt;query xmlns="jabber:iq:roster"/&gt; &lt;error type="cancel"&gt; &lt;feature-not-implemented xmlns="urn:ietf:params:xml:ns:xmpp-stanzas"/&gt; &lt;/error&gt;&lt;/iq&gt; 如果请求成功：12345&lt;iq to="william_duan@jabber.org/study" type="result" id="roster1"&gt; &lt;query xmlns="jabber:iq:roster"/&gt; &lt;item jid="account_one@jabber.org" name="one"/&gt; &lt;item jid="account_two@jabber.org" name="two"/&gt;&lt;/iq&gt; william 获取到了自己的花名册列表，该列表中有两个好友。 1.3 message 节点正如名字一样，message 节（stanza）用于用户之间传递消息。这消息可以是单纯的聊天信息，也可以某种格式化的信息。message 节点信息是传递之后就被忘记的。当消息被送出之后，发送者是不管这个消息是否已经送出或者什么时候被接收到。通过扩展协议，可以改变这样一种状况。 私人会话示例：1234&lt;message from="william_duan@jabber.org" to="test_account@jabber.org" type="chat"&gt; &lt;body&gt;Come on&lt;/body&gt; &lt;thread&gt;23sdfewtr234weasdf&lt;/thread&gt;&lt;/message&gt; 群组会话示例：123&lt;message from="test_account@jabber.org" to="william_duan@jabber.org" type="groupchat"&gt; &lt;body&gt;welcome&lt;/body&gt;&lt;/message&gt; 1.4 presence 节点presence 节（stanza）用来控制和表示实体的在线状态，可以展示从离线到在线甚至于离开，不能打扰等复杂状态，另外，还能被用来建立和结束在线状态的订阅。 在线状态示例：1234567891011//设定用户状态为在线&lt;presence/&gt;..............................//设定用户状态为离线&lt;presence type="unavailable"/&gt;..............................//用于显示用户状态的详细信息。上面的例子表明用户因为at the ball 在离开状态。&lt;presence&gt; &lt;show&gt;away&lt;/show&gt; &lt;status&gt;at the ball&lt;/status&gt;&lt;/presence&gt; 标签在presence 节点中最多出现一次，可以有以下取值：away，chat，dnd，xa away：离线 chat:交谈中 dnd:希望不被打扰 xa:离开一段时间 标签用于显示额外信息。 在线状态预定(presence subscription) ： 12345678910&lt;presence from="william_duan@jabber.org" to="test_account@jabber.org" type="subscribe"/&gt;..............................&lt;presence from="test_account@jabber.org" to="william_duan@jabber.org" type="subscribed"/&gt; 通过上述交互，william_duan 就能看到test_account 的在线状态，并能接收到test_account 的在线状态通知了。 2. XMPP 服务器平台我们在学习JavaWEB 的时候要用到web 服务器，那么我们就选择了Tomcat 作为web 服务器。同样的道理我们要学习即时通信，这整个体系是一个C/S 架构，Server 端不需要我们编写，那么我们就选择一款市场上免费开源的服务，除了Openfire 暂无他选，Openfire 是开源免费功能强大的IM 服务器。为什么选择Openfire 呢？请往下看。 Openfire 采用Java 开发，开源的实时协作（RTC）服务器基于XMPP（Jabber）协议。Openfire 安装和使用都非常简单，并利用Web 进行管理。单台服务器可支持上万并发用户。您可以使用它轻易的构建高效率的即时通信服务器。由于是采用开放的XMPP 协议，您可以使用各种支持XMPP 协议的IM 客户端软件登陆服务。 相关的下载：asmack github、asmack下载地址1、asmack下载地址2、openfire下载地址、smack使用指南 2.1 案例-Openfire 的下载和安装下载地址：http://www.igniterealtime.org/downloads/index.jsp 我们下载windows 平台的openfire_3_10_2.exe 文件 双击开始安装 选择中文（简体），然后点击确定 选择我接受协议，然后点击下一步 选择好安装路径，然后点击下一步 耐心等待，大概50 秒 点击完成 openfire启动失败问题，安装好后，启动，提示 Java.io.FileNotFoundException: ..\lib\commons-el.jar ，解决办法：只需要 以管理员的身份运行openfire 即可 启动之后弹出如上界面，有异常！大概应该是日志相关的文件找不到。我们先不管，点击Launch Admin 启动管理控制台。 我们注意上图中的地址栏，端口是9090，这是openfire 使用的端口，我们有时候喜欢把tomact 配置层9090，一定注意不要占用了该端口。 我们选择中文（简体），然后点击continue。 设置域，其他设置默认即可。然后点击继续（上一页还是continue，选中过中文后可就成继续了）。 注意：这个时候必须先确保本机已经安装了MySQL，并创建了数据库，我创建的数据库名字就叫做openfire。然后在该数据库中执行sql 脚本，该sql 脚本是openfire 提供的，位置位于： 在数据库中将该脚本内容执行一下，让其初始化数据表结构。然后点击继续，进入下一个页面。 使用默认配置，继续点击继续。进入下一个页面。 在上面填写邮箱和管理员密码，然后点击继续。 成功啦！点击登录到控制台，进入如下界面。 openfire 管理员默认账号为admin，密码就是我们上一个界面设置的密码。输入账号和密码，然后点击登录。进入下一个界面。 我们就来浏览一下成功后的界面吧 用户列表界面： 会话界面： 分组聊天界面： 当我们用org.jivesoftware.smack.XMPPConnection.login(String username,String password)登录时，如果出现“SASLError using DIGEST-MD5: not-authorized”异常，这说明我们客户端没有开启SASL机制，在XMPP连接配置的时候，加上“SASLAuthentication.supportSASLMechanism(“PLAIN”,0);”这个支持SASL机制的方法就可以解决了。 3. XMPP 客户端平台3.1 Spark 客户端的下载和安装Spark 是一个开源，跨平台IM 客户端。它的特性支持集组聊天，电话集成和强大安全性能。如果企业内部部署IM 使用Openfire+Spark 是最佳的组合。其官网对Spark 的介绍如下： Spark is an Open Source， cross-platform IM client optimized for businesses and organizations. It features built-in support for group chat， telephony integration， and strong security. It also offers a great end-user experience with features like in-line spell checking， group chat room bookmarks， and tabbed conversations。 Combined with the Openfire server， Spark is the easiest and best alternative to using un-secure public IM networks。 Spark 的下载地址 下载好以后： 双击安装。安装非常简单，一路点击下一步即可 点击Next，进入下一个界面： 点击Next……Next 进入下一个界面： 看到如下界面就OK 了，如果在上一个界面点击Finish 没有起效，那么可以找到生成的桌面快捷图标，双击。 点击账号，进入下一个界面。 在上图中输入用户、密码和服务器地址。 然后创建账号。 在上图中点击确定，进入如下图界面。 点击Login 进入如下界面： 在openfire 中刷新界面，打开用户/组选项卡，可以看到所有注册的用户列表。 3.2 Spark 和Openfire 通信原理从网上找到一个Spark 和Openfire 直接通讯架构图。看懂这张图就知道他们之间是如何通信的了。 Smack 是对XMPP 协议的封装库，Smack 是XMPP 协议的Java 层的封装。让我们Java 程序员不用直接跟枯燥无味的XML 打交道（生成XML 和解析XML）。 随着移动互联网的快速发展，尤其是即时通信的发展，几乎90%以上的App 都有这样的功能。因此asmack也与13 年诞生，asmack 其实就是Android Smack 的简称。asmack 也是我们该门课程用到的主要API。 下面请看《即时通讯：XMPP项目实践-微聊》吧，让我们一起学习如何使用asmack 打造我们的交友神器。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>xmpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark抓包实战]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FWireshark%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[抓取某新闻客户端的数据 注意事项 在抓取数据之前先清除缓存，缓存会影响抓包 过滤get请求 通过ping命令获取新闻数据的目标IP地址，封包信息中网址带有163可能就是新闻客户端的url 拿到目标IP地址，就可以通过目标IP地址过滤数据 用浏览器打开抓到的url，即可得到新闻的数据 http://c.m.163.com/nc/article/list/T1467284926140/0-20.html 新闻分类idurl组织形式：http://c.m.163.com/nc/article/list/id/startindex-count.html 其中tid是新闻类别的id，startindex是数据的起始索引，count是新闻数据的条数 体育T1348649079062 头条T1467284926140 娱乐T1348648517839 要闻T1348647909107 新闻Tab标签http://c.m.163.com/nc/topicset/android/subscribe/manage/listspecial.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#123; "tList": [ &#123; "template": "normal1", "topicid": "0001899N", "hasCover": false, "weburl": "http://www.163.com/", "alias": "Top News", "subnum": "3.2万", "recommendOrder": 0, "isNew": 0, "hashead": 1, "img": "", "isHot": 0, "hasIcon": false, "cid": "C1348646712614", "recommend": "0", "headLine": true, "hasAD": 1, "color": "", "bannerOrder": 0, "tname": "头条", "ename": "androidnews", "showType": "comment", "special": 0, "tid": "T1348647909107", "ad_type": 1 &#125;, &#123; "template": "normal1", "topicid": "0001899N;000187QQ", "hasCover": false, "alias": "yaowenspecial", "subnum": "10.6万", "recommendOrder": 0, "isNew": 0, "hashead": 1, "img": "", "isHot": 0, "hasIcon": false, "cid": "C1348647991705", "recommend": "0", "headLine": false, "hasAD": 1, "color": "", "bannerOrder": 0, "tname": "要闻", "ename": "yaowenspecial", "showType": "comment", "special": 0, "tid": "T1467284926140", "ad_type": 1 &#125;, &#123; "template": "recommend", "topicid": "00037VVH", "hasCover": false, "weburl": "http://ent.163.com/", "alias": "Entertainment", "subnum": "超过1000万", "recommendOrder": 120, "isNew": 0, "hashead": 1, "img": "T1348648517839", "isHot": 0, "hasIcon": true, "cid": "C1348648351901", "recommend": "1", "headLine": false, "hasAD": 1, "color": "", "bannerOrder": 0, "tname": "娱乐", "ename": "yule", "showType": "comment", "special": 0, "tid": "T1348648517839", "ad_type": 1 &#125; ]&#125; json数据中的tid即为上文中的新闻类别id 新闻详情页https://c.m.163.com/news/a/docid.html http://c.m.163.com/nc/article/docid/full.html 例如： https://c.m.163.com/news/a/CG4A99320001899O.html http://c.m.163.com/nc/article/CG4A99320001899O/full.html 其中CG4A99320001899O是docid，如图所示]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[揭秘Java网络爬虫程序原理]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2F%E6%8F%AD%E7%A7%98Java%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[随着互联网+时代的来临，越来越多的互联网企业层出不穷，涉及游戏、视频、新闻、社交、电商、房产、旅游等众多行业。如今互联网成为大量信息的载体，如何有效地从中提取有价值的信息并利用这些信息成为一个巨大的挑战 爬虫，一个可怕的怪物，从百度、Google等搜索引擎公司诞生开始便有了它的身影，如今移动互联网时代爬虫更是猖狂，每个网站似乎都被它光顾过，只是你看不到，不过你放心它不干坏事，你能在网上迅速搜索到你到的信息应该都是它的功劳，它每天会默默无闻的采集互联网上的丰富信息供大家查询共享。Java作为互联网开发的主流语言，广泛应用于互联网领域，本课程使用java技术为大家讲解如何编写爬虫程序爬取网络上有价值的数据信息。 知识点 爬虫的架构解析 爬虫基本原理分析 编写爬虫程序 爬虫在电商中的应用 1. 爬虫简介我们访问某一个网页的时候，在地址栏输入网址，按回车，该网站的服务器就会返回一个HTML文件给我们，浏览器解析返回的数据，展示在UI上。同样爬虫程序也是模仿人的操作，给网站发送一个请求，网站会给爬虫程序返回一个HTML文件，爬虫程序再根据返回的数据进行抓取分析 1.1 爬虫概论网络爬虫（Web crawler）也叫网络蜘蛛（Web spide）自动检索工具（automatic indexer），是一种”自动化浏览网络“的程序，或者说是一种网络机器人。 爬虫被广泛用于互联网搜索引擎或其他类似网站，以获取或更新这些网站的内容和检索方式。它们可以自动采集所有其能够访问到的页面内容，以供搜索引擎做进一步处理（分检整理下载的页面），而使得用户能更快的检索到他们需要的信息。 通俗的讲，就是把你手动打开窗口，输入数据等等操作用程序代替。用程序替你获取你想要的信息，这就是网络爬虫 1.2 爬虫应用1.2.1 搜索引擎爬虫程序可以为搜索引擎系统爬取网络资源，用户可以通过搜索引擎搜索网络上一切所需要的资源。搜索引擎是一套非常庞大且精密的算法系统，搜索的准确性，高效性等都对搜索系统有很高的要求。 1.2.2 数据挖掘 爬虫除了用来做搜索外，还可以做非常多的工作，可以说爬虫现在在互联网项目中应用的非常广泛。互联网项目通过爬取相关数据主要进行数据分析，获取价值数据。那么爬虫具体可以做那么分析，下面可以简单做一个简单了解： 股票分析—预测股市 社会学方面统计预测 情绪地图 饮食分布图 票房分析预测 机场实时流量 公交系统实时线路 火车票实时销售统计 App下载量分析 1.3 爬虫原理1.3.1 爬虫目的一般来讲对我们而言需要抓取的是某个网站或者某个应用的内容，提取有用的价值，进行数据分析。 1.3.2 爬虫框架设计为了开发的方便，也可以使用爬虫框架来开发项目中的爬虫；一个通用的网络爬虫的框架如图所示： 网络爬虫的基本工作流程如下： 首先选取一部分精心挑选的种子URL 将这些URL放入待抓取URL队列 从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列 分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环 2. Java爬虫框架2.1 NutchNutch属于分布式爬虫，爬虫使用分布式，主要是解决两个问题：1)海量URL管理；2)网速。如果要做搜索引擎，Nutch1.x是一个非常好的选择。Nutch1.x和solr或者es配合，就可以构成一套非常强大的搜索引擎，否则尽量不要选择Nutch作为爬虫。用Nutch进行爬虫的二次开发，爬虫的编写和调试所需的时间，往往是单机爬虫所需的十倍时间不止。 2.2 HeritrixHeritrix 是个“Archival Crawler”——来获取完整的、精确的、站点内容的深度复制。包括获取图像以及其他非文本内容。抓取并存储相关的内容。对内容来者不拒，不对页面进行内容上的修改。重新爬行对相同的URL不针对先前的进行替换。爬虫主要通过Web用户界面启动、监控和调整，允许弹性的定义要获取的url。 2.3 crawler4jcrawler4j是Java实现的开源网络爬虫。提供了简单易用的接口，可以在几分钟内创建一个多线程网络爬虫。 2.4 WebCollectorWebCollector使用了Nutch的爬取逻辑（分层广度遍历），Crawler4j的的用户接口（覆盖visit方法，定义用户操作）,以及一套自己的插件机制，设计了一套爬虫内核。 2.5 WebMagicWebMagic项目代码分为核心和扩展两部分。核心部分(webmagic-core)是一个精简的、模块化的爬虫实现，而扩展部分则包括一些便利的、实用性的功能。WebMagic的架构设计参照了Scrapy，目标是尽量的模块化，并体现爬虫的功能特点。 3. HttpClient&amp;Jsoup爬虫实现的技术有很多，对于java语言来说，有很多的选择，可以是很多开源的爬虫框架，也可以使用基本httpClient,Jsoup来爬取网页 3.1 HttpClient简介HttpClient 是 apache 组织下面的一个用于处理 HTTP 请求和响应的开源工具。它不是一个浏览器，也不处理客户端缓存等浏览器的功能。它只是一个类库！它在 JDK 的基本类库基础上做了更好的封装。 HttpClient 项目依赖于 HttpCore（处理核心的 HTTP 协议）、commons-codec（处理与编码有关的问题的项目）和 commons-logging（处理与日志记录有关问题的项目）。如果你希望能够通过 HttpClient 向服务器上传文件等与 multipart 编码类型有关的请求，以及其它复杂的MIME 类型，那么，你需要另外一个依赖包：HttpMime（它是专门处理与 MIME 类型有关问题的项目），在下载的 HttpClient 包中（下载地址）已经包含了 HttpMime 项目中使用的 HttpClient 版本为：4.0.1GA，httpClient需要有以下依赖包： httpclient-4.0.1.jar httpcore-4.0.1.jar httpmime-4.0.1.jar 又依赖于 mime4j（apache-mime4j-0.6.jar） commons-codec-1.4.jar commons-logging-1.1.1.jar commons-io-1.4.jar – 为了更方便处理与 IO 有关的需求 ##3.2 HttpClient抓取网页流程 使用HttpClient发送请求、接收响应很简单，一般需要如下几步： 创建HttpClient对象。 创建请求方法的实例，并指定请求URL。如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象。 如果需要发送请求参数，可调用HttpGet、HttpPost共同的setParams(HetpParams params)方法来添加请求参数；对于HttpPost对象而言，也可调用setEntity(HttpEntity entity)方法来设置请求参数。 调用HttpClient对象的execute(HttpUriRequest request)发送请求，该方法返回一个HttpResponse。 调用HttpResponse的getAllHeaders()、getHeaders(String name)等方法可获取服务器的响应头；调用HttpResponse的getEntity()方法可获取HttpEntity对象，该对象包装了服务器的响应内容。程序可通过该对象获取服务器的响应内容。 释放连接。无论执行方法是否成功，都必须释放连接。 3.3 简单抓取代码用HttpClient发送请求，请求头不带cookie，用EntityUtils解析响应结果 1234567891011121314151617181920212223242526272829public class MyHttpClient &#123; /*** * 需求：使用httpClient爬取传智播客官方网站数据 * * @param args * @throws Exception * @throws ClientProtocolException */ public static void main(String[] args) throws Exception &#123; // 创建HttpClient对象 HttpClient hClient = new DefaultHttpClient(); // 设置响应时间，设置传智源码时间，设置代理服务器(不使用本机的IP爬取，以防止被服务器识别从而IP加入黑名单) hClient.getParams().setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 10000) .setParameter(CoreConnectionPNames.SO_TIMEOUT, 10000) .setParameter(ConnRouteParams.DEFAULT_PROXY, new HttpHost("111.155.124.67", 8123)); // 爬虫URL大部分都是get请求，创建get请求对象 HttpGet hget = new HttpGet("http://www.itcast.cn/"); // 向传智播客官方网站发送请求，获取网页源码 HttpResponse response = hClient.execute(hget); // EntityUtils工具类把网页实体转换成字符串 String content = EntityUtils.toString(response.getEntity(), "utf-8"); System.out.println(content); &#125;&#125; 解析结果 用HttpClient发送请求，请求头带cookie，用EntityUtils解析响应结果 123456789101112131415161718192021222324252627282930//使用httpClient发送请求，使用Jsoup分析网页public static void main(String[] args) throws Exception &#123; //创建httpClient客户端 HttpClient hClient = new DefaultHttpClient(); //创建http发送请求对象，Httpget HttpGet hget = new HttpGet("http://www.itcast.cn"); //设置请求头 hget.setHeader("Cookie", "login_sid_t=f39c57f474a4fbffeeac8b0d727c7310; " + "YF-Ugrow-G0=169004153682ef91866609488943c77f; " + "YF-V5-G0=cd5d86283b86b0d506628aedd6f8896e; WBStorage=7754ff192036c629|undefined;" + " _s_tentry=-; YF-Page-G0=074bd03ae4e08433ef66c71c2777fd84; " + "Apache=1025338456965.9829.1478277156276; " + "SINAGLOBAL=1025338456965.9829.1478277156276; " + "ULV=1478277156293:1:1:1:1025338456965.9829.1478277156276:; " + "SUB=_2AkMvQDcef8NhqwJRmP4Uzm7mbYxwzA_EieLBAH7sJRMxHRl" + "-yj9jqmwNtRBn0SIxPIgzk6P4Umq_twX_A70bVg..; " + "SUBP=0033WrSXqPxfM72-Ws9jqgMF55529P9D9W5J2ZDKK_Q-h8ni.aX3E1Ci"); hget.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 " + "(KHTML, like Gecko) Chrome/44.0.2403.157 Safari/537.36"); //设置连接超时，传递响应超时 hClient.getParams() .setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 10000) .setParameter(CoreConnectionPNames.SO_TIMEOUT, 10000) .setParameter(ConnRouteParams.DEFAULT_PROXY, new HttpHost("121.31.71.63", 80)); //发送请求 HttpResponse response = hClient.execute(hget); //获取网页内容 String content = EntityUtils.toString(response.getEntity(), "utf-8"); System.out.println(content);&#125; 4. Jsoup简介jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据 通常在写爬虫程序时，httpClient结合Jsoup共同使用即可实现完美的爬虫系统。httpClient负责模拟浏览器发送请求，Jsoup负责解析httpClient请求返回的HTML页面，解析获取需要的数据 4.1 Jsoup获取网页流程 从一个 URL，文件或字符串中解析 HTML 使用 DOM 或 CSS 选择器来查找、取出数据 可操作 HTML 元素、属性、文本 4.2 Jsoup获取网页代码用Jsoup抓取传智播客官网左侧的数据，如图所示 用谷歌浏览器开发者工具（F12）打开查看源码如下图，从中可以看到ul标签的class选择器为nav_txt 12345678910111213141516171819202122232425262728293031323334353637383940public class HttpClientJsoup &#123; /*** * 需求：使用httpClient爬取传智播客官方网站数据 * * @param args * @throws Exception * @throws ClientProtocolException */ public static void main(String[] args) throws Exception &#123; // 创建HttpClient对象 HttpClient hClient = new DefaultHttpClient(); // 设置响应时间，设置传智源码时间，设置代理服务器 /*hClient.getParams().setParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, 10000) .setParameter(CoreConnectionPNames.SO_TIMEOUT, 10000) .setParameter(ConnRouteParams.DEFAULT_PROXY, new HttpHost("111.155.124.67", 8123));*/ // 爬虫URL大部分都是get请求，创建get请求对象 HttpGet hget = new HttpGet("http://www.itcast.cn/"); hget.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 " + "(KHTML, like Gecko) Chrome/44.0.2403.157 Safari/537.36"); // 向传智播客官方网站发送请求，获取网页源码 HttpResponse response = hClient.execute(hget); // EntityUtils工具类把网页实体转换成字符串 String content = EntityUtils.toString(response.getEntity(), "utf-8"); // 使用Jsoup解析网页内容 Document document = Jsoup.parse(content); // 获取文档标题 String title = document.title(); System.out.println(title); Elements elements = document.select("ul.nav_txt a"); System.out.println(elements); for(Element element : elements)&#123; System.out.println(element.text() + ":" + element.attr("href")); &#125; &#125;&#125; 解析结果 使用jsoup向服务器发送请求 12345678910111213141516171819public class MyJsoup &#123; /* * 需求：使用Jsoup解析网页源码 */ public static void main(String[] args) throws Exception &#123; // 使用jsoup向服务器发送请求 Document doc = Jsoup.connect("http://www.itcast.cn").get(); // Jsoup使用类型css,Jquery选择器方式获取元素节点 // Elements elements = doc.getElementsByTag("a"); // System.out.println(elements.text()); Elements elements = doc.select("ul.nav_txt a"); // 循环元素 for (Element element : elements) &#123; System.out.println(element.text() + ":" + element.attr("href")); &#125; &#125;&#125; 解析结果 5. 综合应用解析下图中红色框的内容，HttpClient发送请求，Jsoup解析结果 点击开发者工具的第一个图标，移动鼠标到网页的目标位置，即可定位到该目标的网页源码位置 12345678910111213141516171819202122232425262728293031323334package com.github.webcrawder;import java.io.IOException;import org.apache.http.HttpResponse;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.HttpClient;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.DefaultHttpClient;import org.apache.http.util.EntityUtils;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.select.Elements;public class CrawderDemo &#123; public static void main(String[] args) throws ClientProtocolException, IOException &#123; // 创建httpClient客户端 HttpClient hClient = new DefaultHttpClient(); // 创建http发送请求对象，Httpget HttpGet hget = new HttpGet("http://www.itcast.cn"); // 发送请求 HttpResponse response = hClient.execute(hget); // 获取网页内容 String content = EntityUtils.toString(response.getEntity(), "utf-8"); // 使用Jsoup解析网页内容 Document document = Jsoup.parse(content); // 使用元素选择器选择网页的内容 Elements elements = document.select("ul.nav_li a"); System.out.println(elements.text()); System.out.println(elements); &#125;&#125; 解析结果 12345678910111213141516171819202122//使用jsoup加载远程连接数据@Testpublic void myJsouptest() throws Exception &#123; String userAgent = "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like " + "Gecko) Chrome/44.0.2403.157 Safari/537.36"; //准备cookie信息 Map&lt;String, String&gt; maps = new HashMap&lt;String, String&gt;(); maps.put("TC-Ugrow-G0", "968b70b7bcdc28ac97c8130dd353b55e"); maps.put("SUB", "2AkMvfeeDf8NhqwJRmP0dzGvhZY5yywvEieLBAH7sJRMxHRl-yT9jqmAHtRAgR4BQZgBIE" + "-Xz-jsqjVftcUdtrA.."); maps.put("SUBP", "0033WrSXqPxfM72-Ws9jqgMF55529P9D9WhBu3bohh6dYkXbY_GUs5d8"); //获取网页dom对象 Document doc = Jsoup.connect("http://www.itcast.cn/") .userAgent(userAgent) .cookies(maps).get(); //获取文档标签 String title = doc.title(); System.out.println(title); //获取网页元素 Elements elements = doc.select("div.qrcode-text"); System.out.println(elements.text());&#125; 6.爬虫在电商网站应用]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件：SlidingMenu，侧边栏，侧滑菜单]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%9ASlidingMenu%EF%BC%8C%E4%BE%A7%E8%BE%B9%E6%A0%8F%EF%BC%8C%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[1. 项目概述观察如图2-4 的完整项目中的效果界面，点击标题栏的左上角会弹出侧边栏，再次点击时会关闭侧边栏，这种效果在很多手机应用中使用，因此，我们有必要学会如何自定义一个具有侧边栏效果的控件。 2. 布局界面UI在本章中，主界面为MainActivity.java，具体代码如文件所示：res/layout/activity_main.xml 1234567891011121314&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;com.itheima.slidmenudemo.view.SlidMenu android:id="@+id/slidmenu" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;!-- 当前为左边菜单界面索引为0 --&gt; &lt;include layout="@layout/slidmenu_left" /&gt; &lt;!-- 当前为主界面索引为1 --&gt; &lt;include layout="@layout/slidmenu_main"/&gt; &lt;/com.itheima.slidmenudemo.view.SlidMenu&gt;&lt;/RelativeLayout&gt; 其中，slidmenu_left.xml 是侧边栏的布局文件，具体代码如文件【2-7】所示：【文件2-7】res/layout/slidmenu_left.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;ScrollView xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="240dp" android:layout_height="match_parent" &gt; &lt;LinearLayout android:layout_width="240dp" android:layout_height="match_parent" android:orientation="vertical" android:background="@drawable/menu_bg" &gt; &lt;ImageButton style="@style/tab_style" android:text="新闻" android:background="#33000000" android:drawableLeft="@drawable/tab_news" /&gt; &lt;ImageButton style="@style/tab_style" android:text="订阅" android:drawableLeft="@drawable/tab_read" /&gt; &lt;TextView style="@style/tab_style" android:text="本地" android:drawableLeft="@drawable/tab_local" /&gt; &lt;TextView style="@style/tab_style" android:text="跟帖" android:drawableLeft="@drawable/tab_ties" /&gt; &lt;TextView style="@style/tab_style" android:text="图片" android:drawableLeft="@drawable/tab_pics" /&gt; &lt;TextView style="@style/tab_style" android:text="话题" android:drawableLeft="@drawable/tab_ugc" /&gt; &lt;TextView style="@style/tab_style" android:text="投票" android:drawableLeft="@drawable/tab_vote" /&gt; &lt;TextView style="@style/tab_style" android:text="聚合阅读" android:drawableLeft="@drawable/tab_focus" /&gt; &lt;/LinearLayout&gt;&lt;/ScrollView&gt; 上面的代码中我们在styles.xml 文件中定义了一个样式tab_style，它是用来修饰左边侧栏中每一个条目，详细代码如下所示。 1234567891011121314&lt;!-- tab 菜单界面的样式--&gt;&lt;style name="tab_style"&gt; &lt;item name="android:padding"&gt;5dp&lt;/item&gt; &lt;item name="android:gravity"&gt;center_vertical&lt;/item&gt; &lt;item name="android:drawablePadding"&gt;5dp&lt;/item&gt; &lt;item name="android:layout_width"&gt;match_parent&lt;/item&gt; &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt; &lt;item name="android:textSize"&gt;18sp&lt;/item&gt; &lt;item name="android:background"&gt;@drawable/tab_bg&lt;/item&gt; &lt;item name="android:textColor"&gt;#ffffff&lt;/item&gt; &lt;item name="android:onClick"&gt;clickTab&lt;/item&gt; &lt;item name="android:focusable"&gt;true&lt;/item&gt; &lt;item name="android:clickable"&gt;true&lt;/item&gt;&lt;/style&gt; 主界面的右边slidmenu_main.xml 布局文件的代码如文件【2-8】所示。【文件2-8】res/layout/slidmenu_left.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/top_bar_bg" android:orientation="horizontal" &gt; &lt;ImageButton android:id="@+id/main_back" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@null" android:src="@drawable/main_back" /&gt; &lt;View android:layout_width="1dp" android:layout_height="match_parent" android:layout_margin="5dp" android:background="@drawable/top_bar_divider" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:layout_marginLeft="10dp" android:text="黑马新闻" android:textColor="#fff" android:textSize="24sp" /&gt; &lt;/LinearLayout&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:text="钓鱼岛是中国的！！！！\nXXX 是世界的" android:textColor="#000" android:textSize="24sp" /&gt;&lt;/LinearLayout&gt; 3. 主界面业务逻辑自定好控件之后，MainActivity,java 主界面的业务逻辑如下所示。activity_setting.xml 如文件【2-9】所示：【文件2-9】res/layout/setup_password_dialog.xml 1234567891011121314151617181920212223242526public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); ImageButton main_back = (ImageButton) findViewById(R.id.main_back); final SlidMenu slidmenu = (SlidMenu) findViewById(R.id.slidmenu); main_back.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; boolean currentView = slidmenu.isMenuShow(); if(currentView)&#123;//当前菜单界面显示，就隐藏 slidmenu.hideMenu(); &#125;else&#123; slidmenu.showMenu(); &#125; &#125; &#125;); &#125; public void clickTab(View v)&#123; TextView tv = (TextView) v; Toast.makeText(getApplicationContext(), tv.getText(), 0).show(); &#125;&#125; 侧边栏在项目会经常用到，这里我们将自定义一个侧边栏，具体代码如文件【2-10】所示。【文件2-10】com/itheima/slidmenudemo/view/SlidMenu.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156public class SlidMenu extends ViewGroup &#123; private int downX; private final int MAIN_VIEW = 0;// 主界面 private final int MENU_VIEW = 1;// 左边菜单界面 private int currentView = MAIN_VIEW;// 记录当前界面，默认为主界面 private Scroller scroller;// 用来模拟数据 private int touchSlop; public SlidMenu(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public SlidMenu(Context context) &#123; this(context, null); &#125; @SuppressWarnings("deprecation") private void init() &#123; scroller = new Scroller(getContext()); touchSlop = ViewConfiguration.getTouchSlop();// 系统默认你进行了一个滑动操作的固定值 &#125; /** * widthMeasureSpec 屏幕的宽度heightMeasureSpec 屏幕的高度 */ @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // TODO Auto-generated method stub super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 测量主界面 View mainView = getChildAt(1);// 主界面 // 主界面宽高：屏幕的宽度屏幕的高度 mainView.measure(widthMeasureSpec, heightMeasureSpec); // 测量左边菜单界面和主界面的宽高 View menuView = getChildAt(0);// 左边菜单界面 menuView.measure(menuView.getLayoutParams().width, heightMeasureSpec); &#125; // viewgroup 的排版方法 /** * int l 左边0 int t 上边0 int r 右边屏幕的宽度int b 下边屏幕的高度 */ @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; // 排版主界面左边0， 高度0， 右边屏幕宽度，下边屏幕高度 View mainView = getChildAt(1); mainView.layout(l, t, r, b); // 排版左边菜单界面左边-左边菜单界面的宽度， 高度0 ，右边0， 下边屏幕高度 View menuView = getChildAt(0); menuView.layout(-menuView.getMeasuredWidth(), t, 0, b); &#125; // 按下的点： downX = 100 // 移动过后的点： moveX = 150 // 间距diffX = -50 =100 -150 = downX - moveX; // scrollby(diffX,0) // downX = moveX = 150 @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: downX = (int) event.getX(); break; case MotionEvent.ACTION_MOVE: int moveX = (int) event.getX(); // 计算间距 int diffX = downX - moveX; int scrollX = getScrollX();// 获得当前界面的左上角的X 值 // 屏幕将要移动到的X 值 int dff = scrollX + diffX; if (dff &lt; -getChildAt(0).getMeasuredWidth()) &#123;// 设置左边界 scrollTo(-getChildAt(0).getMeasuredWidth(), 0); &#125; else if (dff &gt; 0) &#123;// 设置右边界 scrollTo(0, 0); &#125; else &#123;// 如果不超过边界值，就要根据屏幕左上角的点的X 值，来计算位置 scrollBy(diffX, 0); &#125; downX = moveX; break; case MotionEvent.ACTION_UP: int center = -getChildAt(0).getMeasuredWidth() / 2; if (getScrollX() &gt; center) &#123; System.out.println("显示主界面"); currentView = MAIN_VIEW; &#125; else &#123; System.out.println("显示左边菜单界面"); currentView = MENU_VIEW; &#125; switchView(); break; default: break; &#125; return true;// 由我们自己来处理触摸事件 &#125; // 根据当前状态值来切换切面 private void switchView() &#123; int startX = getScrollX(); int dx = 0; if (currentView == MAIN_VIEW) &#123; // scrollTo(0, 0); dx = 0 - startX; &#125; else &#123; // scrollTo(-getChildAt(0).getMeasuredWidth(), 0); dx = -getChildAt(0).getMeasuredWidth() - startX; &#125; int duration = Math.abs(dx) * 10; if (duration &gt; 1000) &#123; duration = 1000; &#125; scroller.startScroll(startX, 0, dx, 0, duration); invalidate(); // scrollTo(scroller.getCurrX(), 0); &#125; @Override public void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; int currX = scroller.getCurrX(); scrollTo(currX, 0); invalidate(); &#125; &#125; // 判断当前是否是菜单界面,true 就是菜单界面 public boolean isMenuShow() &#123; return currentView == MENU_VIEW; &#125; // 隐藏菜单界面 public void hideMenu() &#123; currentView = MAIN_VIEW; switchView(); &#125; // 显示菜单界面 public void showMenu() &#123; currentView = MENU_VIEW; switchView(); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: downX = (int) ev.getX(); break; case MotionEvent.ACTION_MOVE: int moveX = (int) ev.getX(); int diff = moveX - downX; if (Math.abs(diff) &gt; touchSlop) &#123; return true; &#125; break; case MotionEvent.ACTION_UP: break; default: break; &#125; return super.onInterceptTouchEvent(ev); &#125;&#125; 自定义好侧边栏之后，运行程序，效果图如图2-5 所示。 4. ViewDragHelper实现SlidingMenu 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235package com.github.slidingmenu.viewdraghelper;import android.content.Context;import android.graphics.Color;import android.support.v4.view.ViewCompat;import android.support.v4.widget.ViewDragHelper;import android.support.v4.widget.ViewDragHelper.Callback;import android.util.AttributeSet;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.widget.FrameLayout;public class SlideMenu2 extends FrameLayout&#123; private String TAG = SlideMenu2.class.getSimpleName(); public SlideMenu2(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; private ViewDragHelper viewDragHelper; private void init()&#123; viewDragHelper = ViewDragHelper.create(this, callback); &#125; private View menuView,mainView; private int menuWidth,menuHeight,mainWidth; private int dragRange; @Override protected void onFinishInflate() &#123; super.onFinishInflate(); if(getChildCount()&lt;2)&#123; throw new IllegalStateException("Your layout must has 2 children or more!"); &#125; menuView = getChildAt(0); mainView = getChildAt(1); setBackgroundColor(Color.BLACK); &#125; // @Override// protected void onLayout(boolean changed, int left, int top, int right,// int bottom) &#123;// super.onLayout(changed, left, top, right, bottom);// menuView.layout(left, top, right, bottom);// mainView.layout(left, top, right, bottom);// &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); menuWidth = menuView.getMeasuredWidth(); menuHeight = menuView.getMeasuredHeight(); mainWidth = mainView.getMeasuredWidth(); dragRange = (int) (menuWidth * 0.6);// ViewHelper.setScaleX(menuView, 0.5f);// ViewHelper.setScaleY(menuView, 0.5f);// ViewHelper.setTranslationX(menuView, -dragRange/2); &#125; private int lastX,lastY; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; int x = (int) ev.getX(); int y = (int) ev.getY(); if(mStatus==Status.Open &amp;&amp; viewDragHelper.isViewUnder(mainView, x, y))&#123; return true; &#125;// Log.e(TAG, "onInterceptTouchEvent : "+); if(viewDragHelper.isViewUnder(mainView, x, y))&#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_MOVE: int deltaX = x - lastX; int deltaY = y - lastY; if(Math.abs(deltaX)&gt;Math.abs(deltaY)*2) &#123;// Log.e(TAG, "移动斜角太大，拦截事件"); viewDragHelper.cancel(); return true; &#125; break; case MotionEvent.ACTION_UP: lastX = 0; lastY = 0; break; &#125; lastX = x; lastY = y; &#125; return viewDragHelper.shouldInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); if(mStatus==Status.Open &amp;&amp; viewDragHelper.isViewUnder(mainView, x, y))&#123; if(event.getAction()==MotionEvent.ACTION_UP)&#123; Log.e(TAG, "抬起"); close(); &#125; &#125; viewDragHelper.processTouchEvent(event); return true; &#125; private Callback callback = new Callback() &#123; @Override public boolean tryCaptureView(View child, int pointerId) &#123; return child==menuView || child==mainView; &#125; @Override public void onViewDragStateChanged(int state) &#123; super.onViewDragStateChanged(state); &#125; @Override public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; super.onViewPositionChanged(changedView, left, top, dx, dy);// Log.e(TAG, "onViewPositionChanged dx: "+dx); if(changedView==menuView)&#123; menuView.layout(0, 0, menuWidth, menuHeight); if(mainView.getLeft()&gt;dragRange)&#123; mainView.layout(dragRange, 0, dragRange+mainWidth, mainView.getBottom()); &#125;else &#123; mainView.layout(mainView.getLeft()+dx, 0, mainView.getRight()+dx, mainView.getBottom()); &#125; &#125; float percent = mainView.getLeft()/(float)dragRange; excuteAnimation(percent); if(mainView.getLeft()==0 &amp;&amp; mStatus != Status.Close)&#123; mStatus = Status.Close; if(onDragStatusChangeListener!=null )&#123; onDragStatusChangeListener.onClose(); &#125; &#125;else if (mainView.getLeft()==dragRange &amp;&amp; mStatus != Status.Open) &#123; mStatus = Status.Open; if(onDragStatusChangeListener!=null )&#123; onDragStatusChangeListener.onOpen(); &#125; &#125;else &#123; if(onDragStatusChangeListener!=null)&#123; onDragStatusChangeListener.onDragging(percent); &#125; &#125; &#125; private void excuteAnimation(float percent) &#123; menuView.setScaleX(0.5f + 0.5f * percent); menuView.setScaleY(0.5f + 0.5f * percent); mainView.setScaleX(1 - percent * 0.2f); mainView.setScaleY( 1 - percent * 0.2f); menuView.setTranslationX( -dragRange / 2 + dragRange / 2 * percent); menuView.setAlpha(percent); getBackground().setAlpha((int) ((1 - percent) * 255)); &#125; @Override public void onViewCaptured(View capturedChild, int activePointerId) &#123; super.onViewCaptured(capturedChild, activePointerId); &#125; @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; super.onViewReleased(releasedChild, xvel, yvel);// Log.e(TAG, "onViewReleased ："+(releasedChild==mainView)); if(mainView.getLeft()&gt;dragRange/2)&#123; open(); &#125;else &#123; close(); &#125; &#125; @Override public int getViewHorizontalDragRange(View child) &#123; return menuWidth; &#125; @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123; if(child==mainView)&#123; if(left&lt;0)return 0; if(left&gt;dragRange) return dragRange; &#125; if(child==menuView)&#123; mainView.layout(mainView.getLeft()+dx, 0, mainView.getRight()+dx, mainView.getBottom()); menuView.layout(0, 0, menuWidth, menuHeight); return 0; &#125; return left; &#125; &#125;; public void open()&#123; viewDragHelper.smoothSlideViewTo(mainView, dragRange, 0); ViewCompat.postInvalidateOnAnimation(SlideMenu2.this); &#125; public void close()&#123; viewDragHelper.smoothSlideViewTo(mainView, 0, 0); ViewCompat.postInvalidateOnAnimation(SlideMenu2.this); &#125; public void computeScroll() &#123; if(viewDragHelper.continueSettling(true))&#123; ViewCompat.postInvalidateOnAnimation(this); &#125; &#125; public OnDragStatusChangeListener getOnDragStatusChangeListener() &#123; return onDragStatusChangeListener; &#125; public void setOnDragStatusChangeListener(OnDragStatusChangeListener onDragStatusChangeListener) &#123; this.onDragStatusChangeListener = onDragStatusChangeListener; &#125; public Status mStatus = Status.Close;; public enum Status&#123; Open,Close &#125; private OnDragStatusChangeListener onDragStatusChangeListener; public interface OnDragStatusChangeListener&#123; void onOpen(); void onClose(); void onDragging(float dragProgress); &#125; &#125; 代码：https://github.com/JackChen1999/SlidingMenu]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件：侧滑面板]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%9A%E4%BE%A7%E6%BB%91%E9%9D%A2%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[本篇博客讲解的是自定义View之侧滑面板，应用场景：QQ，知乎，效果图如下 ##1. 内容摘要 了解ViewDragHelper 的产生及解决的问题 掌握ViewDragHelper 的使用步骤 掌握属性动画的使用 掌握状态更新及事件回调的用法 ##2. 实现最简单的拖拽 ###2.1 实现最简单的拖拽在创建DragLayout 时，继承FrameLayout,这里需要注意两个问题 为什么不继承ViewGroup,因为继承ViewGroup 需要重写onMeasure()和实现onLayout()方法，自己实现子view 的测量和摆放，在这里我们不需要自己去做测量和摆放，而FrameLayout 已经对这两个方法进行了具体实现，所以继承FrameLayout 更加简单省事 为什么不继承RelativeLayout,因为这里我们只需要层级关系，不需要相对关系，继承RelativeLayout界面效果是一样的，但RelativeLayout 对FrameLayout 多了相对关系的计算，效率会低一些，所以选择继承FrameLayout 1234567891011public class DragLayout extends FrameLayout &#123; public DragLayout(Context context) &#123; super(context); &#125; public DragLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public DragLayout(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; &#125; ###2.2 串联构造方法DragLayout 实例化时需要做一些初始化操作，如果我们定义一个init()方法，则我们需要在三个构造方法中都调用init()方法，这样非常麻烦，我们可以通过串连三个构造方法的方式实现只调用一次init()方法这样无论是代码创建还是布局在xml 中都能调用到我们的初始化代码 12345678910111213141516public class DragLayout extends FrameLayout &#123; public DragLayout(Context context) &#123; //代码创建时调用 this(context, null); &#125; public DragLayout(Context context, AttributeSet attrs) &#123; //布局在xml 中，实例化时调用 this(context, attrs, 0); &#125; public DragLayout(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); //在这里初始化 &#125; &#125; ###2.3 ViewDragHelper 简介我们要实现拖拽的效果，则需要自己去解析Touch 事件的ACTION_DOWN，ACTION_MOVE，ACTION_UP，相当的麻烦。所以Google 在2013 年的IO 大会上发布了ViewDragHelper 这个类，用来解决滑动拖拽问题，用这个类可以非常简单的实现view 的拖拽 ###2.4 创建ViewDragHelper由于eclipse 创建项目时，为我们添加的android-support-v4.jar 没有包含ViewDragHelper,我们需要将最新的android-support-v4.jar 拷贝到libs 下面，然后clean 一下工程。 在这里我们需要关联android-support-v4.jar 的源码，通过配置文件的方法来关联源码 在libs 下面创建一个android-support-v4.jar.properties 的文件 android-support-v4.jar.properties 中的内容为src = V4 包源码路径 我们只需要在第三个构造方法中实现ViewDragHelper 的实例即可 123456789public DragLayout(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); // 在这里初始化 // forParent 父类容器 // sensitivity 敏感度，越大越敏感，1.0f 是默认值 // Callback 回调事件 //1.通静态方法创建拖拽辅助类 mViewDragHelper = ViewDragHelper.create(this, 1.0f, mCallback); &#125; ViewDragHelper 三个参数的创建的方法源码中的mTouchSlop 表示触摸的最小敏感范围，越小越敏感即在界面拖动的瞬间变化量大于mTouchSlop 时才可以成功触发拖拽事件 12345public static ViewDragHelper create(ViewGroup forParent, float sensitivity, Callback cb)&#123; final ViewDragHelper helper = create(forParent, cb); helper.mTouchSlop = (int) (helper.mTouchSlop * (1 / sensitivity)); return helper;&#125; ###2.5 触摸事件转交ViewDragHelper 创建成功了，但它和DragLayout 并没有任何关系，我们需要让它们建立关系 123456//2.转交触摸事件@Overridepublic boolean onInterceptTouchEvent(MotionEvent event) &#123; //由ViewDragHelper 判断是否拦截 return mViewDragHelper.shouldInterceptTouchEvent(event);&#125;; 重写onInterceptTouchEvent 方法，将触摸事件交给ViewDragHelper 判断是否拦截，这样它们就建立了关系，事件拦截后，还需要对拦截到的事件进行处理，注意返回值必须是true 123456789@Override public boolean onTouchEvent(MotionEvent event) &#123; try &#123; //由ViewDragHelper 处理拦截的事件 mViewDragHelper.processTouchEvent(event); &#125; catch (Exception e) &#123;&#125; //事件已被处理，所以需要返回true return true; &#125;; ###2.6 处理回调事件ViewDragHelper 在处理触摸事件时会通过传入的callback 给我们反馈，通过对回调方法的处理即可实现简单的拖拽 12345678910111213141516//3.处理回调事件 ViewDragHelper.Callback mCallback = new ViewDragHelper.Callback() &#123; @Override //返回值决定了child 是否可以被拖拽 public boolean tryCaptureView(View child, int pointerId) &#123; //child 被用户拖拽的孩子 //pointerId 多点触摸的手指id return true; &#125; @Override //修正子view 水平方向上的位置，此时还没有真正的移动，返回值决定view 将移动到的位置 public int clampViewPositionHorizontal(View child, int left, int dx) &#123; //left 建议移动到的位置 return left; &#125; &#125;; ###2.7 DragLayout 布局到xml 中给左面板和主面板设置不同的背景颜色便于拖拽时观察效果，运行工程，即可实现简单的拖拽12345678910111213141516171819&lt;com.example.draglayout.widget.DragLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/bg"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:background="#66ff0000"&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:background="#00ff00"&gt; &lt;/LinearLayout&gt;&lt;/com.example.draglayout.widget.DragLayout&gt; ##3. 限定拖拽范围现在左面板和主面板可以任意拖动，本节要实现左面板不动，拖动时，主面板在一定范围内拖动 3.1 OnFinishInflate()介绍onFinishInflate()在控件inflate 完成时会被调用，可以在这个方法中查找子控件 可以通过findViewById()的方式查找子控件 可以通过子view 索引的方式查找子控件 这里采用第二种方式 123456789101112131415@Override protected void onFinishInflate() &#123; super.onFinishInflate(); //增强代码的健壮性 if(getChildCount() &lt; 2)&#123; //必须有两个子view throw new IllegalStateException("Your viewgroup must have two children."); &#125; if(!(getChildAt(0)instanceofViewGroup)||!(getChildAt(1)instanceof ViewGroup))&#123; //子view 必须是viewgroup 的子类 throw new IllegalStateException("The child must an instance of viewgroup."); &#125; mLeftContent = getChildAt(0); mMainContent = getChildAt(1); &#125;; 3.2 获取控件宽高在onMeasure()方法中可以获取到控件的宽高，也可以在onSizeChanged()方法中去获取宽高，onMeasure()方法调用后会检测宽高值有没有变化，有变化才调用onSizeChanged()方法，无变化则不调用，所以onSizeChanged()调用的次数比onMeasure()少，在这里我们在onSizeChanged()方法中去获取宽高，同时计算出拖拽范围为宽度的60% 123456789@Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getMeasuredWidth(); mHeight = getMeasuredHeight(); //拖拽的范围 mRange = (int) (mWidth * 0.6f); System.out.println("mWidth:"+mWidth+" mHeight:"+mHeight +" mRange:"+mRange); &#125; 3.3 限定主面板的拖动范围对callback 中的其它几个方法进行重写 123456789101112131415161718192021222324252627282930//3.处理回调事件 ViewDragHelper.Callback mCallback = new ViewDragHelper.Callback() &#123; @Override //返回值决定了child 是否可以被拖拽 public boolean tryCaptureView(View child, int pointerId) &#123; //child 被用户拖拽的孩子 //pointerId 多点触摸的手指id return true; &#125; @Override public int getViewHorizontalDragRange(View child) &#123; return super.getViewHorizontalDragRange(child); &#125; @Override //修正子view 水平方向上的位置，此时还没有真正的移动，返回值决定view 将移动到的位置 public int clampViewPositionHorizontal(View child, int left, int dx) &#123; //left 建议移动到位置 return left; &#125; @Override public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; super.onViewPositionChanged(changedView, left, top, dx, dy); &#125; @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; super.onViewReleased(releasedChild, xvel, yvel); &#125; &#125;; 回调方法中的getViewHorizontalDragRange(View child)方法返回拖拽的范围，但不会真正限定这个范围，只要返回一个大于零的值即可。 在ViewDragHelper 源码中，computeSettleDuration()会调用这个返回值来计算动画执行的时长，checkTouchSlop()方法会调用这个返回值检查左面板，主面板是否可以被滑动，所以需要返回一个大于0的值才能实现拖动。 如果返回值为0，左面板，主面板中不能有子view 或子view 没有对touch 事件做处理，最后触摸还是会交给ViewDragHelper 处理，所以也能实现拖动 1234567@Override //返回拖拽的范围，返回一个大于零的值，计算动画执行的时长，水平方向是否可以被滑开 public int getViewVerticalDragRange(View child) &#123; //computeSettleDuration 计算动画执行的时长 //checkTouchSlop 检查是否可以被滑动（没有孩子处理触摸事件，最后返回给DragLayout 处理） return mRange; &#125; 限定主面板的拖拽范围，当建议的值left 小于0 时，让left 等于0，大于mRange 时等于mRange，然后再将left 返回 123456789101112131415161718192021222324252627282930@Override// 修正子view 水平方向上的位置，此时还没有真正的移动，返回值决定view 将移动到的位置public int clampViewPositionHorizontal(View child, int left, int dx) &#123; // child 被用户拖拽的孩子 // left 建议移动到位置 // dx 新的位置与旧的位置的差值 int oldLeft = mMainContent.getLeft(); System.out.println("clamp: left:" + left + " oldLeft:" + oldLeft + " dx:" + dx); if (child == mMainContent) &#123; left = fixLeft(left); &#125; return left;&#125;/** * 修正左边的位置，限定拖拽范围在0 到mRange 间变化 * * @param left * @return */private int fixLeft(int left) &#123; if (left &lt; 0) &#123; left = 0; &#125; else if (left &gt; mRange) &#123; left = mRange; &#125; return left;&#125; 当控件位置变化时会调用onViewPositionChanged()方法，可以在此方法中做伴随动画，状态更新，事件回调，left 表示最新的水平位置，dx 表示刚刚发生的水平变化量。 此时左面板还可以任意拖动，为了实现拖动左面板时界面表现为拖动主面板，可以对changedView 进行判断，如果changedView 是左面板，则通过layout()把左面板放回到原来的位置，然后把变化量dx 累加给主面板，再通过layout()方法来移动主面板 12345678910111213141516171819202122@Override // 当控件位置变化时调用，可以做伴随动画，状态更新，事件回调 public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; super.onViewPositionChanged(changedView, left, top, dx, dy); // left 最新的水平位置 // dx 刚刚发生的水平变化量 System.out.println("onViewPositionChanged: left:" + left + " dx:" + dx); if (changedView == mLeftContent) &#123; // 如果滑动的是左面板 // 1.放回到原来的位置 mLeftContent.layout(0, 0, mWidth, mHeight); // 2.把变化量传递给主面板,主面板旧的值+变化量 int newLeft = mMainContent.getLeft() + dx; // 需要修正左边值 newLeft = fixLeft(newLeft); mMainContent.layout(newLeft, 0, newLeft + mWidth, mHeight); &#125; // offsetLeftAndRight 在低版本中没有重绘界面，手动调用重绘 invalidate(); &#125; 注意：由于onViewPositionChanged()方法调用前调用了offsetLeftAndRight()方法，此方法在低版本中没有重绘界面，并且在高版本中也有一个bug，最后一帧没有被绘制，所以需要手动调用一次invalidate()，否则在低版本中无法实现拖拽效果 ##4. 结束动画拖拽过程中当手指抬起时，需要实现一个打开，关闭面板的动画，结束动画可以在 onViewReleased()方法实现 4.1 跳转的结束动画onViewReleased()方法在松手之后会被调用，此时可以做结束动画，结束动画只需要考虑需要打开的情况，其它则为需要关闭情况 当水平方向的速度等于 0，并且主面板此时左边的位置在拖拽范围中轴线的右边则需要执行打开动 画，即 mMainContent.getLeft() &gt; mRange*0.5f 当水平方向的速度大于 0 时，则需要执行打开动画 其它情况则需要执行关闭动画 123456789101112131415161718//5.决定松手后要做的事件，结束动画 public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; super.onViewReleased(releasedChild, xvel, yvel); //releasedChild 被释放的孩子 //xvel 水平方向的速度,向左为-，向右为+ System.out.println("onViewReleased: xvel:"+xvel); //考虑开启的情况，其它情况则关闭的情况 if(xvel == 0 &amp;&amp; mMainContent.getLeft()&gt; mRange*0.5f)&#123; //在允许滑动的范围的中轴线右边，则打开 open(); &#125;else if(xvel &gt; 0)&#123; //速度向右时，则打开 open(); &#125;else&#123; //关闭 close(); &#125; &#125; open()，close()创建为 DragLayout 的方法，这样方便外界调用 12345678//直接打开 protected void open() &#123; mMainContent.layout(mRange, 0, mRange + mWidth, mHeight); &#125; //直接关闭 protected void close() &#123; mMainContent.layout(0, 0, 0 + mWidth, mHeight); &#125; 4.2 平滑的结束动画首先实现平滑的打开动画，在这里需要用到 ViewDragHelper 提供的一个方法smoothSlideViewTo(child,finalLeft,finalTop),三个参数的意思分别是： child 需要平滑移动的 view finalLeft 需要移动到的终点左边位置 finalTop 需要移动到的终点的上边位置 smoothSlideViewTo()方法的返回值为 true，表示位置不是最终位置，需要重绘界面 重载一个 open(boolean isSmooth)方法，用参数 isSmooth 标识是调用平滑动画还是跳转动画，open()方法则直接调用 open(true),默认为平滑动画 12345678910111213141516protected void open() &#123; open(true); &#125; protected void open(boolean isSmooth) &#123; int finalLeft = mRange; if(isSmooth)&#123; //触发一个平滑动画 if(mViewDragHelper.smoothSlideViewTo(mMainContent, finalLeft, 0))&#123; //invalidate();可能会漏帧 ViewCompat.postInvalidateOnAnimation(this); &#125;; &#125;else&#123; //直接跳转 mMainContent.layout(finalLeft, 0, finalLeft + mWidth, mHeight); &#125; &#125; 注意：smoothSlideViewTo()方法返回 true,需要重绘界面，此时不建议使用 invalidate(),因为在动画的过程中可能会丢帧，推荐使用 ViewCompat.postInvalidateOnAnimation(this),参数一定要传子 view 所在的容器，因为只有容器才知道子 view 的具体位置 重绘命令调用后，还需要重写 computScroll()方法，重绘时，系统会在 draw()方法后调用 computScroll()，在该方法中调用 ViewDragHelper 的维持动画的方法continueSettling(deferCallbacks)参数 deferCallbacks 表示是否延迟画下一帧，此处传入 true，返回值表示是否已经移动到最终位置，如果为 true，还没有移动到最终位置，需要重绘界面，这样 computeScroll()方法就会不断的调用，界面也就会不断的重绘，直到移动到最终位置 1234567891011@Override//维持动画的执行，高频率调用public void computeScroll() &#123; super.computeScroll(); //调用完后会调用 draw() if(mViewDragHelper.continueSettling(true))&#123; //参数传入 true，表示延迟画下一帧 //mViewDragHelper.continueSettling(true) ViewCompat.postInvalidateOnAnimation(this); &#125;&#125; 同样的道理，关闭的平滑动画只需要修改 finalLeft = 0 即可 12345678910111213141516protected void close() &#123; close(true); &#125; protected void close(boolean isSmooth) &#123; int finalLeft = 0; if(isSmooth)&#123; //触发一个平滑动画 if(mViewDragHelper.smoothSlideViewTo(mMainContent, finalLeft, 0))&#123; //invalidate();可能会漏帧 ViewCompat.postInvalidateOnAnimation(this); &#125;; &#125;else&#123; mMainContent.layout(finalLeft, 0, finalLeft + mWidth, mHeight); &#125; &#125; ##5. 伴随动画 5.1 分解伴随动画 伴随动画是拖拽的过程中，左面板，主面板会跟随拖拽百分比所做的动画，该动画需要在onViewPositionChanged()回调方法中实现 左面板：缩放动画，平移动画，透明度动画 主面板：缩放动画 背景： 亮度变化 5.2 实现伴随动画创建一个方法 dispatchDragEvent(),在 onViewPositionChanged()方法中调用 1234567public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; super.onViewPositionChanged(changedView, left, top, dx, dy); //...此处代码省略 dispatchDragEvent(); invalidate(); &#125; 实现左面板的缩放动画 123456789101112131415161718192021222324protected void dispatchDragEvent() &#123; //0.0f-&gt;1.0f 获取动画的百分比，主面板左边的位置引起的一系列变化 float percent = mMainContent.getLeft()*1.0f/mRange; System.out.println("dispatchDragEvent: percent:"+percent); //左面板：缩放动画，平移动画，透明度动画 //0.0f -&gt;1.0f percent*0.5f =&gt; 0.0f -&gt; 0.5f //寻找规律-&gt;拷贝 FloatEvaluator.java 中的估值方法 //percent*0.5f + 0.5f =&gt; 0.5f -&gt; 1.0f //percent*(1.0f -0.6f)+0.6f =&gt; 0.6f -&gt; 1.0f =&gt; start + percent(end - start) //兼容低版本引入 nineoldandroid.jar //用 ViewHelper 做属性动画 //1.缩放动画 ViewHelper.setScaleX(mLeftContent, evaluate(percent, 0.5f, 1.0f)); ViewHelper.setScaleY(mLeftContent, evaluate(percent, 0.5f, 1.0f)); &#125; //源码 FloatEvaluator.java 中拷贝的估值方法 public Float evaluate(float fraction, Number startValue, Number endValue) &#123; float startFloat = startValue.floatValue(); return startFloat + fraction * (endValue.floatValue() - startFloat); &#125; 第 3 行通过主面板左边位置与拖拽范围的相除可以得到一个 0.0f -&gt;1.0f 的比例值，因为在整个拖拽过程中，主面板左边位置的变化是引起一系列变化的原因 第 7-10 行可以推出一个公式 start + percent(end - start),即通过 percent 的变化可以计算出 start 到 end 间的任意值。源码 FloatEvaluator.java 中已经提供了这么一个方法，将其拷贝到代码中，即第 20-23 行 第 12-16 行为了兼容低版本引入 nineoldandroid.jar 中的 ViewHelper 做属性动画 同理可以实现其它伴随动画 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected void dispatchDragEvent() &#123; //0.0f-&gt;1.0f 获取动画的百分比，主面板左边的位置引起的一系列变化 float percent = mMainContent.getLeft()*1.0f/mRange; System.out.println("dispatchDragEvent: percent:"+percent); //左面板：缩放动画，平移动画，透明度动画 //0.0f -&gt;1.0f percent*0.5f =&gt; 0.0f -&gt; 0.5f //寻找规律-&gt;拷贝 FloatEvaluator.java 中的估值方法 //percent*0.5f + 0.5f =&gt; 0.5f -&gt; 1.0f //percent*(1.0f -0.6f)+0.6f =&gt; 0.6f -&gt; 1.0f =&gt; start + percent(end - start) //兼容低版本引入 nineoldandroid.jar //用 ViewHelper 做属性动画 //1.缩放动画,从 50%-&gt;100% ViewHelper.setScaleX(mLeftContent, evaluate(percent, 0.5f, 1.0f)); ViewHelper.setScaleY(mLeftContent, evaluate(percent, 0.5f, 1.0f)); //2.平移动画,从宽度一半在屏幕外-&gt;全部移到屏幕内 ViewHelper.setTranslationX(mLeftContent, evaluate(percent, -mWidth*0.5f, 0f)); //3.透明度动画,从 20%-&gt;100% ViewHelper.setAlpha(mLeftContent, evaluate(percent, 0.2f, 1.0f)); //主面板：缩放动画,从 100%-&gt;80% ViewHelper.setScaleY(mMainContent, evaluate(percent, 1.0f, 0.8f)); //背景亮度变化,PorterDuff.Mode.SRC_OVER 叠加模式，直接叠加在上面 getBackground().setColorFilter((Integer) evaluateColor(percent, Color.BLACK,Color.TRANSPARENT), PorterDuff.Mode.SRC_OVER); &#125; //源码 ArgbEvaluator.java 中拷贝的估值方法 public Object evaluateColor(float fraction, Object startValue, Object endValue) &#123; //api18 以上的代码才有透明度的过滤 int startInt = (Integer) startValue; int startA = (startInt &gt;&gt; 24) &amp; 0xff; int startR = (startInt &gt;&gt; 16) &amp; 0xff; int startG = (startInt &gt;&gt; 8) &amp; 0xff; int startB = startInt &amp; 0xff; int endInt = (Integer) endValue; int endA = (endInt &gt;&gt; 24) &amp; 0xff; int endR = (endInt &gt;&gt; 16) &amp; 0xff; int endG = (endInt &gt;&gt; 8) &amp; 0xff; int endB = endInt &amp; 0xff; return (int)((startA + (int)(fraction * (endA - startA))) &lt;&lt; 24) | (int)((startR + (int)(fraction * (endR - startR))) &lt;&lt; 16) | (int)((startG + (int)(fraction * (endG - startG))) &lt;&lt; 8) | (int)((startB + (int)(fraction * (endB - startB)))); &#125; 第 27 行叠加模式 PorterDuff.Mode.SRC_OVER 表示直接叠加在上面 第 30-48 行 ArgbEvaluator.java 源码中拷贝的估值方法，api18 以上的代码才有透明度的过滤 ##6. 状态更新及事件回调 6.1 状态分析拖拽的状态可以分为： 打开状态 关闭状态 拖拽状态 通过枚举定义这三种状态，且定义默认状态为关闭 12345678910//默认状态为关闭private Status status = Status.Close;//提供 get()方法public Status getStatus() &#123; return status;&#125;//状态的枚举值，有三种状态，打开，关闭，拖拽中public enum Status&#123; Open,Close,Draging;&#125; 6.2 事件回调分析定义一个事件回调接口，事件回调和状态密切相关 打开状态时回调 onOpen()方法 关闭状态时回调 onClose()方法 拖拽中回调 onDraging(float percent)方法，并将拖拽百分比传出去 12345678910111213141516171819202122//接收外界注册的接口类，以便回调接口方法 private OnDragChangeListener onDragChangeListener; //提供 set()方法，让外界注册监听接口类 public void setOnDragChangeListener(OnDragChangeListener onDragChangeListener) &#123; this.onDragChangeListener = onDragChangeListener; &#125; //模仿 View 的 OnClickListener 的写法，定义一个内部的公开的接口 public interface OnDragChangeListener&#123; /** * 打开时调用 */ public void onOpen(); /** * 关闭时调用 */ public void onClose(); /** * 拖拽中调用 * @param percent 当前拖拽的百分比 */ public void onDraging(float percent); &#125; 6.3 实现状态更新及事件回调通过拖拽百分比可以判断当前的状态，在 dispatchDragEvent()方法中实现状态更新及事件回调 百分比为 0，则为关闭状态 百分比为 1，则为打开状态 其它百分比，则为拖拽状态 事件回调需要先做空判断，拖拽状态调用频率高，直接调用即可，打开和关闭可以判断上次状态和当前状态是否一致，不一致则调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected void dispatchDragEvent() &#123; //0.0f-&gt;1.0f 获取动画的百分比，主面板左边的位置引起的一系列变化 float percent = mMainContent.getLeft()*1.0f/mRange; System.out.println("dispatchDragEvent: percent:"+percent); Status lastStatus = status; //更新状态，通过动画百分比判断 if(percent ==0 )&#123; status = Status.Close; &#125;else if(percent == 1)&#123; status = Status.Open; &#125;else&#123; status = Status.Close; &#125; if(onDragChangeListener != null)&#123; //调用频率高，直接调用 onDragChangeListener.onDraging(percent); &#125; if(lastStatus != status &amp;&amp; onDragChangeListener != null)&#123; if(status == Status.Open)&#123; //最新状态是 open，说明刚才不是 open，则需要调用一下 onOpen 方法 onDragChangeListener.onOpen(); &#125;else if(status == Status.Close)&#123; //最新状态是 close，说明刚才不是 close，则需要调用一下 onClose 方法 onDragChangeListener.onClose(); &#125; &#125; //左面板：缩放动画，平移动画，透明度动画 //0.0f -&gt;1.0f percent*0.5f =&gt; 0.0f -&gt; 0.5f //寻找规律-&gt;拷贝 FloatEvaluator.java 中的估值方法 //percent*0.5f + 0.5f =&gt; 0.5f -&gt; 1.0f //percent*(1.0f -0.6f)+0.6f =&gt; 0.6f -&gt; 1.0f =&gt; start + percent(end - start) //兼容低版本引入 nineoldandroid.jar //用 ViewHelper 做属性动画 //1.缩放动画 ViewHelper.setScaleX(mLeftContent, evaluate(percent, 0.5f, 1.0f)); ViewHelper.setScaleY(mLeftContent, evaluate(percent, 0.5f, 1.0f)); //2.平移动画 ViewHelper.setTranslationX(mLeftContent, evaluate(percent, -mWidth*0.5f, 0f)); //3.透明度动画 ViewHelper.setAlpha(mLeftContent, evaluate(percent, 0.2f, 1.0f)); //主面板：缩放动画 ViewHelper.setScaleY(mMainContent, evaluate(percent, 1.0f, 0.8f)); //背景亮度变化,如果没有设置背景会出问题，PorterDuff.Mode.SRC_OVER 叠加模式，直接叠加在上 面 getBackground().setColorFilter((Integer) evaluateColor(percent, Color.BLACK,Color.TRANSPARENT), PorterDuff.Mode.SRC_OVER); &#125; ##7. 触摸优化 7.1 填充界面数据1．修改主界面 xml，左面板，主面板分别加入 ListView 及头像 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;com.example.draglayout.widget.DragLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/dl" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/bg" tools:context=".MainActivity" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="50dp" android:paddingLeft="10dp" android:paddingRight="50dp" android:orientation="vertical" android:paddingTop="50dp" &gt; &lt;ImageView android:layout_width="50dp" android:layout_height="50dp" android:contentDescription="@null" android:src="@drawable/head" /&gt; &lt;ListView android:id="@+id/lv_left" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;/ListView&gt; &lt;/LinearLayout&gt; &lt;com.example.draglayout.widget.MyLinearLayout android:id="@+id/ll_my" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#ffffff" android:orientation="vertical" &gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="50dip" android:background="#18b6ef" android:gravity="center_vertical" &gt; &lt;ImageView android:id="@+id/iv_header" android:layout_width="30dp" android:layout_height="30dp" android:layout_marginLeft="10dp" android:contentDescription="@null" android:src="@drawable/head" /&gt; &lt;/RelativeLayout&gt; &lt;ListView android:id="@+id/lv_main" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;/ListView&gt; &lt;/com.example.draglayout.widget.MyLinearLayout&gt;&lt;/com.example.draglayout.widget.DragLayout&gt; 2．ListView 数据源 123456789101112131415161718192021public class Cheeses &#123; public static final String[] sCheeseStrings = &#123; "Abbaye de Belloc", "Abbaye du Mont des Cats", "Abertam", "Abondance", "Ackawi", "Acorn", "Adelost", "Affidelice au Chablis", "Afuega'l Pitu", "Airag", "Airedale", "Xanadu", "Xynotyro", "Yarg Cornish", "Yarra Valley Pyramid", "Yorkshire Blue", "Zamorano", "Zanetti Grana Padano", "Zanetti Parmigiano Reggiano" &#125;; public static final String[] NAMES = new String[]&#123;"宋江", "卢俊义", "吴用", "公孙胜", "关胜", "林冲", "秦明", "呼延灼", "花荣", "柴进", "李应", "朱仝", "鲁智 深", "武松", "董平", "张清", "杨志", "徐宁", "索超", "戴宗", "刘唐", "李逵", "史进", " 穆弘", "雷横", "李俊", "阮小二", "张横", "阮小五", " 张顺", "阮小七", "杨雄", "石秀", " 解珍", " 解宝", "燕青", "朱武", "黄信", "孙立", "宣赞", "郝思文", "韩滔", "彭玘", "单廷珪 ", "魏定国", "萧让", "裴宣", "欧鹏", "邓飞", " 燕顺", "杨林", "凌振", "蒋敬", "吕方 ", "郭 盛", "安道全", "皇甫端", "王英", "扈三娘", "鲍旭", "樊瑞", "孔明", "孔亮", " 项充", "李衮", "金大坚", "马麟", "童威", "童猛", "孟康", "侯健", "陈达", "杨春", "郑天寿 ", "陶宗旺", "宋清", "乐和", "龚旺", "丁得孙", "穆春", "曹正", "宋万", "杜迁", "薛永 ", " 施恩", "周通", "李忠", "杜兴", "汤隆", "邹渊", "邹润", "朱富", "朱贵", "蔡福", "蔡庆", " 李立", "李云", "焦挺", "石勇", "孙新", "顾大嫂", "张青", "孙二娘", " 王定六", "郁保四", " 白胜", "时迁", "段景柱"&#125;; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498public class DragLayout extends FrameLayout &#123; private static final String TAG = "TAG"; private View mLeftContent; private View mMainContent; private View mRightContent; private int mWidth; private int mHeight; private int mRangeLeft; private ViewDragHelper mDragHelper; private Status mStatus = Status.Close; private Direction mDirction = Direction.Left; private OnDragListener mDragListener; private boolean mScaleEnable = true; private int mRightWidth; private int mRangeRight; public interface OnDragListener &#123; void onClose(); void onStartOpen(Direction direction); void onOpen(); void onDrag(float percent); &#125; public static enum Status &#123; Open, Close, Draging &#125; public static enum Direction &#123; Left, Right, Default &#125; public Direction getDirction() &#123; return mDirction; &#125; public void setDirction(Direction dirction) &#123; mDirction = dirction; &#125; public DragLayout(Context context) &#123; this(context, null); &#125; public DragLayout(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public DragLayout(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); mDragHelper = ViewDragHelper.create(this, mCallBack); mGestureDetector = new GestureDetectorCompat(context, mYGestureListener); &#125; SimpleOnGestureListener mYGestureListener = new SimpleOnGestureListener() &#123; public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; return Math.abs(distanceX) &gt;= Math.abs(distanceY); &#125;; &#125;; @Override protected void onFinishInflate() &#123; Log.i(TAG, "--onFinishInflate"); mLeftContent = (View) getChildAt(0); mRightContent = getChildAt(1); mMainContent = (View) getChildAt(2); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); Log.i(TAG, "--onSizeChanged"); mWidth = mMainContent.getMeasuredWidth(); mHeight = mMainContent.getMeasuredHeight(); mRightWidth = mRightContent.getMeasuredWidth(); mRangeLeft = (int) (mWidth * 0.6f); mRangeRight = mRightWidth; &#125; private int mMainLeft = 0; ViewDragHelper.Callback mCallBack = new ViewDragHelper.Callback() &#123; @Override public boolean tryCaptureView(View child, int pointerId) &#123; // 1. 决定当前被拖拽的child是否拖的动。(抽象方法，必须重写) Log.d(TAG, "tryCaptureView: " + (child == mMainContent) + " : " + (child == mLeftContent) + " : " + (child == mRightContent)); return true; &#125; @Override public int getViewHorizontalDragRange(View child) &#123; // 2. 决定拖拽的范围 return mWidth; &#125; @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123; // 3. 决定拖动时的位置，可在这里进行位置修正。（若想在此方向拖动，必须重写，因为默认返回0） Log.d(TAG, "clampViewPositionHorizontal left: " + left + " dx: " + dx + " mRange: " + mRangeLeft); return clampResult(mMainLeft + dx, left); &#125; @Override public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; // 4. 决定了当View被拖动时，希望同时引发的其他变化 Log.d(TAG, "onViewPositionChanged left: " + left + " dx: " + dx); if (changedView == mMainContent) &#123; mMainLeft = left; &#125; else &#123; mMainLeft += dx; &#125; mMainLeft = clampResult(mMainLeft, mMainLeft); if(changedView == mLeftContent || changedView == mRightContent)&#123; layoutContent(); &#125; dispathDragEvent(mMainLeft); invalidate(); &#125;; /** * @param releasedChild * 被释放的孩子 * @param xvel * 释放时X方向的速度 * @param yvel * 释放时Y方向的速度 */ @Override public void onViewReleased(View releasedChild, float xvel, float yvel) &#123; // 5. 决定当childView被释放时，希望做的事情——执行打开/关闭动画，更新状态 boolean scrollRight = xvel &gt; 1.0f; boolean scrollLeft = xvel &lt; -1.0f; if (scrollRight || scrollLeft) &#123; if (scrollRight &amp;&amp; mDirction == Direction.Left) &#123; open(true, mDirction); &#125; else if (scrollLeft &amp;&amp; mDirction == Direction.Right) &#123; open(true, mDirction); &#125; else &#123; close(true); &#125; return; &#125; if (releasedChild == mLeftContent &amp;&amp; mMainLeft &gt; mRangeLeft * 0.7f) &#123; open(true, mDirction); &#125; else if (releasedChild == mMainContent) &#123; if (mMainLeft &gt; mRangeLeft * 0.3f) open(true, mDirction); else if (-mMainLeft &gt; mRangeRight * 0.3f) open(true, mDirction); else close(true); &#125; else if (releasedChild == mRightContent &amp;&amp; -mMainLeft &gt; mRangeRight * 0.7f) &#123; open(true, mDirction); &#125; else &#123; close(true); &#125; &#125; @Override public void onViewDragStateChanged(int state) &#123; if (mStatus == Status.Close &amp;&amp; state == ViewDragHelper.STATE_IDLE &amp;&amp; mDirction == Direction.Right) &#123; mDirction = Direction.Left; &#125; &#125; @Override public void onViewCaptured(View capturedChild, int activePointerId) &#123; &#125;; &#125;; private int clampResult(int tempValue, int defaultValue) &#123; Integer minLeft = null; Integer maxLeft = null; if (mDirction == Direction.Left) &#123; minLeft = 0; maxLeft = 0 + mRangeLeft; &#125; else if (mDirction == Direction.Right) &#123; minLeft = 0 - mRangeRight; maxLeft = 0; &#125; if (minLeft != null &amp;&amp; tempValue &lt; minLeft) return minLeft; else if (maxLeft != null &amp;&amp; tempValue &gt; maxLeft) return maxLeft; else return defaultValue; &#125; private GestureDetectorCompat mGestureDetector; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); Log.i(TAG, "--onMeasure"); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; Log.i(TAG, "--onLayout"); layoutContent(); &#125; private void layoutContent() &#123; mLeftContent.layout(0, 0, mWidth, mHeight); mRightContent.layout(mWidth - mRightWidth, 0, mWidth, mHeight); mMainContent.layout(mMainLeft, 0, mMainLeft + mWidth, mHeight); &#125; @Override public void computeScroll() &#123; if (mDragHelper.continueSettling(true)) &#123; ViewCompat.postInvalidateOnAnimation(this); &#125; &#125; public void setDragListener(OnDragListener mDragListener) &#123; this.mDragListener = mDragListener; &#125; /** * 处理其他同步动画 * * @param mainLeft */ protected void dispathDragEvent(int mainLeft) &#123; // 注意转换成float float percent = 0; if (mDirction == Direction.Left) percent = mainLeft / (float) mRangeLeft; else if (mDirction == Direction.Right) percent = Math.abs(mainLeft) / (float) mRangeRight; if (mDragListener != null) &#123; mDragListener.onDrag(percent); &#125; // 更新动画 if (mScaleEnable) &#123; animViews(percent); &#125; // 更新状态 Status lastStatus = mStatus; if (updateStatus() != lastStatus) &#123; if(lastStatus == Status.Close &amp;&amp; mStatus == Status.Draging)&#123; mLeftContent.setVisibility(mDirction == Direction.Left ? View.VISIBLE : View.GONE); mRightContent.setVisibility(mDirction == Direction.Right ? View.VISIBLE : View.GONE); if(mDragListener != null)&#123; mDragListener.onStartOpen(mDirction); &#125; &#125; if (mStatus == Status.Close) &#123; if (mDragListener != null) mDragListener.onClose(); &#125; else if (mStatus == Status.Open) &#123; if (mDragListener != null) mDragListener.onOpen(); &#125; &#125; &#125; private Status updateStatus() &#123; if (mDirction == Direction.Left) &#123; if (mMainLeft == 0) &#123; mStatus = Status.Close; &#125; else if (mMainLeft == mRangeLeft) &#123; mStatus = Status.Open; &#125; else &#123; mStatus = Status.Draging; &#125; &#125; else if (mDirction == Direction.Right) &#123; if (mMainLeft == 0) &#123; mStatus = Status.Close; &#125; else if (mMainLeft == 0 - mRangeRight) &#123; mStatus = Status.Open; &#125; else &#123; mStatus = Status.Draging; &#125; &#125; return mStatus; &#125; private void animViews(float percent) &#123; Log.d(TAG, "percent: " + percent); animMainView(percent); animBackView(percent); &#125; private void animBackView(float percent) &#123; if (mDirction == Direction.Right) &#123; // 右边栏X, Y放大，向左移动, 逐渐显示 ViewHelper.setScaleX(mRightContent, 0.5f + 0.5f * percent); ViewHelper.setScaleY(mRightContent, 0.5f + 0.5f * percent); ViewHelper.setTranslationX(mRightContent, evaluate(percent, mRightWidth + mRightWidth / 2.0f, 0.0f)); ViewHelper.setAlpha(mRightContent, percent); &#125; else &#123; // 左边栏X, Y放大，向右移动, 逐渐显示 ViewHelper.setScaleX(mLeftContent, 0.5f + 0.5f * percent); ViewHelper.setScaleY(mLeftContent, 0.5f + 0.5f * percent); ViewHelper.setTranslationX(mLeftContent, evaluate(percent, -mWidth / 2f, 0.0f)); ViewHelper.setAlpha(mLeftContent, percent); &#125; // 背景逐渐变亮 getBackground().setColorFilter( caculateValue(percent, Color.BLACK, Color.TRANSPARENT), PorterDuff.Mode.SRC_OVER); &#125; private void animMainView(float percent) &#123; Float inverseP = null; if (mDirction == Direction.Left) &#123; inverseP = 1 - percent * 0.25f; &#125; else if (mDirction == Direction.Right) &#123; inverseP = 1 - percent * 0.25f; &#125; // 主界面X,Y缩小 if (inverseP != null) &#123; if (mDirction == Direction.Right) &#123; ViewHelper.setPivotX(mMainContent, mWidth); ViewHelper.setPivotY(mMainContent, mHeight / 2.0f); &#125; else &#123; ViewHelper.setPivotX(mMainContent, mWidth / 2.0f); ViewHelper.setPivotY(mMainContent, mHeight / 2.0f); &#125; ViewHelper.setScaleX(mMainContent, inverseP); ViewHelper.setScaleY(mMainContent, inverseP); &#125; &#125; public Float evaluate(float fraction, Number startValue, Number endValue) &#123; float startFloat = startValue.floatValue(); return startFloat + fraction * (endValue.floatValue() - startFloat); &#125; private int caculateValue(float fraction, Object start, Object end) &#123; int startInt = (Integer) start; int startIntA = startInt &gt;&gt; 24 &amp; 0xff; int startIntR = startInt &gt;&gt; 16 &amp; 0xff; int startIntG = startInt &gt;&gt; 8 &amp; 0xff; int startIntB = startInt &amp; 0xff; int endInt = (Integer) end; int endIntA = endInt &gt;&gt; 24 &amp; 0xff; int endIntR = endInt &gt;&gt; 16 &amp; 0xff; int endIntG = endInt &gt;&gt; 8 &amp; 0xff; int endIntB = endInt &amp; 0xff; return ((int) (startIntA + (endIntA - startIntA) * fraction)) &lt;&lt; 24 | ((int) (startIntR + (endIntR - startIntR) * fraction)) &lt;&lt; 16 | ((int) (startIntG + (endIntG - startIntG) * fraction)) &lt;&lt; 8 | ((int) (startIntB + (endIntB - startIntB) * fraction)); &#125; float mDownX; private SwipeListAdapter adapter; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if(getStatus() == Status.Close)&#123; int actionMasked = MotionEventCompat.getActionMasked(ev); switch (actionMasked) &#123; case MotionEvent.ACTION_DOWN: mDownX = ev.getRawX(); break; case MotionEvent.ACTION_MOVE: if(adapter.getUnClosedCount() &gt; 0)&#123; return false; &#125; float delta = ev.getRawX() - mDownX; if(delta &lt; 0)&#123; return false; &#125; break; default: mDownX = 0; break; &#125; &#125; return mDragHelper.shouldInterceptTouchEvent(ev) &amp; mGestureDetector.onTouchEvent(ev); &#125; public void close()&#123; close(true); &#125; public void close(boolean withAnim) &#123; mMainLeft = 0; if (withAnim) &#123; if (mDragHelper.smoothSlideViewTo(mMainContent, mMainLeft, 0)) &#123; ViewCompat.postInvalidateOnAnimation(this); &#125; &#125; else &#123; layoutContent(); dispathDragEvent(mMainLeft); &#125; &#125; public void open()&#123; open(true); &#125; public void open(boolean withAnim) &#123; open(withAnim, Direction.Left); &#125; public void open(boolean withAnim, Direction d) &#123; mDirction = d; if (mDirction == Direction.Left) mMainLeft = mRangeLeft; else if (mDirction == Direction.Right) mMainLeft = -mRangeRight; if (withAnim) &#123; // 引发动画的开始 if (mDragHelper.smoothSlideViewTo(mMainContent, mMainLeft, 0)) &#123; // 需要在computeScroll中使用continueSettling方法才能将动画继续下去（因为ViewDragHelper使用了scroller）。 ViewCompat.postInvalidateOnAnimation(this); &#125; &#125; else &#123; layoutContent(); dispathDragEvent(mMainLeft); &#125; &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; try &#123; mDragHelper.processTouchEvent(event); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return true; &#125; public Status getStatus() &#123; return mStatus; &#125; public void switchScaleEnable() &#123; this.mScaleEnable = !mScaleEnable; if (!mScaleEnable) &#123; animBackView(1.0f); &#125; &#125; public void setAdapterInterface(SwipeListAdapter adapter) &#123; this.adapter = adapter; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940public class DragRelativeLayout extends RelativeLayout &#123; private DragLayout dl; public DragRelativeLayout(Context context) &#123; super(context); &#125; public DragRelativeLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public DragRelativeLayout(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; public void setDragLayout(DragLayout dl) &#123; this.dl = dl; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent event) &#123; if (dl.getStatus() != Status.Close) &#123; return true; &#125; return super.onInterceptTouchEvent(event); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (dl.getStatus() != Status.Close) &#123; if (event.getAction() == MotionEvent.ACTION_UP) &#123; dl.close(true); &#125; return true; &#125; return super.onTouchEvent(event); &#125;&#125; 代码：https://github.com/JackChen1999/DragLayout]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件：快速索引]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[快速索引在应用中很常见，在联系人，微信，省市列表，应用管理，文件管理等应用场景都可以看到快速索引的身影，本篇博客将讲解快速索引的自定义，从中你可以学到获取汉字首字母的方法，绘制字母时，纵坐标的计算方法 1. 静态绘制1.1 初始化数据创建自定义控件QuickIndexBar 继承View 1234567891011121314151617181920212223242526272829public class QuickIndexBar extends View &#123; private Paint paint; // 字母数组 private static final String[] LETTERS = new String[] &#123; "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" &#125;; public QuickIndexBar(Context context) &#123; this(context, null); &#125; public QuickIndexBar(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public QuickIndexBar(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); paint = new Paint(); // 设置抗锯齿，设置后画出来的边缘更加平滑 paint.setAntiAlias(true); //设置字体为粗体 paint.setTypeface(Typeface.DEFAULT_BOLD); // 设置字体颜色 paint.setColor(Color.WHITE); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //画文字的方法 canvas.drawText("A", 10f, 10f, paint); &#125; &#125; 第3-6 行初始化字母数组 第7-12 行串连构造方法 第15-21 行初始化画笔 第27 行画文字的方法 将QuickIndexBar 布局到activity_main.xml 中 123456789101112&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;com.example.quickindexer.widget.QuickIndexBar android:id="@+id/quick_bar" android:layout_width="30dp" android:layout_height="match_parent" android:layout_alignParentRight="true" android:background="#ff0000"/&gt;&lt;/RelativeLayout&gt; 1.2 计算字母坐标 画文字的x，y 坐标是文字左下角的位置 第一个字母的x 坐标则等于单元格宽度的一半减去文字宽度的一半，由于所有字母离左边的距离一样，所以x 不变int x = cellWidth/2 - textWidth/2 第一个字母的y 坐标则等于单元格高度的一半加上文字，第二个字母需要加上一个单元格的宽度由此类推int y = cellHeight/2 +textHeight/2 +i*cellHeight 单元格cellWidth 为QuickIndexBar 宽度，cellHeight 为QuickIndexBar 高度/字母数组的长度 12345678910111213141516171819202122232425262728@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //遍历字母数组，计算坐标，进行绘制 for (int i = 0; i &lt; LETTERS.length; i++) &#123; String letter = LETTERS[i]; //计算x 坐标 float x = cellWidth*0.5f - paint.measureText(letter)*0.5f; //计算y 坐标 Rect bounds = new Rect(); //获取文本的矩形区域 paint.getTextBounds(letter, 0, letter.length(), bounds); float y = cellHeight*0.5f + bounds.height()+ i*cellHeight; //绘制文本 canvas.drawText(letter, x, y, paint); &#125; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //控件高度 int height = getMeasuredHeight(); //控件宽度，也为单元格宽度 cellWidth = getMeasuredWidth(); //单元格宽度，控件高度除以字母数组长度，此处需要用float 类型 //10/3 = 3.333 如果用int 接收则为3，此时高度比实际分配的高度小，所以用float 接收 cellHeight = height*1.0f/LETTERS.length; &#125; 第19-26 行获取单元的宽高，注意单元格高度需要用float 类型 第8-12 行通过paint 测量文字的宽高，并计算出每个字母的坐标 2. Android drawText获取text宽度的三种方式原文链接：http://blog.csdn.net/chuekup/article/details/751823912345678910111213141516171819202122232425262728293031String str = "Hello"; canvas.drawText( str , x , y , paint); //1. 粗略计算文字宽度 Log.d(TAG, "measureText=" + paint.measureText(str)); //2. 计算文字所在矩形，可以得到宽高 Rect rect = new Rect(); paint.getTextBounds(str, 0, str.length(), rect); int w = rect.width(); int h = rect.height(); Log.d(TAG, "w=" +w+" h="+h); //3. 精确计算文字宽度 int textWidth = getTextWidth(paint, str); Log.d(TAG, "textWidth=" + textWidth); public static int getTextWidth(Paint paint, String str) &#123; int iRet = 0; if (str != null &amp;&amp; str.length() &gt; 0) &#123; int len = str.length(); float[] widths = new float[len]; paint.getTextWidths(str, widths); for (int j = 0; j &lt; len; j++) &#123; iRet += (int) Math.ceil(widths[j]); &#125; &#125; return iRet; &#125; //4. mPaint.getTextSize(); 3. 响应触摸事件重写onTouchEvent()方法，解析触摸事件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//初始值需要设置为-1，不能为0，因为按下第一个字母的索引是0 private int lastIndex = -1; @Override public boolean onTouchEvent(MotionEvent event) &#123; float y ; int currentIndex; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: y = event.getY(); //根据y 计算当前按下的字母索引 //例如：y = 21,cellHeight = 10 =&gt;(int) (y/cellHeight)= 2 currentIndex = (int) (y/cellHeight); if(lastIndex != currentIndex)&#123; //判断计算出来的索引值，避免数组越界 if(0 &lt;= currentIndex &amp;&amp; currentIndex &lt; LETTERS.length)&#123; String letter = LETTERS[currentIndex]; Utils.showToast(getContext(), letter); //记录上次按下的索引 lastIndex = currentIndex; &#125; &#125; break; case MotionEvent.ACTION_MOVE: y = event.getY(); //根据y 计算当前按下的字母索引 //例如：y = 21,cellHeight = 10 =&gt;(int) (y/cellHeight)= 2 currentIndex = (int) (y/cellHeight); //判断计算出来的索引值，避免数组越界 if(0 &lt;= currentIndex &amp;&amp; currentIndex &lt; LETTERS.length)&#123; String letter = LETTERS[currentIndex]; Utils.showToast(getContext(), letter); //记录上次按下的索引 lastIndex = currentIndex; &#125; break; case MotionEvent.ACTION_UP: //手指抬起时需要将记录的值设为-1，否则再次按下该字母不会弹出toast lastIndex = -1; break; default: break; &#125; //事件已被处理，返回true return true; &#125; 第12 行通过触摸的y 值计算按下字母的索引值 第19 行记录上次按下字母的索引值，通过判断上次按下字母的索引与本次按下字母的索引是否相同，如果不同才弹出toast，避免在同一个字母上来回移动也一直弹出toast 第38 行手指抬起需要将lastIndex 还原为初始值 第45 行一定要返回true，代表事件已被消费 第17 行是单例Toast 1234567891011public class Utils &#123; private static Toast toast; public static void showToast(Context context, String msg) &#123; if (toast == null) &#123; toast = Toast.makeText(context, "", Toast.LENGTH_SHORT); &#125; toast.setText(msg); toast.show(); &#125; &#125; 4. 监听回调定义监听回调接口 1234567891011private OnLetterUpdateListener onLetterUpdateListener; public OnLetterUpdateListener getOnLetterUpdateListener() &#123; return onLetterUpdateListener; &#125; public void setOnLetterUpdateListener( OnLetterUpdateListener onLetterUpdateListener) &#123; this.onLetterUpdateListener = onLetterUpdateListener; &#125; public interface OnLetterUpdateListener&#123; public void onLetterUpdate(String letter); &#125; 在弹出Toast 的地方替换成调用接口方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean onTouchEvent(MotionEvent event) &#123; float y ; int currentIndex; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: y = event.getY(); //根据y 计算当前按下的字母索引 //例如：y = 21,cellHeight = 10 =&gt;(int) (y/cellHeight)= 2 currentIndex = (int) (y/cellHeight); if(lastIndex != currentIndex)&#123; //判断计算出来的索引值，避免数组越界 if(0 &lt;= currentIndex &amp;&amp; currentIndex &lt; LETTERS.length)&#123; String letter = LETTERS[currentIndex]; if(onLetterUpdateListener != null)&#123; onLetterUpdateListener.onLetterUpdate(letter); &#125; //记录上次按下的索引 lastIndex = currentIndex; &#125; &#125; break; case MotionEvent.ACTION_MOVE: y = event.getY(); //根据y 计算当前按下的字母索引 //例如：y = 21,cellHeight = 10 =&gt;(int) (y/cellHeight)= 2 currentIndex = (int) (y/cellHeight); //判断计算出来的索引值，避免数组越界 if(0 &lt;= currentIndex &amp;&amp; currentIndex &lt; LETTERS.length)&#123; String letter = LETTERS[currentIndex]; if(onLetterUpdateListener != null)&#123; onLetterUpdateListener.onLetterUpdate(letter); &#125; //记录上次按下的索引 lastIndex = currentIndex; &#125; break; case MotionEvent.ACTION_UP: //手指抬起时需要将记录的值设为-1，否则再次按下该字母不会弹出toast lastIndex = -1; break; default: break; &#125; //事件已被处理，返回true return true; &#125; 第14-16 调用回调接口方法，通知外面当前触摸的字母 第30-32 调用回调接口方法，通知外面当前触摸的字母 主Activity 中给QuickIndexBar 设置回调监听 1234567891011protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); QuickIndexBar quickBar = (QuickIndexBar) findViewById(R.id.quick_bar); quickBar.setOnLetterUpdateListener(new OnLetterUpdateListener() &#123; @Override public void onLetterUpdate(String letter) &#123; Utils.showToast(getApplicationContext(), letter); &#125; &#125;); &#125; 5. 根据拼音排序5.1.1 创建PinyinUtil.javaGitHub上有可以将汉字转拼音的开源项目，TinyPinyin，pinyin4j TinyPinyin：https://github.com/promeG/TinyPinyin pinyin4j：https://github.com/belerweb/pinyin4j 汉字转拼音需要导入pinyin4j-2.5.0.jar 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class PinyinUtil &#123; /** * 根据指定的汉字字符串, 返回其对应的拼音 * @param string * @return */ public static String getPinyin(String string) &#123; // 黑-&gt; HEI 马-&gt; MA // 黑马*&amp;^* // 黑123dfasdf 马 HanyuPinyinOutputFormat format = new HanyuPinyinOutputFormat(); // 不需要音标 format.setToneType(HanyuPinyinToneType.WITHOUT_TONE); // 设置转换出大写字母 format.setCaseType(HanyuPinyinCaseType.UPPERCASE); char[] charArray = string.toCharArray(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; charArray.length; i++) &#123; char c = charArray[i]; // 如果是空格, 跳过当前循环 if(Character.isWhitespace(c))&#123; continue; &#125; if(c &gt;= -128 &amp;&amp; c &lt; 127)&#123; // 不可能是汉字, 直接拼接 sb.append(c); &#125;else &#123; try &#123; // 获取某个字符对应的拼音. 可以获取到多音字. 单-&gt;DAN, SHAN String s = PinyinHelper.toHanyuPinyinStringArray(c, format)[0]; sb.append(s); &#125; catch (BadHanyuPinyinOutputFormatCombination e) &#123; e.printStackTrace(); &#125; &#125; &#125; return sb.toString(); &#125; &#125; 5.1.2 填充ListView用于填充ListView 的姓名数组 123456789101112131415161718192021222324public class Cheeses &#123; public static final String[] NAMES = new String[] &#123; "宋江", "卢俊义", "吴用", "公孙胜", "关胜", "林冲", "秦明", "呼延灼", "花荣", "柴进", "李应", "朱仝", "鲁智 深", "武松", "董平", "张清", "杨志", "徐宁", "索超", "戴宗", "刘唐", "李逵", "史进", " 穆弘", "雷横", "李俊", "阮小二", "张横", "阮小五", " 张顺", "阮小七", "杨雄", "石秀", " 解珍", " 解宝", "燕青", "朱武", "黄信", "孙立", "宣赞", "郝思文", "韩滔", "彭玘", "单廷珪 ", "魏定国", "萧让", "裴宣", "欧鹏", "邓飞", " 燕顺", "杨林", "凌振", "蒋敬", "吕方 ", "郭盛", "安道全", "皇甫端", "王英", "扈三娘", "鲍旭", "樊瑞", "孔明", "孔亮", " 项充", "李衮", "金大坚", "马麟", "童威", "童猛", "孟康", "侯健", "陈达", "杨春", "郑天寿 ", "陶宗旺", "宋清", "乐和", "龚旺", "丁得孙", "穆春", "曹正", "宋万", "杜迁", "薛永 ", "施恩", "周通", "李忠", "杜兴", "汤隆", "邹渊", "邹润", "朱富", "朱贵", "蔡福", "蔡庆", " 李立", "李云", "焦挺", "石勇", "孙新", "顾大嫂", "张青", "孙二娘", " 王定六", "郁保四", " 白胜", "时迁", "段景柱" &#125;; &#125; 将姓名转化为HaoHan 对象 12345678910111213141516171819202122232425262728public class HaoHan implements Comparable&lt;HaoHan&gt;&#123; private String name; private String pinyin; public HaoHan(String name) &#123; super(); this.name = name; this.pinyin = PinyinUtil.getPinyin(name); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPinyin() &#123; return pinyin; &#125; public void setPinyin(String pinyin) &#123; this.pinyin = pinyin; &#125; @Override public int compareTo(HaoHan another) &#123; return this.pinyin.compareTo(another.pinyin); &#125; &#125; 第24-27 行实现Comparable 接口，用于排序操作activity_main.xml 中添加ListView 123456789101112131415161718&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/lv" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/ListView&gt; &lt;com.example.quickindexer.widget.QuickIndexBar android:id="@+id/quick_bar" android:layout_width="30dp" android:layout_height="match_parent" android:layout_alignParentRight="true" android:background="#ff0000"/&gt;&lt;/RelativeLayout&gt; 为ListView 创建数据适配器ListView 条目的布局item_person.xml,每一个条目上都加上显示首字母的TextView 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:id="@+id/tv_index" android:layout_width="match_parent" android:layout_height="40dp" android:background="#666666" android:gravity="center_vertical" android:paddingLeft="15dp" android:text="A" android:textColor="#FFFFFF" android:textSize="18sp"/&gt; &lt;TextView android:id="@+id/tv_name" android:layout_width="match_parent" android:layout_height="50dp" android:gravity="center_vertical" android:paddingLeft="15dp" android:text="宋江" android:textSize="22sp"/&gt;&lt;/LinearLayout&gt; 数据适配器代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class HaoHanAdapter extends BaseAdapter &#123; private ArrayList&lt;HaoHan&gt; persons = new ArrayList&lt;HaoHan&gt;(); private final Context context; public HaoHanAdapter(ArrayList&lt;HaoHan&gt; persons, Context context) &#123; super(); this.persons = persons; this.context = context; &#125; @Override public int getItemViewType(int position) &#123; // TODO Auto-generated method stub return super.getItemViewType(position); &#125; @Override public int getViewTypeCount() &#123; // TODO Auto-generated method stub return super.getViewTypeCount(); &#125; @Override public int getCount() &#123; return persons.size(); &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; View view; if(convertView == null)&#123; view = View.inflate(context, R.layout.item_person, null); &#125;else &#123; view = convertView; &#125; TextView tv_index = (TextView) view.findViewById(R.id.tv_index); TextView tv_name = (TextView) view.findViewById(R.id.tv_name); HaoHan haoHan = persons.get(position); // 当前首字母 String currentStr = haoHan.getPinyin().charAt(0) + ""; tv_index.setText(currentStr); tv_name.setText(haoHan.getName()); return view; &#125; @Override public Object getItem(int position) &#123; return null; &#125; @Override public long getItemId(int position) &#123; return 0; &#125; &#125; 6. 根据首字母分组6.1 修改数据适配器的getView()方法1234567891011121314151617181920212223242526272829303132333435363738@Override public View getView(int position, View convertView, ViewGroup parent) &#123; View view; if(convertView == null)&#123; view = View.inflate(context, R.layout.item_person, null); &#125;else &#123; view = convertView; &#125; TextView tv_index = (TextView) view.findViewById(R.id.tv_index); TextView tv_name = (TextView) view.findViewById(R.id.tv_name); HaoHan haoHan = persons.get(position); // 当前首字母 String currentStr = haoHan.getPinyin().charAt(0) + ""; String indexStr = null; // 如果是第一个, 直接显示 if(position == 0)&#123; indexStr = currentStr; &#125;else &#123; // 判断当前首字母和上一个条目的首字母是否一致, 不一致时候显示. String lastStr = persons.get(position - 1).getPinyin().charAt(0) + ""; if(!TextUtils.equals(lastStr, currentStr))&#123; // 不一致时候赋值indexStr indexStr = currentStr; &#125; &#125; tv_index.setVisibility(indexStr != null ? View.VISIBLE : View.GONE); tv_index.setText(currentStr); tv_name.setText(haoHan.getName()); return view; &#125; 第16-32 行如果是第一行直接显示首字母条目，如果不是第一行判断当前首字母和上一个条目的首字母是否一致, 不一致时候显示，一致则隐藏 7. ListView 和自定义控件结合修改回调接口代码，for 循环persons 集合找到与传回来的letter 值相同的索引值，ListView 直接滚动到对应位置即可1234567891011121314151617QuickIndexBar quickBar = (QuickIndexBar) findViewById(R.id.quick_bar); quickBar.setOnLetterUpdateListener(new OnLetterUpdateListener() &#123; @Override public void onLetterUpdate(String letter) &#123; Utils.showToast(MainActivity.this, letter); for (int i = 0; i &lt; persons.size(); i++) &#123; String l = persons.get(i).getPinyin().charAt(0) + ""; if(TextUtils.equals(letter, l))&#123; // 找到第一个首字母是letter 条目. lv.setSelection(i); break; &#125; &#125; &#125; &#125;); 8. 细节优化置置为当前选中的字母 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public boolean onTouchEvent(MotionEvent event) &#123; float y ; int currentIndex; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: y = event.getY(); //根据y 计算当前按下的字母索引 //例如：y = 21,cellHeight = 10 =&gt;(int) (y/cellHeight)= 2 currentIndex = (int) (y/cellHeight); if(lastIndex != currentIndex)&#123; //判断计算出来的索引值，避免数组越界 if(0 &lt;= currentIndex &amp;&amp; currentIndex &lt; LETTERS.length)&#123; String letter = LETTERS[currentIndex]; if(onLetterUpdateListener != null)&#123; onLetterUpdateListener.onLetterUpdate(letter); &#125; //记录上次按下的索引 lastIndex = currentIndex; &#125; &#125; break; case MotionEvent.ACTION_MOVE: y = event.getY(); //根据y 计算当前按下的字母索引 //例如：y = 21,cellHeight = 10 =&gt;(int) (y/cellHeight)= 2 currentIndex = (int) (y/cellHeight); //判断计算出来的索引值，避免数组越界 if(0 &lt;= currentIndex &amp;&amp; currentIndex &lt; LETTERS.length)&#123; String letter = LETTERS[currentIndex]; if(onLetterUpdateListener != null)&#123; onLetterUpdateListener.onLetterUpdate(letter); &#125; //记录上次按下的索引 lastIndex = currentIndex; &#125; break; case MotionEvent.ACTION_UP: //手指抬起时需要将记录的值设为-1，否则再次按下该字母不会弹出toast lastIndex = -1; break; default: break; &#125; //重绘一次界面，会再次调用onDraw()方法，通过判断lastIndex 的值，把按下的字母置为灰色 invalidate(); //事件已被处理，返回true return true; &#125; 第46 行为新增代码，此时lastIndex 为当前按下的字母索引，调用一次invalidate()方法，会再次调用onDraw()方法，在onDraw()方法中通过判断lastIndex 的值，把当前按下的字母置为灰色 12345678910111213141516171819202122protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //遍历字母数组，计算坐标，进行绘制 for (int i = 0; i &lt; LETTERS.length; i++) &#123; String letter = LETTERS[i]; //计算x 坐标 float x = cellWidth*0.5f - paint.measureText(letter)*0.5f; //计算y 坐标 Rect bounds = new Rect(); //获取文本的矩形区域 paint.getTextBounds(letter, 0, letter.length(), bounds); float y = cellHeight*0.5f + bounds.height()+ i*cellHeight; //把当前选中的字母置为灰色 if(lastIndex == i)&#123; paint.setColor(Color.GRAY); &#125;else&#123; paint.setColor(Color.WHITE); &#125; //绘制文本 canvas.drawText(letter, x, y, paint); &#125; &#125; 第13-18 行如果当前字母的索引是选中的，则将画笔颜色改为灰色，没有选中的将画笔改为白色 把回调方法中Toast 的显示方式改为TextView 显示 123456789101112131415161718192021222324252627282930&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/lv" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/ListView&gt; &lt;TextView android:id="@+id/tv_center" android:layout_width="160dp" android:layout_height="100dp" android:layout_centerInParent="true" android:background="@drawable/shape_tv_center" android:gravity="center" android:text="A" android:textColor="#ffffff" android:textSize="32sp" android:visibility="gone"/&gt; &lt;com.example.quickindexer.widget.QuickIndexBar android:id="@+id/quick_bar" android:layout_width="30dp" android:layout_height="match_parent" android:layout_alignParentRight="true" android:background="#ff0000"/&gt;&lt;/RelativeLayout&gt; 第11-21 行在屏幕中间添加一个提示框，默认情况为不显示 第16 行提示框的背景文件，需要在res 下新建一个drawable 文件夹，将shape_tv_center.xml 放在此文件夹下 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle" &gt; &lt;!-- android:shape="rectangle" 该形状为矩形--&gt; &lt;solid android:color="#66000000" /&gt;&lt;!--填充颜色--&gt; &lt;corners android:radius="20dp" /&gt;&lt;!--圆角半径--&gt;&lt;/shape&gt; 修改回调接口中字母提示方式 12345678910111213141516171819202122232425262728293031323334353637//屏幕中间的提示框 tvCenter = (TextView) findViewById(R.id.tv_center); quickBar.setOnLetterUpdateListener(new OnLetterUpdateListener() &#123; @Override public void onLetterUpdate(String letter) &#123; //Utils.showToast(MainActivity.this, letter); //将Toast 改成文本提示框 showLetter(letter); for (int i = 0; i &lt; persons.size(); i++) &#123; String l = persons.get(i).getPinyin().charAt(0) + ""; if(TextUtils.equals(letter, l))&#123; // 找到第一个首字母是letter 条目. lv.setSelection(i); break; &#125; &#125; &#125; &#125;); private Handler mHandler = new Handler(); /** * 在屏幕中间显示一个字母提示 * @param letter */ private void showLetter(String letter) &#123; tvCenter.setText(letter); tvCenter.setVisibility(View.VISIBLE); //移除所有的消息及任务 mHandler.removeCallbacksAndMessages(null); //用消息机制延迟隐藏提示框 mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; //2 秒后隐藏提示框 tvCenter.setVisibility(View.GONE); &#125; &#125;, 2000); &#125; 第6-8 行将Toast 提示改为文本框提示 第28-36 行用消息机制延迟隐藏文本提示框，如果快速滑动showLetter()方法会频繁调用，会有多个延迟任务在消息队列中，其实当前延迟任务之前的任务都是没有必要执行的，所以可以先移除队列中所有的任务再将本次任务添加到队列中 QuickIndexBar123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/** * 快速索引 * * 用于根据字母快速定位联系人 * @author AllenIverson * */public class QuickIndexBar extends View &#123; private static final String[] LETTERS = new String[]&#123; "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"&#125;; private static final String TAG = "TAG"; private Paint mPaint; private int cellWidth; private float cellHeight; /** * 暴露一个字母的监听 */ public interface OnLetterUpdateListener&#123; void onLetterUpdate(String letter); &#125; private OnLetterUpdateListener listener; public OnLetterUpdateListener getListener() &#123; return listener; &#125; /** * 设置字母更新监听 * @param listener */ public void setListener(OnLetterUpdateListener listener) &#123; this.listener = listener; &#125; public QuickIndexBar(Context context) &#123; this(context, null); &#125; public QuickIndexBar(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public QuickIndexBar(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.WHITE); mPaint.setTypeface(Typeface.DEFAULT_BOLD); &#125; @Override protected void onDraw(Canvas canvas) &#123; for (int i = 0; i &lt; LETTERS.length; i++) &#123; String text = LETTERS[i]; // 计算坐标 int x = (int) (cellWidth / 2.0f - mPaint.measureText(text) / 2.0f); // 获取文本的高度 Rect bounds = new Rect();// 矩形 mPaint.getTextBounds(text, 0, text.length(), bounds); int textHeight = bounds.height(); int y = (int) (cellHeight / 2.0f + textHeight / 2.0f + i * cellHeight); // 根据按下的字母, 设置画笔颜色 mPaint.setColor(touchIndex == i ? Color.GRAY : Color.WHITE); // 绘制文本A-Z canvas.drawText(text, x, y, mPaint); &#125; &#125; int touchIndex = -1; @Override public boolean onTouchEvent(MotionEvent event) &#123; int index = -1; switch (MotionEventCompat.getActionMasked(event)) &#123; case MotionEvent.ACTION_DOWN: // 获取当前触摸到的字母索引 index = (int) (event.getY() / cellHeight); if(index &gt;= 0 &amp;&amp; index &lt; LETTERS.length)&#123; // 判断是否跟上一次触摸到的一样 if(index != touchIndex) &#123; if(listener != null)&#123; listener.onLetterUpdate(LETTERS[index]); &#125; Log.d(TAG, "onTouchEvent: " + LETTERS[index]); touchIndex = index; &#125; &#125; break; case MotionEvent.ACTION_MOVE: index = (int) (event.getY() / cellHeight); if(index &gt;= 0 &amp;&amp; index &lt; LETTERS.length)&#123; // 判断是否跟上一次触摸到的一样 if(index != touchIndex)&#123; if(listener != null)&#123; listener.onLetterUpdate(LETTERS[index]); &#125; Log.d(TAG, "onTouchEvent: " + LETTERS[index]); touchIndex = index; &#125; &#125; break; case MotionEvent.ACTION_UP: touchIndex = -1; break; default: break; &#125; invalidate(); return true; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); // 获取单元格的宽和高 cellWidth = getMeasuredWidth(); int mHeight = getMeasuredHeight(); cellHeight = mHeight * 1.0f / LETTERS.length; &#125;&#125; MainActivity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends Activity &#123; private ListView mMainList; private ArrayList&lt;Person&gt; persons; private TextView tv_center; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); QuickIndexBar bar = (QuickIndexBar) findViewById(R.id.bar); // 设置监听 bar.setListener(new OnLetterUpdateListener() &#123; @Override public void onLetterUpdate(String letter) &#123;// Utils.showToast(getApplicationContext(), letter); showLetter(letter); // 根据字母定位ListView, 找到集合中第一个以letter为拼音首字母的对象,得到索引 for (int i = 0; i &lt; persons.size(); i++) &#123; Person person = persons.get(i); String l = person.getPinyin().charAt(0) + ""; if(TextUtils.equals(letter, l))&#123; // 匹配成功 mMainList.setSelection(i); break; &#125; &#125; &#125; &#125;); mMainList = (ListView) findViewById(R.id.lv_main); persons = new ArrayList&lt;Person&gt;(); // 填充数据 , 排序 fillAndSortData(persons); mMainList.setAdapter(new HaoHanAdapter(MainActivity.this , persons)); tv_center = (TextView) findViewById(R.id.tv_center); &#125; private Handler mHandler = new Handler(); /** * 显示字母 * @param letter */ protected void showLetter(String letter) &#123; tv_center.setVisibility(View.VISIBLE); tv_center.setText(letter); mHandler.removeCallbacksAndMessages(null); mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; tv_center.setVisibility(View.GONE); &#125; &#125;, 2000); &#125; private void fillAndSortData(ArrayList&lt;Person&gt; persons) &#123; // 填充数据 for (int i = 0; i &lt; Cheeses.NAMES.length; i++) &#123; String name = Cheeses.NAMES[i]; persons.add(new Person(name)); &#125; // 进行排序 Collections.sort(persons); &#125;&#125; HaoHanAdapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class HaoHanAdapter extends BaseAdapter &#123; private Context mContext; private ArrayList&lt;Person&gt; persons; public HaoHanAdapter(Context mContext, ArrayList&lt;Person&gt; persons) &#123; this.mContext = mContext; this.persons = persons; &#125; @Override public int getCount() &#123; // TODO Auto-generated method stub return persons.size(); &#125; @Override public Object getItem(int position) &#123; return persons.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; View view = convertView; if(convertView == null)&#123; view = view.inflate(mContext, R.layout.item_list, null); &#125; ViewHolder mViewHolder = ViewHolder.getHolder(view); Person p = persons.get(position); String str = null; String currentLetter = p.getPinyin().charAt(0) + ""; // 根据上一个首字母,决定当前是否显示字母 if(position == 0)&#123; str = currentLetter; &#125;else &#123; // 上一个人的拼音的首字母 String preLetter = persons.get(position - 1).getPinyin().charAt(0) + ""; if(!TextUtils.equals(preLetter, currentLetter))&#123; str = currentLetter; &#125; &#125; // 根据str是否为空,决定是否显示索引栏 mViewHolder.mIndex.setVisibility(str == null ? View.GONE : View.VISIBLE); mViewHolder.mIndex.setText(currentLetter); mViewHolder.mName.setText(p.getName()); return view; &#125; static class ViewHolder &#123; TextView mIndex; TextView mName; public static ViewHolder getHolder(View view) &#123; Object tag = view.getTag(); if(tag != null)&#123; return (ViewHolder)tag; &#125;else &#123; ViewHolder viewHolder = new ViewHolder(); viewHolder.mIndex = (TextView) view.findViewById(R.id.tv_index); viewHolder.mName = (TextView) view.findViewById(R.id.tv_name); view.setTag(viewHolder); return viewHolder; &#125; &#125; &#125;&#125; FancyListIndexer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506public class FancyIndexer extends View &#123; public interface OnTouchLetterChangedListener &#123; public void onTouchLetterChanged(String s); &#125; private static final String TAG = "FancyIndexer"; ///////////////////////////////////////////////////////////////////////// //Properties // 向右偏移多少画字符， default 30 float mWidthOffset = 30.0f; // 最小字体大小 int mMinFontSize = 24; // 最大字体大小 int mMaxFontSize = 48; // 提示字体大小 int mTipFontSize = 52; // 提示字符的额外偏移 float mAdditionalTipOffset = 20.0f; // 贝塞尔曲线控制的高度 float mMaxBezierHeight = 150.0f; // 贝塞尔曲线单侧宽度 float mMaxBezierWidth = 240.0f; // 贝塞尔曲线单侧模拟线量 int mMaxBezierLines = 32; // 列表字符颜色 int mFontColor = 0xffffffff; // 提示字符颜色// int mTipFontColor = 0xff3399ff; int mTipFontColor = 0xffd33e48; ///////////////////////////////////////////////////////////////////////// private OnTouchLetterChangedListener mListener; private final String[] ConstChar = &#123;"#","A","B","C","D","E","F","G","H","I","J","K","L" ,"M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"&#125;; int mChooseIndex = -1; Paint mPaint = new Paint(); PointF mTouch = new PointF(); PointF[] mBezier1; PointF[] mBezier2; float mLastOffset[] = new float[ConstChar.length]; // 记录每一个字母的x方向偏移量, 数字&lt;=0 PointF mLastFucusPostion = new PointF(); Scroller mScroller; boolean mAnimating = false; float mAnimationOffset; boolean mHideAnimation = false; int mAlpha = 255; Handler mHideWaitingHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; if( msg.what == 1 ) &#123;// mScroller.startScroll(0, 0, 255, 0, 1000); mHideAnimation = true; mAnimating = false; FancyIndexer.this.invalidate(); return; &#125; super.handleMessage(msg); &#125; &#125;; public FancyIndexer(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); initData(context, attrs); &#125; public FancyIndexer(Context context, AttributeSet attrs) &#123; super(context, attrs); initData(context, attrs); &#125; public FancyIndexer(Context context) &#123; super(context); initData(null, null); &#125; private void initData(Context context, AttributeSet attrs) &#123; if( context != null &amp;&amp; attrs != null ) &#123; TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.FancyIndexer, 0, 0); mWidthOffset = a.getDimension(R.styleable.FancyIndexer_widthOffset, mWidthOffset); mMinFontSize = a.getInteger(R.styleable.FancyIndexer_minFontSize, mMinFontSize); mMaxFontSize = a.getInteger(R.styleable.FancyIndexer_maxFontSize, mMaxFontSize); mTipFontSize = a.getInteger(R.styleable.FancyIndexer_tipFontSize, mTipFontSize); mMaxBezierHeight = a.getDimension(R.styleable.FancyIndexer_maxBezierHeight, mMaxBezierHeight); mMaxBezierWidth = a.getDimension(R.styleable.FancyIndexer_maxBezierWidth, mMaxBezierWidth); mMaxBezierLines = a.getInteger(R.styleable.FancyIndexer_maxBezierLines, mMaxBezierLines); mAdditionalTipOffset = a.getDimension(R.styleable.FancyIndexer_additionalTipOffset, mAdditionalTipOffset); mFontColor = a.getColor(R.styleable.FancyIndexer_fontColor, mFontColor); mTipFontColor = a.getColor(R.styleable.FancyIndexer_tipFontColor, mTipFontColor); a.recycle(); &#125; mScroller = new Scroller( getContext() ); mTouch.x = 0; mTouch.y = -10*mMaxBezierWidth; mBezier1 = new PointF[mMaxBezierLines]; mBezier2 = new PointF[mMaxBezierLines]; calculateBezierPoints(); &#125; @Override protected void onDraw(Canvas canvas) &#123; // 控件宽高 int height = getHeight(); int width = getWidth(); // 单个字母高度 float singleHeight = height / (float)ConstChar.length; int workHeight = 0; if( mAlpha == 0 ) return; mPaint.reset(); int saveCount = 0; if( mHideAnimation ) &#123; saveCount = canvas.save(); canvas.saveLayerAlpha( 0, 0, width, height, mAlpha, Canvas.ALL_SAVE_FLAG ); &#125; for(int i=0;i&lt;ConstChar.length;i++) &#123; mPaint.setColor(mFontColor); mPaint.setAntiAlias(true); float xPos = width - mWidthOffset; float yPos = workHeight + singleHeight/2; //float adjustX = adjustXPos( yPos, i == mChooseIndex ); // 根据当前字母y的位置计算得到字体大小 int fontSize = adjustFontSize(i, yPos ); mPaint.setTextSize(fontSize); // 添加一个字母的高度 workHeight += singleHeight; // 绘制字母 drawTextInCenter(canvas, ConstChar[i], xPos + ajustXPosAnimation(i, yPos ) , yPos ); // 绘制的字母和当前触摸到的一致, 绘制红色被选中字母 if(i == mChooseIndex) &#123; mPaint.setColor( mTipFontColor ); mPaint.setFakeBoldText(true); mPaint.setTextSize( mTipFontSize ); yPos = mTouch.y; float pos = 0; if( mAnimating || mHideAnimation ) &#123; pos = mLastFucusPostion.x; yPos = mLastFucusPostion.y; &#125; else &#123; pos = xPos + ajustXPosAnimation(i, yPos ) - mAdditionalTipOffset; mLastFucusPostion.x = pos; mLastFucusPostion.y = yPos; &#125; drawTextInCenter(canvas, ConstChar[i], pos, yPos );// mPaint.setStrokeWidth(5);// canvas.drawLine(0, yPos, width, yPos, mPaint); &#125; mPaint.reset(); &#125; if( mHideAnimation ) &#123; canvas.restoreToCount(saveCount); &#125; &#125; /** * @param canvas 画板 * @param string 被绘制的字母 * @param xCenter 字母的中心x方向位置 * @param yCenter 字母的中心y方向位置 */ private void drawTextInCenter(Canvas canvas, String string, float xCenter, float yCenter) &#123; FontMetrics fm = mPaint.getFontMetrics(); //float fontWidth = paint.measureText(string); float fontHeight = mPaint.getFontSpacing(); float drawY = yCenter + fontHeight/2 - fm.descent; if( drawY &lt; -fm.ascent -fm.descent ) drawY = -fm.ascent -fm.descent; if( drawY &gt; getHeight() ) drawY = getHeight() ; mPaint.setTextAlign(Align.CENTER); canvas.drawText(string, xCenter, drawY, mPaint); &#125; private int adjustFontSize(int i, float yPos ) &#123; // 根据水平方向偏移量计算出一个放大的字号 float adjustX = Math.abs(ajustXPosAnimation(i, yPos )); int adjustSize =(int)( (mMaxFontSize - mMinFontSize ) * adjustX / (float)mMaxBezierHeight) + mMinFontSize; return adjustSize; &#125; /** * x 方向的向左偏移量 * @param i 当前字母的索引 * @param yPos y方向的初始位置 * @return */ private float ajustXPosAnimation (int i, float yPos ) &#123; float offset ; if( this.mAnimating || this.mHideAnimation ) &#123; // 正在动画中或在做隐藏动画 offset = mLastOffset[i]; if( offset !=0.0f ) &#123; offset += this.mAnimationOffset; if( offset &gt; 0) offset = 0; &#125; &#125; else &#123; // 根据当前字母y方向位置, 计算水平方向偏移量 offset = adjustXPos( yPos ); // 当前触摸的x方向位置 float xPos = mTouch.x ; float width = getWidth() - mWidthOffset; width = width - 60; // 字母绘制时向左偏移量 进行修正, offset需要是&lt;=0的值 if( offset != 0.0f &amp;&amp; xPos &gt; width ) offset += ( xPos - width ); if( offset &gt; 0) offset = 0; mLastOffset[i] = offset; &#125; return offset; &#125; private float adjustXPos(float yPos ) &#123; float dis = yPos - mTouch.y; // 字母y方向位置和触摸时y值坐标的差值, 距离越小, 得到的水平方向偏差越大 if( dis &gt; -mMaxBezierWidth &amp;&amp; dis &lt; mMaxBezierWidth ) &#123; // 在2个贝赛尔曲线宽度范围以内 (一个贝赛尔曲线宽度是指一个山峰的一边) // 第一段 曲线 if( dis &gt; mMaxBezierWidth/4 ) &#123; for( int i = mMaxBezierLines-1; i&gt;0 ; i-- ) &#123; // 从下到上, 逐个计算 if( dis == -mBezier1[i].y ) // 落在点上 return mBezier1[i].x; // 如果距离dis落在两个贝塞尔曲线模拟点之间, 通过三角函数计算得到当前dis对应的x方向偏移量 if( dis &gt; -mBezier1[i].y &amp;&amp; dis &lt; -mBezier1[i-1].y ) &#123; return (dis + mBezier1[i].y) * ( mBezier1[i-1].x - mBezier1[i].x ) / ( -mBezier1[i-1].y + mBezier1[i].y ) + mBezier1[i].x; &#125; &#125; return mBezier1[0].x; &#125; // 第三段 曲线, 和第一段曲线对称 if( dis &lt; -mMaxBezierWidth/4 ) &#123; for( int i = 0; i&lt; mMaxBezierLines-1; i++ ) &#123; // 从上到下 if( dis == mBezier1[i].y ) // 落在点上 return mBezier1[i].x; // 如果距离dis落在两个贝塞尔曲线模拟点之间, 通过三角函数计算得到当前dis对应的x方向偏移量 if( dis &gt; mBezier1[i].y &amp;&amp; dis &lt; mBezier1[i+1].y ) &#123; return (dis - mBezier1[i].y )* (mBezier1[i+1].x - mBezier1[i].x ) / ( mBezier1[i+1].y - mBezier1[i].y ) + mBezier1[i].x; &#125; &#125; return mBezier1[mMaxBezierLines-1].x; &#125; // 第二段 峰顶曲线 for( int i = 0; i&lt; mMaxBezierLines-1; i++ ) &#123; if( dis == mBezier2[i].y ) return mBezier2[i].x; // 如果距离dis落在两个贝塞尔曲线模拟点之间, 通过三角函数计算得到当前dis对应的x方向偏移量 if( dis &gt; mBezier2[i].y &amp;&amp; dis &lt; mBezier2[i+1].y ) &#123; return ( dis - mBezier2[i].y) * ( mBezier2[i+1].x - mBezier2[i].x ) / (mBezier2[i+1].y - mBezier2[i].y ) + mBezier2[i].x; &#125; &#125; return mBezier2[mMaxBezierLines-1].x; &#125; return 0.0f; &#125; @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; final int action = event.getAction(); final float y = event.getY(); final int oldmChooseIndex = mChooseIndex; final OnTouchLetterChangedListener listener = mListener; final int c = (int) (y/getHeight()*ConstChar.length); switch (action) &#123; case MotionEvent.ACTION_DOWN: if( this.getWidth() &gt; mWidthOffset ) &#123; if ( event.getX() &lt; this.getWidth() - mWidthOffset ) return false; &#125; mHideWaitingHandler.removeMessages(1); mScroller.abortAnimation(); mAnimating = false; mHideAnimation = false; mAlpha = 255; mTouch.x = event.getX(); mTouch.y = event.getY(); if(oldmChooseIndex != c &amp;&amp; listener != null)&#123; if(c &gt; 0 &amp;&amp; c&lt; ConstChar.length)&#123; listener.onTouchLetterChanged(ConstChar[c]); mChooseIndex = c; &#125; &#125; invalidate(); break; case MotionEvent.ACTION_MOVE: mTouch.x = event.getX(); mTouch.y = event.getY(); invalidate(); if(oldmChooseIndex != c &amp;&amp; listener != null)&#123; if(c &gt;= 0 &amp;&amp; c&lt; ConstChar.length)&#123; listener.onTouchLetterChanged(ConstChar[c]); mChooseIndex = c; &#125; &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: mTouch.x = event.getX(); mTouch.y = event.getY(); //this.mChooseIndex = -1; mScroller.startScroll(0, 0, (int)mMaxBezierHeight, 0, 2000); mAnimating = true; postInvalidate(); break; &#125; return true; &#125; @Override public void computeScroll() &#123; super.computeScroll(); if (mScroller.computeScrollOffset()) &#123; if( mAnimating ) &#123; float x = mScroller.getCurrX(); mAnimationOffset = x; &#125; else if( mHideAnimation ) &#123; mAlpha = 255 - (int) mScroller.getCurrX(); &#125; invalidate(); &#125; else if( mScroller.isFinished() ) &#123; if( mAnimating ) &#123; mHideWaitingHandler.sendEmptyMessage(1); &#125; else if( mHideAnimation ) &#123; mHideAnimation = false; this.mChooseIndex = -1; mTouch.x = -10000; mTouch.y = -10000; &#125; &#125; &#125; public void setOnTouchLetterChangedListener( OnTouchLetterChangedListener listener) &#123; this.mListener = listener; &#125; /** * 计算出所有贝塞尔曲线上的点 * 个数为 mMaxBezierLines * 2 = 64 */ private void calculateBezierPoints() &#123; PointF mStart = new PointF(); // 开始点 PointF mEnd = new PointF(); // 结束点 PointF mControl = new PointF(); // 控制点 // 计算第一段红色部分 贝赛尔曲线的点 // 开始点 mStart.x = 0.0f; mStart.y = -mMaxBezierWidth; // 控制点 mControl.x = 0.0f; mControl.y = -mMaxBezierWidth/2; // 结束点 mEnd.x = - mMaxBezierHeight / 2; mEnd.y = - mMaxBezierWidth / 4; mBezier1[0] = new PointF(); mBezier1[mMaxBezierLines-1] = new PointF(); mBezier1[0].set(mStart); mBezier1[mMaxBezierLines-1].set(mEnd); for( int i = 1; i&lt; mMaxBezierLines -1; i++ ) &#123; mBezier1[i] = new PointF(); mBezier1[i].x = calculateBezier( mStart.x, mEnd.x, mControl.x, i / (float) mMaxBezierLines ); mBezier1[i].y = calculateBezier( mStart.y, mEnd.y, mControl.y, i / (float) mMaxBezierLines ); &#125; // 计算第二段蓝色部分 贝赛尔曲线的点 mStart.y = -mMaxBezierWidth / 4; mStart.x = -mMaxBezierHeight / 2; mControl.y = 0.0f; mControl.x = -mMaxBezierHeight; mEnd.y = mMaxBezierWidth / 4; mEnd.x = -mMaxBezierHeight / 2; mBezier2[0] = new PointF(); mBezier2[mMaxBezierLines-1] = new PointF(); mBezier2[0].set(mStart); mBezier2[mMaxBezierLines-1].set(mEnd); for( int i = 1; i&lt; mMaxBezierLines -1 ; i++ ) &#123; mBezier2[i]= new PointF(); mBezier2[i].x = calculateBezier( mStart.x, mEnd.x, mControl.x, i / (float) mMaxBezierLines ); mBezier2[i].y = calculateBezier( mStart.y, mEnd.y, mControl.y, i / (float) mMaxBezierLines ); &#125; &#125; /** * 贝塞尔曲线核心算法 * @param start * @param end * @param control * @param val * @return * 公式及动图, 维基百科: https://en.wikipedia.org/wiki/B%C3%A9zier_curve * 中文可参考此网站: http://blog.csdn.net/likendsl/article/details/7852658 * */ private float calculateBezier(float start, float end, float control, float val) &#123; float t = val; float s = 1-t; float ret = start * s * s + 2 * control * s * t + end * t * t; return ret; &#125; &#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>自定义控件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oauth机制]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FOauth%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. 登录1.1 javaweb中如何去维持登录状态 登录后信息放入 session中 页面内验证session中是否有登录信息 如果有，不需要再次登录 如果没有，跳转登录页面 如果登录后点击注销，删除session中登录信息，并清除页面缓存(必要的) 1.2 javaweb中哪些情况我们的session会过期 过期–&gt;很长时间没有去访问网站 主动关闭–&gt;用户注销 切换浏览器 1.3 手机端如何维持登录状态通过sessionKey/tokenKey 登录协议 ###1.3.1 sessionKey/tokenKey哪里来?登录成功之后,后台返回 ###1.3.2 sessionKey/tokenKey生成有什么规则?后台返回的，按照一定规则生成的(比如可以随机数生成一个24位以上的字符串) ###1.3.3 登录成功返回的sessionkey/tokenKey存到哪里?保存到sp中就可以了 ###1.3.4 sessionkey/tokenKey使用场景有些协议需要用到登录信息，就需要看登录状态，就需要用到sessionkey/tokenKey，比如支付协议 ###1.3.5 如何使用sessionkey/tokenKey?需要登录状态，判断sp中是否有sessionkey/tokenKey? 有：那当前是已登录状态，就把个人信息和sessionkey/tokenKey上传到服务器; 没有：跳到登录界面，让用户登录 ###1.3.6 谁去判断sessionkey/tokenKey是否过期?任何协议把sessionkey/tokenKey传到服务器.服务器会判断sessionkey/tokenKey是否过期? 过期：告知客户端，登录状态已过期，需要重新登录 未过期：可以使用当前的登录信息，继续走逻辑###1.3.7 为什么判断是否过期需要后台做?因为前端可以修改当前时间?###1.3.8 sessionkey/tokenKey多久过期?这个具体看公司###1.3.9 后台如何去判断sessionkey/tokenKey是否过期？ 分配sessionkey/tokenKey的时候记录时间 判断是否存在对应的sessionKey：如果不存在，是不是直接就是无效. 某一时刻，用户判断sessionkey/tokenKey是否过期的时候，拿着当前时间和sessionkey/tokenKey分配时间做比较 大于指定时间：过期 没有大于指定时间：未过期 ##2. logindemo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class MainActivity extends Activity &#123; private Button mLogin; private SPUtil mSpUtil; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mLogin = (Button) findViewById(R.id.login); mSpUtil = new SPUtil(MainActivity.this); mLogin.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO try &#123; DefaultHttpClient httpClient = new DefaultHttpClient(); HttpGet get = new HttpGet( "http://mobileif.maizuo.com/user/login?" + "username=18682036558&amp;" + "password=96e79218965eb72c92a549dd5a330112&amp;" + "type=1&amp;" + "userType=1&amp;" + "appType=31&amp;" + "agentID=0-maizuo&amp;" + "loginType=1&amp;" + "clientID=31&amp;" + "channelID=31"); HttpResponse response = httpClient.execute(get); if (response.getStatusLine().getStatusCode() == 200) &#123; HttpEntity entity = response.getEntity(); String result = EntityUtils.toString(entity); System.out.println("result :" + result); // 得到sessionKey保存到sp中 JSONObject jsonObject = new JSONObject(result); String sessionKey = jsonObject.optString("sessionKey"); // 保存到sp中 mSpUtil.putString("sessionKey", sessionKey); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125;); findViewById(R.id.pay).setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // 这个地方需要使用sessionKey,对应的一般操作,首先判断是否存在 String spSessionKey = mSpUtil.getString("sessionKey", ""); if ("".equals(spSessionKey)) &#123; Toast.makeText(getApplicationContext(), "请先登录", 0).show(); return ; &#125; //接着就是把对应的sessionKey和userid和payinfo上传给服务器 &#125; &#125;); &#125;&#125; 返回数据 ##3. 绘流程图说明sessionKey的使用以确认支付协议为例 ##验证码登录/注册_简单流程1、提交手机号 2、下发短信验证码 3、提交验证码 验证码后台过期逻辑 ##验证码登录/注册_流程描述 用户填写手机号，点击发送验证码，发送请求把手机号传到server server调用短信平台的接口知道发送内容，发送对象，完成短信的发送 用户收到短信，得到验证码，填写验证码，发送请求把手机号，验证码上传到server server判断我们的验证码是否正确，验证是否过期，根据不同的判断，返回不同的结果 ##share sdk 短信验证码理解 #Android登录注册模块解决方案原文链接：http://blog.csdn.net/wwj_748/article/details/50575642 几乎每个app都会有登录注册的功能，可以看看笔者开发的『南方周末新闻阅读器』，登录、手机注册、忘记密码这些入口，这些功能在app中要如何来实现呢？这个模块看似很简单，但要做好就需要考虑很多细节，比如对用户的输入的容错，操作的提示文案的设定，登录成功保存用户信息等等。 业务逻辑描述上一节的流程图已经很清晰的展现了登录注册的流程，这里继续用文字说明一下： 点击进入个人中心或者需要用户登录状态的操作，先判断用户是否已经登录。 如果已经登录，则继续后面的业务，否则，跳转到登录页面进行登录。 如果已经有账号，则可以直接登录，或者可以直接选择第三方平台授权登录。 如果未注册账号，则需要先进行账号注册，注册成功后再登录；也可以不注册账号，通过第三方平台授权进行登录。 如果有账号，但忘记密码，则需要进行重置密码，否则直接登录。 具体实现登录可以使用账号登录，现在的app基本上都是手机号码登录，注册的时候也是一个手机对应一个账号，通过发送验证码进行验证；用户也可以选择第三方平台进行登录，一般会提供微信、QQ、新浪微博这样的主流社交平台进行授权登录，这里使用了友盟的SDK进行实现。 登录注册的解决方案，已经做成一个Demo，大家在实际开发的时候可以参考着根据自身的业务进行调整，但基本上不会差太多，第三方登录、验证码这个都可以选用第三方服务来实现 示例代码：LoginActivity.Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355package com.devilwwj.loginandregister; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.text.TextUtils; import android.text.method.HideReturnsTransformationMethod; import android.text.method.PasswordTransformationMethod; import android.view.KeyEvent; import android.view.View; import android.view.inputmethod.EditorInfo; import android.widget.TextView; import android.widget.Toast; import com.devilwwj.loginandregister.global.AppConstants; import com.devilwwj.loginandregister.utils.LogUtils; import com.devilwwj.loginandregister.utils.ProgressDialogUtils; import com.devilwwj.loginandregister.utils.RegexUtils; import com.devilwwj.loginandregister.utils.ShareUtils; import com.devilwwj.loginandregister.utils.SpUtils; import com.devilwwj.loginandregister.utils.ToastUtils; import com.devilwwj.loginandregister.utils.Utils; import com.devilwwj.loginandregister.views.CleanEditText; import com.umeng.socialize.bean.SHARE_MEDIA; import com.umeng.socialize.controller.UMServiceFactory; import com.umeng.socialize.controller.UMSocialService; import com.umeng.socialize.controller.listener.SocializeListeners.UMAuthListener; import com.umeng.socialize.controller.listener.SocializeListeners.UMDataListener; import com.umeng.socialize.exception.SocializeException; import java.util.Map; import static android.view.View.OnClickListener; /** * @desc 登录界面 * Created by devilwwj on 16/1/24. */ public class LoginActivity extends Activity implements OnClickListener &#123; private static final String TAG = "loginActivity"; private static final int REQUEST_CODE_TO_REGISTER = 0x001; // 界面控件 private CleanEditText accountEdit; private CleanEditText passwordEdit; // 第三方平台获取的访问token，有效时间，uid private String accessToken; private String expires_in; private String uid; private String sns; // 整个平台的Controller，负责管理整个SDK的配置、操作等处理 private UMSocialService mController = UMServiceFactory .getUMSocialService(AppConstants.DESCRIPTOR); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); initViews(); // 配置分享平台 ShareUtils.configPlatforms(this); &#125; /** * 初始化视图 */ private void initViews() &#123; accountEdit = (CleanEditText) this.findViewById(R.id.et_email_phone); accountEdit.setImeOptions(EditorInfo.IME_ACTION_NEXT); accountEdit.setTransformationMethod(HideReturnsTransformationMethod .getInstance()); passwordEdit = (CleanEditText) this.findViewById(R.id.et_password); passwordEdit.setImeOptions(EditorInfo.IME_ACTION_DONE); passwordEdit.setImeOptions(EditorInfo.IME_ACTION_GO); passwordEdit.setTransformationMethod(PasswordTransformationMethod .getInstance()); passwordEdit.setOnEditorActionListener(new TextView.OnEditorActionListener() &#123; @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; if (actionId == EditorInfo.IME_ACTION_DONE || actionId == EditorInfo.IME_ACTION_GO) &#123; clickLogin(); &#125; return false; &#125; &#125;); &#125; private void clickLogin() &#123; String account = accountEdit.getText().toString(); String password = passwordEdit.getText().toString(); if (checkInput(account, password)) &#123; // TODO: 请求服务器登录账号 &#125; &#125; /** * 检查输入 * * @param account * @param password * @return */ public boolean checkInput(String account, String password) &#123; // 账号为空时提示 if (account == null || account.trim().equals("")) &#123; Toast.makeText(this, R.string.tip_account_empty, Toast.LENGTH_LONG) .show(); &#125; else &#123; // 账号不匹配手机号格式（11位数字且以1开头） if ( !RegexUtils.checkMobile(account)) &#123; Toast.makeText(this, R.string.tip_account_regex_not_right, Toast.LENGTH_LONG).show(); &#125; else if (password == null || password.trim().equals("")) &#123; Toast.makeText(this, R.string.tip_password_can_not_be_empty, Toast.LENGTH_LONG).show(); &#125; else &#123; return true; &#125; &#125; return false; &#125; @Override public void onClick(View v) &#123; Intent intent = null; switch (v.getId()) &#123; case R.id.iv_cancel: finish(); break; case R.id.btn_login: clickLogin(); break; case R.id.iv_wechat: clickLoginWexin(); break; case R.id.iv_qq: clickLoginQQ(); break; case R.id.iv_sina: loginThirdPlatform(SHARE_MEDIA.SINA); break; case R.id.tv_create_account: enterRegister(); break; case R.id.tv_forget_password: enterForgetPwd(); break; default: break; &#125; &#125; /** * 点击使用QQ快速登录 */ private void clickLoginQQ() &#123; if (!Utils.isQQClientAvailable(this)) &#123; ToastUtils.showShort(LoginActivity.this, getString(R.string.no_install_qq)); &#125; else &#123; loginThirdPlatform(SHARE_MEDIA.QZONE); &#125; &#125; /** * 点击使用微信登录 */ private void clickLoginWexin() &#123; if (!Utils.isWeixinAvilible(this)) &#123; ToastUtils.showShort(LoginActivity.this, getString(R.string.no_install_wechat)); &#125; else &#123; loginThirdPlatform(SHARE_MEDIA.WEIXIN); &#125; &#125; /** * 跳转到忘记密码 */ private void enterForgetPwd() &#123; Intent intent = new Intent(this, ForgetPasswordActivity.class); startActivity(intent); &#125; /** * 跳转到注册页面 */ private void enterRegister() &#123; Intent intent = new Intent(this, SignUpActivity.class); startActivityForResult(intent, REQUEST_CODE_TO_REGISTER); &#125; /** * 授权。如果授权成功，则获取用户信息 * * @param platform */ private void loginThirdPlatform(final SHARE_MEDIA platform) &#123; mController.doOauthVerify(LoginActivity.this, platform, new UMAuthListener() &#123; @Override public void onStart(SHARE_MEDIA platform) &#123; LogUtils.i(TAG, "onStart------" + Thread.currentThread().getId()); ProgressDialogUtils.getInstance().show( LoginActivity.this, getString(R.string.tip_begin_oauth)); &#125; @Override public void onError(SocializeException e, SHARE_MEDIA platform) &#123; LogUtils.i(TAG, "onError------" + Thread.currentThread().getId()); ToastUtils.showShort(LoginActivity.this, getString(R.string.oauth_fail)); ProgressDialogUtils.getInstance().dismiss(); &#125; @Override public void onComplete(Bundle value, SHARE_MEDIA platform) &#123; LogUtils.i(TAG, "onComplete------" + value.toString()); if (platform == SHARE_MEDIA.SINA) &#123; accessToken = value.getString("access_key"); &#125; else &#123; accessToken = value.getString("access_token"); &#125; expires_in = value.getString("expires_in"); // 获取uid uid = value.getString(AppConstants.UID); if (value != null &amp;&amp; !TextUtils.isEmpty(uid)) &#123; // uid不为空，获取用户信息 getUserInfo(platform); &#125; else &#123; ToastUtils.showShort(LoginActivity.this, getString(R.string.oauth_fail)); &#125; &#125; @Override public void onCancel(SHARE_MEDIA platform) &#123; LogUtils.i(TAG, "onCancel------" + Thread.currentThread().getId()); ToastUtils.showShort(LoginActivity.this, getString(R.string.oauth_cancle)); ProgressDialogUtils.getInstance().dismiss(); &#125; &#125;); &#125; /** * 获取用户信息 * * @param platform */ private void getUserInfo(final SHARE_MEDIA platform) &#123; mController.getPlatformInfo(LoginActivity.this, platform, new UMDataListener() &#123; @Override public void onStart() &#123; // 开始获取 LogUtils.i("getUserInfo", "onStart------"); ProgressDialogUtils.getInstance().dismiss(); ProgressDialogUtils.getInstance().show( LoginActivity.this, "正在请求..."); &#125; @Override public void onComplete(int status, Map info) &#123; try &#123; String sns_id = ""; String sns_avatar = ""; String sns_loginname = ""; if (info != null &amp;&amp; info.size() != 0) &#123; LogUtils.i("third login", info.toString()); if (platform == SHARE_MEDIA.SINA) &#123; // 新浪微博 sns = AppConstants.SINA; if (info.get(AppConstants.UID) != null) &#123; sns_id = info.get(AppConstants.UID) .toString(); &#125; if (info.get(AppConstants.PROFILE_IMAGE_URL) != null) &#123; sns_avatar = info .get(AppConstants.PROFILE_IMAGE_URL) .toString(); &#125; if (info.get(AppConstants.SCREEN_NAME) != null) &#123; sns_loginname = info.get( AppConstants.SCREEN_NAME) .toString(); &#125; &#125; else if (platform == SHARE_MEDIA.QZONE) &#123; // QQ sns = AppConstants.QQ; if (info.get(AppConstants.UID) == null) &#123; ToastUtils .showShort( LoginActivity.this, getString(R.string.oauth_fail)); return; &#125; sns_id = info.get(AppConstants.UID) .toString(); sns_avatar = info.get( AppConstants.PROFILE_IMAGE_URL) .toString(); sns_loginname = info.get( AppConstants.SCREEN_NAME) .toString(); &#125; else if (platform == SHARE_MEDIA.WEIXIN) &#123; // 微信 sns = AppConstants.WECHAT; sns_id = info.get(AppConstants.OPENID) .toString(); sns_avatar = info.get( AppConstants.HEADIMG_URL) .toString(); sns_loginname = info.get( AppConstants.NICKNAME).toString(); &#125; // 这里直接保存第三方返回来的用户信息 SpUtils.putBoolean(LoginActivity.this, AppConstants.THIRD_LOGIN, true); LogUtils.e("info", sns + "," + sns_id + "," + sns_loginname); // TODO: 这里执行第三方连接(绑定服务器账号） &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; 示例代码：SignUpActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package com.devilwwj.loginandregister; import android.app.Activity; import android.os.Bundle; import android.text.TextUtils; import android.util.Log; import android.view.KeyEvent; import android.view.View; import android.view.View.OnClickListener; import android.view.inputmethod.EditorInfo; import android.widget.Button; import android.widget.TextView; import android.widget.TextView.OnEditorActionListener; import com.devilwwj.loginandregister.utils.RegexUtils; import com.devilwwj.loginandregister.utils.ToastUtils; import com.devilwwj.loginandregister.utils.VerifyCodeManager; import com.devilwwj.loginandregister.views.CleanEditText; /** * @desc 注册界面 * 功能描述：一般会使用手机登录，通过获取手机验证码，跟服务器交互完成注册 * Created by devilwwj on 16/1/24. */ public class SignUpActivity extends Activity implements OnClickListener&#123; private static final String TAG = "SignupActivity"; // 界面控件 private CleanEditText phoneEdit; private CleanEditText passwordEdit; private CleanEditText verifyCodeEdit; private Button getVerifiCodeButton; private VerifyCodeManager codeManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_signup); initViews(); codeManager = new VerifyCodeManager(this, phoneEdit, getVerifiCodeButton); &#125; /** * 通用findViewById,减少重复的类型转换 * * @param id * @return */ @SuppressWarnings("unchecked") public final E getView(int id) &#123; try &#123; return (E) findViewById(id); &#125; catch (ClassCastException ex) &#123; Log.e(TAG, "Could not cast View to concrete class.", ex); throw ex; &#125; &#125; private void initViews() &#123; getVerifiCodeButton = getView(R.id.btn_send_verifi_code); getVerifiCodeButton.setOnClickListener(this); phoneEdit = getView(R.id.et_phone); phoneEdit.setImeOptions(EditorInfo.IME_ACTION_NEXT);// 下一步 verifyCodeEdit = getView(R.id.et_verifiCode); verifyCodeEdit.setImeOptions(EditorInfo.IME_ACTION_NEXT);// 下一步 passwordEdit = getView(R.id.et_password); passwordEdit.setImeOptions(EditorInfo.IME_ACTION_DONE); passwordEdit.setImeOptions(EditorInfo.IME_ACTION_GO); passwordEdit.setOnEditorActionListener(new OnEditorActionListener() &#123; @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; // 点击虚拟键盘的done if (actionId == EditorInfo.IME_ACTION_DONE || actionId == EditorInfo.IME_ACTION_GO) &#123; commit(); &#125; return false; &#125; &#125;); &#125; private void commit() &#123; String phone = phoneEdit.getText().toString().trim(); String password = passwordEdit.getText().toString().trim(); String code = verifyCodeEdit.getText().toString().trim(); if (checkInput(phone, password, code)) &#123; // TODO:请求服务端注册账号 &#125; &#125; private boolean checkInput(String phone, String password, String code) &#123; if (TextUtils.isEmpty(phone)) &#123; // 电话号码为空 ToastUtils.showShort(this, R.string.tip_phone_can_not_be_empty); &#125; else &#123; if (!RegexUtils.checkMobile(phone)) &#123; // 电话号码格式有误 ToastUtils.showShort(this, R.string.tip_phone_regex_not_right); &#125; else if (TextUtils.isEmpty(code)) &#123; // 验证码不正确 ToastUtils.showShort(this, R.string.tip_please_input_code); &#125; else if (password.length() &lt; 6 || password.length() &gt; 32 || TextUtils.isEmpty(password)) &#123; // 密码格式 ToastUtils.showShort(this, R.string.tip_please_input_6_32_password); &#125; else &#123; return true; &#125; &#125; return false; &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.btn_send_verifi_code: // TODO 请求接口发送验证码 codeManager.getVerifyCode(VerifyCodeManager.REGISTER); break; default: break; &#125; &#125; &#125; #QQ登录 网址：http://wiki.connect.qq.com/sdk%E4%B8%8B%E8%BD%BD集成步骤(移动应用接入流程) 1.注册成为开发者，登录2.点击申请加入，创建应用–&gt;会分配appId，appKey APP ID：1104072093 APP KEY：PzMWIM4GYZvxGRjd 3.完善信息4.下载demo.运行看效果5.集成开发 webview方式(老方式)：授权的时候是跳到了一个webview上去授权 sso方式：如果手机里面装了qq.那就是单点登录的形式.如果没有装qq，就是跳到webview这种老方式; sso：单点登录 集成步骤_官方 1.注册成为开发者2.创建应用3.完善应用信息4.提交上线申请5.通过审核上线 通过广播的方式拿到access_token #新浪微博 1、点击了发起授权请求的按钮，使用WebView加载登陆网页，也是oauth2.0授权步骤中的第一步，其实就是去打开了一个授权的网页 通过Get方式传递三个参数: client_id(应用的appkey)，redirect_uri(回调地址)，display(展示方式，手机设备为mobile) https://auth.sina.com.cn/oauth2/authorize?client_id=3237555059&amp;redirect_uri=http%3A%2F%2Fbilly.itheima.com&amp;display=mobile 2、用户授权完成之后，回调到回调页，同时传递code(授权码) 在wap页点击登陆按钮后, 会有一个回调地址, 可以在WebViewClient的shouldOverrideUrlLoading方法中捕获。 用户点击登录后, 是一个302跳转, 跳转地址就是申请appkey时填写的Redirect URL, 登录成功后这个地址后面带有code参数. 如果是移动端的话, 这个地址不需要有实体的页面 回调页：http://billy.itheima.com/?code=ce97366666b1b902575ce207401477ff&amp;state= 3、拿着授权的code请求access_token 请求地址:https://auth.sina.com.cn/oauth2/access_token请求方式:post请求参数的形式:key-value请求具体参数client_id=3237555059&amp;client_secret=2b6c964b071e2ecc28c1835628cc6901&amp;grant_type=authorization_code&amp;code=ce97366666b1b902575ce207401477ff&amp;redirect_uri=http%3A%2F%2Fbilly.itheima.com 1234567&#123; &quot;access_token&quot;: &quot;26883566623yk3e3x6rXZ3gOj5J35b6d&quot;, &quot;expires_in&quot;: 1437982314, &quot;time_left&quot;: 22868, &quot;uid&quot;: &quot;1884774904&quot;, &quot;refresh_token&quot;: &quot;f244f166623yk3e3x6rXZ3gOj5Jf1bb7&quot; &#125; 获取用户信息 https://api.weipan.cn/2/account/info?access_token=26883566623yk3e3x6rXZ3gOj5J35b6d ##access_token加密access_token的保存，有关加密算法的相关知识，请看Android安全加密系列文章 密码规则 12this.PASSWORD = &quot;com.sina.vdisk.security.password.d7af3082d815945ff47ae58647bd9436&quot; + IMEI + appKeyPair.key + appKeyPair.secret; ##IMEI有别于sim卡的序列号，可以作为手机的唯一标识，类似我们pc的机器码 两个概念 imei：设备的唯一标识 imsi：移动sim卡的唯一标识 买手机：3码合一 手机序列号 电池序列号 手机包装序列号 统计apk的安装量：启动应用程序的时候，把手机的imei号上传到服务器 获取IMEI 12TelephonyManager telephonyManager = (TelephonyManager) ctx .getSystemService(Context.TELEPHONY_SERVICE);telephonyManager.getDeviceId(); ##3层加密只是加大了被破解的难度 des加密–&gt;密码唯一化，复杂化(但是还是不安全) 1this.PASSWORD = &quot;com.sina.vdisk.security.password.d7af3082d815945ff47ae58647bd9436&quot; + IMEI + appKeyPair.key + appKeyPair.secret; 秘钥放到so库里面，通过jni调用-&gt;密码放到so库里面，这个时候，加到了获取秘钥的难度。(同样，反编译apk，可以拿到so库，然后可以调用本地方法获取到密码) 1234567// 本地方法 c实现public native String getDataFromC();//从c中获取秘钥public static String getKey()&#123; return getInstance().getDataFromC();&#125; 123456789101112131415#include &lt;jni.h&gt;jstring Java_com_example_level3encrypt_util_LanguageTransform_getDataFromC(JNIEnv* env, jobject obj) &#123; //JNIEnv* env jni环境的上下文对象 //jobject obj 调用该方法的java对象 //返回一个java字符串,即秘钥 char* cstr = &quot;myKey0510YUY1234&quot;; //将c字符串 转换成 java字符串 // jstring (*NewStringUTF)(JNIEnv*, const char*); jstring jstr = (**env).NewStringUTF(env, cstr); return jstr;&#125; 混淆(也是可以拿到，混淆的时候。我们的字符串是不会进行混淆的。只是混淆我们方法名，以及变量名) #第三方登录 用qq号/微信号/微博号去登录自己的应用 核心：就是拿到我们access_token 实际开发第三方登录的协议：http://xxx?token=&gt;xxx&amp;type=x，token就是我们授权之后返回的access_token，type是为了区分不同登录渠道 第三方登录协议 #access_token是啥，干嘛用? 形象解释：申请调兵–&gt;皇帝同意–&gt;兵符–&gt;开始调兵拿到用户在第三方平台的唯一的标识;获取用户的nickname，头像，邮箱等其他信息; ##实际开发3大步app做的事情，实际开发，我们能把我这里的几个步骤，就可以完成开发工作 1.发起授权请求，让用户授权（输入账号密码）2.处理授权结果，拿到access_token3.调用第三方登录协议(自己公司定义)，传递access_token到app的server，后续逻辑交给server ##server拿到access_token做了什么 静默注册新用户或者返回已有用户用户信息 1.使用access_token拿到用户在第三方平台的唯一ID;判断第三方平台的唯一ID是否存在我们的用户信息表中;存在：(之前使用qq号登陆过自己的系统)返回当前用户的用户信息不存在：(用户还没有使用过此qq登陆过我们的系统) 调用相关的接口，拿到nickname，邮箱，头像(需要什么拿取什么); ##qq登录_sso形式 sso(单点登录)方式：如果手机里面装了qq，那就是单点登录的形式，如果没有装qq，就是跳到webview这种老方式 返回参数 #什么是开发平台 开放平台（Open Platform） 在软件业和网络中，开放平台是指软件系统通过公开其应用程序编程接口（API）或函数（function)来使外部的程序可以增加该软件系统的功能或使用该软件系统的资源，而不需要更改该软件系统的源代码 开发平台的作用：提供功能，提供资源 #OAuthOAuth是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用 ##oauth产生背景传统互联网时代，各个网站和服务之间是封闭的，数据无法进行交互。随着互联网技术的迅猛发展、系统之间的相互协作日益增多，开放与共享数据的需求不断增加，互联网服务之间的整合已经成为必然趋势，一个通过自身开放平台来实现数据互通甚至用户共享的时代已经来临。把网站的服务封装成一系列计算机易识别的数据接口开放出去，供第三方开发者使用，这种行为就叫做Open API，提供开放API 的平台本身就被称为开放平台。 2007 年5 月份，Facebook 宣布改版，最早提出了开放平台的概念，正式从一个社交网站向一个社交应用平台转型。至此，开放平台发展迅速，成为互联网发展的趋势，也是一种革命性的发展模式 国内外已经有很多的公司开发了自己的开放平台，Facebook、Twitter、腾讯、新浪微博、人人网，它们用户规模大、技术实力强，为第三方提供了一整套自成体系、纷繁复杂的“开放API”。通过开放平台，网站不仅能提供对Web 网页的简单访问，还可以进行复杂的数据交互，允许第三方开发者利用其资源开发复杂的应用，既丰富自身网站应用，为用户提供更好的服务，逐步建立起一个服务完备的网络社会，也为第三方连接的网站带来更多的用户。开放平台迅速成为互联网发展的趋势。 开放平台的核心问题在于用户验证和授权。对于服务提供商来说，一般不会希望第三方直接使用用户名和密码来验证用户身份，除非双方具有很强的信任关系。OAuth 协议正是为了解决服务整合时“验证和授权”这一根本问题而产生的，具有同样认证功能的协议还有Openid。 如果一个用户拥有两项服务：一项服务是图片在线存储服务A，另一个是图片在线打印服务B。如下图所示。由于服务A与服务B是由两家不同的服务提供商提供的，所以用户在这两家服务提供商的网站上各自注册了两个用户，假设这两个用户名各不相同，密码也各不相同。当用户要使用服务B打印存储在服务A上的图片时，用户该如何处理？ 方法一：用户可能先将待打印的图片从服务A上下载下来并上传到服务B上打印，这种方式安全但处理比较繁琐，效率低下 方法二：用户将在服务A上注册的用户名与密码提供给服务B，服务B使用用户的帐号再去服务A处下载待打印的图片，这种方式效率是提高了，但是安全性大大降低了，服务B可以使用用户的用户名与密码去服务A上查看甚至篡改用户的资源。很多公司和个人都尝试解决这类问题，包括Google、Yahoo、Microsoft，这也促使OAUTH项目组的产生。OAuth是由Blaine Cook、Chris Messina、Larry Halff 及David Recordon共同发起的，目的在于为API访问授权提供一个开放的标准。 ##什么是OAuth OAuth是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息。 简单：不管是OAUTH服务提供者还是应用开发者，都很容易于理解与使用安全：没有涉及到用户密钥等信息，更安全更灵活开放：任何服务提供商都可以实现OAUTH，任何软 件开发商都可以使用OAUTH ##OAuth的核心工作流程 OAuth 为客户端提供了一种代表资源拥有者访问受保护资源的方法。在客户端访问受保护资源之前，它必须先从资源拥有者获取授权（访问许可），然后用访问许可交换访问令牌（Access Token，包含许可的作用域、持续时间和其它属性等信息）。客户端通过向资源服务器出示访问令牌来访问受保护资源。 ###OAuth1.0OAuth1.0主要流程是四步骤： 1、获取未授权的Request Token2、请求用户授权Request Token3、使用授权后的Request Token换取Access Token4、使用 Access Token 访问或修改受保护资源。 1.0的缺陷： 1、oauth1.0对手机客户端，移动设备等非server第三方的支持不好。是因为oauth1.0将多种流程合并成了一种，而事实证明，这种合并的流程体验性非常差。2、oauth1.0的三步认证过程比较繁琐和复杂，对第三方开发者增加了极大的开发难度。3、oauth1.0的加密需求过于复杂，第三方开发者使用oauth之前需要花费精力先实现oauth1.0的加密算法。4、oauth1.0生成的access_token要求是永久有效的，这导致的问题是网站的安全性和破坏网站的架构。 ###OAuth2.0 oauth2.0针对1.0的各种问题提供了解决方法： 1、 oauth2.0提出了多种流程，各个客户端按照实际情况选择不同的流程来获取access_token。这样就解决了对移动设备等第三方的支持，也解决了拓展性的问题 2 、oauth2.0删除了繁琐的加密算法。利用了https传输对认证的安全性进行了保证 3、 oauth2.0的认证流程一般只有2步，对开发者来说，减轻了负担 4 、oauth2.0提出了access_token的更新方案，获取access_token的同时也获取refresh_token， access_token是有过期时间的，refresh_token的过期时间较长，这样能随时使用refresh_token对access_token进行更新 oauth2.0授权流程 用户打开客户端以后，客户端要求用户给予授权。 用户同意给予客户端授权。 客户端使用上一步获得的授权，向认证服务器(比如qq登录，那就是腾讯)申请令牌。 认证服务器对客户端进行认证以后，确认无误，同意发放令牌。 客户端使用令牌，向资源服务器申请获取资源。 资源服务器确认令牌无误，同意向客户端开放资源 授权流程图 Oauth2.0根据授权方式和客户端状态的不同对应不一样的实现方式。 ##Webserver方式 适用场景：Web Server子态适用于有能力与终端用户的user-agent（通常是浏览器）交互并能够从授权服务器接收（通过重定向）请求（即有能力担当HTTP服务器的角色）的客户端。 ##userAgent方式 适用场景：Web Server子态适用于有能力与终端用户的user-agent（通常是浏览器）交互并能够从授权服务器接收（通过重定向）请求（即有能力担当HTTP服务器的角色）的客户端 ，典型的例子是用诸如JavaScript语言编写并运行在浏览器的程序。这些客户端不能保存客户端私有证书，并且客户端的验证基于user-agent的同源策略。 说明：在其它子态中，客户端对于终端用户的授权和访问令牌使用分开的不同请求来完成，而与之不同的是，在user-agent子态中，客户端以HTTP重定向的方式在终端用户授权请求的结果中获取到访问令牌。客户端请求授权服务器将user-agent重定向到另一个web服务器或user-agent能访问到的本地资源，而且user-agent有能力从响应信息中提取出访问令牌并传给客户端。 ##原生程序方式 适用场景：原生程序方式适用于作为原生代码运行在终端用户计算机或移动设备上的客户端。这些客户端通常有能力与终端用户的user-agent交互（或嵌入user-agent）。 基于不同的需求和期望的终端用户体验，原生程序客户端可以有三种方式实现： 外部启用一个user-agent；内嵌一个user-agent；直接要求用户输入用户名和密码。 ##优缺点：外部浏览器可能会提高完成效率，因为终端用户可能已经登录过了而不需要重新进行身份验证。 嵌入的user-agent通常能提供更好的用户流程，因为它不必切换上下文并打开新窗口。 但嵌入的user-agent对安全提出了挑战，因为用户在一个无法辨别的窗口之中进行身份验证，而不像很多user-agent那样能提供可视化的保护。 第三种方式，实现起来最简单，但它将终端用户的密码直接交给了第三方客户端，而客户端不得不用明文存储密码，所以它要求客户端和认证服务方有很强的信任关系。 ##刷新令牌 OAuth2.0引入刷新令牌的方式重新获取访问令牌。访问令牌的生命周期通常比资源拥有者授予的要短一些。当分发一个访问令牌时，授权服务器可以同时传回一个刷新令牌，在当前访问令牌超时后，客户端可以用这个刷新令牌重新获取一个访问令牌。当请求新的访问令牌时，刷新令牌担当起访问许可的角色。使用刷新令牌，不再需要再次与资源拥有者交互，也不需要存储原始的访问许可来获得访问令牌和刷新令牌。 注：可以使用刷新令牌也可以直接使用客户端的私有证书 ##oauth2.0涉及的角色 Third-party application：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印” HTTP service：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google Resource Owner：资源所有者，本文中又称”用户”（user）。 User Agent：用户代理，本文中就是指浏览器 Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器 Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器 说明：本文提出的OAuth使用方式是基于2.0协议，只对OAuth2.0 最核心的工作流程进行设计，即获取Access Token 的过程。 #服务器端的数据存储方案 OAuth2.0 机制的核心工作流程，大部分信息，如APP 信息、用户和APP 之间的授权关系、Access Token等，需要永久性存储，存储在数据库中。一些不需要永久存储的信息，如临时授权码，只使用一次，而且，在很短的时间内就要使其失效，就没有必要存储在数据库之中，可存储在譬如memcached 等缓存系统中，即提高了系统的处理速度，又减少了数据库压力 #数据库表结构设计 客户端要先注册一个应用，获取该应用的APPID和APPSECRET，应用的详细信息存储在数据表中，如下图所示： 用户授权信息表用来保存授权成功的访问令牌。 #OAuth和Openid的比较 ##Openid是什么 OpenID 是一个以用户为中心的数字身份识别框架。 OpenID 的创建基于这样一个概念：我们可以通过 URI （又叫 URL 或网站地址）来认证一个网站的唯一身份，同理，我们也可以通过这种方式来作为用户的身份认证。由于URI 是整个网络世界的核心，它为基于URI的用户身份认证提供了广泛的、坚实的基础。 OAuth和Openid同为认证机制，但它们的侧重点不一样。 OAuth关注的授权，即：“用户能做什么” ；而OpenID关注的是证明，即：“用户是谁”。 下面就分别来举例说明两者的功能。 ###OpenID 用户希望访问其在example.com的账户 example.com 提示用户输入他/她/它的OpenID 用户给出了他的OpenID，比如说”http://user.myopenid.com” example.com 跳转到了用户的OpenID提供商“mypopenid.com” 用户在”myopenid.com”(OpenID provider)提示的界面上输入用户名密码登录 “myopenid.com” (OpenID provider) 问用户是否要登录到example.com 用户同意后，”myopenid.com” (OpenID provider) 跳转回example.com example.com 允许用户访问其资源 ###OAuth 用户在使用example.com时希望从mycontacts.com导入他的联系人 example.com (在OAuth的黑话里面叫“Consumer”)把用户送往mycontacts.com (黑话是“Service Provider”) 用户在mycontacts.com 登录 mycontacts.com问用户是不是希望授权example.com访问他在mycontact.com的联系人 用户确定 mycontacts.com 把用户送回example.com example.com 从mycontacts.com拿到联系人 example.com 告诉用户导入成功]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VR全景图片与视频功能开发详解]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FVR%E5%85%A8%E6%99%AF%E5%9B%BE%E7%89%87%E4%B8%8E%E8%A7%86%E9%A2%91%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. VR开发概述时下关于“谷歌、Android与VR”的各种言论纷飞。VR群里有人在争论Android VR是不是一体机，是不是类似Android Wear、为VR打造的全新平台，是不是改良后的Android N。 随着vr设备的流行开来，各大招聘平台上也发布了不少关于andorid vr开发相关的Android工程师岗位，从这点来说掌握vr在项目中的实际应用要点，有助于大家为自己的开发经验上增加前沿技术的积累。 经过研发市面上的主流vr app 的功能，抽取并整合项目中的vr开发知识点，希望大家掌握后，在企业相关vr app游刃有余。 1.1 下载google vr sdk 并搭建开发环境 带大家去github上搜索并下载google vr sdk 介绍sdk的组成部分与应用范围 搭建一个基本android vr app的开发环境 1.2 CardBorad应用核心功能 带大家查找本地vr 全景图片资源 介绍vr全景图与普通图片的不同点 使用rv列表进行展示 使用VrPanoramaView控件进行本地全景图片的展示 1.3 UtoVR应用核心功能 带大家通过网络请求获取vr视频的json数据 使用 Gson解析得到javaBean数据 使用VrVideoView控件进行网络全景视图的展示 以上这些功能是现流行的在线vr视频，vr图片相关app的核心功能。例如.vr管家应用，3d播播，discovery VR ，看房 vr等等热门应用。 1.4 知识点 http网络请求技术 Gson解析技术与gsonformat插件 RecyclerView与cardView Glider流行图片加载框架 VrPanoramaView VrVideoView 1.5 好玩好用的VR成本其实很便宜！教你用手机体验VR魅力 17块钱！把手机改造为VR眼镜 好玩好用的VR APP推荐 2. 全景图片显示 2.1 搭建vr全景图片的开发环境VR开发需要gvr-android-sdk，GitHub下载地址 VR开发Google官方技术文档 2.1.1 导入全景图相关的三个开发库common，commonwidget，panowidgetPS：最新的SDK已经没有这三个文件夹了，使用下一步的依赖库即可 2.1.2 依赖该库123456compile 'com.google.vr:sdk-panowidget:1.30.0'//compile project(':common')//compile project(':commonwidget')//compile project(':panowidget')//google的一套序列化数据结构开发库//compile 'com.google.protobuf.nano:protobuf-javanano:3.0.0-alpha-7' 2.1.3 准备全景图片测试资源放在assets目录 例:assets/a.jpg(全景图与普通图片的不同 大，立体) 2.1.4 功能清单配置android:largeHeap=”true” 全景图片比较耗资源 123&lt;application android:largeHeap="true"&gt;&lt;/application&gt; 2.2 布局全景控件显示加载后的全景图片1234&lt;com.google.vr.sdk.widgets.pano.VrPanoramaView android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/vr_pv" /&gt; 12345678910111213141516public class MainActivity extends AppCompatActivity &#123; private VrPanoramaView vrPanoramaView; private ImageTask imageTask; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //全景图片的浏览功能 //步骤一。下载github上google开源 vr-sdk //1.1.导入到我们的工作空间 common,commonwidget panowidget //1.2.依赖到我们的项目中 //1.3.依赖sdk中找不到的api //1.4.准备一些测试素材 放置在assets目录下面 例:assets/a.jpg //1.5.开启内存设置 android:largeHeap="true"尽可能使应用使用最大内存 2.2.1 布局查找控件123//步骤二。布局全景控件显示加载后的全景图片//2.1.布局查找控件vrPanoramaView = (VrPanoramaView) findViewById(R.id.vr_pv); 2.2.2 设置初始化参数123456//2.2.设置初始化参数vrPanoramaView.setDisplayMode(VrWidgetView.DisplayMode.FULLSCREEN_STEREO);//删除不需要连接，信息图标vrPanoramaView.setInfoButtonEnabled(false);//隐藏全屏按钮vrPanoramaView.setFullscreenButtonEnabled(false); 2.2.3 创建异步任务加载图片Bitmap是图片在内存中的表示对象，全景图也可加载成bitmap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 //2.3.创建异步任务加载图片 Bitmap是图片在内存中的表示对象，全景图也可加载成bitmap imageTask = new ImageTask(); imageTask.execute();&#125;private class ImageTask extends AsyncTask&lt;Void, Void, Bitmap&gt; &#123; @Override protected Bitmap doInBackground(Void... params) &#123; //2.4.从资产目录打开一个流 try &#123; InputStream inputStream = getAssets().open("a.jpg"); //2.5.使用BitmapFactory转换成Bitmap Bitmap bitmap = BitmapFactory.decodeStream(inputStream); return bitmap; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; //2.6任务执行完后,可获取Bitmap图片 @Override protected void onPostExecute(Bitmap bitmap) &#123; super.onPostExecute(bitmap); if (bitmap != null) &#123; //loadImageFromBitmap加载bitmap到显示控件 参1.bitmap 参2 显示参数的封装 VrPanoramaView.Options options = new VrPanoramaView.Options(); //加载立体图片，上部分显示在左眼，下部分显示在右眼 options.inputType = VrPanoramaView.Options.TYPE_STEREO_OVER_UNDER; if (listener == null) &#123; listener = new VrPanoramaEventListener() &#123; @Override public void onLoadError(String errorMessage) &#123; super.onLoadError(errorMessage); //处理加载失败的情况 Toast.makeText(MainActivity.this, "错误消息:" + errorMessage, Toast.LENGTH_SHORT).show(); &#125; @Override public void onLoadSuccess() &#123; super.onLoadSuccess(); //成功的情况提示下现在要进行全景图片的展示 Toast.makeText(MainActivity.this, "进入vr:", Toast.LENGTH_SHORT).show(); &#125; &#125;; // 增加加载出错的业务逻辑处理 vrPanoramaView.setEventListener(listener); &#125; //2.7.让控件加载bitmap对象 vrPanoramaView.loadImageFromBitmap(bitmap, options); //2.8.如果loadImageFromBitmap加载失败需要提示用户相关信息则需要添加事件监听器listener &#125; &#125;&#125;private VrPanoramaEventListener listener; 2.3 VrPanoramaView控件退到后台，回到屏幕，销毁处理细节123456789101112131415161718192021222324252627282930 //步骤三。VrPanoramaView控件退到后台，回到屏幕，销毁处理细节 //3.1.退到后台.暂停显示 @Override protected void onPause() &#123; super.onPause(); if (vrPanoramaView != null) &#123; vrPanoramaView.pauseRendering(); &#125; &#125; //3.2.回到屏幕,恢复显示 @Override protected void onResume() &#123; super.onResume(); if (vrPanoramaView != null) &#123; vrPanoramaView.resumeRendering(); &#125; &#125; //3.3.退出界面停止显示 @Override protected void onDestroy() &#123; if (vrPanoramaView != null) &#123; vrPanoramaView.shutdown(); &#125; if (imageTask != null &amp;&amp; !imageTask.isCancelled()) &#123;//销毁任务 imageTask.cancel(true); imageTask = null; &#125; super.onDestroy(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package com.itheima.demovrimagevideo2;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.AsyncTask;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.Toast;import com.google.vr.sdk.widgets.common.VrWidgetView;import com.google.vr.sdk.widgets.pano.VrPanoramaEventListener;import com.google.vr.sdk.widgets.pano.VrPanoramaView;import java.io.IOException;import java.io.InputStream;public class MainActivity extends AppCompatActivity &#123; private VrPanoramaView vrPanoramaView; private ImageTask imageTask; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //全景图片的浏览功能 //步骤一。下载github上google开源 vr-sdk //1.1.导入到我们的工作空间 common,commonwidget panowidget //1.2.依赖到我们的项目中 //1.3.依赖sdk中找不到的api //1.4.准备一些测试素材 放置在assets目录下面 例:assets/a.jpg //1.5.开启内存设置 android:largeHeap="true"尽可能使应用使用最大内存 //步骤二。将全景图片加载到内存中，再显示在控件 //2.1.布局全景图片显示控件 vrPanoramaView = (VrPanoramaView) findViewById(R.id.vr_pano); //删除不需要连接 vrPanoramaView.setInfoButtonEnabled(false); //隐藏全屏按钮 vrPanoramaView.setFullscreenButtonEnabled(false); //2.2.所有的图片在内存表示成Bitmap imageTask = new ImageTask(); imageTask.execute(); //vrPanoramaView.loadImageFromBitmap(bitmap); &#125; //2.3.AsyncTask异步加载 private class ImageTask extends AsyncTask&lt;Void, Void, Bitmap&gt; &#123; @Override protected Bitmap doInBackground(Void... params) &#123; try &#123; InputStream inputStream = getAssets().open("a.jpg"); //2.4.使用BitmapFactory 可以sd ,byte[] inputstream--&gt;Bitmap Bitmap bitmap = BitmapFactory.decodeStream(inputStream); return bitmap; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; @Override protected void onPostExecute(Bitmap bitmap) &#123; super.onPostExecute(bitmap); if (bitmap != null) &#123; //loadImageFromBitmap加载bitmap到显示控件 参1.bitmap 参2 显示参数的封装 VrPanoramaView.Options option = new VrPanoramaView.Options(); //立体图片:上半张显示在左眼，下半张显示在右眼 option.inputType = VrPanoramaView.Options.TYPE_STEREO_OVER_UNDER; VrPanoramaEventListener listener=new VrPanoramaEventListener()&#123; @Override public void onLoadSuccess() &#123; super.onLoadSuccess(); //成功的情况提示下现在要进行全景图片的展示 Toast.makeText(MainActivity.this, "进入vr图片", Toast.LENGTH_SHORT).show(); &#125; @Override public void onLoadError(String errorMessage) &#123; super.onLoadError(errorMessage); //处理加载失败的情况 Toast.makeText(MainActivity.this, "E:"+errorMessage, Toast.LENGTH_SHORT).show(); &#125; &#125;; //2.5.增加加载出错的业务逻辑处理 vrPanoramaView.setEventListener(listener); //2.6.全屏展示 vrPanoramaView.setDisplayMode(VrWidgetView.DisplayMode.FULLSCREEN_MONO); //2.4.加载bitmap到控件上显示 vrPanoramaView.loadImageFromBitmap(bitmap, option); &#125; &#125; &#125; //步骤三。优化程序细节 ，页面退到后台,暂停显示 ，页面显示在屏幕 恢复显示。销毁页面,释放全景图片 //3.1 页面退到后台,暂停显示 @Override protected void onPause() &#123; super.onPause(); if(vrPanoramaView!=null) &#123; vrPanoramaView.pauseRendering(); &#125; &#125; //3.2 页面显示在屏幕 恢复显示 @Override protected void onResume() &#123; super.onResume(); if(vrPanoramaView!=null) &#123; vrPanoramaView.resumeRendering(); &#125; &#125; //3.3.销毁页面,释放全景图片 @Override protected void onDestroy() &#123; super.onDestroy(); if (vrPanoramaView != null) &#123; vrPanoramaView.shutdown(); &#125; if (imageTask != null &amp;&amp; !imageTask.isCancelled()) &#123; imageTask.cancel(true); imageTask = null; &#125; &#125;&#125; 3. 全景视频显示开发 3.1 vr视频环境搭建 导入需要的三个库 common,comonwidget.videowiget 依赖这三个库 准备显示使用到全景视频 assets目录下面 例:assets/b.mp4 配置大内存选项 android:largeHeap=”true” 可以使用最大内存3.1.1 导入vr sdk 中的相关库 common，commonwidget，videowidgetPS：最新的SDK已经没有这三个文件夹了，使用下一步的依赖库即可 3.1.2 依赖以上三个库1234567compile 'com.google.vr:sdk-videowidget:1.30.0'//compile project(':common')//compile project(':commonwidget')//compile project(':videowidget')// 出现类未定义错误的缺少库//compile 'com.google.android.exoplayer:exoplayer:r1.5.10'//compile 'com.google.protobuf.nano:protobuf-javanano:3.0.0-alpha-7' 3.1.3 打开内存设置 android:largeHeap=”true”123&lt;application android:largeHeap="true"&gt;&lt;/application&gt; 3.1.4 准备测试使用的全景视频放置在assets目录 例:assets/congo_2048.mp4 3.2 布局视频控件，并加载视频内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class MainActivity extends AppCompatActivity &#123; private VrVideoView vrVideoView; private VideoTask videoTask; private SeekBar seekBar; private TextView text; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //步骤一。搭建vr全景视频的开发环境 //1.1.导入需要的三个库 common,comonwidget.videowiget //1.2.依赖这三个库 //1.3.准备显示使用到全景视频 assets目录下面 例:assets/b.mp4 //1.4.配置大内存选项 android:largeHeap="true" 可以使用最大内存 //步骤二。布局视频控件，并加载视频内容 //2.1布局控件 //2.2查找控件 vrVideoView = (VrVideoView) findViewById(R.id.vr_vv); //2.3加载视频数据 videoTask = new VideoTask(); videoTask.execute("congo_2048.mp4"); &#125; // 创建异步任务防止占用主线程 private class VideoTask extends AsyncTask&lt;String, Void, Void&gt; &#123; @Override protected Void doInBackground(String... params) &#123; // 把文件名取出来进行加载 视频资源来自asssets VrVideoView.Options options = new VrVideoView.Options(); //2.4.输入模式 //立体模式 options.inputType = VrVideoView.Options.TYPE_STEREO_OVER_UNDER; //2.5.设置视频来源 //处理视频加载的格式(sd卡或者assets) //options.inputFormat = VrVideoView.Options.FORMAT_DEFAULT; //FORMAT_DEFAULT 视频资源来自assetss/sd //FORMAT_HLS 视频来自网络流媒 直播 //处理视频加载的格式 流媒体直播格式 options.inputFormat=VrVideoView.Options.FORMAT_HLS; try &#123; //2.8 如果资源有问题，不能正常播放需要处理下界面提示 if (listener == null) &#123; listener = new VrVideoEventListener() &#123; @Override public void onLoadSuccess() &#123; super.onLoadSuccess(); //获取当前总时长 long max=vrVideoView.getDuration(); seekBar.setMax((int) max); seekBar.setProgress(0); Toast.makeText(MainActivity.this, "准备播放vr", Toast.LENGTH_SHORT).show(); &#125; @Override public void onNewFrame() &#123; super.onNewFrame(); //获取当前播放位置 long currentPosition = vrVideoView.getCurrentPosition(); //设置当前进度 seekBar.setProgress((int) currentPosition); //时间值 String total=String.format("%.2f",vrVideoView.getDuration()/1000f); String curr=String.format("%.2f",vrVideoView.getCurrentPosition()/1000f); text.setText("播放进度"+curr+":"+total); &#125; private boolean isPause=true; @Override public void onCompletion() &#123; super.onCompletion(); seekBar.setProgress(0); vrVideoView.seekTo(0);//重回0位置 vrVideoView.pauseVideo();//暂停播放 isPause=true;//保存暂停状态 &#125; @Override public void onClick() &#123; super.onClick(); if (isPause) &#123;//播放 vrVideoView.playVideo(); isPause=false; &#125; else &#123; vrVideoView.pauseVideo(); isPause=true; &#125; &#125; @Override public void onLoadError(String errorMessage) &#123; super.onLoadError(errorMessage); Toast.makeText(MainActivity.this, "加载失败", Toast.LENGTH_SHORT).show(); &#125; &#125;; vrVideoView.setEventListener(listener); &#125; //2.7加载视频资源 //vrVideoView.loadVideoFromAsset(params[0], options); String url="http://youkesvideo.oss-cn-hangzhou.aliyuncs.com/movie2/2016/10/11/%E6%B9%84%E5%85%AC%E6%B2%B3%E8%A1%8C%E5%8A%A8.Operation.Mekong.2016.TC720P.X264.AAC.Mandarin.CHS.Mp4Ba.mp4"; vrVideoView.loadVideo(Uri.parse(url),options); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; &#125; private VrVideoEventListener listener; 3.3 处理页面退到后台，回到屏幕,页面销毁123456789101112131415161718192021222324252627282930313233 //步骤三。处理页面退到后台，回到屏幕,页面销毁。 //3.1.页面退到后台暂停视频 @Override protected void onPause() &#123; super.onPause(); if (vrVideoView != null) &#123; vrVideoView.pauseRendering(); &#125; &#125; //3.2.页面回到屏幕继续播放 @Override protected void onResume() &#123; super.onResume(); if (vrVideoView != null) &#123; vrVideoView.resumeRendering(); &#125; &#125; //3.3.页面销毁 @Override protected void onDestroy() &#123; super.onDestroy(); if (vrVideoView != null) &#123; vrVideoView.shutdown(); &#125; if (videoTask != null &amp;&amp; !videoTask.isCancelled()) &#123; videoTask.cancel(false); videoTask = null; &#125; &#125;&#125; 3.4 添加进度条相关事件3.4.1布局查找出控件123456789101112131415161718&lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical"&gt; &lt;SeekBar android:id="@+id/seek_bar" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;TextView android:id="@+id/text" android:background="#AEAEAE" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:textColor="#FFFFFF" android:textSize="22sp" android:text="00:00" /&gt;&lt;/LinearLayout&gt; 12seekBar = (SeekBar) findViewById(R.id.seek_bar);text = (TextView) findViewById(R.id.text); 3.4.2.加载成功设置最大值在VrVideoEventListener中的onLoadSuccess处理 3.4.3.在播放过程中不断更新进度值 onNewFrame 每播放一个画面就调用该方法一次 3.4.4.同步理新文本时间值在VrVideoEventListener中的onNewFrame处理 3.4.5.播放完成重新播放在VrVideoEventListener中的onCompletion处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package com.itheima.appvideo;import android.os.AsyncTask;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.SeekBar;import android.widget.TextView;import android.widget.Toast;import com.google.vr.sdk.widgets.common.VrWidgetView;import com.google.vr.sdk.widgets.video.VrVideoEventListener;import com.google.vr.sdk.widgets.video.VrVideoView;import java.io.IOException;public class MainActivity extends AppCompatActivity &#123; private VrVideoView vrVideoView; private VideoTask task; private SeekBar seekBar; private TextView timeText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //步骤一。搭建vr全景视频的开发环境 //1.1.导入需要的三个库 common,comonwidget.videowiget //1.2.依赖这三个库 //1.3.准备显示使用到全景视频 assets目录下面 例:assets/b.mp4 //1.4.配置大内存选项 android:largeHeap="true" 可以使用最大内存 //步骤二。加载视频到内存中，再使用控件显示 //2.1 布局全景视频控件 vrVideoView = (VrVideoView) findViewById(R.id.vr_video_view); //2.2加载全景视频 task = new VideoTask(); task.execute("b.mp4"); seekBar = (SeekBar) findViewById(R.id.seekbar); timeText = (TextView) findViewById(R.id.time); &#125; //2.2.1创建异步任务防止占用主线程 private class VideoTask extends AsyncTask&lt;String, Void, Void&gt; &#123; @Override protected Void doInBackground(String... params) &#123; //2.2.2.把文件名取出来进行加载 视频资源来自asssets VrVideoView.Options options = new VrVideoView.Options(); //立体的视频资源:上半画面显示在左眼，下半画面显示右眼 options.inputType = VrVideoView.Options.TYPE_STEREO_OVER_UNDER; //FORMAT_DEFAULT 视频资源来自assetss/sd //FORMAT_HLS 视频来自网络流媒 直播 options.inputFormat = VrVideoView.Options.FORMAT_DEFAULT; try &#123; //步骤四.编写进度显示 业务逻辑 VrVideoEventListener listener = new VrVideoEventListener() &#123; //4.1.加载成功 @Override public void onLoadSuccess() &#123; super.onLoadSuccess(); Toast.makeText(MainActivity.this, "准备放3d视频", Toast.LENGTH_SHORT).show(); upProgress(); &#125; //4.2加载失败的提示 @Override public void onLoadError(String errorMessage) &#123; super.onLoadError(errorMessage); Toast.makeText(MainActivity.this, "视频加载失败" + errorMessage, Toast.LENGTH_SHORT).show(); &#125; //4.3.显示播放时长与播放进度 //4.3.1.布局显示控件SeekBar 与TextView //4.3.2.查找出来 //4.3.3.在onLoadSuccess里面获取视频时长 视频播放位置 //4.3.4.在onNewFrame 不断获取最新的进度值来更新界面 @Override//播放了一个画面,onNewFrame就被调用次 public void onNewFrame() &#123; super.onNewFrame(); upProgress(); &#125; private boolean isPause = false; //4.4.处理播放完成 @Override public void onCompletion() &#123; super.onCompletion(); vrVideoView.seekTo(0); vrVideoView.pauseVideo(); isPause = true; upProgress(); &#125; //4.5.点击业务 @Override public void onClick() &#123; super.onClick(); if (isPause) &#123; isPause = false; vrVideoView.playVideo(); &#125; else &#123; isPause = true; vrVideoView.pauseVideo(); &#125; &#125; &#125;; vrVideoView.setEventListener(listener); vrVideoView.loadVideoFromAsset(params[0], options);//参1文件名 参2 设置参数 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private void upProgress() &#123; long max = vrVideoView.getDuration(); long currPosition = vrVideoView.getCurrentPosition(); seekBar.setMax((int) max); seekBar.setProgress((int) currPosition); timeText.setText(String.format("%.2f", currPosition / 1000f) + "/" + String.format("%.2f", max / 1000f)); &#125; &#125; //步骤三。程序优化 页面退到后台，暂停 页面回到屏幕继续播放 页面销毁 关闭 //3.1. 页面退到后台，暂停 @Override protected void onPause() &#123; super.onPause(); if (vrVideoView != null) &#123; vrVideoView.pauseRendering(); &#125; &#125; //3.2 页面回到屏幕继续播放 @Override protected void onResume() &#123; super.onResume(); if (vrVideoView != null) &#123; vrVideoView.resumeRendering(); &#125; &#125; //3.3. 页面销毁 关闭销毁 @Override protected void onDestroy() &#123; super.onDestroy(); if (vrVideoView != null) &#123; vrVideoView.shutdown(); &#125; if (task != null &amp;&amp; !task.isCancelled()) &#123; task.cancel(true); task = null; &#125; &#125;&#125; GitHub：https://github.com/JackChen1999/GoogleVR]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>vr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android应用开发-快速入门]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FAndroid%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[内容摘要 了解Android 操作系统 搭建Android 开发工具 使用Android 模拟器 案例-电话拨号器/短信发送器 掌握点击事件的四种实现方式 掌握Android 常见布局 了解Android 中的长度单位 1. 手机制式手机的发展根据通信技术大致可以划分为4 个时代（G：Generation 的缩写） 第一代模拟制式手机（1G）：1G就是大哥大，手机类似于简单的无线电双工电台，通话是锁定在一定频率，所以使用可调频电台就可以窃听通话 第二代GSM、CDMA等数字手机（2G）：手机使用PHS，GSM或者CDMA这些十分成熟的标准，具有稳定的通话质量和合适的待机时间，支持彩信业务的GPRS和上网业务的WAP服务，以及各式各样的Java程序等 第三代移动通信技术（3G）：3G，是英文3rd Generation的缩写，指第三代移动通信技术。指将无线通信与国际互联网等多媒体通信结合的新一代移动通信系统。它能够处理图像、音乐、视频流等多种媒体形式，提供包括网页浏览、电话会议、电子商务等多种信息服务 第四代移动电话行动通信（4G）：4G。该技术包括TD-LTE和FDD-LTE两种制式。4G是集3G与WLAN于一体，并能够传输高质量视频图像，它的图像传输质量与高清晰度电视不相上下。4G系统能够以100Mbps的速度下载，比目前的拨号上网快200倍，并能够满足几乎所有用户对于无线服务的要求。此外，4G可以在DSL和有限电视调制解调器没有覆盖的地方部署，然后再扩展到整个地区 1G制式：彻底退出历史舞台…… 2G/3G/4G的区别：网速的区别。 2G：打个电话给你：“我租了一张苍老师的VCD，一起来看”。 3G：发个消息给你：“种子发你邮箱了，注意查收，请叫我雷锋”。 4G：发个地址给你：“在线看，高清的，还能边看边吐槽”。 2G 拨号上网，带宽12.2k每用户。 3G 宽带上网，带宽384k~2M每用户。 4G 光纤到户，带宽可以达到100M每用户。 1.1 买手机注意网络制式 2G制式： GSM：移动/联通 CDMA：电信 3G制式 WCDMA：联通 TD-SCDMA：移动 CDMA 2000：电信 4G制式 FDD-LTE：电信/联通 TD-LTE（3个版本，对应三大运营商，互不兼容）：移动/电信/联通 2. Android简单历史2.1 安卓之父：安迪·鲁宾 2003年10月，安迪·鲁宾牵头创建了一家公司，名为Android，开始开发一款针对手机端的操作系统。2005年8月，谷歌低调收购了这家公司及其团队，安迪·鲁宾成为Google公司工程部副总裁，继续负责Android项目。2007年11月，谷歌公司正式向外界展示了这款名为Android的操作系统，并宣布建立一个全球性的联盟组织，该组织由34家手机制造商、软件开发商、电信运营商以及芯片制造商共同组成，他们共同搭建起了Android系统最早的生态圈。2011年，Android在全球的市场份额首次超过塞班系统，跃居第一，目前的主要竞争对手是iOS。 2.2 Android进化史 2008 年9 月23 日Android 1.0 发布，代号Bender（发条机器人），这也是Android 系统最早的版本 2009 年9 月15 日Android 1.6 发布，代号Donut（甜甜圈）该版本首次支持了CDMA 网络 2009 年11 月Android 2.0 发布，代号Eclair（松饼）无论从哪个方面说，它都是Android 发展历史上第二个重要的里程碑时刻（第一个是Android1.5） 2010 年5 月20 日Android 2.2 发布，代号Froyo（冻酸奶）为Android 添加了很多企业级功能 2011 年10 月19 日Android 4.0 发布，代号Ice Cream Sandwich（冰激凌三明治）是Android 发展历史上最重大的一次升级 2012 年6 月28 日Android 4.1 发布，代号Jelly Bean（果冻豆）是谷歌继蜂巢之后，一次全新的平板策略尝试 2014 年10 月15 日Android 5.0 发布，代号Lollipop（棒棒糖），全新的UI 设计，全新的操作系统 2015 年10 月6 日Android 6.0 发布，代号Marshmallow（棉花糖），这次的新版系统在UI 和交互上和Android 5.X 保持高度一致 2016年5月19日，谷歌在美国加州的山景城举办了 Google I/O 开发者大会中发布。2016年6月，Android N正式命名为“牛轧糖” 3. Android体系结构Android 的系统架构采用了分层的设计。从架构图看，Android 分为四层，从低层到高层分别是Linux 内核层、系统运行库层、应用程序框架层和应用程序层 3.1 LINUX KERNELLinux核心，Android系统是基于Linux系统修改过来的，Android底层都是Linux的东西，大多都是操作硬件的一些驱动，如Display Driver、Audio Drivers等，Linux 内核也同时作为硬件和软件栈之间的抽象层 3.2 LIBRARIES用C语言编写的完成Android核心功能的一些类库，这些库能被Android 系统中不同的组件使用。它们通过Android 应用程序框架为开发者提供服务 OpenGL|ES（图形图像引擎简化版） WebKit（浏览器内核） SQLite（轻量级数据库） Surface Manager（界面管理器） Media Framework（多媒体框架） FreeType（字体类库） SGL（另一个图形图像引擎） SSL（基于TCP的安全协议） libc（零散的类库） 3.3 Android Runtime Core Libraries - 该核心库提供了Java 编程语言核心库的大多数功能 Dalvik Virtual MachineAndroid底层是Linux系统，使用C、C++语言编写的，所以Android程序（Java语言编写）要在Linux上运行就需要虚拟机，也就是DVM。每一个Android 应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik 虚拟机实例。Dalvik 虚拟机依赖于linux 内核的一些功能，比如线程机制和底层内存管理机制 3.4 APPLICATION FRAMEWORK应用框架层，全部是用Java语言编写的，供开发人员调用。Android 系统中的每个应用都依赖于该框架提供的一系列服务和系统，其中包括： 活动管理器( Activity Manager) 用来管理应用程序生命周期并提供常用的导航回退功能。 丰富而又可扩展的视图(Views)，可以用来构建应用程序， 它包括列表(lists)，网格(grids)，文本框(textboxes)，按钮(buttons)，甚至可嵌入的web 浏览器。 内容提供器(Content Providers)使得应用程序可以访问另一个应用程序的数据(如联系人数据库)， 或者共享它们自己的数据。 资源管理器(Resource Manager)提供非代码资源的访问，如本地字符串，图形，和布局文件( layoutfiles )。 通知管理器(Notification Manager) 使得应用程序可以在状态栏中显示自定义的提示信息。 3.5 APPLICATIONS应用层，我们安装的所有应用都属于这一层，如，微信，植物大战僵尸。该层不仅包括系统内置的应用也包括用户自己安装的应用，比如email 客户端，SMS短消息程序，日历，地图，浏览器，联系人管理程序，QQ，微信，淘宝，美团等，该层所有的应用程序都是使用Java语言编写的 3.6 举例：闹钟应用闹钟应用的功能实际上就是定时播放音乐。闹钟应用调用APPLICATION FRAMEWORK层的MediaPlayer，MeidaPlayer访问LIBRARIES层中的Media Framework，Media Framework再使用C语言操作Andio Drivers去播放音乐 4. Dalvik VM和JVM的比较JavaSE 程序使用的虚拟机叫Java Virtual Machine，简称JVM，Android 应用也使用Java 语言开发，但是使用的虚拟就是Dalvik Virtual Machine，简称DVM。 Dalvik 是Google 公司自己设计用于Android 平台的Java 虚拟机。它执行的是已转换为.dex（即Dalvik Executable）格式的Java 应用程序的运行，.dex 格式是专为Dalvik 设计的一种压缩格式，适合内存和处理器速度有限的系统。 Dalvik 经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。 DVM执行的是.dex格式文件，JVM执行的是.class格式文件。Android程序编译完之后生成.class文件，然后，dex工具会把.class文件处理成.dex文件，然后把资源文件和.dex文件等打包成.apk文件，apk就是android package的意思。 4.1 DVM相比JVM运行效率更高的原因 每个jar包中都会有很多的class文件，每个class文件都有一个Header，Header中保存了class文件的初始信息，如，生成该class的jdk版本。而在apk文件中的dex文件，只有一个Header，所有class文件的初始信息都保存在其中，效率更高 每个class文件中有常量、字节码、方法、域等保存自己的对应的信息。dex文件中把所有class文件中的常量放在常量池中，所有class文件中的字节码放到一个字节码常量池中，等等。虽然这样打包慢一点，但是读取的时候会很快。 class文件存在很多的冗余信息，dex工具会去除冗余信息，并把所有的.class文件整合到.dex文件中，减少了I/O操作，提高了类的查找速度。 4.2 Dalvik 和标准Java 虚拟机(JVM)首要差别Dalvik 基于寄存器，而JVM 基于栈。基于寄存器的虚拟机对于编译后变大的程序来说，在它们执行的时候，花费的时间更短。 Dalvik 和Java 运行环境的区别： Dalvik 主要是完成对象生命周期管理，堆栈管理，线程管理，安全和异常管理，以及垃圾回收等重要功能 Dalvik 负责进程隔离和线程管理，每一个Android 应用在底层都会对应一个独立的Dalvik 虚拟机实例，其代码在虚拟机的解释下得以执行 不同于Java 虚拟机运行Java 字节码，Dalvik 虚拟机运行的是其专有的文件格式Dex dex 文件格式可以减少整体文件尺寸，提高I/O 操作的类查找速度 odex 是为了在运行过程中进一步提高性能，对dex 文件的进一步优化 所有的Android 应用的线程都对应一个Linux 线程，虚拟机因而可以更多的依赖操作系统的线程调度和管理机制 有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化，库的加载，预制类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的数据提供给系统。对于一些只读的系统库，所有虚拟机实例都和Zygote 共享一块内存区域 Dalvik 是由Dan Bornstein 编写的，名字来源于他的祖先曾经居住过名叫Dalvík 的小渔村，村子位于冰岛 4.3 Android的新虚拟机ART ART 模式是什么？ ART 模式英文全称为：Android runtime，谷歌从Android 4.4 系统开始新增的一种应用运行模式，与传统的Dalvik 模式不同，ART 模式可以实现更为流畅的Android 系统体验。 在4.4 系统之前，Android 系统在Linux 的底层下构筑Dalvik 一层的虚拟机，通过其可以更好适应多样的硬件架构，开发者只需要按一套规则进行应用便可，无需因为不同的硬件架构而处理与底层的驱动关系，从而大大提高开发的效率，但因为应用均是运行在Dalvik 虚拟机中，因此应用程序每次运行的时候，一部分代码都需要重新进行编译，这过程需要消耗一定的时间和降低应用的执行效率，最明显的便是拖延了应用的启动时间和降低了运行速度。 ART 模式有什么作用？ ART 模式最大的作用就是提升了Android 系统流畅度，相比Dalvik 模式中出现的耗电快、占用内存大、即使是旗舰机用久了也会卡顿严重等现象，ART 模式中这种问题得到了很好的解决，通过在安装应用程序时，自动对程序进行代码预读取编译，让程序直接编译成机器语言，免去了Dalvik 模式要时时转换代码，实现高效率、省电、占用更低的系统内存、手机运行流畅。 ART 模式的缺点 ART 模式可以降低手机硬件配置要求，减少RAM 内存依赖，不过在安卓4.4 系统中，安装应用的时间比安卓4.4 以下版本系统更长，这主要由于应用安装过程中需要先执行编码导致，并且安装应用更占存储空间（ROM） Android 5.0以上版本的手机正式开始使用ART 4.4 DVM和ART虚拟机的区别Dalvik：应用程序每次运行的时候，字节码都需要通过即时编译器转换为机器码，这会拖慢应用的运行效率。 ART：应用在第一次安装的时候，字节码就会预先编译成机器码（java语言翻译成C指令），使其成为真正的本地应用，应用的启动和执行速度都会显著提升。弊端就是ART需要存储java和C两份指令，有些耗内存。 上图说明：进入开发者模式，选择运行环境切换。在切换至ART模式时，系统会重新启动，改变运行环境，需要等待程序优化完毕，即可。 QQ实际占用内用内存，原本为44.64MB，ART模式下，变为63.00MB，说明ART有些耗内存（存两份指令）。 5. Android开发环境搭建目前主流的开发工具有两个，一个是Eclipse 另外一个是Android Studio。Eclipse 需要和ADT（Android Develop Tool）插件整合后才能使用，不过Google 官方已经直接提供了Eclipse 和ADT 集成好的开发工具，叫ADT-Bundle，但是现在Google已经不再支持这种方式开发，已经完全转移到Android Studio平台 Android Studio 是Google 基于IntelliJ IDEA 开发的Android 集成开发工具，目前国内使用该开发工具的企业也越来越多。Android 基础阶段我们依然使用Eclipse 作为开发工具，在后面的课程中才会使用到Android Studio。 获取SDK工具包（Software development kits）下载地址、Android首页、 Android中文版首页 工具包，包含以下内容： Eclipse+ADT插件 Android SDK Android Platform-tools 最新的Android开发平台 最新的模拟器镜像 Android Studio是一个Android开发环境，基于IntelliJ IDEA，类似Eclipse ADT，Android Studio提供了集成的Android开发工具用于开发和调试。 6. SDK目录结构 双击SDK Manager.exe。 SDK文件夹目录结构（请对应上图查看）： add-ons文件夹中保存着附加库，比如Google Maps。 build-tools文件夹中保存着编译工具。 tools文件中只有少数指令需要我们手动调用，如，draw9patch.bat。 platform-tools文件夹中包含可执行程序和批处理文件，其中adb.exe很重要。 extras文件夹中v4表示最低可以支持到1.6版本，v7表示最低可以支持到1.7版本。 temp文件夹为临时目录。 docs文件夹中是SDK帮助文档，在线文档使用起来很不方便。但是，我们可以使用离线文档。双击sdk目录下的docs文件夹，双击此文件夹中的index.html，双击打开。然后，会等待很久，因为浏览器要去google服务器请求数据。如果请求不到，就会一直请求，直到超时。如果断网了，也就请求不到数据了 但是，我们可以脱机使用。步骤1、打开火狐，选择“开发者”–&gt;“脱机工作”。 步骤2、打开SDK离线文档，可以搜索API。如，Activity。 安装intel文件夹中的IntelHAXM.exe可能报错。如果报错为如下，说明本机不支持安装HAXM.exe，不用装了。 如果报错如下，说明本机支持，但是支持加速器的选项没有打开，去BIOS中打开即可。进入BIOS找到virtual technology选项，选择enable即可。 7. 模拟器的创建1、首先指定SDK的路径。 点击Windows–&gt;preferences–&gt;Android，默认指定正确的SDK路径。但是，如果以前装过SDK，那么就会指定旧的SDK，也就是错误的，手动更换成新的SDK路径即可。 2、点击虚拟机管理器按钮–&gt;点击New，创建模拟器。 3、点击“detail”可以看到模拟器配置明细。 4、点击“Start”–&gt;Launch，启动模拟器。 不建议使用这么大的分辨率，屏幕分辨率越大，启动越慢，最好用320*480的分辨率。 8. 创建Android项目步骤1、右击–&gt;New–&gt;Android Application Project。 步骤二、设置Android项目参数。 步骤三、设置应用图标。 步骤四、创建Activity。我们创建的时候都使用空白的Activity，需要什么效果，最好自己写。自动生成的Activity，很多自动生成的代码需要删除、修改，很麻烦。 给Activity起个名字，一般就叫MainActivity，不需要修改。 步骤五、生成项目成功。 步骤六、空白项目也可以部署，运行。右击–&gt;Run As–&gt;Android Application。 然后，此项目就会被部署到Android的模拟器上。选择Console中的Android选项卡，可以看到部署的状态。 步骤七、运行成功。 9. Android项目目录结构 示例1：更改应用程序图标、名称。 将图标存入drawable-hdpi文件夹中。 查看R.java文件，可以看到生成了相应的id。 打开AndroidManifest.xml文件，修改。 运行。 在AndroidManifest.xml文件中，修改图标及应用名称时，一定要注意：如果activity标签中没有android:label及android:icon这两个属性，那么显示的就是application标签中的这两个属性的值，不存在覆盖问题。但是，如果activity标签中也有android:label及android:icon这两个属性，那么就会覆盖application标签中的android:label及android:icon属性。也就是说，显示的就是activity标签中的这两个属性的值。 图片3中的图标及应用名称会始终依据AndroidManifest.xml文件中的application标签中的android:icon和android:label两个属性值展示，因为此界面属于管理页面，要与图1和图2中的普通的Activity区分开。 示例2：修改展示内容。 修改res中values文件夹中的strings.xml文件。 查看R.java文件，可以看到生成了相应的id。 修改res中layout文件夹中的布局文件activity_mainxml。 运行。 10. 应用打包安装过程 1、Android项目编译、打包成apk.apk中包含 .dex文件 resources.arsc（apk中的“配置文件”、“布局文件”、“图片”的索引） uncompiled resources（未编译的资源，res文件下的资源都是不会被编译的，res文件夹下的图片、布局文件都是原封不动的打包到apk中） 清单文件（AndroidManifest.xml，也会被原封不动的打包进apk中） PS：被编译的只有.java代码 2、签名（给apk包打个数字签名）。然后再通过ADB运行到Devices emulator上，Devices指的是手机，Emulator指的是模拟器。系统判断两个应用是否属于同一款应用，首先先确认清单文件中Manifest标签的package属性值（应用程序在系统中的唯一标识）是否相同，其次判断签名是否相同。只有两个都相同，才会存在高版本覆盖低版本的情况。也就是说，只有签名相同或者包名相同，是无法覆盖的。签名是属于企业商业机密，是不能被他人获取的。签名是用一个key文件（相当于是秘钥）计算出来的一个字符串，不同的秘钥生成的字符串肯定不同，不同公司的签名也是不同的。所以，一般是无法山寨另一个公司的应用程序的。 PS：1. 启动应用程序后，通过LogCat（LogCat展示的是Android模拟器的后台输出）可以看到一个应用程序的包名。 在Android里面，安装一个应用程序是不能选路径的。 通过点击Window–&gt;Show View–&gt;Other…–&gt;Android–&gt;File Explorer，可以查看Android设备的文件目录结构。 所有第三方应用（也就是可以删除的项目）安装在data/app目录下，并且apk文件名是以包名命名的。 所有系统应用（不可以删除的项目）都安装在system/app目录下。 11. DDMSDDMS 是Dalvik Debug Monitor Service 的简称。DDMS 为IDE 和emulator 以及Android 真机架起来了一座桥梁。开发人员可以通过DDMS 看到目标机器上运行的进程/线程状态，可以看进程的heap 信息，可以查看logcat 信息，可以查看进程分配内存情况，可以向目标机发送短信以及打电话，可以向Android发送地理位置信息。下面以Eclipse 的DDMS perspective 为例简单介绍DDMS 的功能。图1-11 为DDMS透视图主界面。 1、Devices选项卡用来查看与开发环境建立连接的Android设备，在这里是模拟器，也可以是真机。 2、SD卡所在的目录为storage/sdcard。 3、Emulator Control为控制模拟器的选项卡。 PS：1. 这里有个bug，一旦用模拟器打电话，连接就会终端。只需要点击Devices选项卡右边的小三角–&gt;Reset ADB，重启ADB即可。 DDMS中所有的选项卡都可以在Java中使用，只需要切换到Java透视图，点击Window–&gt;show View，选择需要的选项卡即可。 12. 常用ADB指令ADB，Android debug bridge Android调试桥，用于建立Android设备与开发环境的连接。模拟器中的操作日志原本是不可能在Windows平台上输出的。但是，正是由于有了ADB，所以LogCat中才可以输出模拟器中的操作日志。1、ADB是一个可执行的指令，在CMD中使用，使用前首先配置环境变量。 ADB相关指令功能介绍： adb install xxx.apk：把一个apk安装到模拟器中。 adb uninstall 应用包名：从模拟器中卸载一个apk。 adb devices：查看当前跟eclipse建立连接的Android设备。 PS：adb同时也是个进程，如果这个进程挂掉了，Android设备和开发环境连接就会中断。 示例： 打开“任务管理器”–&gt;点击“adb.exe”–&gt;点击“结束进程”。 可以看到没有任何Android设备再连接到模拟器上了。 通过控制台，我们可以看到经过11秒尝试连接后，ADB连接重新恢复。 11秒时间太长，我们可以使用adb kill-server杀死adb进程，通过adb start-server开启adb。 可以看到经过不用花11秒，ADB就已经启动了。 通过adb devices也可以重启ADB。 adb shell：进入Android的命令行，其实是Linux的命令行。 示例： 可以通过ls指令查看当前目录结构。 可以通过cd data进入data目录，然后再通过ls查看data下的目录结构。 通过ps可以查看当前Android设备上运行的所有的进程，包括C进程和Java进程。 在Devices中看到的都是Java进程，可以通过“stop”按钮关掉进程。例如，关掉sms（短信）进程。 PS 如果连接ADB时出现emulator-5554 offline，那就必须通过重启模拟器解决了。 如果感觉模拟器太慢，可以通过真机测试，速度更快一些。有些测试模拟器更方便一些，因为真机有些目录结构是无法查看的。 有些进程是不能关闭的，例如com.android.launcher进程，关了，Android就会崩溃。不过关闭之后，它会自动重启。 某些时候，通过adb start-server启动adb会失败，可能就是5037端口被占用了。例如，360手机助手，腾讯手机管家都有可能占用此端口。可以通过netstat -ano查看是哪个进程占用了5037端口。如下图中可以看到，pid（如果看不到，那么点击任务管理器–&gt;选择列–&gt;勾上PID即可）为1848的进程占用了5037端口，而pid为1848的进程目前正是adb进程。如果不是adb进程，那么就直接杀掉占用5037端口的进程，然后重新启动adb进程即可。 13. 电话拨号器拨号器只负责拨号功能，打电话功能是通过切换到打电话的应用实现的。拨号器应用可以替换，但是打电话应用是无法替代的，只能使用Android自己的打电话应用。原因是与打电话相关的API，上层应用是无法调用的，只有系统级别的应用才能调用。也就是说打电话相关的API在Android jar包中都是不存在的。但是，这些API在源码中是可以查看的。 步骤一、创建项目。 步骤二、写布局文件，打开res\layout\activity_main.xml，编辑。 res\layout\activity_main.xml12345678910111213141516171819202122232425262728&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" android:orientation="vertical" tools:context=".MainActivity" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="请输入号码：" android:textSize="18sp" /&gt; &lt;EditText android:id="@+id/et" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="请输入号码" /&gt; &lt;Button android:id = "@+id/bt" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="拨打" /&gt;&lt;/LinearLayout&gt; PS TextView用来显示文本。 layout_width，layout_height是定义文本宽高的，默认值是wrap_content，表示正好能够紧紧包裹文本内容的宽高，也就是文本大小决定宽高多少。layout_width，layout_height有3个属性值，fill_parent与match_parent都是一样的，表示填充父元素。在上面的代码中也就是填充满LinearLayout（线性布局）。可以看到LinearLayout的layout_width、layout_height也是填充满父元素，也就是填充满手机屏幕。但是，并没有填充满。原因在于paddingBottom、paddingTop、paddingLeft、paddingRight等属性也决定了其与父元素（手机屏幕）的内间距大小。 Android不推荐使用像素，长度用dp，字体大小用sp，不要使用像素，因为像素在屏幕适配时很难做。 布局类型在这里使用LinearLayout（现形布局）而不是RelativeLayout（相对布局）的原因在于线性布局不存在元素重叠的情况，而相对布局则存在。 LinearLayout的属性android oritation表示排列方式，有两种，vertical（垂直排列）和horizontal（水平排列）。 EditText用来展示输入框。 EditText中的属性hint表示：如果文本框中有内容，就不显示提示内容；如果文本框没有内容，就会显示提示内容。 步骤三、写java代码，打开src\cn.itcast.dialer\MainActivity.java，编辑。 src\cn.itcast.dialer\MainActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.itcast.dialer;import android.app.Activity;import android.content.Intent;import android.net.Uri;import android.os.Bundle;import android.view.Menu;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.EditText;public class MainActivity extends Activity &#123; //onCreate方法是被系统在创建Activity时调用的。 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //设置按钮点击侦听 //通过资源id来获取指定的组件的对象 Button bt = (Button) findViewById(R.id.bt); //设置点击侦听 bt.setOnClickListener(new MyListener()); &#125; //这里的OnClickListener的全名为：android.view.View.OnClickListener class MyListener implements OnClickListener &#123; //按钮按下时，此方法被调用 @Override public void onClick(View v) &#123; //findViewById返回的是布局所有组件的父类android.view.View，需要强转 EditText et = (EditText) findViewById(R.id.et); //拿到用户输入的号码 String phone = et.getText().toString(); //告诉系统，我们的动作 //1. 创建意图对象 Intent intent = new Intent(); //2. 设置动作 intent.setAction(intent.ACTION_CALL); //3. 设置号码，通过Uri转 intent.setData(Uri.parse("tel:" + phone)); //4. 把动作告诉系统，开启打电话应用的Activity startActivity(intent); &#125; &#125;&#125; 14. 关联源码的方法： Ctrl+左键，点击某个类，再点击Attach Source按钮。 点击External Folder…。 选择关联sdk\sources\android-18。 看到源码，则说明关联成功。 步骤四、试运行，可以看到出现了安全异常，没有权限。因为打电话是需要费用的，所以需要出示权限。 步骤五、添加权限。 打开清单文件AndroidManifest.xml，使用可视化方式，点击Permission选项卡–&gt;Add–&gt;Uses Permission。 添加Uses Permission的属性“android.permission.CALL_PHONE”，Ctrl+S保存。 可以看到清单文件代码中生成了如下代码。 步骤六、重新运行，可以看到，拨打成功。 15. 点击事件的实现代码：三种java写法。 res\layout\activity_main.xml123456789101112131415161718192021222324&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context=".MainActivity" android:orientation="vertical"&gt; &lt;Button android:id="@+id/bt_iq" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="点我一下，云鹤智商-10" /&gt; &lt;Button android:id="@+id/bt_eq" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="点我一下，云鹤情商-10" /&gt; &lt;/LinearLayout&gt; src\cn.itcast.clickevent\MainActivity.java12345678910111213141516171819202122232425262728293031323334353637package cn.itcast.clickevent;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;public class MainActivity extends Activity implements OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button bt_iq = (Button) findViewById(R.id.bt_iq); Button bt_eq = (Button) findViewById(R.id.bt_eq); //第一种：Java写法，内部类实现OnClickListener接口，上个案例中就是按照内部类的方法实现的。 //第二种：Java写法，匿名内部类实现OnClickListener接口。 bt_iq.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("点我一下，云鹤智商-10"); &#125; &#125;); bt_eq.setOnClickListener(this); &#125; //第三种：Java写法，当前类实现OnClickListener接口。 @Override public void onClick(View v) &#123; System.out.println("点我一下，云鹤情商-10"); &#125; &#125; 运行结果： 代码：Android写法。 res\layout\activity_main.xml123456789101112131415161718192021222324252627282930313233&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context=".MainActivity" android:orientation="vertical"&gt; &lt;Button android:id="@+id/bt1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮1" android:onClick="click1"/&gt; &lt;Button android:id="@+id/bt2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮2" android:onClick="click1" /&gt; &lt;Button android:id="@+id/bt3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按钮3" android:onClick="click1" /&gt; &lt;/LinearLayout&gt; src\cn.itcast.clickevent\MainActivity.java123456789101112131415161718192021222324252627282930313233343536package cn.itcast.clickevent;import android.app.Activity;import android.os.Bundle;import android.view.View;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; //Android写法。 //注意：1. 在Activity中定义。 // 2. 方法名必须与Button的onClick属性值相同。 // 3. 返回值必须为void。 // 4. 参数必须为View类型对象。系统调用此方法时，会把触发的对象传进来。这里就是按钮，Button是View的子类。 // 5. 多个按钮Button的onClick属性值可以相同，点击任何一个按钮都会调用相同的方法。通过id可以判断用户按下的是哪一个按钮。 public void click1(View v) &#123; int id = v.getId(); switch(id)&#123; case R.id.bt1: System.out.println("按钮1被按下"); break; case R.id.bt2: System.out.println("按钮2被按下"); break; case R.id.bt3: System.out.println("按钮3被按下"); break; &#125; &#125; &#125; 运行结果： 16. 短信发送器代码：res\layout\activity_main.xml12345678910111213141516171819202122232425262728293031323334&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context=".MainActivity" android:orientation="vertical"&gt; &lt;!-- android:inputType="phone"表示只能输入电话号码 --&gt; &lt;EditText android:id="@+id/et_phone" android:layout_width="wrap_content" android:layout_height="wrap_content" android:hint="请输入号码" android:inputType="phone" /&gt; &lt;!-- android:lines="5"表示只能输入5行 --&gt; &lt;EditText android:id="@+id/et_content" android:layout_width="wrap_content" android:layout_height="wrap_content" android:hint="请输入内容" android:lines="5"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="发送" android:onClick="send"/&gt; &lt;/LinearLayout&gt; src\cn.itcast.smssender\MainActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.itcast.smssender;import java.util.ArrayList;import android.app.Activity;import android.os.Bundle;import android.telephony.SmsManager;import android.view.View;import android.widget.EditText; public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void send(View v) &#123; //获取用户输入的号码和数据 EditText et_phone = (EditText) findViewById(R.id.et_phone); EditText et_content = (EditText) findViewById(R.id.et_content); String phone = et_phone.getText().toString(); String content = et_content.getText().toString(); //获取发送短信的API //SmsManager要使用android.telephony包内的，不要使用android.telephony.gsm包内的，已过时。 SmsManager sm = SmsManager.getDefault(); //如果短信过长，发布出去，可以把长短信拆分成若干条短短信。 ArrayList&lt;String&gt; smss = sm.divideMessage(content); for(String str : smss)&#123; //第一个参数表示对方号码。 //第二个参数表示短信服务中心的号码，可以传null，表示使用默认的短信服务中心地址。 //第三个参数表示短信内容。 //第四个参数表示广播，如果不传null，短信发送成功或失败时，会给予回执信息。 //第五个参数表示如果对方成功接收信息了，会给予回执信息。 sm.sendTextMessage(phone, null, str, null, null); &#125; &#125; &#125; 添加权限： 运行结果： 发送一般短信结果。 发送超长短信结果。 17. dp和pxdp最终显示长度多少是根据屏幕密度来换算的，屏幕越大，1dp就能显示更长的像素。 320x480屏幕上，1dp=1px，160dp=160px，正好是屏幕宽度的一般。 480x800屏幕上，1dp=1.5px，160dp=240px，正好是屏幕宽度的一般 sp与dp类似，只是sp用于字体大小，dp用于长度大小。 res\layout\activity_main.xml12345678910111213141516171819202122232425&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context=".MainActivity" &gt; &lt;TextView android:layout_width="160px" android:layout_height="wrap_content" android:text="@string/hello_world" android:background="#ff0000" android:textSize="15sp"/&gt; &lt;TextView android:layout_width="160dp" android:layout_height="wrap_content" android:text="@string/hello_world" android:background="#ff0000" android:textSize="15sp"/&gt; &lt;/LinearLayout&gt; 运行结果： 320x480屏幕下显示： 480x800屏幕下显示： 18. 布局介绍为适应各种界面风格，满足开发的需要，Android提供了6种布局方式 LinearLayout（线性布局） RelativeLayout（相对布局） FrameLayout（帧布局） TableLayout（表格布局） AbsoluteLayout（绝对布局） GridLayout（网格布局） 通过这6种布局我们可以做出来各种复杂的UI效果。 18.1 线性布局LinearLayout orientation属性是指定线性布局的排列方向： horizontal 水平 vertical 垂直 示例1：res\layout\activity_main.xml123456789101112131415161718192021222324&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:orientation="vertical" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="第一个" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="第二个" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="第三个" /&gt; &lt;/LinearLayout&gt; 运行结果： 设置android: orientation为vertical结果。 设置android: orientation为horizontal结果。 gravity属性是指定当前控件内容显示位置： left 左边 right 右边 top 上边 bottom 底边 示例2：res\layout\activity_main.xml1234567891011121314151617181920212223&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:orientation="vertical" &gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center_horizontal" android:text="第一个" android:background="#ff0000"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center_horizontal" android:text="第二个" android:background="#00ff00"/&gt; &lt;/LinearLayout&gt; 运行结果： 设置第一个TextView的android:layout_width属性值为match_parent，由于父组件足够宽，因此设置第一个TextView的android:gravity属性值为center_horizontal，可以看到控件内容居中。但是，第二个TextView的父组件宽高都是由包裹着内容决定的，所以，设置第二个TextView的android:gravity起不到任何效果。 layout_gravity属性是指定当前控件在父元素的位置： left 左边 right 右边 top 上边 bottom 底边 示例3：res\layout\activity_main.xml1234567891011121314151617181920212223242526272829&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:orientation="vertical" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="第一个" android:background="#ff0000" android:layout_gravity="right"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="第二个" android:background="#00ff00" android:layout_gravity="center_horizontal"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="第三个" android:layout_gravity="bottom"/&gt; &lt;/LinearLayout&gt; 运行结果：设置第一个TextView的android:layout_gravity属性值为right，设置第二个TextView的android:layout_gravity属性值为center_horizontal，设置第三个TextView的android:layout_gravity属性值为bottom。然后会发现，第三个TextView的设置将不会有任何效果。因为， 在线性布局中，竖直排列（vertical）时，顶部、底部、竖直居中对齐都无效。水平排列（horizontal）时，左右对齐，水平居中对齐都无效。 layout_weightSum(权重)属性是把线性布局中剩余空间分成N份。layout_weight (权重)属性是指定当前控件在父元素(线性布局)中占N份。 示例4：res\layout\activity_main.xml123456789101112131415161718192021222324252627&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:orientation="horizontal" &gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="第一个" android:background="#ff0000"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="第二个" android:background="#00ff00"/&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="第三个" android:background="#0000ff"/&gt; &lt;/LinearLayout&gt; 运行结果： 水平排列（horizontal）时，设置第一个TextView的android:layout_width属性值为match_parent，将会发现第二个、第三个TextView被第一个TextView完全挤出去，看不到了。这时候就需要使用权重来解决这个问题。 示例5：res\layout\activity_main.xml123456789101112131415161718192021222324&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:orientation="horizontal" android:weightSum="2" &gt; &lt;TextView android:layout_width="100dp" android:layout_height="wrap_content" android:text="第一个" android:background="#ff0000" android:layout_weight="1"/&gt; &lt;TextView android:layout_width="100dp" android:layout_height="wrap_content" android:text="第二个" android:background="#00ff00" android:layout_weight="1"/&gt; &lt;/LinearLayout&gt; 运行结果： 首先，将第一个、第二个TextView的android:layout_width的属性值分别设置为100dp。然后，通过为LinearLayout标签设置android:layout_weightSum属性值，把屏幕的总宽度权重设置为2，每个TextView的宽度权重通过android:layout_weight属性设置为1，也就是平均分配。 但是，如果将第一个TextView的android:layout_width属性值设置为100dp，将第二个TextView的android:layout_width属性值设置为50dp，结果如下。 说明：android:weightSum及android:weight的属性值设置，针对的是剩余空间的分配。 第一次分配情况如下： 第二次分配情况如下： 所以，当排列为水平排列（horizontal），利用权重进行分配的时候，一定要搭配将android:layout_width属性值设置为0dp来使用，这样很容易计算。同理，当排列为垂直排列（vertical），在利用权重进行分配的时候，一定要搭配将android:layout_height属性值设置为0dp来使用。 PS： android:weightSum是可以不写的，上例中，如果第一个TextView的android:weight属性值设置为1，第二个TextView的android:weight属性值设置为2，那么weightSum即为3，两个TextView按照1:2分配。但是，如果weightSum设置为4，相当于把宽度切成四份，前面3份，两个TextView按照1:2分配，第4块不分配。 TextView的android:weight属性如果不写，相当于android:weight的属性值为0，也就是不会分配到剩余空间任何部分。此时，如果android:layout_width属性值设置为0dp，那么就会报错。因为，此TextView已经无法显示出来了。 visibility属性是控制布局是否显示: visible 显示 invisible 不显示但占空间 gone 隐藏 练习：做出如下效果的布局。 实现：右击res/layout文件夹–&gt;点击New–&gt;Android XML File–&gt;选择LinearLayout–&gt;取一个名字。 代码：res\layout\linearlayout_demo.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:orientation="horizontal"&gt; &lt;TextView android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:background="#000000" /&gt; &lt;TextView android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:background="#ffffff" /&gt; &lt;TextView android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:background="#ff0000" /&gt; &lt;TextView android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:background="@android:color/darker_gray" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:orientation="vertical"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:background="#00ffff" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:background="#ffffff" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:background="#ff0000" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:background="@android:color/darker_gray" /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 运行结果： PS：@android:color/darker_gray表示引用Android定义好的颜色资源id。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android四大组件之BroadCastReceiver]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FAndroid%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BBroadCastReceiver%2F</url>
    <content type="text"><![CDATA[1. 基本概念在Android 中，Broadcast 是一种广泛运用的在应用程序之间传输信息的机制。而BroadcastReceiver 是对发送出来的Broadcast 进行过滤接受并响应的一类组件，是Android 四大组件之一。 广播接收者（BroadcastReceiver）用于接收广播的，广播的发送是通过调用sendBroadcast（Intent），sendOrderedBroadcast（Intent）来实现的。通常一个广播可以被多个广播接收者所接收。 广播被分为两种不同的类型：“普通广播（Normal Broadcasts）”也叫无序广播和“有序广播（OrderedBroadcasts）”。 1、普通广播是完全异步（就是不会被某个广播接收者终止）的，可以在同一时刻（逻辑上）被所有接收者接收到（其实被接收者接收到也是由顺序的，接收者配置的优先级越高，越先接收到，也就是说广播接收者的优先级对于无序广播也是有用的），消息传递的效率比较高，但缺点是：接收者不能将处理结果传递给下一个接收者，并且无法终止广播的传播。 2、有序广播是按照接收者声明的优先级别，被接收者依次接收广播。如：A 接收者的级别高于B，B的级别高于C，那么，广播先传给A，再传给B，最后传给C 。在传递的过程中如果有某个接收者终止（abortBroadCast）了该广播，那么后面的接收者就接收不到该广播。 3、广播接收者属于四大组件之一，因此通常需要AndroidManifest.xml 中进行注册，优先级别声明在intent-filter 元素的android:priority 属性中，数越大优先级别越高，取值范围:-1000 到1000，优先级别也可以调用IntentFilter 对象的setPriority()进行设置。 4、有序广播的接收者可以终止广播的传播，广播的传播一旦终止，后面的接收者就无法接收到广播，有序广播的接收者可以将数据传递给下一个接收者，如：A 得到广播后，可以往它的结果对象中存入数据，当广播传给B 时，B 可以从A 的结果对象中得到A 存入的数据。 5、Context.sendBroadcast() 发送的是普通广播，所有订阅者都有机会获得并进行处理。 6、Context.sendOrderedBroadcast() 发送的是有序广播，系统会根据接收者声明的优先级别按顺序逐个执行接收者，前面的接收者有权终止广播(BroadcastReceiver.abortBroadcast())，如果广播被前面的接收者终止， 后面的接收者就再也无法获取到广播。对于有序广播， 前面的接收者可以将数据通过setResultExtras(Bundle)方法存放进结果对象，然后传给下一个接收者，下一个接收者通过代码：Bundle bundle = getResultExtras(true))可以获取上一个接收者存入在结果对象中的据。 2. Android 系统常见的广播Android 为了将系统运行时的各种“事件”通知给其他应用（或者说通知给我们程序员，让我们程序员好做出相应的反应。举个生活中的例子：比如我们坐火车，当前方到达某站的时候，火车乘务员会给所有乘客发送即将到站的广播，这样乘客收到广播后就可以提前准备下车），因此内置了多种广播，比如：系统电量的改变、屏幕的锁屏、网络状态的改变、接收到新的短信、拨打电话事件、sdcard 的挂载和移除、应用的安装和卸载等等。比如我们开发的在线播放视频类的APP，那么我们就有必要监听网络转态改变的事件广播，如果用户的网络状态从wifi 改变为了4G 上网，那么应该提示用户是否使用4G 网络继续播放视频，如果不提示用户，那么就可能导致用户流量被大量使用，一会儿功夫，用户可能就要停机了。 接下来我们会用4 个案例来演示广播接收者的使用。 2.1 案例-IP 拨号器需求分析 什么是IP 拨号服务？我们为什么要用IP 服务？所谓的IP 拨号就是通过接入数据网络来传播语音信息。IP 拨号的目的在于转接至其他频道，减少话费等用处。移动17951，联通17911，打长途时在电话号码前加上这个就便宜了，如果你的手机上有这个键的话，那么打电话时输入长途电话号码后，直接按那个键就拨出去了，它会自动加上IP。通俗的说就是打长途便宜。 例如手机拨打长途电话：移动拨区号+电话号=0.25/分市话+0.7/分长途=0.95/分；移动拨17951+区号+电话号=0.25/分市话+0.3/分长途=0.55/分。 了解了IP 拨号的用途之后，接下来，我们通过程序在用户拨出去的号码前自动加上一个IP 号码，为用户省钱。 之所以能实现这样的功能，是因为拨号的时候Android 系统会发送一个有序广播，该广播中携带了用户拨打的号码，我们通过注册广播接收者就可以获取到该广播，同时将该广播中的数据进行修改。从而实现了用户号码自动加IP 号的功能。 为了能让用户自己决定IP 号码，我们需要一个界面（如图1-2），让那个用户输入IP 号码，然后将该IP 号码保存到SharedPreferences 中。 布局文件如下 12345678910111213141516171819&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;EditText android:id="@+id/et_ip" android:hint="请输入IP 号码，默认17951" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;Button android:onClick="saveIP" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="保存" /&gt;&lt;/LinearLayout&gt; 实现代码在该案例中总共用到了两个类一个是MainActivity.java 负责让用户输入IP 号码，另外一个是自定义的广播接收者IPCallerReceiver 负责监听用户的拨打电话事件。 1234567891011121314151617181920212223242526272829303132333435import android.os.Bundle;import android.app.Activity;import android.content.SharedPreferences;import android.text.TextUtils;import android.view.View;import android.widget.EditText;import android.widget.Toast;//保存用户的IP 号码public class MainActivity extends Activity &#123; private EditText et_ip; private SharedPreferences sp; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //文本编辑控件 et_ip = (EditText) findViewById(R.id.et_ip); //获取sp 对象 sp = getSharedPreferences("config", MODE_PRIVATE); &#125; //保存IP 号码 public void saveIP(View view)&#123; String ipNum = et_ip.getText().toString().trim(); //如果为空则保存默认值 if (TextUtils.isEmpty(ipNum)) &#123; sp.edit().putString("ip", "17951").commit(); &#125;else &#123; sp.edit().putString("ip", ipNum).commit(); &#125; Toast.makeText(this, "IP 号码保存成功", Toast.LENGTH_SHORT).show(); &#125;&#125; 编写自定义广播接收者需要自定义一个类然后继承系统提供的BroadCastReceiver 类，然后覆写抽象方法onReceive。 123456789101112131415161718192021222324252627282930package com.itheima.android.ipcaller;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences;import android.text.TextUtils;import android.util.Log;//自定义广播接收者public class IPCallerReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //获取数据 String resultData = getResultData(); Log.d("tag", "接收到广播："+resultData); //从SharedPreferences 中获取用户保存的IP 号码 SharedPreferences sp = context.getSharedPreferences("config", Context.MODE_PRIVATE); String ipNum = sp.getString("ip", "17951"); if (!TextUtils.isEmpty(ipNum)) &#123; //修改数据 resultData = ipNum+resultData; &#125; //将修改后的数据设置出去 setResultData(resultData); &#125;&#125; 在清单文件中进行注册 广播是Android 四大组件之一，因此需要在AndroidManifest.xml 中进行注册。同时监听用户的拨打电话行为也属于侵犯用户隐私的行为，因此需要添加权限。 注册广播 12345&lt;receiver android:name="com.itheima.android.ipcaller.IPCallerReceiver"&gt; &lt;intent-filter &gt; &lt;action android:name="android.intent.action.NEW_OUTGOING_CALL"&gt;&lt;/action&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 大家可以发现广播接收者的注册也需要通过intent-filter 来监听特定的广播，如果是监听Android 系统的，那么在action 中就需要配置系统提供的常量。如果监听自定义发送的广播，那么就需要配置自定义广播设置的action。 声明权限 1&lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/&gt; 2.2 案例-短信监听器系统接收到短信时会将该事件以有序广播（部分自定义的ROM 可能已经修改了这个策略，比如：小米的MIUI 系统） 的形式发送出去， 因此我们只需要自定义一个BroadCastReceiver 监听该广播（android.provider.Telephony.SMS_RECEIVED）即可监听到短信的到来。由于该广播是有序的，因此如果将我们自定义的BroadCastReceiver 配置了较高的优先级，那么我们就能先于系统短信app 接收到该广播，然后终止该广播，从而就实现了短信拦截功能。 通过该案例我们可以学到： 什么是有序广播？ 如何终止有序广播 如何从广播中获取短信 广播的优先级概念 在该案例中我们要做一个类似短信黑名单的应用，主界面提供一个EditText 和一个Button，让用户输入一个“黑名单”，点击保存之后，如果该号码发短信过来，那么我们的应用就将其拦截 2.3 案例-监听应用的安装和卸载在Android 系统中，安装应用和卸载应用事件也都会发送特定的广播，我们可以通过监听这些广播间接获取到用户新安装了什么软件，卸载了哪些软件，进而可以统计用户的偏好，或统计某个软件的存留率。 需求很简单，监听应用的安装和卸载，并将其报名打印出来即可。该应用不需要界面，代码也很简单，只需要一个自定义广播接收这就可以了。 3. 发送无序广播4. 发送有序广播5. 特殊的广播接收者-锁屏与解屏拦截短信的广播1234567891011121314151617181920212223242526272829303132private class InnerSmsReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; System.out.println("InnerSmsReceiver"); // 获取到短信 Object[] objects = (Object[]) intent.getExtras().get("pdus"); for (Object obj : objects) &#123; SmsMessage smsMessage = SmsMessage.createFromPdu((byte[]) obj); // 获取到短信内容 String body = smsMessage.getMessageBody(); // 获取到电话号码 String phone = smsMessage.getDisplayOriginatingAddress(); // 根据电话号码查询拦截的模式 String mode = dao.findNumberMode(phone); /** * 黑名单的拦截模式1 全部拦截(电话拦截+ 短信拦截) 2 电话拦截3 短信拦截 */ if ("1".equals(mode) || "3".equals(mode)) &#123; System.out.println("被哥拦截了"); //往短信拦截数据库里面添加数据 abortBroadcast(); &#125; /** * 根据内容拦截(智能拦截) */ if (body.contains("xue sheng mei")) &#123; System.out.println("学生妹被拦截了"); abortBroadcast(); &#125; &#125; &#125;&#125; 注册静态广播123456receiver = new InnerSmsReceiver();IntentFilter filter = new IntentFilter("android.provider.Telephony.SMS_RECEIVED");// 设置优先级filter.setPriority(2147483647);// 注册一个短信监听的广播registerReceiver(receiver, filter); 反注册广播，防止内存泄露123456789public void onDestroy() &#123; super.onDestroy(); // 反注册 unregisterReceiver(receiver); receiver = null; // 当不用了。设置为null mTelephonyManager.listen(listener, PhoneStateListener.LISTEN_NONE); listener = null;&#125; 注册广播并设置优先级1234567&lt;!-- 拦截黑名单信息--&gt;&lt;receiver android:name="com.itheima.mobilesafe_sh2.receiver.InnerSmsReceiver " &gt; &lt;intent-filter android:priority="1000" &gt; &lt;action android:name="android.provider.Telephony.SMS_RECEIVED"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 案例1：IP拨号器1234567891011121314151617181920212223public class CallReceiver extends BroadcastReceiver &#123; //接收到广播时就会调用 @Override public void onReceive(Context context, Intent intent) &#123; //添加IP线路 //在打电话广播中，会携带拨打的电话的号码，通过以下代码获取到 String number = getResultData(); if(number.startsWith("0"))&#123; SharedPreferences sp = context.getSharedPreferences("ip", Context.MODE_PRIVATE); String ipNumber = sp.getString("ipNumber", ""); //把IP线路号码添加至用户拨打号码的前面 number = ipNumber + number; //把新的号码重新放入广播中 setResultData(number); abortBroadcast(); &#125; &#125;&#125; 1234567891011121314public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void click(View v)&#123; EditText et = (EditText) findViewById(R.id.et); SharedPreferences sp = getSharedPreferences("ip", MODE_PRIVATE); sp.edit().putString("ipNumber", et.getText().toString()).commit(); &#125;&#125; 案例2：短信防火墙1234567891011121314151617181920212223public class SmsReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //拿到短信的信息 //短信内容封装在intent中 Bundle bundle = intent.getExtras(); //以pdus为键，取出一个object数组，数组中的每一个元素，都是一条短信 Object[] objects = (Object[]) bundle.get("pdus"); //拿到广播中的所有短信 for (Object object : objects) &#123; //通过pdu来构造短信 SmsMessage sms = SmsMessage.createFromPdu((byte[])object); if(sms.getOriginatingAddress().equals("138438"))&#123; //阻止其他广播接收者收到这条广播 abortBroadcast();// SmsManager.getDefault().sendTextMessage(sms.getOriginatingAddress(), null, "你是个好人", null, null); &#125;// System.out.println(sms.getMessageBody()); &#125; &#125;&#125; 案例3：监听SD卡状态1234567891011121314151617public class SDStatusReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //判断收到的到底是什么广播 String action = intent.getAction(); if("android.intent.action.MEDIA_MOUNTED".equals(action))&#123; Toast.makeText(context, "SD卡可用", 0).show(); &#125; else if("android.intent.action.MEDIA_REMOVED".equals(action))&#123; Toast.makeText(context, "SD卡拔出", 0).show(); &#125; else if("android.intent.action.MEDIA_UNMOUNTED".equals(action))&#123; Toast.makeText(context, "SD卡不可用", 0).show(); &#125; &#125;&#125; 案例4：手机勒索软件1234567891011public class BootReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // 启动Activity，实现开机自动启动勒索软件 Intent it = new Intent(context, MainActivity.class); //创建任务栈存放启动的Activity it.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(it); &#125;&#125; 案例5：监控应用的状态123456789101112131415161718public class APPStatusReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO Auto-generated method stub String action = intent.getAction(); Uri uri = intent.getData(); if("android.intent.action.PACKAGE_ADDED".equals(action))&#123; Toast.makeText(context, uri.toString() + "被安装了", 0).show(); &#125; if("android.intent.action.PACKAGE_REPLACED".equals(action))&#123; Toast.makeText(context, uri.toString() + "被升级了", 0).show(); &#125; if("android.intent.action.PACKAGE_REMOVED".equals(action))&#123; Toast.makeText(context, uri.toString() + "被卸载了", 0).show(); &#125; &#125;&#125; 案例6：发送自定义广播12345678910111213141516public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void click(View v)&#123; //发送自定义广播 Intent intent = new Intent(); //广播中的action也是自定义的 intent.setAction("com.itheima.zdy"); sendBroadcast(intent); &#125;&#125;]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>广播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android四大组件之ContentProvider]]></title>
    <url>%2F2017%2F05%2F01%2Fandroid%2FAndroid%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8BContentProvider%2F</url>
    <content type="text"><![CDATA[1. 内容摘要 ContentProvider 基本概念 ContentProvider 的基本使用 操作系统短信 操作系统联系人 内容观察者ContentObserver 案例-短信窃听器 使用ContentObserver 监听自定义ContentProvider 的变化 2. ContentProvider 基本概念内容提供者ContentProvider，是Android 的四大组件之一。内容提供者是应用程序之间共享数据的接口。 Android 系统将这种机制应用到方方面面，比如：联系人（通讯录应用程序）Provider 专为不同应用程序提供联系人数据；短信（短信应用程序）Provider 专为不同应用程序提供系统短信信息。 当应用继承ContentProvider 类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用SharedPreferences 共享数据，需要使用SharedPreferences API 读写数据。而使用ContentProvider 共享数据的好处是统一了数据访问方式。 官方对ContentProvider 的解释如下： Content providers manage access to a structured set of data. They encapsulate the data, and provide mechanisms for defining data security. Content providers are the standard interface that connects data in one process with code running in another process. 内容提供者管理了对结构化数据（最常见的就是数据库中数据）的访问操作。内容提供者封装了这些数据并且提供了一种安全的访问机制。内容提供者是不同进程之间交互数据（数据库数据）的标准方式。 用一张简易图演示内容提供者的工作原理，如下图所示 该图中假设手机助手App 要获取系统的短信，系统的短信是存储在数据库中的，当然该数据库只能由系统短信App 内部代码直接访问。手机助手App 直接访问短信数据库是行不通的，这时候就可以借助内容提供者，系统短信App 已经写好了内容提供者，该内容提供者对外提供了短信数据。因此手机助手App直接去访问系统短信的内容提供者即可间接实现对短信数据库的访问 3. ContentProvider 基本使用为了演示ContentProvider 的基本用法，在该节中我们将创建两个Android 工程：01-内容提供者A（简称AppA）和内容访问者B（简称AppB）。在AppA 中创建数据库user.db，该db 中有两张表，t_woman和t_man。AppA 通过内容提供者对外提供数据库中的数据。AppB 作为一个内容访问者，通过内容解析者（ContentResolver）实现对AppA 中的数据进行增删改查功能。 3.1 在AppA 中创建MySQLiteOpenHelper 类在该类中实现数据库和数据表的创建业务逻辑 123456789101112131415161718192021222324252627282930313233343536373839package com.example.contentProviderA; import android.content.Context; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteDatabase.CursorFactory; import android.database.sqlite.SQLiteOpenHelper; //创建数据库user.db 同时初始化表t_woman 和t_man public class MySQLiteOpenHelper extends SQLiteOpenHelper &#123; //数据库名称 private static final String DB_NAME = "user.db"; //数据库版本号 private static final int VERSION = 1; private MySQLiteOpenHelper(Context context, String name, CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; public MySQLiteOpenHelper(Context context)&#123; this(context, DB_NAME, null, VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; String sql_woman="create table t_woman(id integer primary key, c_name varchar(10),c_phone varchar(20))"; String sql_man = "create table t_man(id integer primary key, c_name varchar(10),c_phone varchar(20))"; db.execSQL(sql_woman); db.execSQL(sql_man); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125; &#125; 3.2 使用测试类初始化user.db为了让MySQLiteOpenHelper.java 中onCreate 方法被调用，我们可以采用一个测试类来实现，当然使用其他方法也是可行的。这里使用测试类初始化AppA 的数据库也是为了复习Android Junit Test的使用 1234567891011121314151617package com.example.contentProviderA; import android.database.sqlite.SQLiteDatabase; import android.test.AndroidTestCase; //定义测试类，用于初始化user.db public class MyTest extends AndroidTestCase &#123; public void test()&#123; /** * 在AndroidTestCase 类中可以直接使用getContext()方法获取到Context 对象 */ MySQLiteOpenHelper sqLiteOpenHelper = new MySQLiteOpenHelper(getContext()); SQLiteDatabase writableDatabase = sqLiteOpenHelper.getWritableDatabase(); writableDatabase.close(); &#125; &#125; 在AndroidManifest.xml 中添加测试指令集和测试库。在application 节点外添加指令集 123&lt;instrumentation android:name="android.test.InstrumentationTestRunner" android:targetPackage="com.example.contentProviderA" /&gt; 在application 节点中添加测试库 1&lt;uses-library android:name="android.test.runner" /&gt; 万事俱备后一定记得运行一下该测试方法，看见如下绿条和数据库文件才行哦 数据库初始化完成 3.3 在AppA 中创建内容提供者我们已经将user.db 创建好了，接下来我们创建一个内容提供者将user.db 中的数据提供出去 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150public class MyContentProvider extends ContentProvider &#123; private SQLiteDatabase database; /** * 创建一个Uri 匹配器，用于区分用户使用的uri 种类，比如区分用户到底想操作哪张表， * 以及哪个表中的哪条数据 */ private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH); private static final int T_WOMAN = 1; private static final int T_MAN = 2; private static final int T_WOMAN_ID = 3; /** * 添加匹配项 */ static&#123; String authority = "com.itheima.provider"; /** * 参数1：内容提供者的主机名，类似于我们隐式意图中intent-filter 中action， * 用于区分内容提供者， * 毕竟对于一个Android 系统来讲，可能内容提供者不止一个 * 参数2：表名或者表名/#，其中#用于指定表中数据的id * 参数3：如果匹配成功了的返回值 */ sURIMatcher.addURI(authority, "t_woman", 1); sURIMatcher.addURI(authority, "t_man", 2); sURIMatcher.addURI(authority, "t_woman/#", 3); &#125; /** * 执行删除方法 */ @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; /** * 获取用户传递进来的uri 的匹配码，如果匹配不成功在，则返回UriMatcher.NO_MATCH */ int match = sURIMatcher.match(uri); switch (match) &#123; case T_WOMAN: Log.d("tag", "匹配t_woman 表"); return database.delete("t_woman", selection, selectionArgs); case T_MAN: Log.d("tag", "匹配t_man 表"); return database.delete("t_man", selection, selectionArgs); case UriMatcher.NO_MATCH: Log.d("tag", "没有匹配项"); return 0; default: break; &#125; return 0; &#125; @Override public String getType(Uri uri) &#123; return null; &#125; /** * 用于处理ContentResolver 发送的insert 请求，一般在该方法中执行数据库的插入操作 * @param uri * @param values */ @Override public Uri insert(Uri uri, ContentValues values) &#123; int match = sURIMatcher.match(uri); switch (match) &#123; case T_WOMAN: database.insert("t_woman", null, values); break; case T_MAN: database.insert("t_man", null, values); break; case UriMatcher.NO_MATCH: Log.d("tag", "匹配不正确"); break; default: break; &#125; return uri; &#125; /** * 在该内容提供者注册以后，当该应用第一次运行起来的时候该方法会被回调 * 用来做一些初始化工作，比如初始化数据库对象 * 如果初始化成功则返回true，否则返回false。 */ @Override public boolean onCreate() &#123; /** * 在ContentProvider 中可以直接通过getContext()方法获取Context 对象 */ MySQLiteOpenHelper sqLiteOpenHelper = new MySQLiteOpenHelper(getContext()); //获取一个SQLiteDatabase 对象，并声明为成员变量，方便其他方法中使用 database = sqLiteOpenHelper.getWritableDatabase(); return true; &#125; /** * 执行查询方法 */ @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; int match = sURIMatcher.match(uri); switch (match) &#123; case T_MAN: return database.query("t_man", projection, selection, selectionArgs, null, null, null); case T_WOMAN: return database.query("t_woman", projection, selection, selectionArgs, null, null, null); case T_WOMAN_ID: //ContentUris 是解析Uri 的一个工具类，可以将Uri 中的id 给解析出来 long id = ContentUris.parseId(uri); return database.query("t_woman", null, "id=?", new String[]&#123;id+""&#125;, null, null, null); case UriMatcher.NO_MATCH: Log.d("tag", "匹配失败"); break; default: break; &#125; return null; &#125; /** * 执行修改方法 */ @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; int match = sURIMatcher.match(uri); switch (match) &#123; case T_MAN: return database.update("t_man", values, selection, selectionArgs); case T_WOMAN: return database.update("t_woman", values, selection, selectionArgs); case UriMatcher.NO_MATCH: Log.d("tag", "匹配失败"); break; default: break; &#125; return 0; &#125; &#125; 3.4 在AndroidManifest.xml 中注册ContentProvider1234&lt;provider android:name="com.example.contentProviderA.MyContentProvider" android:exported="true" android:authorities="com.itheima.provider"/&gt; 注意：exported 属性必须设置为true 才可以被其他应用访问到该内容提供者 3.5 创建工程02-内容访问者B在AppB 中直接使用MainActivity 类，布局文件如下 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="insert1" android:text="给woman 表插入数据"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="insert2" android:text="给man 表插入数据"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="delete1" android:text="删除woman 表的数据"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="update1" android:text="修改woman 表的数据"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="query1" android:text="查询woman 表的所有数据"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="query2" android:text="查询woman 表中的单条数据"/&gt;&lt;/LinearLayout&gt; MainActivity.java 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** * 点击界面不同的按钮实现对AppA 中不同的增删改查操作 */ public class MainActivity extends Activity &#123; private ContentResolver contentResolver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //获取内容解析者（ContentResolver） contentResolver = getContentResolver(); &#125; /** * 往t_woman 表中插入一条数据 */ public void insert1(View view) &#123; /** * 访问内容提供者的uri 的标准写法： * 1.必须以content：//开头 * 2. 主机名必须跟内容提供者的authorities 属性一致 * 3. 主机名后面跟要操作的表名 */ Uri url = Uri.parse("content://com.itheima.provider/t_woman"); ContentValues values = new ContentValues(); values.put("c_name", "lili"); values.put("c_phone", "5554"); //插入一条数据 contentResolver.insert(url, values); //再插入一条新数据 values.clear(); values.put("c_name", "lucy"); values.put("c_phone", "5556"); contentResolver.insert(url, values); //再插入一条数据 values.clear(); values.put("c_name", "fengjie"); values.put("c_phone", "5558"); contentResolver.insert(url, values); &#125; /** * 往t_man 表中插入数据 */ public void insert2(View view) &#123; Uri url = Uri.parse("content://com.itheima.provider/t_woman"); ContentValues values = new ContentValues(); values.put("c_name", "zhangsan"); values.put("c_phone", "6500"); contentResolver.insert(url, values); //再插入一条新数据 values.clear(); values.put("c_name", "lisi"); values.put("c_phone", "6600"); contentResolver.insert(url, values); &#125; /** * 删除t_woman 表中姓名为lili 的数据 */ public void delete1(View view) &#123; Uri url = Uri.parse("content://com.itheima.provider/t_woman"); String where = "c_name=?"; String[] selectionArgs = new String[]&#123;"lili"&#125;; contentResolver.delete(url, where, selectionArgs); &#125; /** * 删除t_man 表中姓名为zhangsan 的数据 */ public void delete2(View view) &#123; Uri url = Uri.parse("content://com.itheima.provider/t_man"); String where = "c_name=?"; String[] selectionArgs = new String[]&#123;"zhangsan"&#125;; contentResolver.delete(url, where, selectionArgs); &#125; /** * 修改t_woman 表中姓名为lucy 的电话为110 */ public void update1(View view) &#123; Uri url = Uri.parse("content://com.itheima.provider/t_woman"); String where = "c_name=?"; String[] selectionArgs = new String[]&#123;"lucy"&#125;; ContentValues values = new ContentValues(); values.put("c_phone", "110"); contentResolver.update(url, values, where, selectionArgs); &#125; /** * 查询t_woman 表中的所有数据 */ public void query1(View view) &#123; Uri uri = Uri.parse("content://com.itheima.provider/t_woman"); /** * 参数2：要查询的字段 * 参数3：where 表达式，null 代表查询所有 * 参数4：用于替换where 表达式中？号的真实值 * 参数5：排序规则 */ Cursor cursor = contentResolver.query(uri, new String[]&#123;"id", "c_name", "c_phone"&#125;, null, null, null); while (cursor.moveToNext()) &#123; int id = cursor.getInt(0); String name = cursor.getString(1); String phone = cursor.getString(2); Log.d("tag", "id=" + id + ",name=" + name + ",phone=" + phone); &#125; cursor.close(); &#125; /** * 查询t_woman 表中id 为2 的数据 */ public void query2(View view) &#123; /** * 该方法的需求的是查询id 为2 的数据，因此只需要在uri 的最后面添加上/id 即可。 */ Uri uri = Uri.parse("content://com.itheima.provider/t_woman/2"); Cursor cursor = contentResolver.query(uri, new String[]&#123;"id", "c_name", "c_phone"&#125;, null, null, null); while (cursor.moveToNext()) &#123; int id = cursor.getInt(0); String name = cursor.getString(1); String phone = cursor.getString(2); Log.d("tag", "id=" + id + ",name=" + name + ",phone=" + phone); &#125; cursor.close(); &#125; &#125; 3.6 内容提供者Uri 的书写规范 schema，用来说明一个ContentProvider 控制这些数据。”content://“ Authority主机名或授权：它定义了是哪个ContentProvider 提供这些数据。 path：路径，URI 下的某一个Item。 ID：通常定义Uri 时使用”#”号占位符代替, 使用时替换成对应的数字 content://com.itheima.provider/person/#：#表示数据id（#代表任意数字） content://com.itheima.provider/person/*：*来匹配任意文本。 4. 操作系统短信使用内容提供者操作系统短信和操作系统联系人是我们企业开发中“经常”遇到的需求，而自定义内容提供者对外提供数据反而使用的场景并不多，除非我们开发的短信或者联系人应用 4.1 准备知识打开Android 系统源码，查看packages\providers\路径下的工程，这些就是Android 系统中的内容提供者，其中TelephonyProvider 就是短信的内容提供者文件 打开TelephonyProvider 下的src 文件，查看java 文件，其中的SmsProvider.java 即短信息内容提供者逻辑代码。UriMatcher 一般在静态代码块中进行初始化操作，查找静态代码块，找到的逻辑代码如下 1234567891011121314151617181920212223242526272829303132private static final UriMatcher sURLMatcher = new UriMatcher(UriMatcher.NO_MATCH); static &#123; URLMatcher.addURI("sms", null, SMS_ALL); URLMatcher.addURI("sms", "#", SMS_ALL_ID); URLMatcher.addURI("sms", "inbox", SMS_INBOX); URLMatcher.addURI("sms", "inbox/#", SMS_INBOX_ID); URLMatcher.addURI("sms", "sent", SMS_SENT); sURLMatcher.addURI("sms", "sent/#", SMS_SENT_ID); sURLMatcher.addURI("sms", "draft", SMS_DRAFT); sURLMatcher.addURI("sms", "draft/#", SMS_DRAFT_ID); sURLMatcher.addURI("sms", "outbox", SMS_OUTBOX); sURLMatcher.addURI("sms", "outbox/#", SMS_OUTBOX_ID); sURLMatcher.addURI("sms", "undelivered", SMS_UNDELIVERED); sURLMatcher.addURI("sms", "failed", SMS_FAILED); sURLMatcher.addURI("sms", "failed/#", SMS_FAILED_ID); sURLMatcher.addURI("sms", "queued", SMS_QUEUED); sURLMatcher.addURI("sms", "conversations", SMS_CONVERSATIONS); sURLMatcher.addURI("sms", "conversations/*", SMS_CONVERSATIONS_ID); sURLMatcher.addURI("sms", "raw", SMS_RAW_MESSAGE); sURLMatcher.addURI("sms", "attachments", SMS_ATTACHMENT); sURLMatcher.addURI("sms", "attachments/#", SMS_ATTACHMENT_ID); sURLMatcher.addURI("sms", "threadID", SMS_NEW_THREAD_ID); sURLMatcher.addURI("sms", "threadID/*", SMS_QUERY_THREAD_ID); sURLMatcher.addURI("sms", "status/#", SMS_STATUS_ID); sURLMatcher.addURI("sms", "sr_pending", SMS_STATUS_PENDING); sURLMatcher.addURI("sms", "icc", SMS_ALL_ICC); sURLMatcher.addURI("sms", "icc/#", SMS_ICC); //we keep these for not breaking old applications sURLMatcher.addURI("sms", "sim", SMS_ALL_ICC); sURLMatcher.addURI("sms", "sim/#", SMS_ICC); &#125; 通过查找系统源码，可以确定短信息内容提供者的Uri 应该为:”content://sms”。查看Android 模拟器下的/data/data/com.android.providers.telephony/databases/目录，查看其mmssms.db文件。 打开数据库，其中sms 表存储的就是短信的数据，其存储格式如下 其中，address 存储的是联系人号码，date 是发送日期，type 对应短信的类型（发送是1/接收是2）,body是短信的主体内容 由于读取和插入系统短信数据库都涉及到可能侵犯用户隐私，因此创建的工程必须添加如下权限12&lt;uses-permission android:name="android.permission.READ_SMS"/&gt;&lt;uses-permission android:name="android.permission.WRITE_SMS"/&gt; 4.2 查询系统短信创建Android 工程03-操作系统短信。布局文件十分简单，只有两个Button，点击不同的Button 分别触发短信的读取和短信的插入功能。因此布局文件不再给出。 1234567891011121314151617//读取系统短信 public void readSms(View view)&#123; Uri uri=Uri.parse("content://sms"); //contentResolver 在MainActivity 的onCreate 方法中获取 Cursor cursor = contentResolver.query(uri, new String[]&#123;"address","date","body","type"&#125;, null, null, null); while(cursor.moveToNext())&#123; String address = cursor.getString(0); String date = cursor.getString(1); String body = cursor.getString(2); String type = cursor.getString(3); Log.d("tag", "address="+address+",body="+body+",type="+type+", date="+new Date(Long.valueOf(date))); &#125; &#125; 5. 内容提供者 应用的数据库是不允许其他应用访问的 内容提供者的作用就是让别的应用访问到你的数据库 自定义内容提供者，继承ContentProvider类，重写增删改查方法，在方法中写增删改查数据库的代码，举例增方法 12345@Override public Uri insert(Uri uri, ContentValues values) &#123; db.insert(&quot;person&quot;, null, values); return uri; &#125; 在清单文件中定义内容提供者的标签，注意必须要有authorities属性，这是内容提供者的主机名，功能类似地址 1234&lt;provider android:name=&quot;com.itheima.contentprovider.PersonProvider&quot;android:authorities=&quot;com.itheima.person&quot;android:exported=&quot;true&quot;&gt;&lt;/provider&gt; 创建一个其他应用，访问自定义的内容提供者，实现对数据库的插入操作 12345678910public void click(View v)&#123; //得到内容分解器对象 ContentResolver cr = getContentResolver(); ContentValues cv = new ContentValues(); cv.put(&quot;name&quot;, &quot;小方&quot;); cv.put(&quot;phone&quot;, 138856); cv.put(&quot;money&quot;, 3000); //url:内容提供者的主机名 cr.insert(Uri.parse(&quot;content://com.itheima.person&quot;), cv);&#125; 6. UriMatcher 用于判断一条uri跟指定的多条uri中的哪条匹配 添加匹配规则 12345//指定多条urium.addURI(&quot;com.itheima.person&quot;, &quot;person&quot;, PERSON_CODE);um.addURI(&quot;com.itheima.person&quot;, &quot;company&quot;, COMPANY_CODE);//#号可以代表任意数字um.addURI(&quot;com.itheima.person&quot;, &quot;person/#&quot;, QUERY_ONE_PERSON_CODE); 通过Uri匹配器可以实现操作不同的表 12345678910111213@Overridepublic Uri insert(Uri uri, ContentValues values) &#123; if(um.match(uri) == PERSON_CODE)&#123; db.insert("person", null, values); &#125; else if(um.match(uri) == COMPANY_CODE)&#123; db.insert("company", null, values); &#125; else&#123; throw new IllegalArgumentException(); &#125; return uri;&#125; 如果路径中带有数字，把数字提取出来的api 1int id = (int) ContentUris.parseId(uri); 7. 短信数据库 只需要关注sms表 只需要关注4个字段 body：短信内容 address:短信的发件人或收件人号码（跟你聊天那哥们的号码） date：短信时间 type：1为收到，2为发送 读取系统短信，首先查询源码获得短信数据库内容提供者的主机名和路径，然后 123456789ContentResolver cr = getContentResolver();Cursor c = cr.query(Uri.parse("content://sms"), new String[]&#123;"body", "date", "address", "type"&#125;, null, null, null);while(c.moveToNext())&#123; String body = c.getString(0); String date = c.getString(1); String address = c.getString(2); String type = c.getString(3); System.out.println(body+";" + date + ";" + address + ";" + type);&#125; 插入系统短信 1234567ContentResolver cr = getContentResolver();ContentValues cv = new ContentValues();cv.put("body", "您尾号为XXXX的招行储蓄卡收到转账1,000,000人民币");cv.put("address", 95555);cv.put("type", 1);cv.put("date", System.currentTimeMillis());cr.insert(Uri.parse("content://sms"), cv); 插入查询系统短信需要注册权限 8. 联系人数据库 raw_contacts表： contact_id：联系人id data表：联系人的具体信息，一个信息占一行 data1：信息的具体内容 raw_contact_id：联系人id，描述信息属于哪个联系人 mimetype_id：描述信息是属于什么类型 mimetypes表：通过mimetype_id到该表查看具体类型 8.1 读取联系人 先查询raw_contacts表拿到联系人id 1Cursor cursor = cr.query(Uri.parse("content://com.android.contacts/raw_contacts"), new String[]&#123;"contact_id"&#125;, null, null, null); 然后拿着联系人id去data表查询属于该联系人的信息 1Cursor c = cr.query(Uri.parse("content://com.android.contacts/data"), new String[]&#123;"data1", "mimetype"&#125;, "raw_contact_id = ?", new String[]&#123;contactId&#125;, null); 得到data1字段的值，就是联系人的信息，通过mimetype判断是什么类型的信息 12345678910111213while(c.moveToNext())&#123; String data1 = c.getString(0); String mimetype = c.getString(1); if("vnd.android.cursor.item/email_v2".equals(mimetype))&#123; contact.setEmail(data1); &#125; else if("vnd.android.cursor.item/name".equals(mimetype))&#123; contact.setName(data1); &#125; else if("vnd.android.cursor.item/phone_v2".equals(mimetype))&#123; contact.setPhone(data1); &#125; &#125; 8.2 插入联系人 先查询raw_contacts表，确定新的联系人的id应该是多少 把确定的联系人id插入raw_contacts表 1cv.put("contact_id", _id); cr.insert(Uri.parse("content://com.android.contacts/raw_contacts"), cv); 在data表插入数据 插3个字段：data1、mimetype、raw_contact_id1234567891011cv = new ContentValues();cv.put("data1", "赵六");cv.put("mimetype", "vnd.android.cursor.item/name");cv.put("raw_contact_id", _id);cr.insert(Uri.parse("content://com.android.contacts/data"), cv);cv = new ContentValues();cv.put("data1", "1596874");cv.put("mimetype", "vnd.android.cursor.item/phone_v2");cv.put("raw_contact_id", _id);cr.insert(Uri.parse("content://com.android.contacts/data"), cv); 9. 内容观察者 当数据库数据改变时，内容提供者会发出通知，在内容提供者的uri上注册一个内容观察者，就可以收到数据改变的通知 12345678910111213141516cr.registerContentObserver(Uri.parse("content://sms"), true, new MyObserver(new Handler())); class MyObserver extends ContentObserver&#123; public MyObserver(Handler handler) &#123; super(handler); // TODO Auto-generated constructor stub &#125; //内容观察者收到数据库发生改变的通知时，会调用此方法 @Override public void onChange(boolean selfChange) &#123; &#125; &#125; 在内容提供者中发通知的代码 123ContentResolver cr = getContext().getContentResolver();//发出通知，所有注册在这个uri上的内容观察者都可以收到通知cr.notifyChange(uri, null); 10. ContentProvider 四大组件之一 内容提供者的作用：把私有数据暴露给其他应用，通常，是把私有数据库的数据暴露给其他应用 10.1 短信数据库 sms表 body：短信内容 date：短信时间 address：对方号码 type：发送还是接收 10.2 联系人数据库 raw_contacts表 contact_id：联系人id data表：存放联系人的详细的信息，每行数据是单独的一条联系人信息 data1：联系人的具体的信息 raw_contact_id：该行信息属于哪个联系人 mimetype_id：该行信息属于什么类型 mimetypes表：mimetype_id对应的类型的字符串 11. 内容提供者案例案例1：自定义内容提供者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class PersonProvider extends ContentProvider &#123; private MyOpenHelper oh; SQLiteDatabase db; //创建uri匹配器对象 static UriMatcher um = new UriMatcher(UriMatcher.NO_MATCH); //检测其他用户传入的uri与匹配器定义好的uri中，哪条匹配 static &#123; um.addURI("com.itheima.people", "person", 1);//content://com.itheima.people/person um.addURI("com.itheima.people", "teacher", 2);//content://com.itheima.people/teacher um.addURI("com.itheima.people", "person/#", 3);//content://com.itheima.people/person/4 &#125; //内容提供者创建时调用 @Override public boolean onCreate() &#123; oh = new MyOpenHelper(getContext()); db = oh.getWritableDatabase(); return false; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; Cursor cursor = null; if(um.match(uri) == 1)&#123; cursor = db.query("person", projection, selection, selectionArgs, null, null, sortOrder, null); &#125; else if(um.match(uri) == 2)&#123; cursor = db.query("teacher", projection, selection, selectionArgs, null, null, sortOrder, null); &#125; else if(um.match(uri) == 3)&#123; //把uri末尾携带的数字取出来 long id = ContentUris.parseId(uri); cursor = db.query("person", projection, "_id = ?", new String[]&#123;id + ""&#125;, null, null, sortOrder, null); &#125; else&#123; throw new IllegalArgumentException("uri又有问题哟亲么么哒"); &#125; return cursor; &#125; @Override public String getType(Uri uri) &#123; if(um.match(uri) == 1)&#123; return "vnd.android.cursor.dir/person"; &#125; else if(um.match(uri) == 3)&#123; return "vnd.android.cursor.item/person"; &#125; return null; &#125; //此方法供其他应用调用，用于往people数据库里插数据 //values：由其他应用传入，用于封装要插入的数据 //uri:内容提供者的主机名，也就是地址 @Override public Uri insert(Uri uri, ContentValues values) &#123; //使用uri匹配器匹配传入的uri if(um.match(uri) == 1)&#123; db.insert("person", null, values); //发送数据改变的通知 //uri:通知发送到哪一个uri上，所有注册在这个uri上的内容观察者都可以收到这个通知 getContext().getContentResolver().notifyChange(uri, null); &#125; else if(um.match(uri) == 2)&#123; db.insert("teacher", null, values); getContext().getContentResolver().notifyChange(uri, null); &#125; else&#123; throw new IllegalArgumentException("uri有问题哟亲么么哒"); &#125; return uri; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; int i = db.delete("person", selection, selectionArgs); return i; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; int i = db.update("person", values, selection, selectionArgs); return i; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void insert(View v)&#123; //通过内容提供者把数据插入people数据库 //拿到contentResolver ContentResolver cr = getContentResolver(); ContentValues values = new ContentValues(); values.put("name", "赵帅哥");// values.put("money", "13000"); //url:内容提供者的主机名 //values:要插入的数据 cr.insert(Uri.parse("content://com.itheima.people/teacher"), values); &#125; public void delete(View v)&#123; ContentResolver cr = getContentResolver(); int i = cr.delete(Uri.parse("content://com.itheima.people"), "name = ?", new String[]&#123;"小志"&#125;); System.out.println(i); &#125; public void update(View v)&#123; ContentResolver cr = getContentResolver(); ContentValues values = new ContentValues(); values.put("name", "sb志"); int i = cr.update(Uri.parse("content://com.itheima.people"), values, "name = ?", new String[]&#123;"大志"&#125;); System.out.println(i); &#125; public void select(View v)&#123; ContentResolver cr = getContentResolver(); Cursor cursor = cr.query(Uri.parse("content://com.itheima.people/person/4"), null, null, null, null); while(cursor.moveToNext())&#123; String name = cursor.getString(1); String money = cursor.getString(2); System.out.println(name + ";" + money); &#125; &#125; &#125; 案例2：获取系统短信12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class MainActivity extends Activity &#123; List&lt;Message&gt; smsList; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); smsList = new ArrayList&lt;Message&gt;(); &#125; public void click(View v)&#123; //访问内容提供者获取短信 ContentResolver cr = getContentResolver(); // 短信内容提供者的主机名 Cursor cursor = cr.query(Uri.parse("content://sms"), new String[]&#123;"address", "date", "body", "type"&#125;, null, null, null); while(cursor.moveToNext())&#123; String address = cursor.getString(0); long date = cursor.getLong(1); String body = cursor.getString(2); String type = cursor.getString(3); Message sms = new Message(body, type, address, date); smsList.add(sms); &#125; &#125; public void click2(View v)&#123; XmlSerializer xs = Xml.newSerializer(); File file = new File("sdcard/sms.xml"); FileOutputStream fos; try &#123; fos = new FileOutputStream(file); xs.setOutput(fos, "utf-8"); xs.startDocument("utf-8", true); xs.startTag(null, "message"); for (Message sms : smsList) &#123; xs.startTag(null, "sms"); xs.startTag(null, "body"); xs.text(sms.getBody()); xs.endTag(null, "body"); xs.startTag(null, "date"); xs.text(sms.getDate() + ""); xs.endTag(null, "date"); xs.startTag(null, "type"); xs.text(sms.getType()); xs.endTag(null, "type"); xs.startTag(null, "address"); xs.text(sms.getAddress()); xs.endTag(null, "address"); xs.endTag(null, "sms"); &#125; xs.endTag(null, "message"); xs.endDocument(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; 案例3：插入系统短信1234567891011121314151617181920212223242526272829303132public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void click(View v)&#123; Thread t = new Thread()&#123; @Override public void run() &#123; try &#123; sleep(7500); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; ContentResolver cr = getContentResolver(); ContentValues values = new ContentValues(); values.put("address", 95555); values.put("type", 1); values.put("date", System.currentTimeMillis()); values.put("body", "您尾号为XXXX的信用卡收到1,000,000RMB转账，请注意查收"); cr.insert(Uri.parse("content://sms"), values); &#125; &#125;; t.start(); &#125; &#125; 案例4：查询联系人12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void click(View v)&#123; //通过内容提供者访问联系人数据库 ContentResolver cr = getContentResolver(); Cursor cursorContactId = cr.query(Uri.parse("content://com.android.contacts/raw_contacts"), new String[]&#123;"contact_id"&#125;, null, null, null); while(cursorContactId.moveToNext())&#123; //获取联系人id String contactId = cursorContactId.getString(0); Cursor cursorData = cr.query(Uri.parse("content://com.android.contacts/data"), new String[]&#123;"data1", "mimetype"&#125;, "raw_contact_id = ?", new String[]&#123;contactId&#125;, null); //获取所有字段的名字// String[] names = cursorData.getColumnNames();// for (String string : names) &#123;// System.out.println(string);// &#125; Contact con = new Contact(); while(cursorData.moveToNext())&#123; String data1 = cursorData.getString(0); String mimetype = cursorData.getString(1); //通过mimetype的判断，把data1存入对应的属性 if("vnd.android.cursor.item/email_v2".equals(mimetype))&#123; con.setEmail(data1); &#125; else if("vnd.android.cursor.item/phone_v2".equals(mimetype))&#123; con.setPhone(data1); &#125; else if("vnd.android.cursor.item/name".equals(mimetype))&#123; con.setName(data1); &#125; &#125; System.out.println(con.toString()); &#125; &#125; &#125; 案例5：插入联系人1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void click(View v)&#123; ContentResolver cr = getContentResolver(); //先查询raw_contacts表，获取最新联系人的主键，然后主键+1，就是要插入的联系人的id Cursor cursorContactId = cr.query(Uri.parse("content://com.android.contacts/raw_contacts"), new String[]&#123;"_id"&#125;, null, null, null); //默认联系人id就是1 int contact_id = 1; if(cursorContactId.moveToLast())&#123; //拿到主键 int _id = cursorContactId.getInt(0); //主键+1，就是要插入的联系人id contact_id = ++_id; &#125; ContentValues values = new ContentValues(); values.put("contact_id", contact_id); //把联系人id插入raw_contacts数据库 cr.insert(Uri.parse("content://com.android.contacts/raw_contacts"), values); values.clear(); values.put("data1", "二bi"); values.put("mimetype", "vnd.android.cursor.item/name"); values.put("raw_contact_id", contact_id); cr.insert(Uri.parse("content://com.android.contacts/data"), values); values.clear(); values.put("data1", "1344567"); values.put("mimetype", "vnd.android.cursor.item/phone_v2"); values.put("raw_contact_id", contact_id); cr.insert(Uri.parse("content://com.android.contacts/data"), values); &#125; &#125; 案例6：内容观察者12345678910111213141516171819202122232425262728293031public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //注册一个内容观察者，监听短信数据库内容的改变 ContentResolver cr = getContentResolver(); //uri:监听哪个uri上的内容提供者的通知 //notifyForDescendents:如果是true，那么只要以content://sms开头的uri的数据改变，都能收到通知，比如content://sms/inbox cr.registerContentObserver(Uri.parse("content://sms"), true, new MyObserver(new Handler())); &#125; class MyObserver extends ContentObserver&#123; public MyObserver(Handler handler) &#123; super(handler); // TODO Auto-generated constructor stub &#125; //收到数据改变的通知，此方法调用 @Override public void onChange(boolean selfChange) &#123; // TODO Auto-generated method stub super.onChange(selfChange); System.out.println("短信数据库改变"); &#125; &#125; &#125; 案例7：监听数据库的改变123456789101112131415161718public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getContentResolver().registerContentObserver(Uri.parse("content://com.itheima.people"), true, new ContentObserver(new Handler()) &#123; @Override public void onChange(boolean selfChange) &#123; // TODO Auto-generated method stub super.onChange(selfChange); System.out.println("01项目的数据库改变了"); &#125; &#125;); &#125; &#125; window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{},"image":{"viewList":["fbook","twi","linkedin","qzone","tsina","douban","weixin","evernotecn"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?'];]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>内容提供者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和Session]]></title>
    <url>%2F2017%2F05%2F01%2Fjavaweb%2FCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[1. 会话跟踪技术1.1 什么是会话跟踪技术我们需要先了解一下什么是会话！可以把会话理解为客户端与服务器之间的一次会晤，在一次会晤中可能会包含多次请求和响应。例如你给10086打个电话，你就是客户端，而10086服务人员就是服务器了。从双方接通电话那一刻起，会话就开始了，到某一方挂断电话表示会话结束。在通话过程中，你会向10086发出多个请求，那么这多个请求都在一个会话中。 在JavaWeb中，客户向某一服务器发出第一个请求开始，会话就开始了，直到客户关闭了浏览器会话结束。 在一个会话的多个请求中共享数据，这就是会话跟踪技术。例如在一个会话中的请求如下： 请求银行主页 请求登录（请求参数是用户名和密码） 请求转账（请求参数与转账相关的数据） 请求信誉卡还款（请求参数与还款相关的数据） 在这个会话中当前用户信息必须在这个会话中共享的，因为登录的是张三，那么在转账和还款时一定是相对张三的转账和还款！这就说明我们必须在一个会话过程中有共享数据的能力 1.2 会话路径技术使用Cookie或Session完成我们知道HTTP协议是无状态协议，也就是说每个请求都是独立的！无法记录前一次请求的状态。但HTTP协议中可以使用Cookie来完成会话跟踪！ 在JavaWeb中，使用Session来完成会话跟踪，Session底层依赖Cookie技术 2. Cookie2.1 什么叫CookieCookie翻译成中文是小甜点，小饼干的意思。在HTTP中它表示服务器送给客户端浏览器的小甜点。其实Cookie就是一个键和一个值构成的，随着服务器端的响应发送给客户端浏览器。然后客户端浏览器会把Cookie保存起来，当下一次再访问服务器时把Cookie再发送给服务器。 Cookie是HTTP协议的规范之一，它是服务器和客户端之间传输的小数据 首先由服务器通过响应头把Cookie传输给客户端，客户端会将Cookie保存起来 当客户端再次请求同一服务器时，客户端会在请求头中添加该服务器保存的Cookie，发送给服务器 Cookie就是服务器保存在客户端的数据 Cookie就是一个键值对 Cookie是由服务器创建，然后通过响应发送给客户端的一个键值对。客户端会保存Cookie，并会标注出Cookie的来源（哪个服务器的Cookie）。当客户端向服务器发出请求时会把所有这个服务器Cookie包含在请求中发送给服务器，这样服务器就可以识别客户端了！ Cookie类的常用方法 方法声明 功能描述 Cookie(String name, String value) 构造方法 getName() 获取Cookie的名称 setValue() 设置Cookie的值 getValue() 获取Cookie的值 setPath() 设置Cookie项的有效目录路径 getPath() 获取Cookie的路径 setDomain() 设置Cookie的有效域 setMaxAge() 设置Cookie在浏览器上保持的时间，以秒为单位 getMaxAge() 获取Cookie在浏览器上保持的秒数 setVersion() 设置Cookie采用的协议版本 getVersion() 获取Cookie采用的协议版本 setComment() 设置Cookie的注解部分 getComment() 获取Cookie的注解 setSecure() 设置Cookie是否使用安全的协议传送 getSecure() 获取Cookie是否使用安全的协议传送 2.2 Cookie的用途 服务器使用Cookie来跟踪客户端状态！ 保存购物车(购物车中的商品不能使用request保存，因为它是一个用户向服务器发送的多个请求信息) 显示上次登录名(也是一个用户多个请求) 2.3 Cookie规范 Cookie通过请求头和响应头在服务器与客户端之间传输 Cookie大小上限为4KB 一个服务器最多在客户端浏览器上保存20个Cookie 一个浏览器最多保存300个Cookie 上面的数据只是HTTP的Cookie规范，但在浏览器大战的今天，一些浏览器为了打败对手，为了展现自己的能力起见，可能对Cookie规范“扩展”了一些，例如每个Cookie的大小为8KB，最多可保存500个Cookie等！但也不会出现把你硬盘占满的可能！ 注意，不同浏览器之间是不共享Cookie的。也就是说在你使用IE访问服务器时，服务器会把Cookie发给IE，然后由IE保存起来，当你在使用FireFox访问服务器时，不可能把IE保存的Cookie发送给服务器。 2.4 Cookie与HTTP头Cookie是通过HTTP请求和响应头在客户端和服务器端传递的： Cookie：请求头，客户端发送给服务器端 格式：Cookie: a=A; b=B; c=C。即多个Cookie用分号离开 Set-Cookie：响应头，服务器端发送给客户端 一个Cookie对象一个Set-Cookie： 123Set-Cookie: a=ASet-Cookie: b=BSet-Cookie: c=C 2.5 Cookie的覆盖如果服务器端发送重复的Cookie那么会覆盖原有的Cookie，例如客户端的第一个请求服务器端发送的Cookie是：Set-Cookie: a=A；第二请求服务器端发送的是：Set-Cookie: a=AA，那么客户端只留下一个Cookie，即：a=AA 2.6 Cookie第一例我们这个案例是，客户端访问AServlet，AServlet在响应中添加Cookie，浏览器会自动保存Cookie。然后客户端访问BServlet，这时浏览器会自动在请求中带上Cookie，BServlet获取请求中的Cookie打印出来 AServlet.java123456789101112131415161718192021222324252627package cn.itcast.servlet;import java.io.IOException;import java.util.UUID;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 给客户端发送Cookie * @author Administrator * */public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); String id = UUID.randomUUID().toString();//生成一个随机字符串 Cookie cookie = new Cookie("id", id);//创建Cookie对象，指定名字和值 response.addCookie(cookie);//在响应中添加Cookie对象 response.getWriter().print("已经给你发送了ID"); &#125;&#125; BServlet.java123456789101112131415161718192021222324252627282930package cn.itcast.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 获取客户端请求中的Cookie * @author Administrator * */public class BServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); Cookie[] cs = request.getCookies();//获取请求中的Cookie if(cs != null) &#123;//如果请求中存在Cookie for(Cookie c : cs) &#123;//遍历所有Cookie if(c.getName().equals("id")) &#123;//获取Cookie名字，如果Cookie名字是id response.getWriter().print("您的ID是：" + c.getValue());//打印Cookie值 &#125; &#125; &#125; &#125;&#125; 2.7 Cookie的生命2.7.1 什么是Cookie的生命Cookie不只是有name和value，Cookie还是生命。所谓生命就是Cookie在客户端的有效时间，可以通过setMaxAge(int)来设置Cookie的有效时间 cookie.setMaxAge(-1)：cookie的maxAge属性的默认值就是-1，表示只在浏览器内存中存活。一旦关闭浏览器窗口，那么cookie就会消失 cookie.setMaxAge(60*60)：表示cookie对象可存活1小时。当生命大于0时，浏览器会把Cookie保存到硬盘上，就算关闭浏览器，就算重启客户端电脑，cookie也会存活1小时 cookie.setMaxAge(0)：cookie生命等于0是一个特殊的值，它表示cookie被作废！也就是说，如果原来浏览器已经保存了这个Cookie，那么可以通过Cookie的setMaxAge(0)来删除这个Cookie。无论是在浏览器内存中，还是在客户端硬盘上都会删除这个Cookie 2.7.2 浏览器查看Cookie下面是浏览器查看Cookie的方式： IE查看Cookie文件的路径：C:\Documents and Settings\Administrator\Cookies FireFox查看Cookie Google查看Cookie 2.7.3 案例：显示上次访问时间 创建Cookie，名为lasttime，值为当前时间，添加到response中 在AServlet中获取请求中名为lasttime的Cookie 如果不存在输出“您是第一次访问本站”，如果存在输出“您上一次访问本站的时间是xxx” AServlet.java1234567891011121314151617181920public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("text/html;charset=utf-8"); Cookie cookie = new Cookie("lasttime", new Date().toString()); cookie.setMaxAge(60 * 60); response.addCookie(cookie); Cookie[] cs = request.getCookies(); String s = "您是首次访问本站！"; if(cs != null) &#123; for(Cookie c : cs) &#123; if(c.getName().equals("lasttime")) &#123; s = "您上次的访问时间是：" + c.getValue(); &#125; &#125; &#125; response.getWriter().print(s); &#125; 3. Cookie的path3.1 什么是Cookie的路径现在有WEB应用A，向客户端发送了10个Cookie，这就说明客户端无论访问应用A的哪个Servlet都会把这10个Cookie包含在请求中！但是也许只有AServlet需要读取请求中的Cookie，而其他Servlet根本就不会获取请求中的Cookie。这说明客户端浏览器有时发送这些Cookie是多余的！ 可以通过设置Cookie的path来指定浏览器，在访问什么样的路径时，包含什么样的Cookie 3.2 Cookie路径与请求路径的关系下面我们来看看Cookie路径的作用：下面是客户端浏览器保存的3个Cookie的路径： a: /cookietestb: /cookietest/servletc: /cookietest/jsp 下面是浏览器请求的URL： A: http://localhost:8080/cookietest/AServletB: http://localhost:8080/cookietest/servlet/BServletC: http://localhost:8080/cookietest/jsp/CServlet 请求A时，会在请求中包含a 请求B时，会在请求中包含a、b 请求C时，会在请求中包含a、c 也就是说，请求路径如果包含了Cookie路径，那么会在请求中包含这个Cookie，否则不会请求中不会包含这个Cookie A请求的URL包含了“/cookietest”，所以会在请求中包含路径为“/cookietest”的Cookie B请求的URL包含了“/cookietest”，以及“/cookietest/servlet”，所以请求中包含路径为“/cookietest”和“/cookietest/servlet”两个Cookie C请求的URL包含了“/cookietest”，以及“/cookietest/jsp”，所以请求中包含路径为“/cookietest”和“/cookietest/jsp”两个Cookie 3.3 设置Cookie的路径设置Cookie的路径需要使用setPath()方法，例如：1cookie.setPath(“/cookietest/servlet”); 如果没有设置Cookie的路径，那么Cookie路径的默认值为当前访问资源所在路径，例如： 访问 http://localhost:8080/cookietest/AServlet 时添加的Cookie默认路径为/cookietest 访问 http://localhost:8080/cookietest/servlet/BServlet 时添加的Cookie默认路径为/cookietest/servlet 访问 http://localhost:8080/cookietest/jsp/BServlet 时添加的Cookie默认路径为/cookietest/jsp 4. Cookie的domainCookie的domain属性可以让网站中二级域共享Cookie，次要！百度你是了解的对吧！ http://www.baidu.comhttp://zhidao.baidu.comhttp://news.baidu.comhttp://tieba.baidu.com 现在我希望在这些主机之间共享Cookie（例如在www.baidu.com中响应的cookie，可以在news.baidu.com请求中包含）。很明显，现在不是路径的问题了，而是主机的问题，即域名的问题。处理这一问题其实很简单，只需要下面两步： 设置Cookie的path为“/”：c.setPath(“/”)； 设置Cookie的domain为“.baidu.com”：c.setDomain(“.baidu.com”) 当domain为“.baidu.com”时，无论前缀是什么，都会共享Cookie的。但是现在我们需要设置两个虚拟主机：www.baidu.com和news.baidu.com 第一步：设置windows的DNS路径解析 找到C:\WINDOWS\system32\drivers\etc\hosts文件，添加如下内容 123127.0.0.1 localhost127.0.0.1 www.baidu.com127.0.0.1 news.baidu.com 第二步：设置Tomcat虚拟主机 找到server.xml文件，添加&lt;Host&gt;元素，内容如下：123456 &lt;Host name="www.baidu.com" appBase="F:\webapps\www" unpackWARs="true" autoDeploy="true" xmlValidation="false" xmlNamespaceAware="false"/&gt;&lt;Host name="news.baidu.com" appBase="F:\webapps\news" unpackWARs="true" autoDeploy="true" xmlValidation="false" xmlNamespaceAware="false"/&gt; 第三步：创建A项目，创建AServlet，设置Cookie。 123456Cookie c = new Cookie("id", "baidu");c.setPath("/");c.setDomain(".baidu.com");c.setMaxAge(60*60);response.addCookie(c);response.getWriter().print("OK"); 把A项目的WebRoot目录复制到F:\webapps\www目录下，并把WebRoot目录的名字修改为ROOT 第四步：创建B项目，创建BServlet，获取Cookie，并打印出来。1234567Cookie[] cs = request.getCookies();if(cs != null) &#123; for(Cookie c : cs) &#123; String s = c.getName() + ": " + c.getValue() + "&lt;br/&gt;"; response.getWriter().print(s); &#125;&#125; 把B项目的WebRoot目录复制到F:\webapps\news目录下，并把WebRoot目录的名字修改为ROOT。 第五步：访问www.baidu.com\AServlet，然后再访问news.baidu.com\BServlet 5. Cookie中保存中文Cookie的name和value都不能使用中文，如果希望在Cookie中使用中文，那么需要先对中文进行URL编码，然后把编码后的字符串放到Cookie中 向客户端响应中添加Cookie12345String name = URLEncoder.encode("姓名", "UTF-8");String value = URLEncoder.encode("张三", "UTF-8");Cookie c = new Cookie(name, value);c.setMaxAge(3600);response.addCookie(c); 从客户端请求中获取Cookie12345678910response.setContentType("text/html;charset=utf-8"); Cookie[] cs = request.getCookies(); if(cs != null) &#123; for(Cookie c : cs) &#123; String name = URLDecoder.decode(c.getName(), "UTF-8"); String value = URLDecoder.decode(c.getValue(), "UTF-8"); String s = name + ": " + value + "&lt;br/&gt;"; response.getWriter().print(s); &#125; &#125; 6. 显示曾经浏览过的商品index.jsp 1234567891011121314151617181920212223&lt;body&gt; &lt;h1&gt;商品列表&lt;/h1&gt; &lt;a href="/day06_3/GoodServlet?name=ThinkPad"&gt;ThinkPad&lt;/a&gt;&lt;br/&gt; &lt;a href="/day06_3/GoodServlet?name=Lenovo"&gt;Lenovo&lt;/a&gt;&lt;br/&gt; &lt;a href="/day06_3/GoodServlet?name=Apple"&gt;Apple&lt;/a&gt;&lt;br/&gt; &lt;a href="/day06_3/GoodServlet?name=HP"&gt;HP&lt;/a&gt;&lt;br/&gt; &lt;a href="/day06_3/GoodServlet?name=SONY"&gt;SONY&lt;/a&gt;&lt;br/&gt; &lt;a href="/day06_3/GoodServlet?name=ACER"&gt;ACER&lt;/a&gt;&lt;br/&gt; &lt;a href="/day06_3/GoodServlet?name=DELL"&gt;DELL&lt;/a&gt;&lt;br/&gt; &lt;hr/&gt; 您浏览过的商品： &lt;% Cookie[] cs = request.getCookies(); if(cs != null) &#123; for(Cookie c : cs) &#123; if(c.getName().equals("goods")) &#123; out.print(c.getValue()); &#125; &#125; &#125; %&gt;&lt;/body&gt; GoodServlet12345678910111213141516171819202122public class GoodServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String goodName = request.getParameter("name"); String goods = CookieUtils.getCookValue(request, "goods"); if(goods != null) &#123; String[] arr = goods.split(", "); Set&lt;String&gt; goodSet = new LinkedHashSet(Arrays.asList(arr)); goodSet.add(goodName); goods = goodSet.toString(); goods = goods.substring(1, goods.length() - 1); &#125; else &#123; goods = goodName; &#125; Cookie cookie = new Cookie("goods", goods); cookie.setMaxAge(1 * 60 * 60 * 24); response.addCookie(cookie); response.sendRedirect("/day06_3/index.jsp"); &#125;&#125; CookieUtils1234567891011121314public class CookieUtils &#123; public static String getCookValue(HttpServletRequest request, String name) &#123; Cookie[] cs = request.getCookies(); if(cs == null) &#123; return null; &#125; for(Cookie c : cs) &#123; if(c.getName().equals(name)) &#123; return c.getValue(); &#125; &#125; return null; &#125;&#125; 7. HttpSession7.1 HttpSession概述7.1.1 什么是HttpSesssionjavax.servlet.http.HttpSession接口表示一个会话，我们可以把一个会话内需要共享的数据保存到HttSession对象中！ 7.1.2 获取HttpSession对象 HttpSession request.getSesssion()：如果当前会话已经有了session对象那么直接返回，如果当前会话还不存在会话，那么创建Session并返回 HttpSession request.getSession(boolean)：当参数为true时，与requeset.getSession()相同。如果参数为false，那么如果当前会话中存在Session则返回，不存在返回null 7.1.3 HttpSession是域对象我们已经学习过HttpServletRequest、ServletContext，它们都是域对象，现在我们又学习了一个HttpSession，它也是域对象。它们三个是Servlet中可以使用的域对象，而JSP中可以多使用一个域对象，明天我们再讲解JSP的第四个域对象 HttpServletRequest：一个请求创建一个request对象，所以在同一个请求中可以共享request，例如一个请求从AServlet转发到BServlet，那么AServlet和BServlet可以共享request域中的数据 ServletContext：一个应用只创建一个ServletContext对象，所以在ServletContext中的数据可以在整个应用中共享，只要不启动服务器，那么ServletContext中的数据就可以共享 HttpSession：一个会话创建一个HttpSession对象，同一会话中的多个请求中可以共享session中的数据 下面是session的域方法： void setAttribute(String name, Object value) 用来存储一个对象，也可以称之为存储一个域属性，例如：session.setAttribute(“xxx”, “XXX”)，在session中保存了一个域属性，域属性名称为xxx，域属性的值为XXX。请注意，如果多次调用该方法，并且使用相同的name，那么会覆盖上一次的值，这一特性与Map相同 Object getAttribute(String name) 用来获取session中的数据，当前在获取之前需要先去存储才行，例如：String value = (String) session.getAttribute(“xxx”);，获取名为xxx的域属性 void removeAttribute(String name)： 用来移除HttpSession中的域属性，如果参数name指定的域属性不存在，那么本方法什么都不做 Enumeration getAttributeNames()：获取所有域属性的名称 7.2 登录案例 需要的页面： login.jsp：登录页面，提供登录表单 index1.jsp：主页，显示当前用户名称，如果没有登录，显示您还没登录 index2.jsp：主页，显示当前用户名称，如果没有登录，显示您还没登录 Servlet： LoginServlet：在login.jsp页面提交表单时，请求本Servlet。在本Servlet中获取用户名、密码进行校验，如果用户名、密码错误，显示“用户名或密码错误”，如果正确保存用户名session中，然后重定向到index1.jsp 当用户没有登录时访问index1.jsp或index2.jsp，显示“您还没有登录”。如果用户在login.jsp登录成功后到达index1.jsp页面会显示当前用户名，而且不用再次登录去访问index2.jsp也会显示用户名。因为多次请求在一个会话范围，index1.jsp和index2.jsp都会到session中获取用户名，session对象在一个会话中是相同的，所以都可以获取到用户名！ login.jsp1234567891011121314151617&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;login.jsp&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;login.jsp&lt;/h1&gt; &lt;hr/&gt; &lt;form action="/day06_4/LoginServlet" method="post"&gt; 用户名：&lt;input type="text" name="username" /&gt;&lt;br/&gt; &lt;input type="submit" value="Submit"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; index1.jsp12345678910111213141516171819202122&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;index1.jsp&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;h1&gt;index1.jsp&lt;/h1&gt;&lt;% String username = (String)session.getAttribute("username"); if(username == null) &#123; out.print("您还没有登录！"); &#125; else &#123; out.print("用户名：" + username); &#125;%&gt;&lt;hr/&gt;&lt;a href="/day06_4/index2.jsp"&gt;index2&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; index2.jsp12345678910111213141516171819202122&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;index2.jsp&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;h1&gt;index2.jsp&lt;/h1&gt;&lt;% String username = (String)session.getAttribute("username"); if(username == null) &#123; out.print("您还没有登录！"); &#125; else &#123; out.print("用户名：" + username); &#125;%&gt;&lt;hr/&gt;&lt;a href="/day06_4/index1.jsp"&gt;index1&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; LoginServlet1234567891011121314151617public class LoginServlet extends HttpServlet &#123; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); String username = request.getParameter("username"); if(username.equalsIgnoreCase("itcast")) &#123; response.getWriter().print("用户名或密码错误！"); &#125; else &#123; HttpSession session = request.getSession(); session.setAttribute("username", username); response.sendRedirect("/day06_4/index1.jsp"); &#125; &#125;&#125; 7.3 Session的实现原理session底层是依赖Cookie的！我们来理解一下session的原理吧！ 当我首次去银行时，因为还没有账号，所以需要开一个账号，我获得的是银行卡，而银行这边的数据库中留下了我的账号，我的钱是保存在银行的账号中，而我带走的是我的卡号 当我再次去银行时，只需要带上我的卡，而无需再次开一个账号了。只要带上我的卡，那么我在银行操作的一定是我的账号 当首次使用session时，服务器端要创建session，session是保存在服务器端，而给客户端的session的id（一个cookie中保存了sessionId）。客户端带走的是sessionId，而数据是保存在session中 当客户端再次访问服务器时，在请求中会带上sessionId，而服务器会通过sessionId找到对应的session，而无需再创建新的session session是依赖Cookie实现的。session是服务器端对象 当用户第一次使用session时（表示第一次请求服务器），服务器会创建session，并创建一个Cookie，在Cookie中保存了session的id，发送给客户端。这样客户端就有了自己session的id了。但这个Cookie只在浏览器内存中存在，也就是说，在关闭浏览器窗口后，Cookie就会丢失，也就丢失了sessionId。 每一个session都有一个32位长的字符串用来作id，id是它的身份证号码 当用户第二次访问服务器时，会在请求中把保存了sessionId的Cookie发送给服务器，服务器通过sessionId查找session对象，然后给使用。也就是说，只要浏览器容器不关闭，无论访问服务器多少次，使用的都是同一个session对象。这样也就可以让多个请求共享同一个session了。 当用户关闭了浏览器窗口后，再打开浏览器访问服务器，这时请求中没有了sessionId，那么服务器会创建一个session，再把sessionId通过Cookie保存到浏览器中，也是一个新的会话开始了。原来的session会因为长时间无法访问而失效。 当用户打开某个服务器页面长时间没动作时，这样session会超时失效，当用户再有活动时，服务器通过用户提供的sessionId已经找不到session对象了，那么服务器还是会创建一个新的session对象，再把新的sessionId保存到客户端。这也是一个新的会话开始了。 7.4 Session与浏览器session保存在服务器，而sessionId通过Cookie发送给客户端，但这个Cookie的生命不为-1，即只在浏览器内存中存在，也就是说如果用户关闭了浏览器，那么这个Cookie就丢失了 当用户再次打开浏览器访问服务器时，就不会有sessionId发送给服务器，那么服务器会认为你没有session，所以服务器会创建一个session，并在响应中把sessionId保存到Cookie中发送给客户端 你可能会说，那原来的session对象会怎样？当一个session长时间没人使用的话，服务器会把session删除了！这个时长在Tomcat中配置是30分钟，可以在${CATALANA}/conf/web.xml找到这个配置，当然你也可以在自己的web.xml中覆盖这个配置！ web.xml123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; session失效时间也说明一个问题！如果你打开网站的一个页面开始长时间不动，超出了30分钟后，再去点击链接或提交表单时你会发现，你的session已经丢失了 7.5 Session其他常用API 返回值 方法 功能描述 String getId() 获取sessionId int getMaxInactiveInterval() 获取session可以的最大不活动时间（秒），默认为30分钟。当session在30分钟内没有使用，那么Tomcat会在session池中移除这个session void setMaxInactiveInterval() 设置session允许的最大不活动时间（秒），如果设置为1秒，那么只要session在1秒内不被使用，那么session就会被移除 long getCreationTime() 返回session的创建时间，返回值为当前时间的毫秒值 long getLastAccessedTime() 返回session的最后活动时间，返回值为当前时间的毫秒值 void invalidate() 让session失效！调用这个方法会被session失效，当session失效后，客户端再次请求，服务器会给客户端创建一个新的session，并在响应中给客户端新session的sessionId boolean isNew() 查看session是否为新。当客户端第一次请求时，服务器为客户端创建session，但这时服务器还没有响应客户端，也就是还没有把sessionId响应给客户端时，这时session的状态为新 7.6 URL重写我们知道session依赖Cookie，那么session为什么依赖Cookie呢？因为服务器需要在每次请求中获取sessionId，然后找到客户端的session对象。那么如果客户端浏览器关闭了Cookie呢？那么session是不是就会不存在了呢？ 其实还有一种方法让服务器收到的每个请求中都带有sessioinId，那就是URL重写！在每个页面中的每个链接和表单中都添加名为jsessionid的参数，值为当前sessionid。当用户点击链接或提交表单时服务器也可以通过获取jsessionid这个参数来得到客户端的sessionId，找到sessoin对象。 index.jsp12345678 &lt;body&gt;&lt;h1&gt;URL重写&lt;/h1&gt;&lt;a href='/day06_5/index.jsp;jsessionid=&lt;%=session.getId() %&gt;' &gt;主页&lt;/a&gt;&lt;form action='/day06_5/index.jsp;jsessionid=&lt;%=session.getId() %&gt;' method="post"&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; &lt;/body&gt; 也可以使用response.encodeURL()对每个请求的URL处理，这个方法会自动追加jsessionid参数，与上面我们手动添加是一样的效果。12345&lt;a href='&lt;%=response.encodeURL("/day06_5/index.jsp") %&gt;' &gt;主页&lt;/a&gt;&lt;form action='&lt;%=response.encodeURL("/day06_5/index.jsp") %&gt;' method="post"&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 使用response.encodeURL()更加“智能”，它会判断客户端浏览器是否禁用了Cookie，如果禁用了，那么这个方法在URL后面追加jsessionid，否则不会追加。 8. 案例：一次性图片验证码8.1 验证码有啥用在我们注册时，如果没有验证码的话，我们可以使用URLConnection来写一段代码发出注册请求。甚至可以使用while(true)来注册！那么服务器就废了！ 验证码可以去识别发出请求的是人还是程序！当然，如果聪明的程序可以去分析验证码图片！但分析图片也不是一件容易的事，因为一般验证码图片都会带有干扰线，人都看不清，那么程序一定分析不出来。 8.2 VerifyCode类现在我们已经有了cn.itcast.utils.VerifyCode类，这个类可以生成验证码图片！下面来看一个小例子123456789101112public void fun1() throws IOException &#123; // 创建验证码类 VerifyCode vc = new VerifyCode(); // 获取随机图片 BufferedImage image = vc.getImage(); // 获取刚刚生成的随机图片上的文本 String text = vc.getText(); System.out.println(text); // 保存图片 FileOutputStream out = new FileOutputStream("F:/xxx.jpg"); VerifyCode.output(image, out); &#125; 8.3 在页面中显示动态图片我们需要写一个VerifyCodeServlet，在这个Servlet中我们生成动态图片，然后它图片写入到response.getOutputStream()流中！然后让页面的&lt;img&gt;元素指定这个VerifyCodServlet即可1234567891011VerifyCodeServletpublic class VerifyCodeServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; VerifyCode vc = new VerifyCode(); BufferedImage image = vc.getImage(); String text = vc.getText(); System.out.println("text:" + text); VerifyCode.output(image, response.getOutputStream()); &#125;&#125; index.jsp123456789101112&lt;script type="text/javascript"&gt; function _change() &#123; var imgEle = document.getElementById("vCode"); imgEle.src = "/day06_6/VerifyCodeServlet?" + new Date().getTime(); &#125; &lt;/script&gt;... &lt;body&gt; &lt;h1&gt;验证码&lt;/h1&gt; &lt;img id="vCode" src="/day06_6/VerifyCodeServlet"/&gt; &lt;a href="javascript:_change()"&gt;看不清，换一张&lt;/a&gt; &lt;/body&gt; 8.4 在注册页面中使用验证码12345678&lt;form action="/day06_6/RegistServlet" method="post"&gt; 用户名：&lt;input type="text" name="username"/&gt;&lt;br/&gt; 验证码：&lt;input type="text" name="code" size="3"/&gt; &lt;img id="vCode" src="/day06_6/VerifyCodeServlet"/&gt; &lt;a href="javascript:_change()"&gt;看不清，换一张&lt;/a&gt; &lt;br/&gt; &lt;input type="submit" value="Submit"/&gt; &lt;/form&gt; 8.5 RegistServlet修改VerifyCodeServlet123456789public class VerifyCodeServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; VerifyCode vc = new VerifyCode(); BufferedImage image = vc.getImage(); request.getSession().setAttribute("vCode", vc.getText()); VerifyCode.output(image, response.getOutputStream()); &#125;&#125; RegistServlet123456789101112131415161718public class RegistServlet extends HttpServlet &#123; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); String username = request.getParameter("username"); String vCode = request.getParameter("code"); String sessionVerifyCode = (String)request.getSession().getAttribute("vCode"); if(vCode.equalsIgnoreCase(sessionVerifyCode)) &#123; response.getWriter().print(username + ", 恭喜！注册成功！"); &#125; else &#123; response.getWriter().print("验证码错误！"); &#125; &#125;&#125; 8.6 总结验证码案例VerifyCodeServlet： 生成验证码：VerifyCode vc = new VerifyCode(); BufferedImage image = vc.getImage() 在session中保存验证码文本：request.getSession.getAttribute(“vCode”, vc.getText()) 把验证码输出到页面：VerifyCode.output(image, response.getOutputStream) regist.jsp： 表单中包含username和code字段 在表单中给出&lt;img&gt;指向VerifyCodeServlet，用来在页面中显示验证码图片 提供“看不清，换一张”链接，指向_change()函数 提交到RegistServlet RegistServlet： 获取表单中的username和code 获取session中的vCode 比较code和vCode是否相同 相同说明用户输入的验证码正确，否则输入验证码错误]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>会话</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaMail邮件开发]]></title>
    <url>%2F2017%2F05%2F01%2Fjavaweb%2FJavaMail%2F</url>
    <content type="text"><![CDATA[1. 邮件协议1.1 收发邮件发邮件大家都会吧！发邮件是从客户端把邮件发送到邮件服务器，收邮件是把邮件服务器的邮件下载到客户端。 我们在163、126、QQ、sohu、sina等网站注册的Email账户，其实就是在邮件服务器中注册的。这些网站都有自己的邮件服务器。 1.2 邮件协议概述与HTTP协议相同，收发邮件也是需要有传输协议的。 SMTP：（Simple Mail Transfer Protocol，简单邮件传输协议）发邮件协议； POP3：（Post Office Protocol Version 3，邮局协议第3版）收邮件协议； IMAP：（Internet Message Access Protocol，因特网消息访问协议）收发邮件协议，我们的课程不涉及该协议。 1.3 理解邮件收发过程其实你可以把邮件服务器理解为邮局！如果你需要给朋友寄一封信，那么你需要把信放到邮筒中，这样你的信会“自动”到达邮局，邮局会把信邮到另一个省市的邮局中。然后这封信会被送到收信人的邮箱中。最终收信人需要自己经常查看邮箱是否有新的信件。 其实每个邮件服务器都由SMTP服务器和POP3服务器构成，其中SMTP服务器负责发邮件的请求，而POP3负责收邮件的请求。 当然，有时我们也会使用163的账号，向126的账号发送邮件。这时邮件是发送到126的邮件服务器，而对于163的邮件服务器是不会存储这封邮件的。 1.4 邮件服务器名称smtp服务器的端口号为25，服务器名称为smtp.xxx.xxx。pop3服务器的端口号为110，服务器名称为pop3.xxx.xxx。 例如： 163：smtp.163.com和pop3.163.com； 126：smtp.126.com和pop3.126.com； qq：smtp.qq.com和pop3.qq.com； sohu：smtp.sohu.com和pop3.sohu.com； sina：smtp.sina.com和pop3.sina.com。 2. Telnet收发邮件 Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法 2.1 BASE64加密BASE64是一种加密算法，这种加密方式是可逆的！它的作用是使加密后的文本无法用肉眼识别。Java提供了sun.misc.BASE64Encoder这个类，用来对做Base64的加密和解密，但我们知道，使用sun包下的东西会有警告！甚至在eclipse中根本使用不了这个类（需要设置），所以我们还是听sun公司的话，不要去使用它内部使用的类，我们去使用apache commons组件中的codec包下的Base64这个类来完成BASE64加密和解密。 1234567891011121314151617181920212223242526272829303132package cn.itcast;import org.apache.commons.codec.binary.Base64;public class Base64Utils &#123; public static String encode(String s) &#123; return encode(s, "utf-8"); &#125; public static String decode(String s) &#123; return decode(s, "utf-8"); &#125; public static String encode(String s, String charset) &#123; try &#123; byte[] bytes = s.getBytes(charset); bytes = Base64.encodeBase64(bytes); return new String(bytes, charset); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public static String decode(String s, String charset) &#123; try &#123; byte[] bytes = s.getBytes(charset); bytes = Base64.decodeBase64(bytes); return new String(bytes, charset); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 2.2 telnet发邮件 Xshell是一个强大的安全终端模拟软件，它支持SSH1, SSH2, 以及Microsoft Windows 平台的TELNET 协议。Xshell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作 Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。 连接163的smtp服务器 连接成功后需要如下步骤才能发送邮件： (1)、与服务器打招呼：ehlo你的名字 (2)、发出登录请求：auth login (3)、输入加密后的邮箱名：(itcast_cxf@163.com)aXRjYXN0X2N4ZkAxNjMuY29t (4)、输入加密后的邮箱密码：(itcast)aXRjYXN0 (5)、输入谁来发送邮件，即from：mail from:&#x69;&#116;&#x63;&#97;&#x73;&#x74;&#95;&#x63;&#120;&#x66;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#x6f;&#x6d; (6)、输入把邮件发给谁，即to：rcpt to:&#105;&#116;&#x63;&#97;&#115;&#116;&#x5f;&#x63;&#x78;&#x66;&#64;&#x31;&#50;&#x36;&#46;&#99;&#x6f;&#109; (7)、发送填写数据请求：data (8)、开始输入数据，数据包含：from、to、subject，以及邮件内容，如果输入结束后，以一个“.”为一行，表示输入结束： 123456from:&lt;zhangBoZhi@163.com&gt;to:&lt;itcast_cxf@sina.com&gt;subject: 我爱上你了我已经深深的爱上你了，我是张柏芝。. 注意，在标题和邮件正文之间要有一个空行！当要退出时，一定要以一个“.”为单行，表示输入结束。 (9)、最后一步：quit 3. telnet收邮件3.1 telnet收邮件的步骤pop3无需使用Base64加密 收邮件连接的服务器是pop3.xxx.com，pop3协议的默认端口号是110。请注意！这与发邮件完全不同。如果你在163有邮箱账户，那么你想使用telnet收邮件，需要连接的服务器是pop3.163.com 连接pop3服务器：telnet pop3.163.com 110 命令 功能描述 user命令 user 用户名，例如：user itcast_cxf@163.com pass命令 pass 密码，例如：pass itcast stat命令 stat命令用来查看邮箱中邮件的个数，所有邮件所占的空间 list命令 list命令用来查看所有邮件，或指定邮件的状态，例如：list 1是查看第一封邮件的大小，list是查看邮件列表，即列出所有邮件的编号，及大小 retr命令 查看指定邮件的内容，例如：retr 1#是查看第一封邮件的内容 dele命令 标记某邮件为删除，但不是马上删除，而是在退出时才会真正删除 quit命令 退出！如果在退出之前已经使用dele命令标记了某些邮件，那么会在退出是删除它们 4. JavaMail4.1 JavaMail概述Java Mail是由SUN公司提供的专门针对邮件的API，主要Jar包：mail.jar、activation.jar。 在使用MyEclipse创建web项目时，需要小心！如果只是在web项目中使用java mail是没有什么问题的，发布到Tomcat上运行一点问题都没有！但是如果是在web项目中写测试那就出问题了。 在MyEclipse中，会自动给web项目导入javax.mail包中的类，但是不全（其实是只有接口，而没有接口的实现类），所以只靠MyEclipse中的类是不能运行java mail项目的，但是如果这时你再去自行导入mail.jar时，就会出现冲突。 处理方案：到下面路径中找到javaee.jar文件，把javax.mail删除！！！ D:\Program Files\MyEclipse\Common\plugins\com.genuitec.eclipse.j2eedt.core_10.0.0.me201110301321\data\libraryset\EE_5 4.2 JavaMail中主要类java mail中主要类：javax.mail.Session、javax.mail.internet.MimeMessage、javax.mail.Transport。 Session：表示会话，即客户端与邮件服务器之间的会话！想获得会话需要给出账户和密码，当然还要给出服务器名称。在邮件服务中的Session对象，就相当于连接数据库时的Connection对象。 MimeMessage：表示邮件类，它是Message的子类。它包含邮件的主题（标题）、内容，收件人地址、发件人地址，还可以设置抄送和暗送，甚至还可以设置附件。 Transport：用来发送邮件。它是发送器！ 4.3 JavaMail之Hello World在使用telnet发邮件时，还需要自己来处理Base64编码的问题，但使用JavaMail就不必理会这些问题了，都由JavaMail来处理。 第一步：获得Session 1Session session = Session.getInstance(Properties prop, Authenticator auth); 其中prop需要指定两个键值，一个是指定服务器主机名，另一个是指定是否需要认证！我们当然需要认证！ 123Properties prop = new Properties();prop.setProperty(“mail.host”, “smtp.163.com”);//设置服务器主机名prop.setProperty(“mail.smtp.auth”, “true”);//设置需要认证 其中Authenticator是一个接口表示认证器，即校验客户端的身份。我们需要自己来实现这个接口，实现这个接口需要使用账户和密码。 12345Authenticator auth = new Authenticator() &#123; public PasswordAuthentication getPasswordAuthentication () &#123; new PasswordAuthentication(“itcast_cxf”, “itcast”);//用户名和密码 &#125;&#125;; 通过上面的准备，现在可以获取得Session对象了： 1Session session = Session.getInstance(prop, auth); 第二步：创建MimeMessage对象创建MimeMessage需要使用Session对象来创建： 1MimeMessage msg = new MimeMessage(session); 然后需要设置发信人地址、收信人地址、主题，以及邮件正文。 123456msg.setFrom(new InternetAddress(“itcast_cxf@163.com”));//设置发信人msg.addRecipients(RecipientType.TO, “itcast_cxf@qq.com,itcast_cxf@sina.com”);//设置多个收信人msg.addRecipients(RecipientType.CC, “itcast_cxf@sohu.com,itcast_cxf@126.com”);//设置多个抄送msg.addRecipients(RecipientType.BCC, ”itcast_cxf@hotmail.com”);//设置暗送msg.setSubject(“这是一封测试邮件”);//设置主题（标题）msg.setContent(“当然是hello world!”, “text/plain;charset=utf-8”);//设置正文 第三步：发送邮件1Transport.send(msg);//发送邮件 4.4 JavaMail发送带有附件的邮件一封邮件可以包含正文、附件N个，所以正文与N个附件都是邮件的一个部份。 上面的hello world案例中，只是发送了带有正文的邮件！所以在调用setContent()方法时直接设置了正文，如果想发送带有附件邮件，那么需要设置邮件的内容为MimeMultiPart。 12MimeMulitpart parts = new MimeMulitpart();//多部件对象，可以理解为是部件的集合msg.setContent(parts);//设置邮件的内容为多部件内容。 然后我们需要把正文、N个附件创建为“主体部件”对象（MimeBodyPart），添加到MimeMuiltPart中即可。 123MimeBodyPart part1 = new MimeBodyPart();//创建一个部件part1.setCotnent(“这是正文部分”, “text/html;charset=utf-8”);//给部件设置内容parts.addBodyPart(part1);//把部件添加到部件集中。 下面我们创建一个附件： 1234MimeBodyPart part2 = new MimeBodyPart();//创建一个部件part2.attachFile(“F:\\a.jpg”);//设置附件part2.setFileName(“hello.jpg”);//设置附件名称parts.addBodyPart(part2);//把附件添加到部件集中 注意，如果在设置文件名称时，文件名称中包含了中文的话，那么需要使用MimeUitlity类来给中文编码： 1part2.setFileName(MimeUitlity.encodeText(“美女.jpg”)); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class JavaMailDemo &#123; public void sendMail() throws Exception &#123; /* * 1. 得到session */ Properties props = new Properties(); props.setProperty("mail.host", "smtp.163.com"); props.setProperty("mail.smtp.auth", "true"); Authenticator auth = new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication("itcast_cxf", "itcast"); &#125; &#125;; Session session = Session.getInstance(props, auth); /* * 2. 创建MimeMessage */ MimeMessage msg = new MimeMessage(session); msg.setFrom(new InternetAddress("itcast_cxf@163.com"));//设置发件人 msg.setRecipients(RecipientType.TO, "itcast_cxf@126.com");//设置收件人 msg.setRecipients(RecipientType.CC, "itcast_cxf@sohu.com");//设置抄送 msg.setRecipients(RecipientType.BCC, "itcast_cxf@sina.com");//设置暗送 msg.setSubject("这是来自ITCAST的测试邮件"); msg.setContent("这就是一封垃圾邮件！", "text/html;charset=utf-8"); /* * 3. 发邮件 */ Transport.send(msg); &#125; /** * 带有附件的邮件！！！ */ public void sendMail2() throws Exception &#123; /* * 1. 得到session */ Properties props = new Properties(); props.setProperty("mail.host", "smtp.163.com"); props.setProperty("mail.smtp.auth", "true"); Authenticator auth = new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication("itcast_cxf", "itcast"); &#125; &#125;; Session session = Session.getInstance(props, auth); /* * 2. 创建MimeMessage */ MimeMessage msg = new MimeMessage(session); msg.setFrom(new InternetAddress("itcast_cxf@163.com"));//设置发件人 msg.setRecipients(RecipientType.TO, "itcast_cxf@126.com");//设置收件人 msg.setSubject("这是来自ITCAST的测试邮件有附件"); //////////////////////////////////////////////////////// /* * 当发送包含附件的邮件时，邮件体就为多部件形式！ * 1. 创建一个多部件的部件内容！MimeMultipart * MimeMultipart就是一个集合，用来装载多个主体部件！ * 2. 我们需要创建两个主体部件，一个是文本内容的，另一个是附件的。 * 主体部件叫MimeBodyPart * 3. 把MimeMultipart设置给MimeMessage的内容！ */ MimeMultipart list = new MimeMultipart();//创建多部分内容 // 创建MimeBodyPart MimeBodyPart part1 = new MimeBodyPart(); // 设置主体部件的内容 part1.setContent("这是一封包含附件的垃圾邮件", "text/html;charset=utf-8"); // 把主体部件添加到集合中 list.addBodyPart(part1); // 创建MimeBodyPart MimeBodyPart part2 = new MimeBodyPart(); part2.attachFile(new File("F:/f/白冰.jpg"));//设置附件的内容 //设置显示的文件名称，其中encodeText用来处理中文乱码问题 part2.setFileName(MimeUtility.encodeText("大美女.jpg")); list.addBodyPart(part2); msg.setContent(list);//把它设置给邮件作为邮件的内容。 //////////////////////////////////////////////////////// /* * 3. 发邮件 */ Transport.send(msg); &#125; public void sendMail3() throws Exception &#123; /* * 1. 得到session */ Session session = MailUtils.createSession("smtp.163.com", "itcast_cxf", "itcast"); /* * 2. 创建邮件对象 */ Mail mail = new Mail("itcast_cxf@163.com", "itcast_cxf@126.com,itcast_cxf@sina.com", "不是垃圾邮件能是什么呢？", "这里是正文"); /* * 创建两个附件对象 */ AttachBean ab1 = new AttachBean(new File("F:/f/白冰.jpg"), "小美女.jpg"); AttachBean ab2 = new AttachBean(new File("F:/f/big.jpg"), "我的羽绒服.jpg"); // 添加到mail中 mail.addAttach(ab1); mail.addAttach(ab2); /* * 3. 发送 */ MailUtils.send(session, mail); &#125;&#125; 5. MailUtils12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MailUtils &#123; public static Session createSession(String host, final String username, final String password) &#123; Properties prop = new Properties(); prop.setProperty("mail.host", host);// 指定主机 prop.setProperty("mail.smtp.auth", "true");// 指定验证为true // 创建验证器 Authenticator auth = new Authenticator() &#123; public PasswordAuthentication getPasswordAuthentication() &#123; return new PasswordAuthentication(username, password); &#125; &#125;; // 获取session对象 return Session.getInstance(prop, auth); &#125; /** * 发送指定的邮件 * * @param mail */ public static void send(Session session, final Mail mail) throws MessagingException, IOException &#123; MimeMessage msg = new MimeMessage(session);// 创建邮件对象 msg.setFrom(new InternetAddress(mail.getFrom()));// 设置发件人 msg.addRecipients(RecipientType.TO, mail.getToAddress());// 设置收件人 // 设置抄送 String cc = mail.getCcAddress(); if (!cc.isEmpty()) &#123; msg.addRecipients(RecipientType.CC, cc); &#125; // 设置暗送 String bcc = mail.getBccAddress(); if (!bcc.isEmpty()) &#123; msg.addRecipients(RecipientType.BCC, bcc); &#125; msg.setSubject(mail.getSubject());// 设置主题 MimeMultipart parts = new MimeMultipart();// 创建部件集对象 MimeBodyPart part = new MimeBodyPart();// 创建一个部件 part.setContent(mail.getContent(), "text/html;charset=utf-8");// 设置邮件文本内容 parts.addBodyPart(part);// 把部件添加到部件集中 /////////////////////////////////////////// // 添加附件 List&lt;AttachBean&gt; attachBeanList = mail.getAttachs();// 获取所有附件 if (attachBeanList != null) &#123; for (AttachBean attach : attachBeanList) &#123; MimeBodyPart attachPart = new MimeBodyPart();// 创建一个部件 attachPart.attachFile(attach.getFile());// 设置附件文件 attachPart.setFileName(MimeUtility.encodeText(attach .getFileName()));// 设置附件文件名 parts.addBodyPart(attachPart); &#125; &#125; msg.setContent(parts);// 给邮件设置内容 Transport.send(msg);// 发邮件 &#125;&#125;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>javamail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传下载文件]]></title>
    <url>%2F2017%2F05%2F01%2Fjavaweb%2F%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1. 文件上传概述1.1 文件上传的作用例如网络硬盘！就是用来上传下载文件的。在智联招聘上填写一个完整的简历还需要上传照片呢。 1.2 文件上传对页面的要求上传文件的要求比较多，需要记一下： 必须使用表单，而不能是超链接 表单的method必须是POST，而不能是GET 表单的enctype必须是multipart/form-data 在表单中添加file表单字段，即&lt;input type=”file” name=”xxx”/&gt; 12345678&lt;form action="$&#123;pageContext.request.contextPath &#125;/FileUploadServlet" method="post" enctype="multipart/form-data"&gt; 用户名：&lt;input type="text" name="username"/&gt;&lt;br/&gt; 文件1：&lt;input type="file" name="file1"/&gt;&lt;br/&gt; 文件2：&lt;input type="file" name="file2"/&gt;&lt;br/&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt; 1.3 比对文件上传表单和普通文本表单的区别通过httpWatch查看“文件上传表单”和“普通文本表单”的区别。 文件上传表单的enctype=”multipart/form-data”，表示多部件表单数据； 普通文本表单可以不设置enctype属性： 当method=”post”时，enctype的默认值为application/x-www-form-urlencoded，表示使用url编码正文 当method=”get”时，enctype的默认值为null，没有正文，所以就不需要enctype了 对普通文本表单的测试： 123456&lt;form action="$&#123;pageContext.request.contextPath &#125;/FileUploadServlet" method="post"&gt; 用户名：&lt;input type="text" name="username"/&gt;&lt;br/&gt; 文件1：&lt;input type="file" name="file1"/&gt;&lt;br/&gt; 文件2：&lt;input type="file" name="file2"/&gt;&lt;br/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 通过httpWatch测试，查看表单的请求数据正文，我们发现请求中只有文件名称，而没有文件内容。也就是说，当表单的enctype不是multipart/form-data时，请求中不包含文件内容，而只有文件的名称，这说明普通文本表单中input:file与input:text没什么区别了。 对文件上传表单的测试：12345678&lt;form action="$&#123;pageContext.request.contextPath &#125;/FileUploadServlet" method="post" enctype="multipart/form-data"&gt; 用户名：&lt;input type="text" name="username"/&gt;&lt;br/&gt; 文件1：&lt;input type="file" name="file1"/&gt;&lt;br/&gt; 文件2：&lt;input type="file" name="file2"/&gt;&lt;br/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 通过httpWatch测试，查看表单的请求数据正文部分，发现正文部分是由多个部件组成，每个部件对应一个表单字段，每个部件都有自己的头信息。头信息下面是空行，空行下面是字段的正文部分。多个部件之间使用随机生成的分隔线隔开 文本字段的头信息中只包含一条头信息，即Content-Disposition，这个头信息的值有两个部分，第一部分是固定的，即form-data，第二部分为字段的名称。在空行后面就是正文部分了，正文部分就是在文本框中填写的内容 文件字段的头信息中包含两条头信息，Content-Disposition和Content-Type。Content-Disposition中多出一个filename，它指定的是上传的文件名称。而Content-Type指定的是上传文件的类型。文件字段的正文部分就是文件的内容 请注意，因为我们上传的文件都是普通文本文件，即txt文件，所以在httpWatch中是可以正常显示的，如果上传的是exe、mp3等文件，那么在httpWatch看到的就是乱码了 1.4 文件上传对Servlet的要求当提交的表单是文件上传表单时，那么对Servlet也是有要求的。首先我们要肯定一点，文件上传表单的数据也是被封装到request对象中的。 request.getParameter(String)方法获取指定的表单字段字符内容，但文件上传表单已经不在是字符内容，而是字节内容，所以失效。 这时可以使用request的getInputStream()方法获取ServletInputStream对象，它是InputStream的子类，这个ServletInputStream对象对应整个表单的正文部分（从第一个分隔线开始，到最后），这说明我们需要的解析流中的数据。当然解析它是很麻烦的一件事情，而Apache已经帮我们提供了解析它的工具：commons-fileupload 可以尝试把request.getInputStream()这个流中的内容打印出来，再对比httpWatch中的请求数据123456public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; InputStream in = request.getInputStream(); String s = IOUtils.toString(in); System.out.println(s);&#125; 123456789101112131415-----------------------------7ddd3370ab2Content-Disposition: form-data; name=&quot;username&quot;hello-----------------------------7ddd3370ab2Content-Disposition: form-data; name=&quot;file1&quot;; filename=&quot;a.txt&quot;Content-Type: text/plainaaa-----------------------------7ddd3370ab2Content-Disposition: form-data; name=&quot;file2&quot;; filename=&quot;b.txt&quot;Content-Type: text/plainbbb-----------------------------7ddd3370ab2-- 2. commons-fileupload为什么使用fileupload： 上传文件的要求比较多，需要记一下： 必须是POST表单； 表单的enctype必须是multipart/form-data； 在表单中添加file表单字段，即&lt;input type=”file”…/&gt; Servlet的要求： 不能再使用request.getParameter()来获取表单数据 可以使用request.getInputStream()得到所有的表单数据，而不是一个表单项的数据 这说明不使用fileupload，我们需要自己来对request.getInputStream()的内容进行解析 2.1 fileupload概述fileupload是由apache的commons组件提供的上传组件。它最主要的工作就是帮我们解析request.getInputStream() fileupload组件需要的JAR包有： commons-fileupload.jar，核心包 commons-io.jar，依赖包 2.2 fileupload简单应用fileupload的核心类有：DiskFileItemFactory、ServletFileUpload、FileItem 使用fileupload组件的步骤如下： 12345678//1.创建工厂类DiskFileItemFactory对象DiskFileItemFactory factory = new DiskFileItemFactory();//2.使用工厂创建解析器对象ServletFileUpload fileUpload = new ServletFileUpload(factory);//3.使用解析器来解析request对象List&lt;FileItem&gt; list = fileUpload.parseRequest(request); 2.2.1 DiskFileItemFactory 磁盘文件项工厂类 public DiskFileItemFactory(int sizeThreshold, File repository)构造工厂时，指定内存缓冲区大小和临时文件存放位置 public void setSizeThreshold(int sizeThreshold)设置内存缓冲区大小，默认10K public void setRepository(File repository)设置临时文件存放位置，默认System.getProperty(“java.io.tmpdir”). 内存缓冲区： 上传文件时，上传文件的内容优先保存在内存缓冲区中，当上传文件大小超过缓冲区大小，就会在服务器端产生临时文件 临时文件存放位置： 保存超过了内存缓冲区大小上传文件而产生临时文件 ，产生临时文件可以通过 FileItem的delete()方法删除 2.2.2 FileItem 表示文件上传表单中 每个数据部分隆重介绍FileItem类，它才是我们最终要的结果。一个FileItem对象对应一个表单项（表单字段）。一个表单中存在文件字段和普通字段，可以使用FileItem类的isFormField()方法来判断表单字段是否为普通字段，如果不是普通字段，那么就是文件字段了 返回值 方法声明 功能描述 String getName() 获取文件字段的文件名称 String getString() 获取字段的内容，如果是文件字段，那么获取的是文件内容，当然上传的文件必须是文本文件 String getFieldName() 获取字段名称，例如：&lt;input type=”text” name=”username”/&gt;，返回的是username String getContentType() 获取上传的文件的类型，例如：text/plain int getSize() 获取上传文件的大小 boolean isFormField() 判断当前表单字段是否为普通文本字段，如果返回false，说明是文件字段 InputStream getInputStream() 获取上传文件对应的输入流 void write(File) 把上传的文件保存到指定文件中 void delete() 删除临时文件（删除时，必须要管理输入输出流） 注意事项：因为文件上传表单采用编码方式multipart/form-data 与传统url编码不同，所有getParameter ()方法不能使用 ，setCharacterEncoding()无法解决输入项乱码问题 2.2.3 ServletFileUpload 文件上传核心类 返回值 方法声明 功能描述 boolean isMultipartContent() 判断request的编码方式是否为multipart/form-data List parseRequest() 解析request，将请求体每个部分封装FileItem对象，返回List&lt;FileItem&gt; void setFileSizeMax(long) 设置单个文件上传大小，必须在解析开始之前调用 void setSizeMax(long) 设置总文件上传大小，必须在解析开始之前调用 void setHeaderEncoding() 设置编码集 解决上传文件名乱码 void setProgressListener() 设置文件上传监听器 （用来监控文件上传进度），上传时间、剩余大小、速度、剩余时间 2.3 简单上传示例写一个简单的上传示例： 表单包含一个用户名字段，以及一个文件字段； Servlet保存上传的文件到uploads目录，显示用户名，文件名，文件大小，文件类型。 第一步： 完成index.jsp，只需要一个表单。注意表单必须是post的，而且enctype必须是mulitpart/form-data的1234567&lt;form action="$&#123;pageContext.request.contextPath &#125;/FileUploadServlet" method="post" enctype="multipart/form-data"&gt; 用户名：&lt;input type="text" name="username"/&gt;&lt;br/&gt; 文件1：&lt;input type="file" name="file1"/&gt;&lt;br/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 第二步：完成FileUploadServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 因为要使用response打印，所以设置其编码 response.setContentType("text/html;charset=utf-8"); // 创建工厂 DiskFileItemFactory dfif = new DiskFileItemFactory(); // 使用工厂创建解析器对象 ServletFileUpload fileUpload = new ServletFileUpload(dfif); try &#123; // 使用解析器对象解析request，得到FileItem列表 List&lt;FileItem&gt; list = fileUpload.parseRequest(request); // 遍历所有表单项 for(FileItem fileItem : list) &#123; // 如果当前表单项为普通表单项 if(fileItem.isFormField()) &#123; // 获取当前表单项的字段名称 String fieldName = fileItem.getFieldName(); // 如果当前表单项的字段名为username if(fieldName.equals("username")) &#123; // 打印当前表单项的内容，即用户在username表单项中输入的内容 response.getWriter().print("用户名：" + fileItem.getString() + "&lt;br/&gt;"); &#125; &#125; else &#123;//如果当前表单项不是普通表单项，说明就是文件字段 String name = fileItem.getName();//获取上传文件的名称 // 如果上传的文件名称为空，即没有指定上传文件 if(name == null || name.isEmpty()) &#123; continue; &#125; // 获取真实路径，对应$&#123;项目目录&#125;/uploads，当然，这个目录必须存在 String savepath = this.getServletContext().getRealPath("/uploads"); // 通过uploads目录和文件名称来创建File对象 File file = new File(savepath, name); // 把上传文件保存到指定位置 fileItem.write(file); // 打印上传文件的名称 response.getWriter().print("上传文件名：" + name + "&lt;br/&gt;"); // 打印上传文件的大小 response.getWriter().print("上传文件大小：" + fileItem.getSize() + "&lt;br/&gt;"); // 打印上传文件的类型 response.getWriter().print("上传文件类型：" + fileItem.getContentType() + "&lt;br/&gt;"); &#125; &#125; &#125; catch (Exception e) &#123; throw new ServletException(e); &#125; &#125; 3. 文件上传之细节3.1 把上传的文件放到WEB-INF目录下如果没有把用户上传的文件存放到WEB-INF目录下，那么用户就可以通过浏览器直接访问上传的文件，这是非常危险的。 假如说用户上传了一个a.jsp文件，然后用户在通过浏览器去访问这个a.jsp文件，那么就会执行a.jsp中的内容，如果在a.jsp中有如下语句：Runtime.getRuntime().exec(“shutdown –s –t 1”);，那么你就会… 通常我们会在WEB-INF目录下创建一个uploads目录来存放上传的文件，而在Servlet中找到这个目录需要使用ServletContext的getRealPath(String)方法，例如在我的upload1项目中有如下语句： 12ServletContext servletContext = this.getServletContext();String savepath = servletContext.getRealPath(“/WEB-INF/uploads”); 其中savepath为：F:\tomcat6_1\webapps\upload1\WEB-INF\uploads。 3.2 文件名称（完整路径、文件名称）上传文件名称可能是完整路径： IE6获取的上传文件名称是完整路径，而其他浏览器获取的上传文件名称只是文件名称而已。浏览器差异的问题我们还是需要处理一下的12String name = file1FileItem.getName();response.getWriter().print(name); 使用不同浏览器测试，其中IE6就会返回上传文件的完整路径，不知道IE6在搞什么，这给我们带来了很大的麻烦，就是需要处理这一问题。 处理这一问题也很简单，无论是否为完整路径，我们都去截取最后一个“\”后面的内容就可以了123456String name = file1FileItem.getName();int lastIndex = name.lastIndexOf("\\");//获取最后一个“\”的位置if(lastIndex != -1) &#123;//注意，如果不是完整路径，那么就不会有“\”的存在。 name = name.substring(lastIndex + 1);//获取文件名称&#125;response.getWriter().print(name); 3.3 中文乱码问题上传文件名称中包含中文： 当上传的文件名称中包含中文时，需要设置编码，commons-fileupload组件为我们提供了两种设置编码的方式： request.setCharacterEncoding(String)：这种方式是我们最为熟悉的方式了 fileUpload.setHeaderEncdoing(String)：这种方式的优先级高与前一种 上传文件的文件内容包含中文： 通常我们不需关心上传文件的内容，因为我们会把上传文件保存到硬盘上！也就是说，文件原来是什么样子，到服务器这边还是什么样子！ 但是如果你有这样的需求，非要在控制台显示上传的文件内容，那么你可以使用fileItem.getString(“utf-8”)来处理编码 文本文件内容和普通表单项内容使用FileItem类的getString(“utf-8”)来处理编码。 3.4 上传文件同名问题（文件重命名）通常我们会把用户上传的文件保存到uploads目录下，但如果用户上传了同名文件呢？这会出现覆盖的现象。处理这一问题的手段是使用UUID生成唯一名称，然后再使用“_”连接文件上传的原始名称 例如用户上传的文件是“我的一寸照片.jpg”，在通过处理后，文件名称为：“891b3881395f4175b969256a3f7b6e10_我的一寸照片.jpg”，这种手段不会使文件丢失扩展名，并且因为UUID的唯一性，上传的文件同名，但在服务器端是不会出现同名问题的 123456789101112131415161718192021222324252627282930313233public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); DiskFileItemFactory dfif = new DiskFileItemFactory(); ServletFileUpload fileUpload = new ServletFileUpload(dfif); try &#123; List&lt;FileItem&gt; list = fileUpload.parseRequest(request); //获取第二个表单项，因为第一个表单项是username，第二个才是file表单项 FileItem fileItem = list.get(1); String name = fileItem.getName();//获取文件名称 // 如果客户端使用的是IE6，那么需要从完整路径中获取文件名称 int lastIndex = name.lastIndexOf("\\"); if(lastIndex != -1) &#123; name = name.substring(lastIndex + 1); &#125; // 获取上传文件的保存目录 String savepath = this.getServletContext().getRealPath("/WEB-INF/uploads"); String uuid = CommonUtils.uuid();//生成uuid String filename = uuid + "_" + name;//新的文件名称为uuid + 下划线 + 原始名称 //创建file对象，下面会把上传文件保存到这个file指定的路径 //savepath，即上传文件的保存目录 //filename，文件名称 File file = new File(savepath, filename); // 保存文件 fileItem.write(file); &#125; catch (Exception e) &#123; throw new ServletException(e); &#125; &#125; 3.5 一个目录不能存放过多的文件（存放目录打散）一个目录下不应该存放过多的文件，一般一个目录存放1000个文件就是上限了，如果在多，那么打开目录时就会很“卡”。你可以尝试打印C:\WINDOWS\system32目录，你会感觉到的 也就是说，我们需要把上传的文件放到不同的目录中。但是也不能为每个上传的文件一个目录，这种方式会导致目录过多。所以我们应该采用某种算法来“打散”！ 打散的方法有很多，例如使用日期来打散，每天生成一个目录。也可以使用文件名的首字母来生成目录，相同首字母的文件放到同一目录下。 日期打散算法：如果某一天上传的文件过多，那么也会出现一个目录文件过多的情况；首字母打散算法：如果文件名是中文的，因为中文过多，所以会导致目录过多的现象。 我们这里使用hash算法来打散： 获取文件名称的hashCode：int hCode = name.hashCode() 获取hCode的低4位，然后转换成16进制字符 获取hCode的5~8位，然后转换成16进制字符 使用这两个16进制的字符生成目录链。例如低4位字符为“5” 这种算法的好处是，在uploads目录下最多生成16个目录，而每个目录下最多再生成16个目录，即256个目录，所有上传的文件都放到这256个目录下。如果每个目录上限为1000个文件，那么一共可以保存256000个文件 例如上传文件名称为：新建 文本文档.txt，那么把“新建 文本文档.txt”的哈希码获取到，再获取哈希码的低4位，和5~8位。假如低4位为：9，5~8位为1，那么文件的保存路径为uploads/9/1/ 123456789int hCode = name.hashCode();//获取文件名的hashCode//获取hCode的低4位，并转换成16进制字符串String dir1 = Integer.toHexString(hCode &amp; 0xF);//获取hCode的低5~8位，并转换成16进制字符串String dir2 = Integer.toHexString(hCode &gt;&gt;&gt; 4 &amp; 0xF);//与文件保存目录连接成完整路径savepath = savepath + "/" + dir1 + "/" + dir2;//因为这个路径可能不存在，所以创建成File对象，再创建目录链，确保目录在保存文件之前已经存在new File(savepath).mkdirs(); 3.6 上传的单个文件的大小限制限制上传文件的大小很简单，ServletFileUpload类的setFileSizeMax(long)就可以了。参数就是上传文件的上限字节数，例如servletFileUpload.setFileSizeMax(1024*10)表示上限为10KB。 一旦上传的文件超出了上限，那么就会抛出FileUploadBase.FileSizeLimitExceededException异常。我们可以在Servlet中获取这个异常，然后向页面输出“上传的文件超出限制”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); DiskFileItemFactory dfif = new DiskFileItemFactory(); ServletFileUpload fileUpload = new ServletFileUpload(dfif); // 设置上传的单个文件的上限为10KB fileUpload.setFileSizeMax(1024 * 10); try &#123; List&lt;FileItem&gt; list = fileUpload.parseRequest(request); //获取第二个表单项，因为第一个表单项是username，第二个才是file表单项 FileItem fileItem = list.get(1); String name = fileItem.getName();//获取文件名称 // 如果客户端使用的是IE6，那么需要从完整路径中获取文件名称 int lastIndex = name.lastIndexOf("\\"); if(lastIndex != -1) &#123; name = name.substring(lastIndex + 1); &#125; // 获取上传文件的保存目录 String savepath = this.getServletContext().getRealPath("/WEB-INF/uploads"); String uuid = CommonUtils.uuid();//生成uuid String filename = uuid + "_" + name;//新的文件名称为uuid + 下划线 + 原始名称 int hCode = name.hashCode();//获取文件名的hashCode //获取hCode的低4位，并转换成16进制字符串 String dir1 = Integer.toHexString(hCode &amp; 0xF); //获取hCode的低5~8位，并转换成16进制字符串 String dir2 = Integer.toHexString(hCode &gt;&gt;&gt; 4 &amp; 0xF); //与文件保存目录连接成完整路径 savepath = savepath + "/" + dir1 + "/" + dir2; //因为这个路径可能不存在，所以创建成File对象，再创建目录链，确保目录在保存文件之前已经存在 new File(savepath).mkdirs(); //创建file对象，下面会把上传文件保存到这个file指定的路径 //savepath，即上传文件的保存目录 //filename，文件名称 File file = new File(savepath, filename); // 保存文件 fileItem.write(file); &#125; catch (Exception e) &#123; // 判断抛出的异常的类型是否为FileUploadBase.FileSizeLimitExceededException // 如果是，说明上传文件时超出了限制。 if(e instanceof FileUploadBase.FileSizeLimitExceededException) &#123; // 在request中保存错误信息 request.setAttribute("msg", "上传失败！上传的文件超出了10KB！"); // 转发到index.jsp页面中！在index.jsp页面中需要使用$&#123;msg&#125;来显示错误信息 request.getRequestDispatcher("/index.jsp").forward(request, response); return; &#125; throw new ServletException(e); &#125;&#125; 3.7 上传文件的总大小限制上传文件的表单中可能允许上传多个文件，例如： 有时我们需要限制一个请求的大小。也就是说这个请求的最大字节数（所有表单项之和）！实现这一功能也很简单，只需要调用ServletFileUpload类的setSizeMax(long)方法即可。 例如fileUpload.setSizeMax(1024 * 10);，显示整个请求的上限为10KB。当请求大小超出10KB时，ServletFileUpload类的parseRequest()方法会抛出FileUploadBase.SizeLimitExceededException异常。 3.8 缓存大小与临时目录大家想一想，如果我上传一个蓝光电影，先把电影保存到内存中，然后再通过内存copy到服务器硬盘上，那么你的内存能吃的消么？所以fileupload组件不可能把文件都保存在内存中，fileupload会判断文件大小是否超出10KB，如果是那么就把文件保存到硬盘上，如果没有超出，那么就保存在内存中。 10KB是fileupload默认的值，我们可以来设置它。 当文件保存到硬盘时，fileupload是把文件保存到系统临时目录，当然你也可以去设置临时目录1234567891011121314151617181920212223242526272829303132333435363738394041public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding("utf-8"); DiskFileItemFactory dfif = new DiskFileItemFactory(1024*20, new File("F:\\temp")); ServletFileUpload fileUpload = new ServletFileUpload(dfif); try &#123; List&lt;FileItem&gt; list = fileUpload.parseRequest(request); FileItem fileItem = list.get(1); String name = fileItem.getName(); String savepath = this.getServletContext().getRealPath("/WEB-INF/uploads"); // 保存文件 fileItem.write(path(savepath, name)); &#125; catch (Exception e) &#123; throw new ServletException(e); &#125; &#125; private File path(String savepath, String filename) &#123; // 从完整路径中获取文件名称 int lastIndex = filename.lastIndexOf("\\"); if(lastIndex != -1) &#123; filename = filename.substring(lastIndex + 1); &#125; // 通过文件名称生成一级、二级目录 int hCode = filename.hashCode(); String dir1 = Integer.toHexString(hCode &amp; 0xF); String dir2 = Integer.toHexString(hCode &gt;&gt;&gt; 4 &amp; 0xF); savepath = savepath + "/" + dir1 + "/" + dir2; // 创建目录 new File(savepath).mkdirs(); // 给文件名称添加uuid前缀 String uuid = CommonUtils.uuid(); filename = uuid + "_" + filename; // 创建文件完成路径 return new File(savepath, filename); &#125; 4. 文件下载4.1 通过Servlet下载1被下载的资源必须放到WEB-INF目录下（只要用户不能通过浏览器直接访问就OK），然后通过Servlet完成下载。 在jsp页面中给出超链接，链接到DownloadServlet，并提供要下载的文件名称。然后DownloadServlet获取文件的真实路径，然后把文件写入到response.getOutputStream()流中。 download.jsp123456&lt;body&gt; This is my JSP page. &lt;br&gt; &lt;a href="&lt;c:url value='/DownloadServlet?path=a.avi'/&gt;"&gt;a.avi&lt;/a&gt;&lt;br/&gt; &lt;a href="&lt;c:url value='/DownloadServlet?path=a.jpg'/&gt;"&gt;a.jpg&lt;/a&gt;&lt;br/&gt; &lt;a href="&lt;c:url value='/DownloadServlet?path=a.txt'/&gt;"&gt;a.txt&lt;/a&gt;&lt;br/&gt;&lt;/body&gt; DownloadServlet.java1234567891011public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String filename = request.getParameter("path"); String filepath = this.getServletContext().getRealPath("/WEB-INF/uploads/" + filename); File file = new File(filepath); if(!file.exists()) &#123; response.getWriter().print("您要下载的文件不存在！"); return; &#125; IOUtils.copy(new FileInputStream(file), response.getOutputStream());&#125; 上面代码有如下问题： 可以下载a.avi，但在下载框中的文件名称是DownloadServlet； 不能下载a.jpg和a.txt，而是在页面中显示它们。 4.2 通过Servlet下载2下面来处理上一例中的问题，让下载框中可以显示正确的文件名称，以及可以下载a.jpg和a.txt文件 通过添加content-disposition头来处理上面问题。当设置了content-disposition头后，浏览器就会弹出下载框 而且还可以通过content-disposition头来指定下载文件的名称！123456789String filename = request.getParameter("path"); String filepath = this.getServletContext().getRealPath("/WEB-INF/uploads/" + filename); File file = new File(filepath); if(!file.exists()) &#123; response.getWriter().print("您要下载的文件不存在！"); return; &#125; response.addHeader("content-disposition", "attachment;filename=" + filename); IOUtils.copy(new FileInputStream(file), response.getOutputStream()); 虽然上面的代码已经可以处理txt和jpg等文件的下载问题，并且也处理了在下载框中显示文件名称的问题，但是如果下载的文件名称是中文的，那么还是不行的 4.3 通过Servlet下载3下面是处理在下载框中显示中文的问题！ 其实这一问题很简单，只需要通过URL来编码中文即可！ download.jsp123&lt;a href=&quot;&lt;c:url value=&apos;/DownloadServlet?path=这个杀手不太冷.avi&apos;/&gt;&quot;&gt;这个杀手不太冷.avi&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;&lt;c:url value=&apos;/DownloadServlet?path=白冰.jpg&apos;/&gt;&quot;&gt;白冰.jpg&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;&lt;c:url value=&apos;/DownloadServlet?path=说明文档.txt&apos;/&gt;&quot;&gt;说明文档.txt&lt;/a&gt;&lt;br/&gt; DownloadServlet.java12345678910111213141516String filename = request.getParameter("path");// GET请求中，参数中包含中文需要自己动手来转换。// 当然如果你使用了“全局编码过滤器”，那么这里就不用处理了filename = new String(filename.getBytes("ISO-8859-1"), "UTF-8");String filepath = this.getServletContext().getRealPath("/WEB-INF/uploads/" + filename);File file = new File(filepath);if(!file.exists()) &#123; response.getWriter().print("您要下载的文件不存在！"); return;&#125;// 所有浏览器都会使用本地编码，即中文操作系统使用GBK// 浏览器收到这个文件名后，会使用iso-8859-1来解码filename = new String(filename.getBytes("GBK"), "ISO-8859-1");response.addHeader("content-disposition", "attachment;filename=" + filename);IOUtils.copy(new FileInputStream(file), response.getOutputStream()); 5. 炫酷的文件上传技术http://blog.csdn.net/axi295309066/article/details/53190065]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[酷炫的文件上传技术]]></title>
    <url>%2F2017%2F05%2F01%2Fjavaweb%2F%E9%85%B7%E7%82%AB%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[1. JavaWeb：上传下载文件 http://blog.csdn.net/axi295309066/article/details/52984462 2. 课程概述在Web应用系统开发中，文件上传功能是非常常用的功能，今天来主要讲讲JavaWeb中的文件上传功能的相关技术实现，并且随着互联网技术的飞速发展，用户对网站的体验要求越来越高，在文件上传功能的技术上也出现许多创新点，例如异步上传文件，拖拽式上传，黏贴上传，上传进度监控，文件缩略图，大文件断点续传，大文件秒传等等。 本课程需要的基础知识： 了解基本的Http协议内容 基本IO流操作技术 Servlet基础知识 javascript/jQuery技术基础知识 3. 文件上传的基础对于文件上传，浏览器在上传的过程中是将文件以流的形式提交到服务器端的，并且所有流数据都会随着Http请求携带到服务器端。所以，文件上传时的请求内容格式要能够基本看懂。 文件上传页面： 1234&lt;form action="/itheimaUpload/UploadServlet" method="post" enctype="multipart/form-data"&gt; 请选择上传的文件：&lt;input type="file" name="attach"/&gt;&lt;br/&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt; Http请求内容： 4. Java后台使用Servlet接收文件如果使用Servlet获取上传文件的输入流然后再解析里面的请求参数是比较麻烦，所以一般后台选择采用Apache的开源工具common-fileupload这个文件上传组件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Java后台代码：Commons-fileUpload组件上传文件public class UploadServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.配置缓存 DiskFileItemFactory factory = new DiskFileItemFactory(1*1024*1024,new File("c:/tempFiles/")); //2.创建ServleFileUpload对象 ServletFileUpload sfu = new ServletFileUpload(factory); //解决文件名称中文问题 sfu.setHeaderEncoding("utf-8"); //3.解析 try &#123; List&lt;FileItem&gt; list = sfu.parseRequest(request); //解析所有内容 if(list!=null)&#123; for(FileItem item:list)&#123; //判断是否为普通表单参数 if(item.isFormField())&#123; //普通表单参数 //获取表单的name属性名称 String fieldName = item.getFieldName(); //获取表单参数值 String value = item.getString("utf-8"); &#125;else&#123; //文件 if(item.getName()!=null &amp;&amp; !item.getName().equals("")) &#123; //保存到服务器硬盘 FileUtils.copyInputStreamToFile(item.getInputStream(), new File("c:/targetFiles/"+item.getName())); item.delete(); &#125; &#125; &#125; &#125; &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 5. 使用WebUploader上传组件文件上传页面的前端我们可以选择使用一些比较好用的上传组件，例如百度的开源组件WebUploader，这个组件基本能满足文件上传的一些日常所需功能，如异步上传文件，拖拽式上传，黏贴上传，上传进度监控，文件缩略图，甚至是大文件断点续传，大文件秒传。 5.1 下载WebUpload组件http://fex.baidu.com/webuploader/ 到WebUpload官网下载WebUpload包 WebUpload目录结构： 5.2 基本文件上传Demo（包含上传进度）前端 1.1 在页面导入所需css，js 123456&lt;link rel="stylesheet" type="text/css" href="$&#123;pageContext.request.contextPath&#125;/css/webuploader.css"&gt;&lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath &#125;/js/jquery-1.10.2.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath &#125;/js/webuploader.js"&gt;&lt;/script&gt; 1.2 编写上传页面标签 1234567&lt;!-- 上传div --&gt;&lt;div id="uploader"&gt; &lt;!-- 显示文件列表信息 --&gt; &lt;ul id="fileList"&gt;&lt;/ul&gt; &lt;!-- 选择文件区域 --&gt; &lt;div id="filePicker"&gt;点击选择文件&lt;/div&gt;&lt;/div&gt; 1.3 编写webupload代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script type="text/javascript"&gt; //1.初始化WebUpload，以及配置全局的参数 var uploader = WebUploader.create( &#123; //flashk控件的地址 swf: "$&#123;pageContext.request.contextPath&#125;/js/Uploader.swf", //后台提交地址 server:"$&#123;pageContext.request.contextPath&#125;/UploadServlet", //选择文件控件的标签 pick:"#filePicker", //自动上传文件 auto:true, &#125; ); //2.选择文件后，文件信息队列展示 // 注册fileQueued事件：当文件加入队列后触发 // file: 代表当前选择的文件 uploader.on("fileQueued",function(file)&#123; //追加文件信息div $("#fileList").append("&lt;div id='"+file.id+"' class='fileInfo'&gt;&lt;span&gt;"+file.name+"&lt;/span&gt;&lt;div class='state'&gt;等待上传...&lt;/div&gt;&lt;span class='text'&gt;&lt;/span&gt;&lt;/div&gt;"); &#125;); //3.注册上传进度监听 //file: 正在上传的文件 //percentage: 当前进度的比例。最大为1.例如:0.2 uploader.on("uploadProgress",function(file,percentage)&#123; var id = $("#"+file.id); //更新状态信息 id.find("div.state").text("上传中..."); //更新上传百分比 id.find("span.text").text(Math.round(percentage*100)+"%"); &#125;); //4.注册上传完毕监听 //file:上传完毕的文件 //response:后台回送的数据，以json格式返回 uploader.on("uploadSuccess",function(file,response)&#123; //更新状态信息 $("#"+file.id).find("div.state").text("上传完毕"); &#125;); 2）后端Servlet代码123456789101112131415161718192021DiskFileItemFactory factory = new DiskFileItemFactory();ServletFileUpload sfu = new ServletFileUpload(factory); sfu.setHeaderEncoding("utf-8");try &#123; List&lt;FileItem&gt; items = sfu.parseRequest(request); for(FileItem item:items)&#123; if(item.isFormField())&#123; //普通信息 &#125;else&#123; //文件信息 //判断只有文件才需要进行保存处理 System.out.println("接收的文件名称:"+item.getName()); //拷贝文件到后台的硬盘 FileUtils.copyInputStreamToFile(item.getInputStream(), new File(serverPath+"/"+item.getName())); System.out.println("文件保存成功"); &#125; &#125;&#125; catch (FileUploadException e) &#123; e.printStackTrace();&#125; 5.3 生成图片缩略图关键点：调用uploader.makeThumb()方法生成缩略图 1234567891011121314151617uploader.on("fileQueued",function(file)&#123; //追加文件信息div $("#fileList").append("&lt;div id='"+file.id+"' class='fileInfo'&gt;&lt;img/&gt;&lt;span&gt;"+file.name+"&lt;/span&gt;&lt;div class='state'&gt;等待上传...&lt;/div&gt;&lt;span class='text'&gt;&lt;/span&gt;&lt;/div&gt;"); //制造图片缩略图：调用makeThumb()方法 //error: 制造缩略图失败 //src: 缩略图的路径 uploader.makeThumb(file,function(error,src)&#123; var id = $("#"+file.id); //如果失败，则显示“不能预览” if(error)&#123; id.find("img").replaceWith("不能预览"); &#125; //成功，则显示缩略图到指定位置 id.find("img").attr("src",src); &#125;); &#125;); 5.4 拖拽，黏贴上传1）页面添加拖拽区域的div 123456789101112&lt;!-- 上传div --&gt; &lt;div id="uploader"&gt; &lt;!-- 文件拖拽区域 --&gt; &lt;div id="dndArea"&gt; &lt;p&gt;将文件直接拖拽到这里即可自动上传&lt;/p&gt; &lt;/div&gt; &lt;!-- 显示文件列表信息 --&gt; &lt;ul id="fileList"&gt;&lt;/ul&gt; &lt;!-- 选择文件区域 --&gt; &lt;div id="filePicker"&gt;点击选择文件&lt;/div&gt; &lt;/div&gt; 2）在webuploader的全局配置参数添加拖拽功能的参数 12345678910111213141516171819//1.初始化WebUpload，以及配置全局的参数 var uploader = WebUploader.create( &#123; //flashk控件的地址 swf: "$&#123;pageContext.request.contextPath&#125;/js/Uploader.swf", //后台提交地址 server:"$&#123;pageContext.request.contextPath&#125;/UploadServlet", //选择文件控件的标签 pick:"#filePicker", //自动上传文件 auto:true, //开启拖拽功能，指定拖拽区域 dnd:"#dndArea", //禁用页面其他地方的拖拽功能，防止页面直接打开文件 disableGlobalDnd:true //开启黏贴功能 paste:"#uploader" &#125; ); 5.5 大文件分块上传1）在webuploader全局参数中添加分块上传参数 1234567891011121314151617181920212223242526272829//1.初始化WebUpload，以及配置全局的参数 var uploader = WebUploader.create( &#123; //flashk控件的地址 swf: "$&#123;pageContext.request.contextPath&#125;/js/Uploader.swf", //后台提交地址 server:"$&#123;pageContext.request.contextPath&#125;/UploadServlet", //选择文件控件的标签 pick:"#filePicker", //自动上传文件 auto:true, //开启拖拽功能，指定拖拽区域 dnd:"#dndArea", //禁用页面其他地方的拖拽功能，防止页面直接打开文件 disableGlobalDnd:true, //开启黏贴功能 paste:"#uploader", //分块上传设置 //是否分块上传 chunked:true, //每块文件大小（默认5M） chunkSize:5*1024*1024, //开启几个并发线程（默认3个） threads:3, //在上传当前文件时，准备好下一个文件 prepareNextFile:true &#125; ); 2）监控上传文件的三个时间点 添加以上三个配置后，会发现当文件超过5M时，webuploader自动把文件会分几个请求发送给后台 每个分块请求，包含的信息： 可以监听文件分块上传的三个重要的时间点。 before-send-file : 在所有分块发送之前调用before-send: 如果有分块，在每个分块发送之前调用after-send-file: 在所有分块发送完成之后调用 1234567891011121314151617181920212223//5.监控文件上传的三个时间点(注意：该段代码必须放在WebUploader.create之前) //时间点1：:所有分块进行上传之前（1.可以计算文件的唯一标记;2.可以判断是否秒传） //时间点2： 如果分块上传，每个分块上传之前（1.询问后台该分块是否已经保存成功，用于断点续传） //时间点3：所有分块上传成功之后（1.通知后台进行分块文件的合并工作） WebUploader.Uploader.register(&#123; "before-send-file":"beforeSendFile", "before-send":"beforeSend", "after-send-file":"afterSendFile" &#125;,&#123; //时间点1：:所有分块进行上传之前调用此函数 beforeSendFile:function()&#123; //1.计算文件的唯一标记，用于断点续传和秒传 //2.请求后台是否保存过该文件，如果存在，则跳过该文件，实现秒传功能 &#125;, //时间点2：如果有分块上传，则 每个分块上传之前调用此函数 beforeSend:function()&#123; //1.请求后台是否保存过当前分块，如果存在，则跳过该分块文件，实现断点续传功能 &#125;, //时间点3：所有分块上传成功之后调用此函数 afterSendFile:function()&#123; //1.如果分块上传，则通过后台合并所有分块文件 &#125; &#125;); before-send-file逻辑： 123456789101112131415161718192021222324252627//利用md5File（）方法计算文件的唯一标记符//该函数接收一个deferred beforeSendFile:function(file)&#123; //创建一个deffered var deferred = WebUploader.Deferred(); //1.计算文件的唯一标记，用于断点续传和秒传 (new WebUploader.Uploader()).md5File(file,0,5*1024*1024) .progress(function(percentage)&#123; $("#"+file.id).find("div.state").text("正在获取文件信息..."); &#125;) .then(function(val)&#123; uniqueFileTag = val; $("#"+file.id).find("div.state").text("成功获取文件信息"); //只有文件信息获取成功，才进行下一步操作 deferred.resolve(); &#125;); //alert(uniqueFileTag); //2.请求后台是否保存过该文件，如果存在，则跳过该文件，实现秒传功能 //返回deffered return deferred.promise(); &#125; before-send逻辑： 1234567//向后台发送当前文件的唯一标记，用于后台创建保存分块文件的目录beforeSend:function()&#123; //携带当前文件的唯一标记到后台，用于让后台创建保存该文件分块的目录 this.owner.options.formData.fileMd5 = fileMd5;&#125; 3）后台需要保存所有分块文件 1234567891011121314151617//为每个文件创建一个目录，并保存这个文件的所有分块文件 //判断是否已经分块上传 if(chunks!=null)&#123; System.out.println("分块处理..."); //进行分块上传了 //建立一个临时目录，用于保存所有分块文件 File chunksDir = new File(serverPath+"/"+fileMd5); if(!chunksDir.exists())&#123; chunksDir.mkdir(); &#125; if(chunk!=null)&#123; //保存分块文件 File chunkFile = new File(chunksDir.getPath()+"/"+chunk); FileUtils.copyInputStreamToFile(item.getInputStream(), chunkFile); &#125; 4）前台通知后台合并所有分块文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//前台通知后台合并文件after-send-file逻辑：afterSendFile:function(file)&#123; //1.如果分块上传，则通过后台合并所有分块文件 //请求后台合并文件 $.ajax( &#123; type:"POST", url:"$&#123;pageContext.request.contextPath&#125;/UploadCheckServlet?action=mergeChunks", data:&#123; //文件唯一标记 fileMd5:fileMd5, //文件名称 fileName:file.name &#125;, dataType:"json", success:function(response)&#123; alert(response.msg); &#125; &#125; ); &#125;//后台合并所有分块文件if("mergeChunks".equals(action))&#123; System.out.println("开始合并文件..."); //合并文件 String fileMd5 = request.getParameter("fileMd5"); String fileName = request.getParameter("fileName"); //读取目录里面的所有文件 File f = new File(serverPath+"/"+fileMd5); File[] fileArray = f.listFiles(new FileFilter()&#123; //排除目录，只要文件 public boolean accept(File pathname) &#123; if(pathname.isDirectory())&#123; return false; &#125; return true; &#125; &#125;); //转成集合，便于排序 List&lt;File&gt; fileList = new ArrayList&lt;File&gt;(Arrays.asList(fileArray)); //从小到大排序 Collections.sort(fileList, new Comparator&lt;File&gt;() &#123; public int compare(File o1, File o2) &#123; if(Integer.parseInt(o1.getName()) &lt; Integer.parseInt(o2.getName()))&#123; return -1; &#125; return 1; &#125; &#125;); File outputFile = new File(serverPath+"/"+fileName); //创建文件 outputFile.createNewFile(); //输出流 FileChannel outChannel = new FileOutputStream(outputFile).getChannel(); //合并 FileChannel inChannel; for(File file : fileList)&#123; inChannel = new FileInputStream(file).getChannel(); inChannel.transferTo(0, inChannel.size(), outChannel); inChannel.close(); //删除分片 file.delete(); &#125; //清除文件夹 File tempFile = new File(serverPath+"/"+fileMd5); if(tempFile.isDirectory() &amp;&amp; tempFile.exists())&#123; tempFile.delete(); &#125; //关闭流 outChannel.close(); response.setContentType("text/html;charset=utf-8"); response.getWriter().write("&#123;\"msg\":\"合并成功\"&#125;"); &#125; 5.6 大文件断点续传在实现了分块上传的基础上，实现断点续传就非常简单了！！！ 前端： 123456789101112131415161718192021222324252627282930313233343536//时间点2：如果有分块上传，则 每个分块上传之前调用此函数 //block:代表当前分块对象 beforeSend:function(block)&#123; //1.请求后台是否保存过当前分块，如果存在，则跳过该分块文件，实现断点续传功能 var deferred = WebUploader.Deferred(); //请求后台是否保存完成该文件信息，如果保存过，则跳过，如果没有，则发送该分块内容 $.ajax( &#123; type:"POST", url:"$&#123;pageContext.request.contextPath&#125;/UploadCheckServlet?action=checkChunk", data:&#123; //文件唯一标记 fileMd5:fileMd5, //当前分块下标 chunk:block.chunk, //当前分块大小 chunkSize:block.end-block.start &#125;, dataType:"json", success:function(response)&#123; if(response.ifExist)&#123; //分块存在，跳过该分块 deferred.reject(); &#125;else&#123; //分块不存在或者不完整，重新发送该分块内容 deferred.resolve(); &#125; &#125; &#125; ); //携带当前文件的唯一标记到后台，用于让后台创建保存该文件分块的目录 this.owner.options.formData.fileMd5 = fileMd5; return deferred.promise(); &#125;, 后台：12345678910111213141516171819//检查该分块是否存在或者完整保存 private void checkChunk(HttpServletRequest request, HttpServletResponse response) throws IOException, FileNotFoundException &#123; System.out.println("checkChunk..."); String fileMd5 = request.getParameter("fileMd5"); String chunk = request.getParameter("chunk"); String chunkSize = request.getParameter("chunkSize"); File checkFile = new File(serverPath+"/"+fileMd5+"/"+chunk); response.setContentType("text/html;charset=utf-8"); //检查文件是否存在，且大小是否一致 if(checkFile.exists() &amp;&amp; checkFile.length()==Integer.parseInt(chunkSize))&#123; response.getWriter().write("&#123;\"ifExist\":1&#125;"); &#125;else&#123; response.getWriter().write("&#123;\"ifExist\":0&#125;"); &#125; &#125; 5.7 文件秒传在所有分块请求之前，就已经可以进行实现秒传功能！！！ 前端： 12345678910111213141516171819202122232425262728293031323334353637383940414243beforeSendFile:function(file)&#123; //创建一个deffered var deferred = WebUploader.Deferred(); //1.计算文件的唯一标记，用于断点续传和秒传 (new WebUploader.Uploader()).md5File(file,0,5*1024*1024) .progress(function(percentage)&#123; $("#"+file.id).find("div.state").text("正在获取文件信息..."); &#125;) .then(function(val)&#123; fileMd5 = val; $("#"+file.id).find("div.state").text("成功获取文件信息"); //2.请求后台是否保存过该文件，如果存在，则跳过该文件，实现秒传功能 $.ajax( &#123; type:"POST", url:"$&#123;pageContext.request.contextPath&#125;/UploadCheckServlet?action=fileCheck", data:&#123; //文件唯一标记 fileMd5:fileMd5 &#125;, dataType:"json", success:function(response)&#123; if(response.ifExist)&#123; $("#"+file.id).find("div.state").text("秒传成功"); //如果存在，则跳过该文件，秒传成功 deferred.reject(); &#125;else&#123; //继续上传 deferred.resolve(); &#125; &#125; &#125; ); &#125;); //返回deffered return deferred.promise(); &#125;, 后台：1234567891011121314151617//检查文件的md5数据是否跟在数据库存在private void fileCheck(HttpServletRequest request, HttpServletResponse response) throws IOException, FileNotFoundException &#123; String fileMd5 = request.getParameter("fileMd5"); //模拟数据库 Map&lt;String,String&gt; database = new HashMap&lt;String,String&gt;(); database.put("576018603f4091782b68b78af85704a1", "01.课程回顾.itcast"); response.setContentType("text/html;charset=utf-8"); if(database.containsKey(fileMd5))&#123; response.getWriter().write("&#123;\"ifExist\":1&#125;"); &#125;else&#123; response.getWriter().write("&#123;\"ifExist\":0&#125;"); &#125;&#125;]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>上传下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC之事务]]></title>
    <url>%2F2017%2F05%2F01%2Fjavaweb%2FJDBC%E4%B9%8B%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[系列阅读 JavaWeb：用JDBC操作数据库 JavaWeb：JDBC之事务 JavaWeb：JDBC之数据库连接池 1. 事务 事务的四大特性：ACID mysql中操作事务 jdbc中操作事务 1.1 事务概述为了方便演示事务，我们需要创建一个account表： 1234567891011CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30), balance NUMERIC(10.2));INSERT INTO account(NAME,balance) VALUES('zs', 100000);INSERT INTO account(NAME,balance) VALUES('ls', 100000);INSERT INTO account(NAME,balance) VALUES('ww', 100000);SELECT * FROM account; 1.2 什么是事务银行转账！张三转10000块到李四的账户，这其实需要两条SQL语句： 给张三的账户减去10000元 给李四的账户加上10000元 如果在第一条SQL语句执行成功后，在执行第二条SQL语句之前，程序被中断了（可能是抛出了某个异常，也可能是其他什么原因），那么李四的账户没有加上10000元，而张三却减去了10000元。这肯定是不行的！ 你现在可能已经知道什么是事务了吧！事务中的多个操作，要么完全成功，要么完全失败！不可能存在成功一半的情况！也就是说给张三的账户减去10000元如果成功了，那么给李四的账户加上10000元的操作也必须是成功的；否则给张三减去10000元，以及给李四加上10000元都是失败的！ 1.3 事务的四大特性（ACID）事务的四大特性是： 原子性（Atomicity）：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败 一致性（Consistency）：事务执行后，数据库状态与其它业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的 隔离性（Isolation）：隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰 持久性（Durability）：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据 1.4 MySQL中的事务在默认情况下，MySQL每执行一条SQL语句，都是一个单独的事务。如果需要在一个事务中包含多条SQL语句，那么需要开启事务和结束事务。 开启事务：start transaction 结束事务：commit或rollback 在执行SQL语句之前，先执行strat transaction，这就开启了一个事务（事务的起点），然后可以去执行多条SQL语句，最后要结束事务，commit表示提交，即事务中的多条SQL语句所做出的影响会持久化到数据库中。或者rollback，表示回滚，即回滚到事务的起点，之前做的所有操作都被撤消了！ 下面演示zs给li转账10000元的示例： 1234567891011121314START TRANSACTION;UPDATE account SET balance=balance-10000 WHERE id=1;UPDATE account SET balance=balance+10000 WHERE id=2;ROLLBACK;START TRANSACTION;UPDATE account SET balance=balance-10000 WHERE id=1;UPDATE account SET balance=balance+10000 WHERE id=2;COMMIT;START TRANSACTION;UPDATE account SET balance=balance-10000 WHERE id=1;UPDATE account SET balance=balance+10000 WHERE id=2;quit; 2. JDBC事务在jdbc中处理事务，都是通过Connection完成的！同一事务中所有的操作，都在使用同一个Connection对象！ 2.1 JDBC中的事务Connection的三个方法与事务相关： setAutoCommit(boolean)：设置是否为自动提交事务，如果true（默认值就是true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置false，那么就相当于开启了事务了 commit()：提交结束事务 rollback()：回滚结束事务 jdbc处理事务的代码格式： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950try &#123; con.setAutoCommit(false);//开启事务… …. … con.commit();//try的最后提交事务&#125; catch() &#123; con.rollback();//回滚事务&#125;public void transfer(boolean b) &#123; Connection con = null; PreparedStatement pstmt = null; try &#123; con = JdbcUtils.getConnection(); //手动提交 con.setAutoCommit(false); String sql = "update account set balance=balance+? where id=?"; pstmt = con.prepareStatement(sql); //操作 pstmt.setDouble(1, -10000); pstmt.setInt(2, 1); pstmt.executeUpdate(); // 在两个操作中抛出异常 if(b) &#123; throw new Exception(); &#125; pstmt.setDouble(1, 10000); pstmt.setInt(2, 2); pstmt.executeUpdate(); //提交事务 con.commit(); &#125; catch(Exception e) &#123; //回滚事务 if(con != null) &#123; try &#123; con.rollback(); &#125; catch(SQLException ex) &#123;&#125; &#125; throw new RuntimeException(e); &#125; finally &#123; //关闭 JdbcUtils.close(con, pstmt); &#125; &#125; 3. 保存点保存点是JDBC3.0的东西！当要求数据库服务器支持保存点方式的回滚。校验数据库服务器是否支持保存点！ 1boolean b = con.getMetaData().supportsSavepoints(); 保存点的作用是允许事务回滚到指定的保存点位置。在事务中设置好保存点，然后回滚时可以选择回滚到指定的保存点，而不是回滚整个事务！注意，回滚到指定保存点并没有结束事务！！！只有回滚了整个事务才算是结束事务了！ Connection类的设置保存点，以及回滚到指定保存点方法： 设置保存点：Savepoint setSavepoint() 回滚到指定保存点：void rollback(Savepoint) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* * 李四对张三说，如果你给我转1W，我就给你转100W。 * ========================================== * * 张三给李四转1W（张三减去1W，李四加上1W） * 设置保存点！ * 李四给张三转100W（李四减去100W，张三加上100W） * 查看李四余额为负数，那么回滚到保存点。 * 提交事务 */@Testpublic void fun() &#123; Connection con = null; PreparedStatement pstmt = null; try &#123; con = JdbcUtils.getConnection(); //手动提交 con.setAutoCommit(false); String sql = "update account set balance=balance+? where name=?"; pstmt = con.prepareStatement(sql); //操作1（张三减去1W） pstmt.setDouble(1, -10000); pstmt.setString(2, "zs"); pstmt.executeUpdate(); //操作2（李四加上1W） pstmt.setDouble(1, 10000); pstmt.setString(2, "ls"); pstmt.executeUpdate(); // 设置保存点 Savepoint sp = con.setSavepoint(); //操作3（李四减去100W） pstmt.setDouble(1, -1000000); pstmt.setString(2, "ls"); pstmt.executeUpdate(); //操作4（张三加上100W） pstmt.setDouble(1, 1000000); pstmt.setString(2, "zs"); pstmt.executeUpdate(); //操作5（查看李四余额） sql = "select balance from account where name=?"; pstmt = con.prepareStatement(sql); pstmt.setString(1, "ls"); ResultSet rs = pstmt.executeQuery(); rs.next(); double balance = rs.getDouble(1); //如果李四余额为负数，那么回滚到指定保存点 if(balance &lt; 0) &#123; con.rollback(sp); System.out.println("张三，你上当了！"); &#125; //提交事务 con.commit(); &#125; catch(Exception e) &#123; //回滚事务 if(con != null) &#123; try &#123; con.rollback(); &#125; catch(SQLException ex) &#123;&#125; &#125; throw new RuntimeException(e); &#125; finally &#123; //关闭 JdbcUtils.close(con, pstmt); &#125;&#125; 4. 事务隔离级别4.1 事务的并发读问题 脏读：读取到另一个事务未提交数据 不可重复读：两次读取不一致 幻读（虚读）：读到另一事务已提交数据 4.2 并发事务问题因为并发事务导致的问题大致有5类，其中两类是更新问题，三类是读问题 脏读（dirty read）：读到另一个事务的未提交更新数据，即读取到了脏数据 不可重复读（unrepeatable read）：对同一记录的两次读取不一致，因为另一事务对该记录做了修改 幻读（虚读）（phantom read）：对同一张表的两次查询不一致，因为另一事务插入了一条记录 4.2.1 脏读事务1：张三给李四转账100元事务2：李四查看自己的账户 t1：事务1：开始事务 t2：事务1：张三给李四转账100元 t3：事务2：开始事务 t4：事务2：李四查看自己的账户，看到账户多出100元（脏读） t5：事务2：提交事务 t6：事务1：回滚事务，回到转账之前的状态 4.2.2不可重复读事务1：酒店查看两次1048号房间状态事务2：预订1048号房间 t1：事务1：开始事务 t2：事务1：查看1048号房间状态为空闲 t3：事务2：开始事务 t4：事务2：预定1048号房间 t5：事务2：提交事务 t6：事务1：再次查看1048号房间状态为使用 t7：事务1：提交事务对同一记录的两次查询结果不一致！ 4.2.3幻读事务1：对酒店房间预订记录两次统计事务2：添加一条预订房间记录 t1：事务1：开始事务 t2：事务1：统计预订记录100条 t3：事务2：开始事务 t4：事务2：添加一条预订房间记录 t5：事务2：提交事务 t6：事务1：再次统计预订记录为101记录 t7：事务1：提交 对同一表的两次查询不一致！ 不可重复读和幻读的区别： 不可重复读是读取到了另一事务的更新； 幻读是读取到了另一事务的插入（MySQL中无法测试到幻读）； 4.3 四大隔离级别4个等级的事务隔离级别，在相同数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力是不同的 4.3.1 SERIALIZABLE（串行化） 不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的 性能最差 4.3.2 REPEATABLE READ（可重复读）（MySQL） 防止脏读和不可重复读，不能处理幻读问题 性能比SERIALIZABLE好 4.3.3 READ COMMITTED（读已提交数据）（Oracle） 防止脏读，没有处理不可重复读，也没有处理幻读； 性能比REPEATABLE READ好 4.3.4 READ UNCOMMITTED（读未提交数据） 可能出现任何事务并发问题 性能最好 MySQL的默认隔离级别为REPEATABLE READ，这是一个很不错的选择吧！ 4.3.5 MySQL隔离级别MySQL的默认隔离级别为Repeatable read，可以通过下面语句查看： 1select @@tx_isolation 也可以通过下面语句来设置当前连接的隔离级别： 1set transaction isolationlevel [4先1] 4.3.6 JDBC设置隔离级别con. setTransactionIsolation(int level);参数可选值如下： Connection.TRANSACTION_READ_UNCOMMITTED Connection.TRANSACTION_READ_COMMITTED Connection.TRANSACTION_REPEATABLE_READ Connection.TRANSACTION_SERIALIZABLE 5. 事务总结 事务的特性：ACID 事务开始边界与结束边界：开始边界（con.setAutoCommit(false)），结束边界（con.commit()或con.rollback()） 事务的隔离级别： READ_UNCOMMITTED、READ_COMMITTED、REPEATABLE_READ、SERIALIZABLE。多个事务并发执行时才需要考虑并发事务]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JDBC操作数据库]]></title>
    <url>%2F2017%2F05%2F01%2Fjavaweb%2F%E7%94%A8JDBC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[JDBC系列阅读 JavaWeb：用JDBC操作数据库 JavaWeb：JDBC之事务 JavaWeb：JDBC之数据库连接池 1. 什么是JDBCJDBC（Java DataBase Connectivity）就是Java数据库连接，说白了就是用Java语言来操作数据库。原来我们操作数据库是在控制台使用SQL语句来操作数据库，JDBC是用Java语言向数据库发送SQL语句。 2. JDBC原理早期SUN公司的天才们想编写一套可以连接天下所有数据库的API，但是当他们刚刚开始时就发现这是不可完成的任务，因为各个厂商的数据库服务器差异太大了。后来SUN开始与数据库厂商们讨论，最终得出的结论是，由SUN提供一套访问数据库的规范（就是一组接口），并提供连接数据库的协议标准，然后各个数据库厂商会遵循SUN的规范提供一套访问自己公司的数据库服务器的API出现。SUN提供的规范命名为JDBC，而各个厂商提供的，遵循了JDBC规范的，可以访问自己数据库的API被称之为驱动！ JDBC是接口，而JDBC驱动才是接口的实现，没有驱动无法完成数据库连接！每个数据库厂商都有自己的驱动，用来连接自己公司的数据库。当然还有第三方公司专门为某一数据库提供驱动，这样的驱动往往不是开源免费的！ 3. JDBC核心类（接口）介绍JDBC中的核心类有：DriverManager、Connection、Statement，和ResultSet！ DriverManger（驱动管理器）的作用有两个： 注册驱动：这可以让JDBC知道要使用的是哪个驱动 获取Connection：如果可以获取到Connection，那么说明已经与数据库连接上了 Connection对象表示连接，与数据库的通讯都是通过这个对象展开的： Connection最为重要的一个方法就是用来获取Statement对象； Statement是用来向数据库发送SQL语句的，这样数据库就会执行发送过来的SQL语句： void executeUpdate(String sql)：执行更新操作（insert、update、delete等） ResultSet executeQuery(String sql)：执行查询操作，数据库在执行查询后会把查询结果，查询结果就是ResultSet ResultSet对象表示查询结果集，只有在执行查询操作后才会有结果集的产生。结果集是一个二维的表格，有行有列。操作结果集要学习移动ResultSet内部的“行光标”，以及获取当前行上的每一列上的数据： boolean next()：使“行光标”移动到下一行，并返回移动后的行是否存在 XXX getXXX(int col)：获取当前行指定列上的值，参数就是列数，列数从1开始，而不是0 4. Hello JDBC下面开始编写第一个JDBC程序 4.1 mysql数据库的驱动jar包mysql-connector-java-5.1.13-bin.jar 4.2 获取连接获取连接需要两步，一是使用DriverManager来注册驱动，二是使用DriverManager来获取Connection对象。 4.2.1 注册驱动看清楚了，注册驱动就只有一句话： 1Class.forName(“com.mysql.jdbc.Driver”); 下面的内容都是对这句代码的解释。今后我们的代码中，与注册驱动相关的代码只有这一句 DriverManager类的registerDriver()方法的参数是java.sql.Driver，但java.sql.Driver是一个接口，实现类由mysql驱动来提供，mysql驱动中的java.sql.Driver接口的实现类为com.mysql.jdbc.Driver！那么注册驱动的代码如下： 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 上面代码虽然可以注册驱动，但是出现硬编码（代码依赖mysql驱动jar包），如果将来想连接Oracle数据库，那么必须要修改代码的。并且其实这种注册驱动的方式是注册了两次驱动！ JDBC中规定，驱动类在被加载时，需要自己“主动”把自己注册到DriverManger中，下面我们来看看com.mysql.jdbc.Driver类的源代码： com.mysql.jdbc.Driver.java 12345678910public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException("Can't register driver!"); &#125; &#125;……&#125; com.mysql.jdbc.Driver类中的static块会创建本类对象，并注册到DriverManager中。这说明只要去加载com.mysql.jdbc.Driver类，那么就会执行这个static块，从而也就会把com.mysql.jdbc.Driver注册到DriverManager中，所以可以把注册驱动类的代码修改为加载驱动类。 1Class.forName(“com.mysql.jdbc.Driver”); 4.2.2 获取连接获取连接的也只有一句代码： 1DriverManager.getConnection(url,username,password); 其中username和password是登录数据库的用户名和密码，如果我没说错的话，你的mysql数据库的用户名和密码分别是：root、123 url查对复杂一点，它是用来找到要连接数据库“网址”，就好比你要浏览器中查找百度时，也需要提供一个url。下面是mysql的url：jdbc:mysql://localhost:3306/mydb1 JDBC规定url的格式由三部分组成，每个部分中间使用逗号分隔。 第一部分是jdbc，这是固定的 第二部分是数据库名称，那么连接mysql数据库，第二部分当然是mysql了 第三部分是由数据库厂商规定的，我们需要了解每个数据库厂商的要求，mysql的第三部分分别由数据库服务器的IP地址（localhost）、端口号（3306），以及DATABASE名称(mydb1)组成 下面是获取连接的语句：1Connection con = DriverManager.getConnection(“jdbc:mysql://localhost:3306/mydb1”,”root”,”123”); 还可以在url中提供参数：jdbc:mysql://localhost:3306/mydb1?useUnicode=true&amp;characterEncoding=UTF8 useUnicode：参数指定这个连接数据库的过程中，使用的字节集是Unicode字节集 characherEncoding：参数指定穿上连接数据库的过程中，使用的字节集编码为UTF-8编码。请注意，mysql中指定UTF-8编码是给出的是UTF8，而不是UTF-8，要小心了 4.3 获取Statement在得到Connectoin之后，说明已经与数据库连接上了，下面是通过Connection获取Statement对象的代码： 1Statement stmt = con.createStatement(); Statement是用来向数据库发送要执行的SQL语句的！ 4.4 发送SQL增、删、改语句12String sql = “insert into user value(’zhangSan’, ’123’)”;int m = stmt.executeUpdate(sql); 其中int类型的返回值表示执行这条SQL语句所影响的行数，我们知道，对insert来说，最后只能影响一行，而update和delete可能会影响0~n行。如果SQL语句执行失败，那么executeUpdate()会抛出一个SQLException。 4.5 发送SQL查询语句12String sql = “select * from user”;ResultSet rs = stmt.executeQuery(sql); 请注册，执行查询使用的不是executeUpdate()方法，而是executeQuery()方法。executeQuery()方法返回的是ResultSet，ResultSet封装了查询结果，我们称之为结果集。 4.6 读取结果集中的数据ResultSet就是一张二维的表格，它内部有一个“行光标”，光标默认的位置在“第一行上方”，我们可以调用rs对象的next()方法把“行光标”向下移动一行，当第一次调用next()方法时，“行光标”就到了第一行记录的位置，这时就可以使用ResultSet提供的getXXX(int col)方法来获取指定列的数据了： 12rs.next();//光标移动到第一行rs.getInt(1);//获取第一行第一列的数据 当你使用rs.getInt(1)方法时，你必须可以肯定第1列的数据类型就是int类型，如果你不能肯定，那么最好使用rs.getObject(1)。在ResultSet类中提供了一系列的getXXX()方法，比较常用的方法有： 1234Object getObject(int col)String getString(int col)int getInt(int col)double getDouble(int col) 4.7 关闭与IO流一样，使用后的东西都需要关闭！关闭的顺序是先得到的后关闭，后得到的先关闭。 123rs.close();stmt.close();con.close(); 4.8 代码1234567891011121314151617181920212223242526272829303132333435363738394041public static Connection getConnection() throws Exception &#123; Class.forName("com.mysql.jdbc.Driver"); String url = "jdbc:mysql://localhost:3306/mydb1"; return DriverManager.getConnection(url, "root", "123"); &#125; @Test public void insert() throws Exception &#123; Connection con = getConnection(); Statement stmt = con.createStatement(); String sql = "insert into user values('zhangSan', '123')"; stmt.executeUpdate(sql); System.out.println("插入成功！"); &#125; @Test public void update() throws Exception &#123; Connection con = getConnection(); Statement stmt = con.createStatement(); String sql = "update user set password='456' where username='zhangSan'"; stmt.executeUpdate(sql); System.out.println("修改成功！"); &#125; @Test public void delete() throws Exception &#123; Connection con = getConnection(); Statement stmt = con.createStatement(); String sql = "delete from user where username='zhangSan'"; stmt.executeUpdate(sql); System.out.println("删除成功！"); &#125; @Test public void query() throws Exception &#123; Connection con = getConnection(); Statement stmt = con.createStatement(); String sql = "select * from user"; ResultSet rs = stmt.executeQuery(sql); while(rs.next()) &#123; String username = rs.getString(1); String password = rs.getString(2); System.out.println(username + ", " + password); &#125; &#125; 4.9 规范化代码所谓规范化代码就是无论是否出现异常，都要关闭ResultSet、Statement，以及Connection，如果你还记得IO流的规范化代码，那么下面的代码你就明白什么意思了12345678910111213141516171819202122232425@Testpublic void query() &#123; Connection con = null; Statement stmt = null; ResultSet rs = null; try &#123; con = getConnection(); stmt = con.createStatement(); String sql = "select * from user"; rs = stmt.executeQuery(sql); while(rs.next()) &#123; String username = rs.getString(1); String password = rs.getString(2); System.out.println(username + ", " + password); &#125; &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if(rs != null) rs.close(); if(stmt != null) stmt.close(); if(con != null) con.close(); &#125; catch(SQLException e) &#123;&#125; &#125;&#125; 5. JDBC对象介绍5.1 JDBC中的主要类（接口）在JDBC中常用的类有： DriverManager Connection Statement ResultSet 5.2 DriverManager其实我们今后只需要会用DriverManager的getConnection()方法即可： 12345Class.forName(“com.mysql.jdbc.Driver”);//注册驱动String url = “jdbc:mysql://localhost:3306/mydb1”;String username = “root”;String password = “123”;Connection con = DriverManager.getConnection(url, username, password); 注意，上面代码可能出现的两种异常： 1、ClassNotFoundException：这个异常是在第1句上出现的，出现这个异常有两个可能： 你没有给出mysql的jar包 你把类名称打错了，查看类名是不是com.mysql.jdbc.Driver 2、SQLException：这个异常出现在第5句，出现这个异常就是三个参数的问题，往往username和password一般不是出错，所以需要认真查看url是否打错 对于DriverManager.registerDriver()方法了解即可，因为我们今后注册驱动只会Class.forName()，而不会使用这个方法 5.3 ConnectionConnection最为重要的方法就是获取Statement： 1Statement stmt = con.createStatement(); 后面在学习ResultSet方法时，还要学习一下下面的方法： 1Statement stmt = con.createStatement(int,int); 5.4 StatementStatement最为重要的方法是： int executeUpdate(String sql)：执行更新操作，即执行insert、update、delete语句，其实这个方法也可以执行create table、alter table，以及drop table等语句，但我们很少会使用JDBC来执行这些语句 ResultSet executeQuery(String sql)：执行查询操作，执行查询操作会返回ResultSet，即结果集 boolean execute() Statement还有一个boolean execute()方法，这个方法可以用来执行增、删、改、查所有SQL语句。该方法返回的是boolean类型，表示SQL语句是否有结果集！ 如果使用execute()方法执行的是更新语句，那么还要调用int getUpdateCount()来获取insert、update、delete语句所影响的行数。 如果使用execute()方法执行的是查询语句，那么还要调用ResultSet getResultSet()来获取select语句的查询结果。 5.5 ResultSet之滚动结果集下一行：默认只能使用它，其他的方法存在，但不能使用！默认的结果集不可滚动！上一行下N行上N行到N行！ ResultSet表示结果集，它是一个二维的表格！ResultSet内部维护一个行光标（游标），ResultSet提供了一系列的方法来移动游标 返回值 方法 功能描述 void beforeFirst() 把光标放到第一行的前面，这也是光标默认的位置 void afterLast() 把光标放到最后一行的后面 boolean first() 把光标放到第一行的位置上，返回值表示调控光标是否成功 boolean last() 把光标放到最后一行的位置上 boolean isBeforeFirst() 当前光标位置是否在第一行前面 boolean isAfterLast() 当前光标位置是否在最后一行的后面； boolean isFirst() 当前光标位置是否在第一行上 boolean isLast() 当前光标位置是否在最后一行上 boolean previous() 把光标向上挪一行 boolean next() 把光标向下挪一行 boolean relative(int row) 相对位移，当row为正数时，表示向下移动row行，为负数时表示向上移动row行 boolean absolute(int row) 绝对位移，把光标移动到指定的行上 int getRow() 返回当前光标所有行 获取结果集元数据 返回值 方法 功能描述 ResultSetMetaData getMetaData() 得到元数据 int getColumnCount() 获取结果集列数 String getColumnName(int colIndex) 获取指定列的列名 结果集特性：当使用Connection的createStatement()时，已经确定了Statement生成的结果集是什么特性。 是否可滚动 是否敏感 是否可更新 con.createSttement()：生成的结果集：不滚动、不敏感、不可更新！ con.createStatement(int resultSetType, int resultSetConcurrency)： 第一个参数： ResultSet.TYPE_FORWARD_ONLY：不滚动结果集 ResultSet.TYPE_SCROLL_INSENSITIVE：滚动结果集，但结果集数据不会再跟随数据库而变化 ResultSet.TYPE_SCROLL_SENSITIVE：滚动结果集，但结果集数据会再跟随数据库而变化 第二个参数： CONCUR_READ_ONLY：结果集是只读的，不能通过修改结果集而反向影响数据库 CONCUR_UPDATABLE：结果集是可更新的，对结果集的更新可以反向影响数据库 上面方法分为两类，一类用来判断游标位置的，另一类是用来移动游标的。如果结果集是不可滚动的，那么只能使用next()方法来移动游标，而beforeFirst()、afterLast()、first()、last()、previous()、relative()方法都不能使用 结果集是否支持滚动，要从Connection类的createStatement()方法说起。也就是说创建的Statement决定了使用Statement创建的ResultSet是否支持滚动。1Statement createStatement(int resultSetType, int resultSetConcurrency); resultSetType的可选值： ResultSet.TYPE_FORWARD_ONLY：不滚动结果集； ResultSet.TYPE_SCROLL_INSENSITIVE：滚动结果集，但结果集数据不会再跟随数据库而变化； ResultSet.TYPE_SCROLL_SENSITIVE：滚动结果集，但结果集数据会再跟随数据库而变化； 可以看出，如果想使用滚动的结果集，我们应该选择TYPE_SCROLL_INSENSITIVE！其实很少有数据库驱动会支持TYPE_SCROLL_SENSITIVE的特性！通常我们也不需要查询到的结果集再受到数据库变化的影响。 resultSetConcurrency的可选值： CONCUR_READ_ONLY：结果集是只读的，不能通过修改结果集而反向影响数据库； CONCUR_UPDATABLE：结果集是可更新的，对结果集的更新可以反向影响数据库。 通常可更新结果集这一“高级特性”我们也是不需要的！ 获取滚动结果集的代码如下： 1234Connection con = …Statement stmt = con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, CONCUR_READ_ONLY);String sql = …//查询语句ResultSet rs = stmt.executeQuery(sql);//这个结果集是可滚动的 5.6 ResultSet之获取列数据可以通过next()方法使ResultSet的游标向下移动，当游标移动到你需要的行时，就需要来获取该行的数据了，ResultSet提供了一系列的获取列数据的方法： 返回值 方法 功能描述 String getString(int columnIndex) 获取指定列的String类型数据 int getInt(int columnIndex) 获取指定列的int类型数据 double getDouble(int columnIndex) 获取指定列的double类型数据 boolean getBoolean(int columnIndex) 获取指定列的boolean类型数据 Object getObject(int columnIndex) 获取指定列的Object类型的数据 上面方法中，参数columnIndex表示列的索引，列索引从1开始，而不是0，这第一点与数组不同。如果你清楚当前列的数据类型，那么可以使用getInt()之类的方法来获取，如果你不清楚列的类型，那么你应该使用getObject()方法来获取 ResultSet还提供了一套通过列名称来获取列数据的方法 返回值 方法 功能描述 String getString(String columnName) 获取名称为columnName的列的String数据 int getInt(String columnName) 获取名称为columnName的列的int数据 double getDouble(String columnName) 获取名称为columnName的列的double数据 boolean getBoolean(String columnName) 获取名称为columnName的列的boolean数据 Object getObject(String columnName) 获取名称为columnName的列的Object数据 6. PreparedStatement 它是Statement接口的子接口； 强大之处： 防SQL攻击； 提高代码的可读性、可维护性； 提高效率！ 学习PreparedStatement的用法： -如何得到PreparedStatement对象： 给出SQL模板！ 调用Connection的PreparedStatement prepareStatement(String sql模板) 调用pstmt的setXxx()系列方法sql模板中的?赋值！ 调用pstmt的executeUpdate()或executeQuery()，但它的方法都没有参数 6.1 预处理的原理服务器的工作： 校验sql语句的语法！ 编译：一个与函数相似的东西！ 执行：调用函数 PreparedStatement： 前提：连接的数据库必须支持预处理！几乎没有不支持的！ 每个pstmt都与一个sql模板绑定在一起，先把sql模板给数据库，数据库先进行校验，再进行编译。执行时只是把参数传递过去而已！ 若二次执行时，就不用再次校验语法，也不用再次编译！直接执行！ 6.2 什么是SQL攻击在需要用户输入的地方，用户输入的是SQL语句的片段，最终用户输入的SQL片段与我们DAO中写的SQL语句合成一个完整的SQL语句！例如用户在登录时输入的用户名和密码都是为SQL语句的片段！ 6.3 演示SQL攻击首先我们需要创建一张用户表，用来存储用户的信息。 12345678CREATE TABLE user( uid CHAR(32) PRIMARY KEY, username VARCHAR(30) UNIQUE KEY NOT NULL, PASSWORD VARCHAR(30));INSERT INTO user VALUES(&apos;U_1001&apos;, &apos;zs&apos;, &apos;zs&apos;);SELECT * FROM user; 现在用户表中只有一行记录，就是zs。下面我们写一个login()方法！ 12345678910111213141516171819202122public void login(String username, String password) &#123; Connection con = null; Statement stmt = null; ResultSet rs = null; try &#123; con = JdbcUtils.getConnection(); stmt = con.createStatement(); String sql = "SELECT * FROM user WHERE " + "username='" + username + "' and password='" + password + "'"; rs = stmt.executeQuery(sql); if(rs.next()) &#123; System.out.println("欢迎" + rs.getString("username")); &#125; else &#123; System.out.println("用户名或密码错误！"); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; JdbcUtils.close(con, stmt, rs); &#125; &#125; 下面是调用这个方法的代码： 1login("a' or 'a'='a", "a' or 'a'='a"); 这行当前会使我们登录成功！因为是输入的用户名和密码是SQL语句片段，最终与我们的login()方法中的SQL语句组合在一起！我们来看看组合在一起的SQL语句： 1SELECT * FROM tab_user WHERE username=&apos;a&apos; or &apos;a&apos;=&apos;a&apos; and password=&apos;a&apos; or &apos;a&apos;=&apos;a&apos; 6.4 防止SQL攻击 过滤用户输入的数据中是否包含非法字符 分步交验！先使用用户名来查询用户，如果查找到了，再比较密码 使用PreparedStatement 6.5 PreparedStatement是什么？PreparedStatement叫预编译声明！ PreparedStatement是Statement的子接口，你可以使用PreparedStatement来替换Statement。 PreparedStatement的好处： 防止SQL攻击 提高代码的可读性，以可维护性 提高效率 6.6 PreparedStatement的使用 使用Connection的prepareStatement(String sql)：即创建它时就让它与一条SQL模板绑定 调用PreparedStatement的setXXX()系列方法为问号设置值 调用executeUpdate()或executeQuery()方法，但要注意，调用没有参数的方法 12345678String sql = “select * from tab_student where s_number=?”;PreparedStatement pstmt = con.prepareStatement(sql);pstmt.setString(1, “S_1001”);ResultSet rs = pstmt.executeQuery();rs.close();pstmt.clearParameters();pstmt.setString(1, “S_1002”);rs = pstmt.executeQuery(); 在使用Connection创建PreparedStatement对象时需要给出一个SQL模板，所谓SQL模板就是有“?”的SQL语句，其中“?”就是参数 在得到PreparedStatement对象后，调用它的setXXX()方法为“?”赋值，这样就可以得到把模板变成一条完整的SQL语句，然后再调用PreparedStatement对象的executeQuery()方法获取ResultSet对象 注意PreparedStatement对象独有的executeQuery()方法是没有参数的，而Statement的executeQuery()是需要参数（SQL语句）的。因为在创建PreparedStatement对象时已经让它与一条SQL模板绑定在一起了，所以在调用它的executeQuery()和executeUpdate()方法时就不再需要参数了 PreparedStatement最大的好处就是在于重复使用同一模板，给予其不同的参数来重复的使用它。这才是真正提高效率的原因 所以，建议大家在今后的开发中，无论什么情况，都去需要PreparedStatement，而不是使用Statement 6.7 MySQL的预编译功能6.7.1 预编译的好处大家平时都使用过JDBC中的PreparedStatement接口，它有预编译功能。什么是预编译功能呢？它有什么好处呢？ 当客户发送一条SQL语句给服务器后，服务器总是需要校验SQL语句的语法格式是否正确，然后把SQL语句编译成可执行的函数，最后才是执行SQL语句。其中校验语法，和编译所花的时间可能比执行SQL语句花的时间还要多。 如果我们需要执行多次insert语句，但只是每次插入的值不同，MySQL服务器也是需要每次都去校验SQL语句的语法格式，以及编译，这就浪费了太多的时间。如果使用预编译功能，那么只对SQL语句进行一次语法校验和编译，所以效率要高。 6.7.2 MySQL执行预编译MySQL执行预编译分为如三步： 执行预编译语句，例如：prepare myfun from ‘select * from t_book where bid=?’ 设置变量，例如：set @str=’b1’ 执行语句，例如：execute myfun using @str 如果需要再次执行myfun，那么就不再需要第一步，即不需要再编译语句了： 设置变量，例如：set @str=’b2’ 执行语句，例如：execute myfun using @str 通过查看MySQL日志可以看到执行的过程： 使用Statement执行预编译 使用Statement执行预编译就是把上面的SQL语句执行一次。 12345678910111213141516171819202122232425Connection con = JdbcUtils.getConnection(); Statement stmt = con.createStatement(); stmt.executeUpdate("prepare myfun from 'select * from t_book where bid=?'"); stmt.executeUpdate("set @str='b1'"); ResultSet rs = stmt.executeQuery("execute myfun using @str"); while(rs.next()) &#123; System.out.print(rs.getString(1) + ", "); System.out.print(rs.getString(2) + ", "); System.out.print(rs.getString(3) + ", "); System.out.println(rs.getString(4)); &#125; stmt.executeUpdate("set @str='b2'"); rs = stmt.executeQuery("execute myfun using @str"); while(rs.next()) &#123; System.out.print(rs.getString(1) + ", "); System.out.print(rs.getString(2) + ", "); System.out.print(rs.getString(3) + ", "); System.out.println(rs.getString(4)); &#125; rs.close(); stmt.close(); con.close(); 6.7.3 useServerPrepStmts参数默认使用PreparedStatement是不能执行预编译的，这需要在url中给出useServerPrepStmts=true参数（MySQL Server 4.1之前的版本是不支持预编译的，而Connector/J在5.0.5以后的版本，默认是没有开启预编译功能的）。 例如：jdbc:mysql://localhost:3306/test?useServerPrepStmts=true 这样才能保证mysql驱动会先把SQL语句发送给服务器进行预编译，然后在执行executeQuery()时只是把参数发送给服务器。 12345678910111213141516171819202122232425Connection con = JdbcUtils.getConnection(); String sql = "select * from t_book where bid=?"; PreparedStatement pstmt = con.prepareStatement(sql); pstmt.setString(1, "b1"); ResultSet rs = pstmt.executeQuery(); while(rs.next()) &#123; System.out.print(rs.getString(1) + ", "); System.out.print(rs.getString(2) + ", "); System.out.print(rs.getString(3) + ", "); System.out.println(rs.getString(4)); &#125; pstmt.setString(1, "b2"); rs = pstmt.executeQuery(); while(rs.next()) &#123; System.out.print(rs.getString(1) + ", "); System.out.print(rs.getString(2) + ", "); System.out.print(rs.getString(3) + ", "); System.out.println(rs.getString(4)); &#125; rs.close(); pstmt.close(); con.close(); 6.7.4 cachePrepStmts参数当使用不同的PreparedStatement对象来执行相同的SQL语句时，还是会出现编译两次的现象，这是因为驱动没有缓存编译后的函数key，导致二次编译。如果希望缓存编译后函数的key，那么就要设置cachePrepStmts参数为true。例如： 1jdbc:mysql://localhost:3306/test?useServerPrepStmts=true&amp;cachePrepStmts=true 1234567891011121314151617181920212223242526Connection con = JdbcUtils.getConnection(); String sql = "select * from t_book where bid=?"; PreparedStatement pstmt = con.prepareStatement(sql); pstmt.setString(1, "b1"); ResultSet rs = pstmt.executeQuery(); while(rs.next()) &#123; System.out.print(rs.getString(1) + ", "); System.out.print(rs.getString(2) + ", "); System.out.print(rs.getString(3) + ", "); System.out.println(rs.getString(4)); &#125; pstmt = con.prepareStatement(sql); pstmt.setString(1, "b2"); rs = pstmt.executeQuery(); while(rs.next()) &#123; System.out.print(rs.getString(1) + ", "); System.out.print(rs.getString(2) + ", "); System.out.print(rs.getString(3) + ", "); System.out.println(rs.getString(4)); &#125; rs.close(); pstmt.close(); con.close(); 6.8 打开批处理MySQL的批处理也需要通过参数来打开： 1rewriteBatchedStatements=true 7. JdbcUtils工具类7.1 JdbcUtils的作用你也看到了，连接数据库的四大参数是：驱动类、url、用户名，以及密码。这些参数都与特定数据库关联，如果将来想更改数据库，那么就要去修改这四大参数，那么为了不去修改代码，我们写一个JdbcUtils类，让它从配置文件中读取配置参数，然后创建连接对象 7.2 JdbcUtils代码JdbcUtils.java 12345678910111213141516171819202122public class JdbcUtils &#123; private static final String dbconfig = "dbconfig.properties"; private static Properties prop = new Properties(); static &#123; try &#123; InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(dbconfig); prop.load(in); Class.forName(prop.getProperty("driverClassName")); &#125; catch(IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public static Connection getConnection() &#123; try &#123; return DriverManager.getConnection(prop.getProperty("url"), prop.getProperty("username"), prop.getProperty("password")); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 连接数据库的四大参数dbconfig.properties1234driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mydb1?useUnicode=true&amp;characterEncoding=UTF8username=rootpassword=123 8. 面向接口编程修改项目： 把UserDao修改为接口，然后把原来的UserDao修改类名为UserDaoImpl 修改UserService中对UserDao的实例化：private UserDao userDao = DaoFactory.getUserDao() 创建DaoFactory，提供getUserDao() 8.1 DAO模式DAO（Data Access Object）模式就是写一个类，把访问数据库的代码封装起来。DAO在数据库与业务逻辑（Service）之间 实体域，即操作的对象，例如我们操作的表是user表，那么就需要先写一个User类 DAO模式需要先提供一个DAO接口 然后再提供一个DAO接口的实现类 再编写一个DAO工厂，Service通过工厂来获取DAO实现 8.2 实现代码User.java 123456public class User &#123; private String uid; private String username; private String password;…&#125; UserDao.java 1234567public interface UserDao &#123; public void add(User user); public void mod(User user); public void del(String uid); public User load(String uid); public List&lt;User&gt; findAll();&#125; UserDaoImpl.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class UserDaoImpl implements UserDao &#123; public void add(User user) &#123; Connection con = null; PreparedStatement pstmt = null; try &#123; con = JdbcUtils.getConnection(); String sql = "insert into user value(?,?,?)"; pstmt = con.prepareStatement(sql); pstmt.setString(1, user.getUid()); pstmt.setString(2, user.getUsername()); pstmt.setString(3, user.getPassword()); pstmt.executeUpdate(); &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if(pstmt != null) pstmt.close(); if(con != null) con.close(); &#125; catch(SQLException e) &#123;&#125; &#125; &#125; public void mod(User user) &#123; Connection con = null; PreparedStatement pstmt = null; try &#123; con = JdbcUtils.getConnection(); String sql = "update user set username=?, password=? where uid=?"; pstmt = con.prepareStatement(sql); pstmt.setString(1, user.getUsername()); pstmt.setString(2, user.getPassword()); pstmt.setString(3, user.getUid()); pstmt.executeUpdate(); &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if(pstmt != null) pstmt.close(); if(con != null) con.close(); &#125; catch(SQLException e) &#123;&#125; &#125; &#125; public void del(String uid) &#123; Connection con = null; PreparedStatement pstmt = null; try &#123; con = JdbcUtils.getConnection(); String sql = "delete from user where uid=?"; pstmt = con.prepareStatement(sql); pstmt.setString(1, uid); pstmt.executeUpdate(); &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if(pstmt != null) pstmt.close(); if(con != null) con.close(); &#125; catch(SQLException e) &#123;&#125; &#125; &#125; public User load(String uid) &#123; Connection con = null; PreparedStatement pstmt = null; ResultSet rs = null; try &#123; con = JdbcUtils.getConnection(); String sql = "select * from user where uid=?"; pstmt = con.prepareStatement(sql); pstmt.setString(1, uid); rs = pstmt.executeQuery(); if(rs.next()) &#123; return new User(rs.getString(1), rs.getString(2), rs.getString(3)); &#125; return null; &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if(pstmt != null) pstmt.close(); if(con != null) con.close(); &#125; catch(SQLException e) &#123;&#125; &#125; &#125; public List&lt;User&gt; findAll() &#123; Connection con = null; PreparedStatement pstmt = null; ResultSet rs = null; try &#123; con = JdbcUtils.getConnection(); String sql = "select * from user"; pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); List&lt;User&gt; userList = new ArrayList&lt;User&gt;(); while(rs.next()) &#123; userList.add(new User(rs.getString(1), rs.getString(2), rs.getString(3))); &#125; return userList; &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; finally &#123; try &#123; if(pstmt != null) pstmt.close(); if(con != null) con.close(); &#125; catch(SQLException e) &#123;&#125; &#125; &#125;&#125; UserDaoFactory.java1234567891011121314151617181920public class UserDaoFactory &#123; private static UserDao userDao; static &#123; try &#123; InputStream in = Thread.currentThread().getContextClassLoader() .getResourceAsStream("dao.properties"); Properties prop = new Properties(); prop.load(in); String className = prop.getProperty("cn.itcast.jdbc.UserDao"); Class clazz = Class.forName(className); userDao = (UserDao) clazz.newInstance(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public static UserDao getUserDao() &#123; return userDao; &#125;&#125; dao.properties 1cn.itcast.jdbc.UserDao=cn.itcast.jdbc.UserDaoImpl 9. 时间类型数据库类型与java中类型的对应关系：DATE -&gt; java.sql.DateTIME -&gt; java.sql.TimeTIMESTAMP -&gt; java.sql.Timestamp 领域对象（domain）中的所有属性不能出现java.sql包下的东西！即不能使用java.sql.Date ResultSet#getDate()返回的是java.sql.Date PreparedStatement#setDate(int, Date)，其中第二个参数也是java.sql.Date 时间类型的转换： java.util.Date -&gt; java.sql.Date、Time、Timestamp -把util的Date转换成毫秒值 -使用毫秒值创建sql的Date、Time、Timestamp java.sql.Date、Time、Timestamp -&gt; java.util.Date -这一步不需要处理了：因为java.sql.Date是java.util.Date 123java.util.Date date = new java.util.Date();long l = date.getTime();java.sql.Date sqlDate = new java.sql.Date(l); 9.1 Java中的时间类型java.sql包下给出三个与数据库相关的日期时间类型，分别是： Date：表示日期，只有年月日，没有时分秒。会丢失时间 Time：表示时间，只有时分秒，没有年月日。会丢失日期 Timestamp：表示时间戳，有年月日时分秒，以及毫秒 这三个类都是java.util.Date的子类 9.2 时间类型相互转换把数据库的三种时间类型赋给java.util.Date，基本不用转换，因为这是把子类对象给父类的引用，不需要转换。12345678java.sql.Date date = …java.util.Date d = date;java.sql.Time time = …java.util.Date d = time;java.sql.Timestamp timestamp = …java.util.Date d = timestamp; 当需要把java.util.Date转换成数据库的三种时间类型时，这就不能直接赋值了，这需要使用数据库三种时间类型的构造器。java.sql包下的Date、Time、TimeStamp三个类的构造器都需要一个long类型的参数，表示毫秒值。创建这三个类型的对象，只需要有毫秒值即可。我们知道java.util.Date有getTime()方法可以获取毫秒值，那么这个转换也就不是什么问题了 1234java.utl.Date d = new java.util.Date();java.sql.Date date = new java.sql.Date(d.getTime());//会丢失时分秒Time time = new Time(d.getTime());//会丢失年月日Timestamp timestamp = new Timestamp(d.getTime()); 9.3 实现代码我们来创建一个dt表：12345CREATE TABLE dt( d DATE, t TIME, ts TIMESTAMP) 下面是向dt表中插入数据的代码：123456789101112@Testpublic void fun1() throws SQLException &#123; Connection con = JdbcUtils.getConnection(); String sql = "insert into dt value(?,?,?)"; PreparedStatement pstmt = con.prepareStatement(sql); java.util.Date d = new java.util.Date(); pstmt.setDate(1, new java.sql.Date(d.getTime())); pstmt.setTime(2, new Time(d.getTime())); pstmt.setTimestamp(3, new Timestamp(d.getTime())); pstmt.executeUpdate();&#125; 下面是从dt表中查询数据的代码：​ 12345678910111213141516@Testpublic void fun2() throws SQLException &#123; Connection con = JdbcUtils.getConnection(); String sql = "select * from dt"; PreparedStatement pstmt = con.prepareStatement(sql); ResultSet rs = pstmt.executeQuery(); rs.next(); java.util.Date d1 = rs.getDate(1); java.util.Date d2 = rs.getTime(2); java.util.Date d3 = rs.getTimestamp(3); System.out.println(d1); System.out.println(d2); System.out.println(d3);&#125; 10. 大数据目标：把mp3保存到数据库中！在my.ini中添加如下配置！max_allowed_packet=10485760 10.1 什么是大数据所谓大数据，就是大的字节数据，或大的字符数据。标准SQL中提供了如下类型来保存大数据类型 类型 长度 tinyblob 28–1B（256B） blob 216-1B（64K） mediumblob 224-1B（16M） longblob 232-1B（4G） tinyclob 28–1B（256B） clob 216-1B（64K） mediumclob 224-1B（16M） longclob 232-1B（4G） 但是，在mysql中没有提供tinyclob、clob、mediumclob、longclob四种类型，而是使用如下四种类型来处理文本大数据 类型 长度 tinytext 28–1B（256B） text 216-1B（64K） mediumtext 224-1B（16M） longtext 232-1B（4G） 首先我们需要创建一张表，表中要有一个mediumblob（16M）类型的字段12345CREATE TABLE tab_bin( id INT PRIMARY KEY AUTO_INCREMENT, filename VARCHAR(100), data MEDIUMBLOB); 向数据库插入二进制数据需要使用PreparedStatement的setBinaryStream(int, InputSteam)方法来完成1234567con = JdbcUtils.getConnection();String sql = "insert into tab_bin(filename,data) values(?, ?)";pstmt = con.prepareStatement(sql);pstmt.setString(1, "a.jpg");InputStream in = new FileInputStream("f:\\a.jpg");pstmt.setBinaryStream(2, in);pstmt.executeUpdate(); 读取二进制数据，需要在查询后使用ResultSet类的getBinaryStream()方法来获取输入流对象。也就是说，PreparedStatement有setXXX()，那么ResultSet就有getXXX()12345678910111213con = JdbcUtils.getConnection();String sql = "select filename,data from tab_bin where id=?";pstmt = con.prepareStatement(sql);pstmt.setInt(1, 1);rs = pstmt.executeQuery();rs.next();String filename = rs.getString("filename");OutputStream out = new FileOutputStream("F:\\" + filename);InputStream in = rs.getBinaryStream("data");IOUtils.copy(in, out);out.close(); 还有一种方法，就是把要存储的数据包装成Blob类型，然后调用PreparedStatement的setBlob()方法来设置数据123456789101112131415161718192021con = JdbcUtils.getConnection();String sql = "insert into tab_bin(filename,data) values(?, ?)";pstmt = con.prepareStatement(sql);pstmt.setString(1, "a.jpg");File file = new File("f:\\a.jpg");byte[] datas = FileUtils.getBytes(file);//获取文件中的数据Blob blob = new SerialBlob(datas);//创建Blob对象pstmt.setBlob(2, blob);//设置Blob类型的参数pstmt.executeUpdate();con = JdbcUtils.getConnection();String sql = "select filename,data from tab_bin where id=?";pstmt = con.prepareStatement(sql);pstmt.setInt(1, 1);rs = pstmt.executeQuery();rs.next();String filename = rs.getString("filename");File file = new File("F:\\" + filename) ;Blob blob = rs.getBlob("data");byte[] datas = blob.getBytes(0, (int)file.length());FileUtils.writeByteArrayToFile(file, datas); 11. 批处理11.1 Statement批处理批处理就是一批一批的处理，而不是一个一个的处理！当你有10条SQL语句要执行时，一次向服务器发送一条SQL语句，这么做效率上很差！处理的方案是使用批处理，即一次向服务器发送多条SQL语句，然后由服务器一次性处理。 批处理只针对更新（增、删、改）语句，批处理没有查询什么事儿！ 可以多次调用Statement类的addBatch(String sql)方法，把需要执行的所有SQL语句添加到一个“批”中，然后调用Statement类的executeBatch()方法来执行当前“批”中的语句。 void addBatch(String sql)：添加一条语句到“批”中 int[] executeBatch()：执行“批”中所有语句。返回值表示每条语句所影响的行数据 void clearBatch()：清空“批”中的所有语句123456789for(int i = 0; i &lt; 10; i++) &#123; String number = "S_10" + i; String name = "stu" + i; int age = 20 + i; String gender = i % 2 == 0 ? "male" : "female"; String sql = "insert into stu values('" + number + "', '" + name + "', " + age + ", '" + gender + "')"; stmt.addBatch(sql);&#125;stmt.executeBatch(); 当执行了“批”之后，“批”中的SQL语句就会被清空！也就是说，连续两次调用executeBatch()相当于调用一次！因为第二次调用时，“批”中已经没有SQL语句了。 还可以在执行“批”之前，调用Statement的clearBatch()方法来清空“批”！ 2、PreparedStatement批处理PreparedStatement的批处理有所不同，因为每个PreparedStatement对象都绑定一条SQL模板。所以向PreparedStatement中添加的不是SQL语句，而是给“?”赋值1234567891011con = JdbcUtils.getConnection();String sql = "insert into stu values(?,?,?,?)";pstmt = con.prepareStatement(sql);for(int i = 0; i &lt; 10; i++) &#123; pstmt.setString(1, "S_10" + i); pstmt.setString(2, "stu" + i); pstmt.setInt(3, 20 + i); pstmt.setString(4, i % 2 == 0 ? "male" : "female"); pstmt.addBatch();&#125;pstmt.executeBatch();]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC之数据库连接池]]></title>
    <url>%2F2017%2F05%2F01%2Fjavaweb%2FJDBC%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[JDBC系列阅读 JavaWeb：用JDBC操作数据库 JavaWeb：JDBC之事务 JavaWeb：JDBC之数据库连接池 1. 池参数（所有池参数都有默认值） 初始大小：10个 最小空闲连接数：3个 增量：一次创建的最小单位（5个） 最大空闲连接数：12个 最大连接数：20个 最大的等待时间：1000毫秒 2. 四大连接参数连接池也是使用四大连接参数来完成创建连接对象！ 3. 实现的接口连接池必须实现：javax.sql.DataSource接口！ 连接池返回的Connection对象，它的close()方法与众不同！调用它的close()不是关闭，而是把连接归还给池！ 4. 数据库连接池4.1 数据库连接池的概念用池来管理Connection，这可以重复使用Connection。有了池，所以我们就不用自己来创建Connection，而是通过池来获取Connection对象。当使用完Connection后，调用Connection的close()方法也不会真的关闭Connection，而是把Connection“归还”给池。池就可以再利用这个Connection对象了 4.2 JDBC数据库连接池接口（DataSource）Java为数据库连接池提供了公共的接口：javax.sql.DataSource，各个厂商可以让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池！ 4.3 自定义连接池（ItcastPool）分析：ItcastPool需要有一个List，用来保存连接对象。在ItcastPool的构造器中创建5个连接对象放到List中！当用人调用了ItcastPool的getConnection()时，那么就从List拿出一个返回。当List中没有连接可用时，抛出异常 我们需要对Connection的close()方法进行增强，所以我们需要自定义ItcastConnection类，对Connection进行装饰！即对close()方法进行增强。因为需要在调用close()方法时把连接“归还”给池，所以ItcastConnection类需要拥有池对象的引用，并且池类还要提供“归还”的方法 ItcastPool.java 123456789101112131415161718192021222324252627282930313233343536public class ItcastPool implements DataSource &#123; private static Properties props = new Properties(); private List&lt;Connection&gt; list = new ArrayList&lt;Connection&gt;(); static &#123; InputStream in = ItcastPool.class.getClassLoader() .getResourceAsStream("dbconfig.properties"); try &#123; props.load(in); Class.forName(props.getProperty("driverClassName")); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public ItcastPool() throws SQLException &#123; for (int i = 0; i &lt; 5; i++) &#123; Connection con = DriverManager.getConnection( props.getProperty("url"), props.getProperty("username"), props.getProperty("password")); ItcastConnection conWapper = new ItcastConnection(con, this); list.add(conWapper); &#125; &#125; public void add(Connection con) &#123; list.add(con); &#125; public Connection getConnection() throws SQLException &#123; if(list.size() &gt; 0) &#123; return list.remove(0); &#125; throw new SQLException("没连接了"); &#125; ......&#125; ItcastConnection.java 12345678910111213public class ItcastConnection extends ConnectionWrapper &#123; private ItcastPool pool; public ItcastConnection(Connection con, ItcastPool pool) &#123; super(con); this.pool = pool; &#125; @Override public void close() throws SQLException &#123; pool.add(this); &#125;&#125; 5. DBCP5.1 什么是DBCP？DBCP是Apache提供的一款开源免费的数据库连接池！ Hibernate3.0之后不再对DBCP提供支持！因为Hibernate声明DBCP有致命的缺欠！DBCP因为Hibernate的这一毁谤很是生气，并且说自己没有缺欠 5.2 DBCP的使用1234567891011121314151617public void fun1() throws SQLException &#123; BasicDataSource ds = new BasicDataSource(); ds.setUsername("root"); ds.setPassword("123"); ds.setUrl("jdbc:mysql://localhost:3306/mydb1"); ds.setDriverClassName("com.mysql.jdbc.Driver"); ds.setMaxActive(20); ds.setMaxIdle(10); ds.setInitialSize(10); ds.setMinIdle(2); ds.setMaxWait(1000); Connection con = ds.getConnection(); System.out.println(con.getClass().getName()); con.close();&#125; 5.3 DBCP的配置信息下面是对DBCP的配置介绍： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#基本配置driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mydb1username=rootpassword=123#初始化池大小，即一开始池中就会有10个连接对象默认值为0initialSize=0#最大连接数，如果设置maxActive=50时，池中最多可以有50个连接，当然这50个连接中包含被使用的和没被使用的（空闲）#你是一个包工头，你一共有50个工人，但这50个工人有的当前正在工作，有的正在空闲#默认值为8，如果设置为非正数，表示没有限制！即无限大maxActive=8#最大空闲连接#当设置maxIdle=30时，你是包工头，你允许最多有20个工人空闲，如果现在有30个空闲工人，那么要开除10个#默认值为8，如果设置为负数，表示没有限制！即无限大maxIdle=8#最小空闲连接#如果设置minIdel=5时，如果你的工人只有3个空闲，那么你需要再去招2个回来，保证有5个空闲工人#默认值为0minIdle=0#最大等待时间#当设置maxWait=5000时，现在你的工作都出去工作了，又来了一个工作，需要一个工人。#这时就要等待有工人回来，如果等待5000毫秒还没回来，那就抛出异常#没有工人的原因：最多工人数为50，已经有50个工人了，不能再招了，但50人都出去工作了。#默认值为-1，表示无限期等待，不会抛出异常。maxWait=-1#连接属性#就是原来放在url后面的参数，可以使用connectionProperties来指定#如果已经在url后面指定了，那么就不用在这里指定了。#useServerPrepStmts=true，MySQL开启预编译功能#cachePrepStmts=true，MySQL开启缓存PreparedStatement功能，#prepStmtCacheSize=50，缓存PreparedStatement的上限#prepStmtCacheSqlLimit=300，当SQL模板长度大于300时，就不再缓存它connectionProperties=useUnicode=true;characterEncoding=UTF8;useServerPrepStmts=true;cachePrepStmts=true;prepStmtCacheSize=50;prepStmtCacheSqlLimit=300#连接的默认提交方式#默认值为truedefaultAutoCommit=true#连接是否为只读连接#Connection有一对方法：setReadOnly(boolean)和isReadOnly()#如果是只读连接，那么你只能用这个连接来做查询#指定连接为只读是为了优化！这个优化与并发事务相关！#如果两个并发事务，对同一行记录做增、删、改操作，是不是一定要隔离它们啊？#如果两个并发事务，对同一行记录只做查询操作，那么是不是就不用隔离它们了？#如果没有指定这个属性值，那么是否为只读连接，这就由驱动自己来决定了。即Connection的实现类自己来决定！defaultReadOnly=false#指定事务的事务隔离级别#可选值：NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE#如果没有指定，那么由驱动中的Connection实现类自己来决定defaultTransactionIsolation=REPEATABLE_READ 6. C3P06.1 C3P0简介C3P0也是开源免费的连接池！C3P0被很多人看好！ 6.2 C3P0的使用C3P0中池类是：ComboPooledDataSource。 12345678910111213141516public void fun1() throws PropertyVetoException, SQLException &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setJdbcUrl("jdbc:mysql://localhost:3306/mydb1"); ds.setUser("root"); ds.setPassword("123"); ds.setDriverClass("com.mysql.jdbc.Driver"); ds.setAcquireIncrement(5); ds.setInitialPoolSize(20); ds.setMinPoolSize(2); ds.setMaxPoolSize(50); Connection con = ds.getConnection(); System.out.println(con); con.close();&#125; 配置文件要求： 文件名称：必须叫c3p0-config.xml 文件位置：必须在src下 c3p0也可以指定配置文件，而且配置文件可以是properties，也可骒xml的。当然xml的高级一些了。但是c3p0的配置文件名必须为c3p0-config.xml，并且必须放在类路径下。 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/mydb1&lt;/property&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;123&lt;/property&gt; &lt;property name="acquireIncrement"&gt;3&lt;/property&gt; &lt;property name="initialPoolSize"&gt;10&lt;/property&gt; &lt;property name="minPoolSize"&gt;2&lt;/property&gt; &lt;property name="maxPoolSize"&gt;10&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name="oracle-config"&gt; &lt;property name="jdbcUrl"&gt;jdbc:mysql://localhost:3306/mydb1&lt;/property&gt; &lt;property name="driverClass"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;123&lt;/property&gt; &lt;property name="acquireIncrement"&gt;3&lt;/property&gt; &lt;property name="initialPoolSize"&gt;10&lt;/property&gt; &lt;property name="minPoolSize"&gt;2&lt;/property&gt; &lt;property name="maxPoolSize"&gt;10&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; c3p0的配置文件中可以配置多个连接信息，可以给每个配置起个名字，这样可以方便的通过配置名称来切换配置信息。上面文件中默认配置为mysql的配置，名为oracle-config的配置也是mysql的配置，呵呵 12345678910111213public void fun2() throws PropertyVetoException, SQLException &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); Connection con = ds.getConnection(); System.out.println(con); con.close();&#125;public void fun2() throws PropertyVetoException, SQLException &#123; ComboPooledDataSource ds = new ComboPooledDataSource("orcale-config"); Connection con = ds.getConnection(); System.out.println(con); con.close();&#125; 7. Tomcat配置连接池7.1 Tomcat配置JNDI资源JNDI（Java Naming and Directory Interface），Java命名和目录接口。JNDI的作用就是：在服务器上配置资源，然后通过统一的方式来获取配置的资源 我们这里要配置的资源当然是连接池了，这样项目中就可以通过统一的方式来获取连接池对象了 下图是Tomcat文档提供的： 配置JNDI资源需要到&lt;Context&gt;元素中配置&lt;Resource&gt;子元素： name：指定资源的名称，这个名称可以随便给，在获取资源时需要这个名称 factory：用来创建资源的工厂，这个值基本上是固定的，不用修改 type：资源的类型，我们要给出的类型当然是我们连接池的类型了 bar：表示资源的属性，如果资源存在名为bar的属性，那么就配置bar的值。对于DBCP连接池而言，你需要配置的不是bar，因为它没有bar这个属性，而是应该去配置url、username等属性 1234567891011121314151617181920212223242526&lt;Context&gt; &lt;Resource name="mydbcp" type="org.apache.tomcat.dbcp.dbcp.BasicDataSource" factory="org.apache.naming.factory.BeanFactory" username="root" password="123" driverClassName="com.mysql.jdbc.Driver" url="jdbc:mysql://127.0.0.1/mydb1" maxIdle="3" maxWait="5000" maxActive="5" initialSize="3"/&gt;&lt;/Context&gt; &lt;Context&gt; &lt;Resource name="myc3p0" type="com.mchange.v2.c3p0.ComboPooledDataSource" factory="org.apache.naming.factory.BeanFactory" user="root" password="123" classDriver="com.mysql.jdbc.Driver" jdbcUrl="jdbc:mysql://127.0.0.1/mydb1" maxPoolSize="20" minPoolSize ="5" initialPoolSize="10" acquireIncrement="2"/&gt;&lt;/Context&gt; 7.2 获取资源配置资源的目的当然是为了获取资源了。只要你启动了Tomcat，那么就可以在项目中任何类中通过JNDI获取资源的方式来获取资源了 下图是Tomcat文档提供的，与上面Tomcat文档提供的配置资源是对应的。 获取资源： Context：javax.naming.Context InitialContext：javax.naming.InitialContext lookup(String)：获取资源的方法，其中”java:comp/env”是资源的入口（这是固定的名称），获取过来的还是一个Context，这说明需要在获取到的Context上进一步进行获取。”bean/MyBeanFactory”对应&lt;Resource&gt;中配置的name值，这回获取的就是资源对象了 1234567891011Context cxt = new InitialContext();DataSource ds = (DataSource)cxt.lookup("java:/comp/env/mydbcp");Connection con = ds.getConnection();System.out.println(con);con.close();Context cxt = new InitialContext();Context envCxt = (Context)cxt.lookup("java:/comp/env");DataSource ds = (DataSource)env.lookup("mydbcp");Connection con = ds.getConnection();System.out.println(con);con.close(); 上面两种方式是相同的效果 7.3 修改JdbcUtils因为已经学习了连接池，那么JdbcUtils的获取连接对象的方法也要修改一下了。 JdbcUtils.java 123456789101112131415public class JdbcUtils &#123; private static DataSource dataSource = new ComboPooledDataSource(); public static DataSource getDataSource() &#123; return dataSource; &#125; public static Connection getConnection() &#123; try &#123; return dataSource.getConnection(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 8. ThreadLocalThread -&gt;人类Runnable -&gt; 任务类 key value thread1 aaa thread2 bbb thread3 ccc 8.1 ThreadLocal APIThreadLocal类只有三个方法 返回值 方法说明 功能描述 void set(T value) 保存值 T get() 获取值 void remove() 移除值 8.2 ThreadLocal的内部是MapThreadLocal内部其实是个Map来保存数据。虽然在使用ThreadLocal时只给出了值，没有给出键，其实它内部使用了当前线程做为键 1234567891011121314class MyThreadLocal&lt;T&gt; &#123; private Map&lt;Thread,T&gt; map = new HashMap&lt;Thread,T&gt;(); public void set(T value) &#123; map.put(Thread.currentThread(), value); &#125; public void remove() &#123; map.remove(Thread.currentThread()); &#125; public T get() &#123; return map.get(Thread.currentThread()); &#125;&#125; 9. BaseServlet9.1 BaseServlet的作用在开始客户管理系统之前，我们先写一个工具类：BaseServlet 我们知道，写一个项目可能会出现N多个Servlet，而且一般一个Servlet只有一个方法（doGet或doPost），如果项目大一些，那么Servlet的数量就会很惊人 为了避免Servlet的“膨胀”，我们写一个BaseServlet。它的作用是让一个Servlet可以处理多种不同的请求。不同的请求调用Servlet的不同方法。我们写好了BaseServlet后，让其他Servlet继承BaseServlet，例如CustomerServlet继承BaseServlet，然后在CustomerServlet中提供add()、update()、delete()等方法，每个方法对应不同的请求。 9.2 BaseServlet分析我们知道，Servlet中处理请求的方法是service()方法，这说明我们需要让service()方法去调用其他方法。例如调用add()、mod()、del()、all()等方法！具体调用哪个方法需要在请求中给出方法名称！然后service()方法通过方法名称来调用指定的方法 无论是点击超链接，还是提交表单，请求中必须要有method参数，这个参数的值就是要请求的方法名称，这样BaseServlet的service()才能通过方法名称来调用目标方法。例如某个链接如下： 1&lt;a href=”/xxx/CustomerServlet?method=add”&gt;添加客户&lt;/a&gt; 9.3 BaseServlet代码1234567891011121314151617181920212223242526272829303132public class BaseServlet extends HttpServlet &#123; /* * 它会根据请求中的m，来决定调用本类的哪个方法 */ protected void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; req.setCharacterEncoding("UTF-8"); res.setContentType("text/html;charset=utf-8"); // 例如：http://localhost:8080/demo1/xxx?m=add String methodName = req.getParameter("method");// 它是一个方法名称 // 当没用指定要调用的方法时，那么默认请求的是execute()方法。 if(methodName == null || methodName.isEmpty()) &#123; methodName = "execute"; &#125; Class c = this.getClass(); try &#123; // 通过方法名称获取方法的反射对象 Method m = c.getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class); // 反射方法目标方法，也就是说，如果methodName为add，那么就调用add方法。 String result = (String) m.invoke(this, req, res); // 通过返回值完成请求转发 if(result != null &amp;&amp; !result.isEmpty()) &#123; req.getRequestDispatcher(result).forward(req, res); &#125; &#125; catch (Exception e) &#123; throw new ServletException(e); &#125; &#125;&#125; 10. DBUtils10.1 DBUtils简介DBUtils是Apache Commons组件中的一员，开源免费！DBUtils是对JDBC的简单封装，但是它还是被很多公司使用！DBUtils的Jar包：dbutils.jar 10.2 DBUtils主要类 DbUtils：都是静态方法，一系列的close()方法； QueryRunner： update()：执行insert、update、delete query()：执行select语句 batch()：执行批处理 10.3 QueryRunnerupdate()方法QueryRunner的update()方法可以用来执行insert、update、delete语句。 无参构造QueryRunner() 12//可执行增、删、改语句，需要调用者提供Connection，这说明本方法不再管理Connection了。支持事务!int update(Connection con, String sql, Object… params); 123456@Testpublic void fun1() throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "insert into user values(?,?,?)"; qr.update(JdbcUtils.getConnection(), sql, "u1", "zhangSan", "123");&#125; 还有另一种方式来使用QueryRunner，QueryRunner(DataSource)带连接池的构造，这种方式在创建QueryRunner时传递了连接池对象，那么在调用update()方法时就不用再传递Connection了 12//可执行增、删、改语句int update(String sql, Object… params); 123456@Testpublic void fun2() throws SQLException &#123; QueryRunner qr = new QueryRunner(JdbcUtils.getDataSource()); String sql = "insert into user values(?,?,?)"; qr.update(sql, "u1", "zhangSan", "123");&#125; ###query()方法 12345//可执行查询，它会先得到ResultSet，然后调用rsh的handle()把rs转换成需要的类型！T query(String sql, ResultSetHandler rsh, Object... params);//支持事务T query(Connection con, String sql, ResultSetHadler rsh, Object... params); 10.4 ResultSetHandler我们知道在执行select语句之后得到的是ResultSet，然后我们还需要对ResultSet进行转换，得到最终我们想要的数据。你可以希望把ResultSet的数据放到一个List中，也可能想把数据放到一个Map中，或是一个Bean中 DBUtils提供了一个接口ResultSetHandler，它就是用来ResultSet转换成目标类型的工具。你可以自己去实现这个接口，把ResultSet转换成你想要的类型 DBUtils提供了很多个ResultSetHandler接口的实现，这些实现已经基本够用了，我们通常不用自己去实现ResultSet接口了 处理器 功能描述 MapHandler 单行处理器！把结果集转换成Map&lt;String,Object&gt;，其中列名为键 MapListHandler 多行处理器！把结果集转换成List&lt;Map&lt;String,Object&gt;&gt; BeanHandler 单行处理器！把结果集转换成Bean，该处理器需要Class参数，即Bean的类型 BeanListHandler 多行处理器！把结果集转换成List&lt;Bean&gt; ColumnListHandler 多行单列处理器！把结果集转换成List&lt;Object&gt;，使用ColumnListHandler时需要指定某一列的名称或编号，例如：new ColumListHandler(“name”)表示把name列的数据放到List中 ScalarHandler 单行单列处理器！把结果集转换成Object。一般用于聚集查询，例如select count(*) from tab_student Map处理器 Bean处理器 Column处理器 Scalar处理器 10.5 QueryRunner之查询QueryRunner的查询方法是： 12public &lt;T&gt; T query(String sql, ResultSetHandler&lt;T&gt; rh, Object… params)public &lt;T&gt; T query(Connection con, String sql, ResultSetHandler&lt;T&gt; rh, Object… params) query()方法会通过sql语句和params查询出ResultSet，然后通过rh把ResultSet转换成对应的类型再返回 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Testpublic void fun1() throws SQLException &#123; DataSource ds = JdbcUtils.getDataSource(); QueryRunner qr = new QueryRunner(ds); String sql = "select * from tab_student where number=?"; Map&lt;String,Object&gt; map = qr.query(sql, new MapHandler(), "S_2000"); System.out.println(map);&#125;@Testpublic void fun2() throws SQLException &#123; DataSource ds = JdbcUtils.getDataSource(); QueryRunner qr = new QueryRunner(ds); String sql = "select * from tab_student"; List&lt;Map&lt;String,Object&gt;&gt; list = qr.query(sql, new MapListHandler()); for(Map&lt;String,Object&gt; map : list) &#123; System.out.println(map); &#125;&#125;@Testpublic void fun3() throws SQLException &#123; DataSource ds = JdbcUtils.getDataSource(); QueryRunner qr = new QueryRunner(ds); String sql = "select * from tab_student where number=?"; Student stu = qr.query(sql, new BeanHandler&lt;Student&gt;(Student.class), "S_2000"); System.out.println(stu);&#125;@Testpublic void fun4() throws SQLException &#123; DataSource ds = JdbcUtils.getDataSource(); QueryRunner qr = new QueryRunner(ds); String sql = "select * from tab_student"; List&lt;Student&gt; list = qr.query(sql, new BeanListHandler&lt;Student&gt;(Student.class)); for(Student stu : list) &#123; System.out.println(stu); &#125;&#125;@Testpublic void fun5() throws SQLException &#123; DataSource ds = JdbcUtils.getDataSource(); QueryRunner qr = new QueryRunner(ds); String sql = "select * from tab_student"; List&lt;Object&gt; list = qr.query(sql, new ColumnListHandler("name")); for(Object s : list) &#123; System.out.println(s); &#125;&#125;@Testpublic void fun6() throws SQLException &#123; DataSource ds = JdbcUtils.getDataSource(); QueryRunner qr = new QueryRunner(ds); String sql = "select count(*) from tab_student"; Number number = (Number)qr.query(sql, new ScalarHandler()); int cnt = number.intValue(); System.out.println(cnt);&#125; 10.6 QueryRunner之批处理QueryRunner还提供了批处理方法：batch() 我们更新一行记录时需要指定一个Object[]为参数，如果是批处理，那么就要指定Object[][]为参数了。即多个Object[]就是Object[][]了，其中每个Object[]对应一行记录： 1234567891011@Testpublic void fun10() throws SQLException &#123; DataSource ds = JdbcUtils.getDataSource(); QueryRunner qr = new QueryRunner(ds); String sql = "insert into tab_student values(?,?,?,?)"; Object[][] params = new Object[10][];//表示 要插入10行记录 for(int i = 0; i &lt; params.length; i++) &#123; params[i] = new Object[]&#123;"S_300" + i, "name" + i, 30 + i, i%2==0?"男":"女"&#125;; &#125; qr.batch(sql, params);&#125; 11. Service事务在Service中使用ThreadLocal来完成事务，为将来学习Spring事务打基础！ 11.1 DAO中的事务在DAO中处理事务真是“小菜一碟”。 123456789101112131415161718192021222324public void xxx() &#123; Connection con = null; try &#123; con = JdbcUtils.getConnection(); con.setAutoCommitted(false); QueryRunner qr = new QueryRunner(); String sql = …; Object[] params = …; qr.update(con, sql, params); sql = …; Object[] params = …; qr.update(con, sql, params); con.commit();&#125; catch(Exception e) &#123; try &#123; if(con != null) &#123;con.rollback();&#125;&#125; catch(Exception e) &#123;&#125;&#125; finally &#123; try &#123; con.close();&#125; catch(Exception e) &#123;&#125;&#125;&#125; 11.2 Service才是处理事务的地方我们要清楚一件事，DAO中不是处理事务的地方，因为DAO中的每个方法都是对数据库的一次操作，而Service中的方法才是对应一个业务逻辑。也就是说我们需要在Service中的一方法中调用DAO的多个方法，而这些方法应该在一起事务中。 怎么才能让DAO的多个方法使用相同的Connection呢？方法不能再自己来获得Connection，而是由外界传递进去。 1234public void daoMethod1(Connection con, …) &#123;&#125;public void daoMethod2(Connection con, …) &#123;&#125; 在Service中调用DAO的多个方法时，传递相同的Connection就可以了。 123456789101112131415161718192021public class XXXService() &#123; private XXXDao dao = new XXXDao(); public void serviceMethod() &#123; Connection con = null; try &#123; con = JdbcUtils.getConnection(); con.setAutoCommitted(false); dao.daoMethod1(con, …); dao.doaMethod2(con, …); com.commint(); &#125; catch(Exception e) &#123; try &#123; con.rollback(); &#125; catch(Exception e) &#123;&#125; &#125; finally &#123; try &#123; con.close(); &#125; catch(Exception e) &#123;&#125; &#125; &#125;&#125; 但是，在Service中不应该出现Connection，它应该只在DAO中出现，因为它是JDBC的东西，JDBC的东西是用来连接数据库的，连接数据库是DAO的事儿！！！但是，事务是Service的事儿，不能放到DAO中！！！ 11.3 修改JdbcUtils我们把对事务的开启和关闭放到JdbcUtils中，在Service中调用JdbcUtils的方法来完成事务的处理，但在Service中就不会再出现Connection这一“禁忌”了。 DAO中的方法不用再让Service来传递Connection了。DAO会主动从JdbcUtils中获取Connection对象，这样，JdbcUtils成为了DAO和Service的中介！ 我们在JdbcUtils中添加beginTransaction()和rollbackTransaction()，以及commitTransaction()方法。这样在Service中的代码如下： 12345678910111213public class XXXService() &#123; private XXXDao dao = new XXXDao(); public void serviceMethod() &#123; try &#123; JdbcUtils.beginTransaction(); dao.daoMethod1(…); dao.daoMethod2(…); JdbcUtils.commitTransaction(); &#125; catch(Exception e) &#123; JdbcUtils.rollbackTransaction(); &#125; &#125;&#125; 1234567DAOpublic void daoMethod1(…) &#123; Connection con = JdbcUtils.getConnection();&#125;public void daoMethod2(…) &#123; Connection con = JdbcUtils.getConnection();&#125; 在Service中调用了JdbcUtils.beginTransaction()方法时，JdbcUtils要做准备好一个已经调用了setAuthCommitted(false)方法的Connection对象，因为在Service中调用JdbcUtils.beginTransaction()之后，马上就会调用DAO的方法，而在DAO方法中会调用JdbcUtils.getConnection()方法。这说明JdbcUtils要在getConnection()方法中返回刚刚准备好的，已经设置了手动提交的Connection对象。 在JdbcUtils中创建一个Connection con属性，当它为null时，说明没有事务！当它不为null时，表示开启了事务。 在没有开启事务时，可以调用“开启事务”方法； 在开启事务后，可以调用“提交事务”和“回滚事务”方法； getConnection()方法会在con不为null时返回con，再con为null时，从连接池中返回连接。 beginTransaction() 判断con是否为null，如果不为null，就抛出异常！如果con为null，那么从连接池中获取一个Connection对象，赋值给con！然后设置它为“手动提交”。 getConnection() 判断con是否为null，如果为null说明没有事务，那么从连接池获取一个连接返回；如果不为null，说明已经开始了事务，那么返回con属性返回。这说明在con不为null时，无论调用多少次getConnection()方法，返回的都是同个Connection对象。 commitTransaction() 判断con是否为null，如果为null，说明没有开启事务就提交事务，那么抛出异常；如果con不为null，那么调用con的commit()方法来提交事务；调用con.close()方法关闭连接；con = null，这表示事务已经结束！ rollbackTransaction() 判断con是否为null，如果为null，说明没有开启事务就回滚事务，那么抛出异常；如果con不为null，那么调用con的rollback()方法来回滚事务；调用con.close()方法关闭连接；con = null，这表示事务已经结束！ JdbcUtils.java 1234567891011121314151617181920212223242526272829303132333435363738394041public class JdbcUtils &#123; private static DataSource dataSource = new ComboPooledDataSource(); private static Connection con = null; public static DataSource getDataSource() &#123; return dataSource; &#125; public static Connection getConnection() throws SQLException &#123; if(con == null) &#123; return dataSource.getConnection(); &#125; return con; &#125; public static void beginTranscation() throws SQLException &#123; if(con != null) &#123; throw new SQLException("事务已经开启，在没有结束当前事务时，不能再开启事务！"); &#125; con = dataSource.getConnection(); con.setAutoCommit(false); &#125; public static void commitTransaction() throws SQLException &#123; if(con == null) &#123; throw new SQLException("当前没有事务，所以不能提交事务！"); &#125; con.commit(); con.close(); con = null; &#125; public static void rollbackTransaction() throws SQLException &#123; if(con == null) &#123; throw new SQLException("当前没有事务，所以不能回滚事务！"); &#125; con.rollback(); con.close(); con = null; &#125;&#125; 11.4 再次修改JdbcUtils现在JdbcUtils有个问题，如果有两个线程！第一个线程调用了beginTransaction()方法，另一个线程再调用beginTransaction()方法时，因为con已经不再为null，所以就会抛出异常了。 我们希望JdbcUtils可以多线程环境下被使用！这说明最好的方法是为每个线程提供一个Connection，这样每个线程都可以开启自己的事务了。还记得ThreadLocal类么？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class JdbcUtils &#123; // 配置文件的默认配置！要求你必须给出c3p0-config.xml！！！ private static ComboPooledDataSource dataSource = new ComboPooledDataSource(); // 它是事务专用连接！ private static ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;Connection&gt;(); /** * 使用连接池返回一个连接对象 * @return * @throws SQLException */ public static Connection getConnection() throws SQLException &#123; Connection con = tl.get(); // 当con不等于null，说明已经调用过beginTransaction()，表示开启了事务！ if(con != null) return con; return dataSource.getConnection(); &#125; /** * 返回连接池对象！ * @return */ public static DataSource getDataSource() &#123; return dataSource; &#125; /** * 开启事务 * 1. 获取一个Connection，设置它的setAutoComnmit(false) * 2. 还要保证dao中使用的连接是我们刚刚创建的！ * -------------- * 1. 创建一个Connection，设置为手动提交 * 2. 把这个Connection给dao用！ * 3. 还要让commitTransaction或rollbackTransaction可以获取到！ * @throws SQLException */ public static void beginTransaction() throws SQLException &#123; Connection con = tl.get(); if(con != null) throw new SQLException("已经开启了事务，就不要重复开启了！"); /* * 1. 给con赋值！ * 2. 给con设置为手动提交！ */ con = getConnection();//给con赋值，表示事务已经开始了 con.setAutoCommit(false); tl.set(con);//把当前线程的连接保存起来！ &#125; /** * 提交事务 * 1. 获取beginTransaction提供的Connection，然后调用commit方法 * @throws SQLException */ public static void commitTransaction() throws SQLException &#123; Connection con = tl.get();//获取当前线程的专用连接 if(con == null) throw new SQLException("还没有开启事务，不能提交！"); /* * 1. 直接使用con.commit() */ con.commit(); con.close(); // 把它设置为null，表示事务已经结束了！下次再去调用getConnection()返回的就不是con了 tl.remove();//从tl中移除连接 &#125; /** * 提交事务 * 1. 获取beginTransaction提供的Connection，然后调用rollback方法 * @throws SQLException */ public static void rollbackTransaction() throws SQLException &#123; Connection con = tl.get(); if(con == null) throw new SQLException("还没有开启事务，不能回滚！"); /* * 1. 直接使用con.rollback() */ con.rollback(); con.close(); tl.remove(); &#125; /** * 释放连接 * @param connection * @throws SQLException */ public static void releaseConnection(Connection connection) throws SQLException &#123; Connection con = tl.get(); /* * 判断它是不是事务专用，如果是，就不关闭！ * 如果不是事务专用，那么就要关闭！ */ // 如果con == null，说明现在没有事务，那么connection一定不是事务专用的！ if(con == null) connection.close(); // 如果con != null，说明有事务，那么需要判断参数连接是否与con相等，若不等， //说明参数连接不是事务专用连接 if(con != connection) connection.close(); &#125;&#125; 11.5 转账示例12345678public class AccountDao &#123; public void updateBalance(String name, double balance) throws SQLException &#123; String sql = "update account set balance=balance+? where name=?"; Connection con = JdbcUtils.getConnection(); QueryRunner qr = new QueryRunner(); qr.update(con, sql, balance, name); &#125;&#125; 123456789101112131415161718public class AccountService &#123; private AccountDao dao = new AccountDao(); public void transfer(String from, String to, double balance) &#123; try &#123; JdbcUtils.beginTranscation(); dao.updateBalance(from, -balance); dao.updateBalance(to, balance); JdbcUtils.commitTransaction(); &#125; catch(Exception e) &#123; try &#123; JdbcUtils.rollbackTransaction(); &#125; catch (SQLException e1) &#123; throw new RuntimeException(e); &#125; &#125; &#125;&#125; 12AccountService as = new AccountService();as.transfer("zs", "ls", 100);]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http协议]]></title>
    <url>%2F2017%2F04%2F30%2Fjavaweb%2FHttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[网络编程 Java基础：网络编程 Uri、URL、UriMatcher、ContentUris详解 Android应用开发：网络编程1 Android应用开发：网络编程2 1. 什么是HTTP协议客户端连上web服务器后，若想获得web服务器中的某个web资源，需遵守一定的通讯格式，HTTP协议用于定义客户端与web服务器通迅的格式。 HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程。这个协议详细规定了浏览器和万维网服务器之间互相通信的规则。 HTTP就是一个通信规则，通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。其实我们要学习的就是这个两个格式！客户端发送给服务器的格式叫“请求协议”；服务器发送给客户端的格式叫“响应协议”。 HTTP协议是学习JavaWEB开发的基石，不深入了解HTTP协议，就不能说掌握了WEB开发，更无法管理和维护一些复杂的WEB站点。 OSI网络七层协议 应用层（HTTP、FTP、SMTP、POP3、TELNET） 表示层 会话层 传输层（TCP、UDP） 网络层（IP） 数据链路层 物理层 2. HTTP协议简介HTTP使用请求-响应的方式进行传输，一个请求对应一个响应，并且请求只能是由客户端发起的。 利用Telnet演示请求与响应的过程 安装IE浏览器插件HttpWatch，查看IE浏览器通过HTTP协议获取某个页面。 HTTP协议的版本：HTTP/1.0、HTTP/1.1 3. HTTP1.0和HTTP1.1的区别在HTTP1.0协议中，客户端与web服务器建立连接后，只能获得一个web资源。 HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取多个web资源。 利用telnet演示HTTP1.0和HTTP1.1的区别 一个好多同学搞不清楚的问题： 一个web页面中，使用img标签引用了三幅图片，当客户端访问服务器中的这个web页面时，客户端总共会访问几次服务器，即向服务器发送了几次HTTP请求。 4. 协议协议：协议的甲乙双方，就是客户端（浏览器）和服务器！ 理解成双方通信的格式！ 请求协议 响应协议 5. HttpWatch和FireBugHttpWatch是专门为IE浏览器提供的，用来查看HTTP请求和响应内容的工具。而FireFox上需要安装FireBug软件。如果你使用的是Chrome，那么就不用自行安装什么工具了，因为它自身就有查看请求和响应内容的功能！ HttpWatch和FireBug这些工具对浏览器而言不是必须的，但对我们开发者是很有帮助的，通过查看HTTP请求响应内容，可以使我们更好的学习HTTP协议。 6. 请求协议请求协议的格式如下： 1234请求首行；请求头信息；空行；请求体。 浏览器发送给服务器的内容就这个格式的，如果不是这个格式服务器将无法解读！在HTTP协议中，请求有很多请求方法，其中最为常用的就是GET和POST。不同的请求方法之间的区别，后面会一点一点的介绍。 6.1 GET请求打开IE，在访问hello项目的index.jsp之间打开HttpWatch，并点击“Record”按钮。然后访问index.jsp页面。查看请求内容如下： 123456789GET /hello/index.jsp HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,zh;q=0.5Accept-Encoding: gzip, deflateAccept-Charset: GB2312,utf-8;q=0.7,*;q=0.7Connection: keep-aliveCookie: JSESSIONID=369766FDF6220F7803433C0B2DE36D98 GET /hello/index.jsp HTTP/1.1：GET请求，请求服务器路径为/hello/index.jsp，协议为1.1 Host:localhost：请求的主机名为localhost User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0：与浏览器和OS相关的信息。有些网站会显示用户的系统版本和浏览器版本信息，这都是通过获取User-Agent头信息而来的 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8：告诉服务器，当前客户端可以接收的文档类型，其实这里包含了/，就表示什么都可以接收 Accept-Language: zh-cn,zh;q=0.5当前客户端支持的语言，可以在浏览器的工具选项中找到语言相关信息 Accept-Encoding: gzip, deflate：支持的压缩格式。数据在网络上传递时，可能服务器会把数据压缩后再发送 Accept-Charset: GB2312,utf-8;q=0.7,*;q=0.7：客户端支持的编码 Connection: keep-alive：客户端支持的链接方式，保持一段时间链接，默认为3000ms Cookie: JSESSIONID=369766FDF6220F7803433C0B2DE36D98因为不是第一次访问这个地址，所以会在请求中把上一次服务器响应中发送过来的Cookie在请求中一并发送去过；这个Cookie的名字为JSESSIONID，然后在讲会话是讲究它！ 6.2 POST请求为了演示POST请求，我们需要修改index.jsp页面，即添加一个表单： 1234&lt;form action="" method="post"&gt; 关键字：&lt;input type="text" name="keyword"/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; 打开HttpWatch，输入hello后点击提交，查看请求内容如下： 1234567891011121314POST /hello/index.jsp HTTP/1.1Accept: image/gif, image/jpeg, image/pjpeg, image/pjpeg, application/msword, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/x-ms-application, application/x-ms-xbap, application/vnd.ms-xpsdocument, application/xaml+xml, */*Referer: http://localhost:8080/hello/index.jspAccept-Language: zh-cn,en-US;q=0.5User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; InfoPath.2; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)Content-Type: application/x-www-form-urlencodedAccept-Encoding: gzip, deflateHost: localhost:8080Content-Length: 13Connection: Keep-AliveCache-Control: no-cacheCookie: JSESSIONID=E365D980343B9307023A1D271CC48E7Dkeyword=hello POST请求是可以有体的，而GET请求不能有请求体。 Referer: http://localhost:8080/hello/index.jsp请求来自哪个页面，例如你在百度上点击链接到了这里，那么Referer:http://www.baidu.com；如果你是在浏览器的地址栏中直接输入的地址，那么就没有Referer这个请求头了 Content-Type: application/x-www-form-urlencoded表单的数据类型，说明会使用url格式编码数据；url编码的数据都是以“%”为前缀，后面跟随两位的16进制，例如“传智”这两个字使用UTF-8的url编码用为“%E4%BC%A0%E6%99%BA” Content-Length:13：请求体的长度，这里表示13个字节 keyword=hello：请求体内容！hello是在表单中输入的数据，keyword是表单字段的名字。 Referer请求头是比较有用的一个请求头，它可以用来做统计工作，也可以用来做防盗链。 6.3 统计工作我公司网站在百度上做了广告，但不知道在百度上做广告对我们网站的访问量是否有影响，那么可以对每个请求中的Referer进行分析，如果Referer为百度的很多，那么说明用户都是通过百度找到我们公司网站的。 6.4 防盗链我公司网站上有一个下载链接，而其他网站盗链了这个地址，例如在我网站上的index.html页面中有一个链接，点击即可下载JDK7.0，但有某个人的微博中盗链了这个资源，它也有一个链接指向我们网站的JDK7.0，也就是说登录它的微博，点击链接就可以从我网站上下载JDK7.0，这导致我们网站的广告没有看，但下载的却是我网站的资源。这时可以使用Referer进行防盗链，在资源被下载之前，我们对Referer进行判断，如果请求来自本网站，那么允许下载，如果非本网站，先跳转到本网站看广告，然后再允许下载 7. 响应协议7.1 响应内容响应协议的格式如下：1234响应首行；响应头信息；空行；响应体。 响应内容是由服务器发送给浏览器的内容，浏览器会根据响应内容来显示。123456HTTP/1.1 200 OKServer: Apache-Coyote/1.1Content-Type: text/html;charset=UTF-8Content-Length: 724Set-Cookie: JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/helloDate: Wed, 25 Sep 2012 04:15:03 GMT 1234567891011121314151617181920212223&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;&lt;html&gt; &lt;head&gt; &lt;base href="http://localhost:8080/hello/"&gt; &lt;title&gt;My JSP 'index.jsp' starting page&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;!-- &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; --&gt; &lt;/head&gt; &lt;body&gt;&lt;form action="" method="post"&gt; 关键字：&lt;input type="text" name="keyword"/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; HTTP/1.1 200 OK：响应协议为HTTP1.1，状态码为200，表示请求成功，OK是对状态码的解释 Server: Apache-Coyote/1.1：服务器的版本信息 Content-Type: text/html;charset=UTF-8：响应体使用的编码为UTF-8 Content-Length: 724：响应体为724字节 Set-Cookie: JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/hello：响应给客户端的Cookie； Date: Wed, 25 Sep 2012 04:15:03 GMT：响应的时间，这可能会有8小时的时区差 7.2 若干响应头 响应头 功能描述 Content-Encoding: gzip 服务器发送数据时使用的压缩格式 Server:apache tomcat 服务器的基本信息 Content-Length: 80 发送数据的大小 Content-Language: zh-cn 发送的数据使用的语言环境 Content-Disposition: attachment;filename=aaa.zip 与下载相关的头 Expires: -1 指定资源缓存的时间，如果取值为0或-1浏览就不缓存资源 Cache-Control: no-cache 缓存相关的头，如果为no-cache则通知浏览器不缓存 Pragma: no-cache 缓存相关的头，如果为no-cache则不缓存 Connection: close/Keep-Alive 是否保持连接 Location 配合302实现请求重定向 Content-Type 发送数据的类型和编码 Last-Modified 最后修改时间 Refresh 自动刷新，n秒后跳转到另一个页面 Set-Cookie 发送Cookie信息 Location: http://www.it315.org/index.jsp 配合302实现请求重定向 Content-Type: text/html; charset=GB2312 当前所发送的数据的基本信息，（数据的类型，所使用的编码） Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT 缓存相关的头 Refresh: 1;url=http://www.it315.org 通知浏览器进行定时刷新，此值可以是一个数字指定多长时间以后刷新当前页面，这个数字之后也可以接一个分号后跟一个URL地址指定多长时间后刷新到哪个URL Transfer-Encoding: chunked 传输类型，如果是此值是一个chunked说明当前的数据是一块一块传输的 Set-Cookie:SS=Q0=5Lb_nQ; path=/search 和cookie相关的头，后面课程单讲 ETag: W/“83794-1208174400000” 和缓存机制相关的头​Date: Tue, 11 Jul 2000 18:23:51 GMT 当前时间 7.3 响应码响应头对浏览器来说很重要，它说明了响应的真正含义。例如200表示响应成功了，302表示重定向，这说明浏览器需要再发一个新的请求。 响应码 描述 200 请求成功，浏览器会把响应体内容（通常是html）显示在浏览器中 206 请求部分资源，和请求头Range使用 302 重定向，当响应码为302时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头Location，它指定了新请求的URL地址 304 服务器通知浏览器使用缓存 307 服务器通知浏览器使用缓存 404 请求的资源没有找到，说明客户端错误的请求了不存在的资源 500 请求资源找到了，但服务器内部出现了错误 304：当用户第一次请求index.html时，服务器会添加一个名为Last-Modified响应头，这个头说明了index.html的最后修改时间，浏览器会把index.html内容，以及最后响应时间缓存下来。当用户第二次请求index.html时，在请求中包含一个名为If-Modified-Since请求头，它的值就是第一次请求时服务器通过Last-Modified响应头发送给浏览器的值，即index.html最后的修改时间，If-Modified-Since请求头就是在告诉服务器，我这里浏览器缓存的index.html最后修改时间是这个，您看看现在的index.html最后修改时间是不是这个，如果还是，那么您就不用再响应这个index.html内容了，我会把缓存的内容直接显示出来。而服务器端会获取If-Modified-Since值，与index.html的当前最后修改时间比对，如果相同，服务器会发响应码304，表示index.html与浏览器上次缓存的相同，无需再次发送，浏览器可以显示自己的缓存页面，如果比对不同，那么说明index.html已经做了修改，服务器会响应200 响应头： Last-Modified：最后的修改时间 请求头 If-Modified-Since：把上次请求的index.html的最后修改时间还给服务器；状态码：304，比较If-Modified-Since的时间与文件真实的时间一样时，服务器会响应304，而且不会有响正文，表示浏览器缓存的就是最新版本 7.4 其他响应头1、告诉浏览器不要缓存的响应头 Expires: -1 Cache-Control: no-cache Pragma: no-cache 以上三个头都是用来控制缓存的，是因为历史原因造成的，不同的浏览器认识不同的头，我们通常三个一起使用保证通用性 2、自动刷新响应头，浏览器会在3秒之后请求http://www.itcast.cn： Refresh: 3;url=http://www.itcast.cn 7.5 HTML中指定响应头在HTMl页面中可以使用&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;来指定响应头，例如在index.html页面中给出&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;3;url=http://www.itcast.cn&quot;&gt;，表示浏览器只会显示index.html页面3秒，然后自动跳转到http://www.itcast.cn。 8. 模拟网络请求restClient，这个是firefox上的一个插件，对应chrome浏览器叫做postman，这个插件主要用作和服务器开发人员联调协议 postman restClient 9. 测试请求的地址http://httpbin.org 10. gzip压缩一种压缩格式，一种压缩方式，可以对网络传输的数据进行压缩。减少网络传输的大小 为什么需要压缩?因为经过压缩，可以减少体积，提高传输速度,提高用户体验 10.1 浏览器发送器请求的过程 1.发送请求头:Accept-Encoding:gzip 2.服务器压缩数据,返回数据,在响应头里面添加Content-Encoding:gzip 3.客户端,根据Content-Encoding这个响应头,对应解压 有Content-Encoding:gzip–&gt;gzip解压 没有Content-Encoding:gzip–&gt;标准解压 app使用gzip压缩：返回的json/xml(文本信息)其实就是个特殊的网页,其实也是可以进行gzip压缩 10.2 gzip压缩效果 通过数据，我们得知，文本的压缩率，大概可以达到70%左右。压缩率很高 10.3 gzip压缩的实现1234567891011121314151617181920212223242526272829303132333435try &#123; boolean isGzip = false; //1.创建httpclient DefaultHttpClient httpClient = new DefaultHttpClient(); //2.创建get请求 HttpGet get = new HttpGet("http://httpbin.org/gzip"); //① 添加请求头 Accept-Encoding:"gzip, deflate" get.addHeader("Accept-Encoding", "gzip"); //3.执行请求 HttpResponse response = httpClient.execute(get); if (response.getStatusLine().getStatusCode() == 200) &#123; //② 得到响应头,Content-Encoding:"gzip" Header[] headers = response.getHeaders("Content-Encoding"); for (Header header : headers) &#123; if (header.getValue().equals("gzip")) &#123;//后台server把数据进行了gzip压缩 isGzip = true; &#125; &#125; String result = ""; HttpEntity entity = response.getEntity(); //③根据是否使用gzip压缩.采取不同的解压方式 if (isGzip) &#123; //④进行gzip的解压 GZIPInputStream in = new GZIPInputStream(response.getEntity().getContent()); //in--&gt;string result = convertStreamToString(in); &#125; else &#123; //4.打印结果 result = EntityUtils.toString(entity); &#125; System.out.println("result:" + result); &#125;&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 11. 抓包11.1 Fiddler只能抓浏览器返回的包，即只可以抓PC上的包，无法抓手机上的包 11.2 Wireshark世界上最流行的网络协议分析器，抓包工具Wireshark基本介绍和学习TCP三次握手 通过ping命令拿到网址的IP window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{},"image":{"viewList":["fbook","twi","linkedin","qzone","tsina","douban","weixin","evernotecn"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?'];]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http协议详解]]></title>
    <url>%2F2017%2F04%2F30%2Fjavaweb%2FHTTP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[当今web程序的开发技术真是百家争鸣，ASP.NET, PHP, JSP，Perl, AJAX 等等。 无论Web技术在未来如何发展，理解Web程序之间通信的基本协议相当重要, 因为它让我们理解了Web应用程序的内部工作. 本文将对HTTP协议进行详细的实例讲解，内容较多，希望大家耐心看。也希望对大家的开发工作或者测试工作有所帮助。使用Fiddler工具非常方便地捕获HTTP Request和HTTP Response, 关于Fiddler工具的用法，请看我另一篇博客[Fiddler 教程] 1. 什么是HTTP协议协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器 目前我们使用的是HTTP/1.1 版本 2. Web服务器，浏览器,代理服务器当我们打开浏览器，在地址栏中输入URL，然后我们就看到了网页。 原理是怎样的呢？ 实际上我们输入URL后，我们的浏览器给Web服务器发送了一个Request, Web服务器接到Request后进行处理，生成相应的Response，然后发送给浏览器， 浏览器解析Response中的HTML,这样我们就看到了网页，过程如下图所示 我们的Request 有可能是经过了代理服务器，最后才到达Web服务器的。过程如下图所示 代理服务器就是网络信息的中转站，有什么功能呢？ 提高访问速度， 大多数的代理服务器都有缓存功能 突破限制， 也就是翻墙了 隐藏身份 3. URL详解 URL(Uniform Resource Locator) 地址用于描述一个网络上的资源, 基本格式如下 1schema://host[:port#]/path/.../[?query-string][#anchor] URL 说明 scheme 指定低层使用的协议(例如：http, https, ftp) host HTTP服务器的IP地址或者域名 port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/ path 访问资源的路径 query-string 发送给http服务器的数据 anchor 锚 URL 的一个例子 1234567http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuffSchema: httphost: www.mywebsite.compath: /sj/test/test.aspxQuery String: name=sviergn&amp;x=trueAnchor: stuff 4. HTTP协议是无状态的http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态. 5. 打开一个网页需要浏览器发送很多次Request 当你在浏览器输入URL http://www.cnblogs.com 的时候，浏览器发送一个Request去获取 http://www.cnblogs.com 的html. 服务器把Response发送回给浏览器 浏览器分析Response中的 HTML，发现其中引用了很多其他文件，比如图片，CSS文件，JS文件 浏览器会自动再次发送Request去获取图片，CSS文件，或者JS文件 等所有的文件都下载成功后。 网页就被显示出来了 6. HTTP消息的结构先看Request 消息的结构, Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行， 结构如下图 第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号 当使用的是”GET” 方法的时候， body是为空的，比如我们打开博客园首页的request 如下 12GET http://www.cnblogs.com/ HTTP/1.1Host: www.cnblogs.com 抽象的东西，难以理解，老感觉是虚的， 所谓眼见为实, 实际见到的东西，我们才能理解和记忆。 我们今天用Fiddler，实际的看看Request和Response 下面我们打开Fiddler 捕捉一个博客园登录的Request 然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Request的消息， 如下图 我们再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行, 结构如下图 HTTP/version-number表示HTTP协议的版本号， status-code 和message 请看下节[状态代码]的详细解释. 我们用Fiddler 捕捉一个博客园首页的Response然后分析下它的结构, 在Inspectors tab下以Raw的方式可以看到完整的Response的消息， 如下图 7. Get和Post方法的区别Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. 我们看看GET和POST的区别 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码. 8. 状态码Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response. HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别 1XX 提示信息 - 表示请求已被成功接收，继续处理 2XX 成功 - 表示请求已被成功接收，理解，接受 3XX 重定向 - 要完成请求必须进行更进一步的处理 4XX 客户端错误 - 请求有语法错误或请求无法实现 5XX 服务器端错误 - 服务器未能实现合法的请求 看看一些常见的状态码 200 OK 最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端 如下图， 打开博客园首页 302 Found 重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request 例如在IE中输入， http://www.google.com. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request. 304 Not Modified 代表上次的文档已经被缓存了， 还可以继续使用，例如打开博客园首页, 发现很多Response 的status code 都是304 提示： 如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面 400 Bad Request 客户端请求与语法错误，不能被服务器所理解 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在（输错了URL），比如在IE中输入一个错误的URL， http://www.cnblogs.com/tesdf.aspx 500 Internal Server Error 服务器发生了不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 9. HTTP Request header使用Fiddler 能很方便的查看Reques header, 点击Inspectors tab -&gt;Request tab-&gt; headers 如下图所示. header 有很多，比较难以记忆，我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。 9.1 Cache 头域 If-Modified-Since 作用： 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中. 例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT，实例如下图 If-None-Match 作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能 例如: If-None-Match: “03f2b33c0bfcc1:0”，实例如下图 Pragma 作用： 防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样 Pargma只有一个用法， 例如： Pragma: no-cache 注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control Cache-Control 作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下 Cache-Control:Public 可以被任何缓存所缓存（） Cache-Control:Private 内容只缓存到私有缓存中 Cache-Control:no-cache 所有内容都不会被缓存 还有其他的一些用法， 我没搞懂其中的意思， 请大家参考其他的资料 9.2 Client 头域 Accept 作用： 浏览器端可以接受的媒体类型, 例如： Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档, 如果服务器无法返回text/html类型的数据,服务器应该返回一个406错误(non acceptable) 通配符 * 代表任意类型 例如 Accept: / 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个) Accept-Encoding： 作用： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）; 例如： Accept-Encoding: gzip, deflate Accept-Language 作用： 浏览器申明自己接收的语言。 语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等； 例如： Accept-Language: en-us User-Agent 作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本. 我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。 例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E) Accept-Charset 作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案） 9.3 Cookie/Login 头域Cookie，作用： 最重要的header, 将cookie的值发送给HTTP 服务器 9.4 Entity头域 Content-Length，作用：发送给HTTP服务器数据的长度。例如： Content-Length: 38 Content-Type，作用：发送给HTTP服务器数据的类型，例如：Content-Type: application/x-www-form-urlencoded 9.5 Miscellaneous 头域 Referer: 作用： 提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。 例如: Referer:http://translate.google.cn/?hl=zh-cn&amp;tab=wT 9.6 Transport 头域 Connection 例如： Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 Host（发送请求时，该报头域是必需的） 作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的 例如: 我们在浏览器中输入：http://www.guet.edu.cn/index.html 浏览器发送的请求消息中，就会包含Host请求报头域，例如，Host：http://www.guet.edu.cn 此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号 10. HTTP Response header同样使用Fiddler 查看Response header, 点击Inspectors tab -&gt;Response tab-&gt; headers 如下图所示 我们也按照Fiddler那样把header 进行分类，这样比较清晰也容易记忆。 10.1 Cache头域 Date，作用: 生成消息的具体时间和日期，例如：Date: Sat, 11 Feb 2012 11:35:14 GMT Expires，作用: 浏览器会在指定过期时间内使用本地缓存，例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT Vary，作用：例如: Vary: Accept-Encoding 10.2 Cookie/Login 头域 P3P，作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题 例如: P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR Set-Cookie 作用： 非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie. 例如: Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com 10.3 Entity头域 ETag 作用: 和If-None-Match 配合使用。 （实例请看上节中If-None-Match的实例） 例如: ETag: “03f2b33c0bfcc1:0” Last-Modified: 作用： 用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例） 例如: Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT Content-Type 作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集，例如: Content-Type: text/html; charset=utf-8Content-Type:text/html;charset=GB2312Content-Type: image/jpeg Content-Length 指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。例如: Content-Length: 19847 Content-Encoding WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip Content-Language 作用： WEB服务器告诉浏览器自己响应的对象的语言者，例如： Content-Language:da 10.4 Miscellaneous 头域 Server，作用：指明HTTP服务器的软件信息，例如:Server: Microsoft-IIS/7.5 X-AspNet-Version: 作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本，例如: X-AspNet-Version: 4.0.30319 X-Powered-By，作用：表示网站是用什么技术开发的，例如： X-Powered-By: ASP.NET 10.5 Transport头域 Connection 例如： Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 例如： Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 10.6 Location头域Location，作用： 用于重定向一个新的位置, 包含新的URL地址，实例请看304状态实例 11. HTTP协议是无状态的和Connection: keep-alive的区别无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系 HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接） 从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的事件分发]]></title>
    <url>%2F2017%2F04%2F30%2Fandroid%2FAndroid%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%2F</url>
    <content type="text"><![CDATA[1. Touch事件和绘制事件的异同之处Touch事件和绘制事件很类似，都是由ViewRoot派发下来的，但是不同之处在绘制事件是由应用中的某个View发起请求，一层一层上传到ViewRoot，再有ViewRoot下发绘制，传递canvas给所有子View让其绘制自身，绘制好后，再通知WMS进行画到屏幕上。而Touch事件是由硬件捕获到触摸后由系统传递给应用的ViewRoot，再由ViewRoot往下一层一层传递。 他们的处理过程都是自上而下的分发，但是绘制多了一层自下往上的请求。 事件存在消耗，事件的处理方法都会返回一个boolean值，如果该值为true，则本次事件下发将会终止。 2. MotionEvent2.1 MotionEvent对象的产生系统有一个线程在循环收集屏幕硬件信息，当用户触摸屏幕时，该线程会把从硬件设备收集到的信息封装成一个MotionEvent对象，然后把该对象存放到一个消息队列中。 系统的另一个线程循环的读取消息队列中的MotionEvent，然后交给WMS去派发，WMS把该事件派发给当前处于活动的Activity，即处于活动栈最顶端的Activity。 这就是一个先进先出的消费者和生产者的模板，一个线程不停的创建MotionEvent对象放入队列中，另一个线程不断的从队列中取出MotionEvent对象进行分发。 当用户的手指从接触屏幕到离开屏幕，是一个完整的触摸事件，在该事件中，系统会不断收集事件信息封装成MotionEvent对象。收集的间隔时间取决于硬件设备，例如屏幕的灵敏度以及cpu的计算能力。目前的手机一般在20毫秒左右。 MotionEventCompat.getActionMasked() 2.2 MotionEvent对象详解MotionEvent对象包含了触摸事件的时间、位置、面积、压力、以及本次事件的Dwon发生的时间。 MotionEvent常用的Action分为5种：Down 、Up、Move、Cancel、OutSide MotionEvent中我们常用的方法就是获取点击的坐标，因为这是与我们操作息息相关的。获取坐标有两种方式： getX和getY用于获取以该View左上角为坐标原点的坐标 getRowX和getRowY用于获取以屏幕左上角为坐标原点的坐标 2.3 5种Touch事件 Down：一次触摸事件的第一个MotionEvent对象，即手指初次接触屏幕。 Up：通常为一次触摸事件的最后一个MotionEvent对象，即手指离开屏幕。 Move：通常多次发生在一次触摸事件之中。表示触摸点发生了移动，我们通常把手指放到屏幕上，实际也会触发该事件，因为人手总是在轻微抖动的。 Cancel：常用于取消某个触摸事件，一般是由程序逻辑来指定该事件，用于取消某次触摸事件。 OutSide：当触摸点发生在响应事件的View之外时，传递的事件，通常由程序逻辑来指定。 在上面5种事件中，Down为最重要的事件，因为这是一个触摸事件的起始点，程序的很多逻辑判断，都需要根据该事件做处理，例如分发拦截。一次触摸事件必须要有Down事件，这也是MotionEvent对象中都包含了本次触摸事件的Down事件发生的时间点这个属性。其次是Move和Up，通过这3个事件的逻辑处理，就构建出来滑动，点击，长按，双击等多种效果。 2.4 创建一个MotionEvent对象1234567891011121314public static MotionEvent obtain( long downTime, //当用户最初按下开始一连串的位置事件。这必须得到SystemClock.uptimeMillis() long eventTime, //当这个特定的事件是生成的。这必须得到SystemClock.uptimeMillis() int action, //该次事件的Action float x, //该次事件的x坐标 float y, //该次事件的y坐标 float pressure, //该次事件的压力，通常感觉标准压力，从0-1取值 float size, //点击的区域大小，通常根据特定标准范围从0-1取值 int metaState, //一个修饰性的状态，好像一直都是0 float xPrecision, //x坐标的精确度 float yPrecision, //y坐标的精确度 int deviceId, //触屏设备id，如果是0，说明这个事件不是来自物理设备 int edgeFlags //系统默认都是返回0，程序在传递时，可以通过逻辑判断加入方向位置 ) 或者一个更简单的方式： 1234567public static MotionEvent obtain( long downTime, long eventTime, int action, float x, float y, int metaState) 也可以通过一个MotionEvent来创建一个新的 1public static MotionEvent obtain(MotionEvent event) 通过以上的方式，我们知道，我们也可以通过代码来构建一个虚假的MotionEvent，并分发下去。 1234view.dispatchTouchEvent( MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN,100,100,0)); 然后通过延迟以此往下派发Move和Up时间，形成一个完整的触摸操作。 3. dispatchTouchEvent触摸事件分发 之前我们知道触摸事件是被包装成MotionEvent进行传递的，而该对象是继承了Parcelable接口，正因为如此，才可以从系统中传递到我们的应用中。系统通过跨进程通知ViewRoot，ViewRoot会调用DecorView的dispatchTouchEvent下发。 这里有一个和其他事件传递不同的地方，DecorView会优先传递给Activity，而不是它的子View。而Activity如果不处理又会回传给DecorView，DecorView才会再将事件传给子View。 dispatchTouchEvent就是触摸事件传递的对外接口，无论是DecorView传给Activity，还是ViewGroup传递给子View，都是直接调用对方的dispatchTouchEvent方法，并传递MotionEvent参数。 我们首先来看看Activity中的dispatchTouchEvent逻辑： 12345678910111213141516171819202122232425public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); //这是一个空实现的方法，以便子类实现，该方法在Key事件和touch事件的dispatch方法中都被调用， // 就是方便用户在事件被传递之前做一下自己的处理。 &#125; //这才是事件真正的分发 if (getWindow().superDispatchTouchEvent(ev)) &#123; //superDispatchTouchEvent是一个抽象方法，但是getWindow()获取的对象实际是FrameWork层的 // PhoneWindow，该对象实现了这个方法，内部是直接调用DecorView的superDispatchTouchEvent // 是直接调用dispatchTouchEvent，这样就传递到子View中了 return true; &#125; //如果上面事件没有被消费掉，那么就调用Activity的onTouchEvent事件。 return onTouchEvent(ev);&#125;//PhoneWindow的superDispatchTouchEvent方法直接调用了mDecor的superDispatchTouchEventpublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125;//mDecor即为Activity真正的根View，我们通过setContentView所添加的内容就是添加在该View上，// 它实际上就是一个FrameLayoutpublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);//FrameLayout.dispatchTouchEvent&#125; 至此我们已经至少明白了以下几点： 1、我们可以重载Activity的onUserInteraction方法，在Down事件触发传递前，实现我们的一些需求，实际上源码中有很多这样的方法，再某个方法体的第一行提供一个空实现的回调方法，在某个方法的最后一行提供一个空实现的回调方法，以便子类去实现自己的逻辑，例如AsyncTask就有类似的方式。这些技巧都能很好的提高我们代码的扩展性。 2、Activity会间接的调用根View的dispatchTouchEvent，并通过if判断返回值，如果为true，即向上层返回true，也就是调用Activity的dispatchTouchEvent的WMS，即操作系统。 3、如果if判断为false，即根View和根View下的所有子View均为消费掉该事件，那么下面的代码就有执行机会，即Activity的onTouchEvent，并把该方法的返回值作为结果返回给上层。 3.1 View的dispatchTouchEvent View中的处理相当简单明了，因为不涉及到子View，所以只在自身内部进行分发。首先判断是否设置了触摸监听，并且可以响应事件，就交由监听的onTouch处理。如果上述条件不成立，或者监听的onTouch事件没有消费掉该事件，则交由onTouchEvent进行处理，并把返回结果交给上层。 123456789public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; //判断mOnTouchListener是否存在，并且控件可点的情况下，执行onTouch，如果onTouch返回true，就消耗该事件 return true; &#125; //如果以上条件都不成立，则把事件交给onTouchEvent来处理 return onTouchEvent(event);&#125; 3.2 ViewGroup的dispatchTouchEvent 3.3 Down事件 通过onInterceptTouchEvent方法判断是否要拦截事件，默认fasle 根据scroll换算后的坐标找出所接受的子View。有动画的子View将不接受触摸事件。 找到能接受的子View后把event中的坐标转换成子View的坐标 调用子View的dispatchTouchEvent把事件传递给子View。 如果子View消费了该事件，则把target记录为子View，方便后面的Move和Up事件的传递。 如果子View没有消费，则继续寻找下一个子View。 如果没找到，或者找到的子View都不消费，就会调用View的dispatchTouchEvent的逻辑，也就是判断是否有触摸监听，有的话交给监听的onTouch处理，没有的话交给自己的onTouchEvent处理 接下来我们来研究ViewGroup的dispatchTouchEvent，这是稍微复杂的分发逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public boolean dispatchTouchEvent(MotionEvent ev) &#123; final int action = ev.getAction();//获取事件 final float xf = ev.getX();//获取触摸坐标 final float yf = ev.getY(); final float scrolledXFloat = xf + mScrollX;//获取当前需要偏移的偏移量量 final float scrolledYFloat = yf + mScrollY; final Rect frame = mTempRect; //当前ViewGroup的视图矩阵 boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;//是否禁止拦截 if (action == MotionEvent.ACTION_DOWN) &#123;//如果事件是按下事件 if (mMotionTarget != null) &#123; //判断接受事件的target是否为空 //不为空肯定是不正常的，因为一个事件是由DOWN开始的，而DOWN还没有被消费，所以目标也不是不可能被确定， //造成这个的原因可能是在上一次up事件或者cancel事件的时候，没有把目标赋值为空 mMotionTarget = null; //在此处挽救 &#125; //不允许拦截，或者onInterceptTouchEvent返回false，也就是不拦截。注意，这个判断都是在DOWN事件中判断 if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123; //从新设置一下事件为DOWN事件，其实没有必要，这只是一种保护错误，防止被篡改了 ev.setAction(MotionEvent.ACTION_DOWN); //开始寻找能响应该事件的子View final int scrolledXInt = (int) scrolledXFloat; final int scrolledYInt = (int) scrolledYFloat; final View[] children = mChildren; final int count = mChildrenCount; for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123;//如果child可见，或者有动画，获取该child的矩阵 child.getHitRect(frame); if (frame.contains(scrolledXInt, scrolledYInt)) &#123; // 设置系统坐标 final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); if (child.dispatchTouchEvent(ev)) &#123;//调用child的dispatchTouchEvent //如果消费了，目标就确定了，以便接下来的事件都传递给child mMotionTarget = child; return true; //事件消费了，返回true &#125; &#125; &#125; &#125; //能到这里来，证明所有的子View都没消费掉Down事件，那么留给下面的逻辑进行处理 &#125; &#125; //判断是不是up或者cancel事件 boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL); if (isUpOrCancel) &#123; //如果是取消，把禁止拦截这个标志位给取消 mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; final View target = mMotionTarget; if (target == null) &#123; //判断该值是否为空，如果为空，则没找到能响应的子View，那么直接调用super的dispatchTouchEvent，也就是View的dispatchTouchEvent ev.setLocation(xf, yf); return super.dispatchTouchEvent(ev); &#125; //能走到这里来，说明已经有target，那也说明，这里不是DOWN事件，因为DOWN事件如果有target，已经在前面返回了，执行不到这里 if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123;//如果有目标，又非要拦截，则给目标发送一个cancel事件 final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; ev.setAction(MotionEvent.ACTION_CANCEL);//该为cancel ev.setLocation(xc, yc); if (!target.dispatchTouchEvent(ev)) &#123; //调用子View的dispatchTouchEvent，就算它没有消费这个cancel事件，我们也无能为力了。 &#125; //清除目标 mMotionTarget = null; //有目标，又拦截，自身也享受不了了，因为一个事件应该由一个View去完成 return true;//直接返回true，以完成这次事件，好让系统开始派发下一次 &#125; if (isUpOrCancel) &#123;//取消或者UP的话，把目标赋值为空，以便下一次DOWN能重新找，此处就算不赋值，下一次DOWN也会先把它赋值为空 mMotionTarget = null; &#125; //又不拦截，又有目标，那么就直接调用目标的dispatchTouchEvent final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; ev.setLocation(xc, yc); return target.dispatchTouchEvent(ev); //也就是说，如果是DOWN事件，拦截了，那么每次一次MOVE或者UP都不会再判断是否拦截，直接调用super的dispatchTouchEvent //如果DOWN没拦截，就是有其他View处理了DOWN事件，那么接下来的MOVE或者UP事件拦截了，那么给目标View发送一个cancel事件，告诉它touch被取消了，并且自身也不会处理，直接返回true //这是为了不违背一个Touch事件只能由一个View处理的原则。&#125; 3.4 Move和Up事件判断事件是否被取消或者事件是否要拦截住，是的话，给Down事件找到的target发送一个取消事件。如果不取消，也不拦截，并且Down已经找到了target，则直接交给target处理，不再遍历子View寻找合适的View了。这种处理事件是正确的，我们用手机经常可以体会到，当我手指按在一个拖动条上之后，在拖动的时候手指就算移出了拖动条，依然会把事件分发给拖动条控制它的拖动。 4. onInterceptTouchEventViewGroup的方法，事件拦截，return true表示拦截触摸事件，事件就不往下传递 子View可以调用getParent().requestDisallowInterceptTouchEvent( true ) 请求父控件不拦截touch事件 5. View的onTouchEvent从View的dispatchTouchEvent可以看出，事件最终的处理无非是交给TouchListener的onTouch方法或者是交由onTouchEvent处理，由于onTouch默认是空实现，由程序员来编写逻辑，那么我们来看看onTouchEvent事件。View只能响应click和longclick，不具备滑动等特性。 Down时，设置按压状态，发送一个延迟500毫秒的长按事件。Move时，判断是否移出了View，移出后移除按压状态，长按事件。Up时，取消按压，并判断它是否可以通过触摸获取焦点，是的话设置焦点，判断长按事件是否执行了，如果还没执行，就删除，并执行点击事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; //先判断标示位是否为disable，也就是无法处理事件。 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125;//如果是UP事件，并且状态为按压，取消按压。 //系统源码解释：虽然是disable，但是还是可以消费掉触摸事件，只是不触发任何click或者longclick事件。 //根据是否可点击,可长按来决定是否消费点击事件。 return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; //先检查触摸的代理对象是否存在，如果存在，就交由代理对象处理。 // 触摸代理对象是可以进行设置的，一般用于当我们手指在某个View上，而让另外一个View响应事件，另外一个View就是该View的事件代理对象。 if (mTouchDelegate.onTouchEvent(event)) &#123;//如果代理对象消费了，则返回true消费该事件 return true; &#125; &#125; if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; //如果是可点击或者长按的标识位执行下面的逻辑，这些标志位可以设置，也可以设置了对应的listener后自动添加 //因为作为一个View，它只能单纯的接受处理点击事件，像滑动之类的复杂事件普通View是不具备的。 switch (event.getAction()) &#123; case MotionEvent.ACTION_UP://处理Up事件 boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;//是否包含临时按压状态 if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;//如果本身处于被按压状态或者临时按压状态 //临时按压状态会在下面的Move事件中说明 boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; //如果它可以获取焦点，并且可以通过触摸来获取焦点，并且现在不是焦点，则请求获取焦点，因为一个被按压的View理论上应该获取焦点 focusTaken = requestFocus(); &#125; if (prepressed) &#123; //如果是临时按压，则设置为按压状态，PFLAG_PREPRESSED是一个非常短暂的状态，用于在某些时候短时间内表示Pressed状态，但不需要绘制 setPressed(true);//设置为按压状态，是因为临时按压不会绘制，这个时候强制绘制一次，确保用户能够看见按压状态 &#125; if (!mHasPerformedLongPress) &#123; //是否执行了长按事件，还没有的话，这个时候可以移除长按的回调了，因为UP都已经触发，说明从按下到UP的时间不足以触发longPress //至于longPress，会在Down事件中说明 removeLongPressCallback(); if (!focusTaken) &#123;//如果是焦点状态，就不会触摸click，这是为什么呢？因为焦点状态一般是交给按键处理的， //pressed状态才是交给触摸处理，如果它是焦点，那么它的click事件应该由按键来触发 if (mPerformClick == null) &#123; //封装一个Runnable对象，这个对象中实际就调用了performClick(); mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123;//向消息队列发生该runnabel，如果发送不成功，则直接执行该方法。 performClick();//这个方法内部会调用clickListner &#125; //为什么不直接执行呢？如果这个时候直接执行，UP事件还没执行完，发送post，可以保障在这个代码块执行完毕之后才执行 &#125; &#125; if (mUnsetPressedState == null) &#123;//仍旧是创建一个Runnabel对象，执行setPressed(false) mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; //如果是临时按压状态，之前的Down和move都还未触发按压状态，只在up时设置了，这个状态才刚刚绘制，为了保证用户能看到，发生一个64秒的延迟消息，来取消按压状态。 postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); //这是一个64毫秒的短暂时间，这是为了让这个按压状态持续一小段时间，以便手指离开时候，还能看见View的按压状态 &#125; else if (!post(mUnsetPressedState)) &#123;//如果不是临时按压，则直接发送，发送失败，则直接执行 mUnsetPressedState.run(); &#125; removeTapCallback(); //移除这个callBack，这个callBack内部就是把临时按压状态设置成按压状态，因为这个已经没必要了，手指已经up了 &#125; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; //按下事件把长按事件执行的变量设置为false，代表还没执行长按，因为才按下，表示新的一个长按事件可以开始计算了 if (performButtonActionOnTouchDown(event)) &#123; //先把这个事件交由该方法，该方法内部会判断是否为上下文的菜单按钮，或者是否为鼠标右键，如果是就弹出上下文菜单。 //现在有些手机的上下文菜单按钮也是在屏幕触屏上的 break; &#125; //这个方法会一直往上找父View，判断自身是否在一个可以滚动的容器中 boolean isInScrollingContainer = isInScrollingContainer(); //如果是在一个滚动的容器中，那么按压事件将会被推迟一段时间，如果这段时间内，发生了Move，那么按压状态讲不会被显示，直接滚动父视图 if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; //先添加临时的按压状态，该状态表示按压，但不会绘制 if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); //创建一个runnable对象，这个runnable内部会取消临时按压状态，设置为按压状态，并启动长按的延迟事件 &#125; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); //向消息机制发生一个64毫秒的延迟时间，该事件会取消临时按压状态，设置为直接按压，并启动长按时间的计时 &#125; else &#123; //如果不在一个滚动的容器中，则直接设置按压状态，并启动长按计时 setPressed(true); checkForLongClick(0); //长按事件就是向消息机制发送一个runnable对象，封装的就是我们在lisner中的代码，延迟500毫秒执行，也就是说长按事件在我们按下的时候发送，在up的时候检查一下执行了吗？如果没执行，就取消，并执行click &#125; break; case MotionEvent.ACTION_CANCEL: //如果是取消事件，那就好办了，把我们之前发送的几个延迟runnable对象给取消掉 setPressed(false); //设置为非按压状态 removeTapCallback(); //取消mPendingCheckForTap，也就是不用再把临时按压设置为按压了 removeLongPressCallback(); //取消长按事件的延迟回调 break; case MotionEvent.ACTION_MOVE: //move事件 final int x = (int) event.getX(); //取触摸点坐标 final int y = (int) event.getY(); // 用于判断是否在View中，为什么还要判断呢？ //这是因为父View是在Down事件中判断是否在该View中的，如果在，以后的Move和up都会传递过来，不再进行范围判断 if (!pointInView(x, y, mTouchSlop)) &#123; //mTouchSlop是一个常量，数值为8,也就是说，就算你的落点超出了View的8像素位置，也算在View中。 //是因为人的手指触摸点比较大，有可能你感觉点在某个控件的边缘，但是实际落点已经超出这个View，所以这里给了8像素的范围 removeTapCallback();//如果在范围外，就移除这些runnable回调 if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; //如果是按压状态，就取消长按，设置为非按压状态，为什么这个时候取消呢，因为在Down的时候，我们可以知道，只有是按压状态，才会设置长按 removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; //至此，可以返回true，消费该事件 &#125; return false; //如果不可点击，也不可长按，则返回false，因为View只具备消费点击事件&#125; 从上面的代码我们总结一下View对触摸事件的处理： 1、是否为diabale，如果是，直接根据是否设置了click和longclick来返回。2、是否设置了触摸代理对象，如果有，把事件传递给触摸代理对象，交由其处理，如果消费了，直接返回3、是否为click或者longclick的，如果是，返回true，不是返回false。 而View对click和longclick的处理如下： Down： 判断是否可以触摸上下文菜单。 是否在可以滑动的容器中，如果是先设置临时按压，再发送一个延迟消息把临时按压改为按压，并发送一个延迟500毫秒的事件去执行长按代码 如果不在滚动容器中，直接设置按压状态，并发送一个延迟500毫秒的事件去执行长按代码。 Move： 取触摸点坐标判断是否在View中（额外增加了8像素的范围） 如果在，不用做任何事。 如果不在，取消临时按压到按压回调，取消长按延迟回调，设置为非按压状态 Up 判断是否为按压或者临时按压状态 如果不是，不做任何处理 如果是先判断其是否可以获取焦点，然后请求焦点。 如果是临时按压状态，设置临时按压状态为按压状态。保证界面被绘制成按压状态，让用户可以看见。 如果长按回调还未触发，取消长按回调，如果不是焦点状态，触发click事件。 如果是临时按压状态，发送一个延迟取消按压状态的，保证按压状态持续一段时间，让用户可见。 如果不是临时按压状态，直接发送消息取消按压状态。发送失败，直接取消按压状态。 取消把临时按压设置按压的回调。 从中我们知道View的onTouchEvent主要处理了click和longclick事件，当按下时，向消息机制发送一个延迟500毫秒的长按回调事件，当移动时候判断是否移出了View的范围，超出则取消事件。当离开时，判断长按事件是否触发了，如果没触发且不是焦点，就触发click事件。 在这里最绕的就是临时按压和按压状态，临时按压是为了处理滑动容器的，让处于滑动容器中，按下时，我们先设置的是临时按压，持续64毫秒，是为了判断接下来的时间内是否发生了move事件，如果发生了，将不会再出发按压状态，这样不会让用户看到listView滚动时，item还处于按压状态。在离开时，我们再次判断是否处于临时按压，如果是在64毫秒内触发了down和up，说明按压状态还没来得急绘制，则强制设置为按压状态，保证用户能看到，并在取消回调的方法上加上64毫秒的延迟 6. onTouch与onClick123456789ImageView iv_image = (ImageView) findViewById(R.id.iv_image);iv_image.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("iv_image---onTouch--" + event.getAction()); return false; &#125;&#125;); 点击ImageView的时候只会打印一次，因为onTouch()返回false，只传递down事件，不会传递up事件1System.out: iv_image---onTouch--0 12345678910// ImageView天生不能被点击，没有点击事件ImageView iv_image = (ImageView) findViewById(R.id.iv_image);iv_image.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("iv_image---onTouch--" + event.getAction()); return true; // 把返回值改为true &#125;&#125;); 把onTouch()方法返回值改为true，点击ImageView会打印两次（down and up） 12System.out: iv_image---onTouch--0System.out: iv_image---onTouch--1 123456789101112131415ImageView iv_image = (ImageView) findViewById(R.id.iv_image);iv_image.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("iv_image---onTouch--" + event.getAction()); return true; &#125;&#125;);//添加click事件iv_image.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("iv_image---onClick"); &#125;&#125;); 还是打印两次，onTouch()返回true，click事件并不会得到执行123456789101112131415ImageView iv_image = (ImageView) findViewById(R.id.iv_image);iv_image.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("iv_image---onTouch--" + event.getAction()); return false; &#125;&#125;);iv_image.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("iv_image---onClick"); &#125;&#125;); 打印三次，两次touch事件（down and up）和一次click事件12345678Button button = (Button) findViewById(R.id.button);button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("button---onTouch--" + event.getAction()); return false; &#125;&#125;); 点击Button会打印两次 12345678910111213141516Button button = (Button) findViewById(R.id.button);button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("button---onTouch--" + event.getAction()); return true; &#125;&#125;);button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("button---onClick"); &#125;&#125;); 打印两次，因为onTouch()返回true，不会执行onTouchEvent()，而click事件是在onTouchEvent()中执行，所以也不会执行click事件12345678910111213141516Button button = (Button) findViewById(R.id.button);button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("button---onTouch--" + event.getAction()); return false; &#125;&#125;);button.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("button---onClick"); &#125;&#125;); 打印三次1234567891011public boolean dispatchTouchEvent(MotionEvent event) &#123; if (!onFilterTouchEventForSecurity(event)) &#123; return false; &#125; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event);&#125; a 判断mOnTouchListener是否为nullb 判断当前的控件是否可用c 判断view的onTouch。d 如果以上一个返回为false。那么就会调用onTouchEvent 首先判断mOnTouchListener不为null，并且view是enable的状态，然后 mOnTouchListener.onTouch(this, event)返回true，这三个条件如果都满足，直接return true ; 也就是下面的onTouchEvent(event）不会被执行了。如果我们设置了setOnTouchListener，并且return true，那么View自己的onTouchEvent就不会被执行了 onTouch是优先于onClick执行, onClick的调用在onTouchEvent(event)方法中 view的事件分发 返回true，说明可以响应down事件和up事件 返回false，只会响应down事件。不会响应up事件。在down事件如果能消费(处理)当前事件。那么在up的时候也会把事件传递给当前的view，在down事件处理不了当前事件。那么在up的时候。也不会把事件传递给当前的view 模拟点击事件 123456789101112131415161718192021private void createClick(final View v) &#123; 08-23 03:22:35.028: I/System.out(1652): x轴坐标---151.0--y轴坐标---218.0 final int x = 151; final int y = 218; long downTime = System.currentTimeMillis(); MotionEvent motionEventDown = MotionEvent.obtain(downTime, downTime, MotionEvent.ACTION_DOWN, x, y, 0); v.dispatchTouchEvent(motionEventDown); new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; long upTime = System.currentTimeMillis(); MotionEvent motionEventUp = MotionEvent.obtain(upTime, upTime, MotionEvent.ACTION_UP, x, y, 0); v.dispatchTouchEvent(motionEventUp); &#125; &#125;, 200); &#125; Android的事件分发实例分析 7. ScrollView的onTouchEvent普通的ViewGroup并没有对onTouchEvent事件做处理，只有可以滚动的才有，我们可以分析一下ScrollView Down时，判断落点是否在子View中，不再就不处理，因为ScrollView只有一个子View。 Move时，通过对比本次手指的位置和上一次的位置的距离，计算出Y方向的差值，然后用scorllBy进行滚动视图 Up时，通过速度进行fling，这里利用了两个帮助类，一个是计算速度的帮助类VelocityTracker，一个是滚动的帮助类Scroller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public boolean onTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; ev.getEdgeFlags() != 0) &#123; //如果是down事件，并且触摸到边缘，就不处理EdgeFlags代表是否为边缘，其值是1/2/4/8。代表上下左右 return false; &#125; if (mVelocityTracker == null) &#123; //这是一个追踪触摸事件，并计算速度的帮助类，实现原理就是用三个数组分别记录每次触摸的x/y和时间 mVelocityTracker = VelocityTracker.obtain(); &#125; mVelocityTracker.addMovement(ev); final int action = ev.getAction(); switch (action &amp; MotionEvent.ACTION_MASK) &#123;//与上ff，去掉高位有关多点的信息 case MotionEvent.ACTION_DOWN: &#123;//如果是down final float y = ev.getY();//获取y坐标 if (!(mIsBeingDragged = inChild((int) ev.getX(), (int) y))) &#123;//判断是否开始拖动 //原理就是判断落点是否在child中，ScrollView只能由一个child，如果在，返回true，反之false //也就是说落点在child中，就是准备开始拖动，不在，就直接返回，这可能是因为设置了padding之类的缘故造成的 return false; &#125; if (!mScroller.isFinished()) &#123;//判断滚动是否完成 mScroller.abortAnimation();//如果没完成，停止滚动 //对应上一次用户手指离开时候处理fling状态，这次按下手指，直接停止滚动 &#125; //记录y坐标，以便下次事件来对比 mLastMotionY = y; mActivePointerId = ev.getPointerId(0);//记住多点的id，下次取值时只取该点的 break; &#125; case MotionEvent.ACTION_MOVE: if (mIsBeingDragged) &#123;//可以看出，如果down的时候落点在child外，则以后就算滑进了child也不处理 //根据上次记录的多点id，找到对应的点，取y值 final int activePointerIndex = ev.findPointerIndex(mActivePointerId); final float y = ev.getY(activePointerIndex); final int deltaY = (int) (mLastMotionY - y);//计算位移 mLastMotionY = y;//重新记录y值 scrollBy(0, deltaY);//滚动指定的距离，这也说明了ScrollView只具备纵向滑动 &#125; break; case MotionEvent.ACTION_UP: if (mIsBeingDragged) &#123;//如果是离开事件 final VelocityTracker velocityTracker = mVelocityTracker; velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);//计算最后1秒钟内的速度，并给定一个最大速度进行限制 //这个最大速度是根据屏幕密度不同而不同的，所以大家也没事别使劲滑动屏幕，因为有这个最大速度限制 //获取y方向的速度 int initialVelocity = (int) velocityTracker.getYVelocity(mActivePointerId); if (getChildCount() &gt; 0 &amp;&amp; Math.abs(initialVelocity) &gt; mMinimumVelocity) &#123; //如果有子View，并且计算出来的y的速度比最小速度要大，执行fling状态 //手指滑动的方向和屏幕移动的方向是相反的，所以这里加- fling(-initialVelocity); &#125; mActivePointerId = INVALID_POINTER;//给mActivePointerId重新赋值为-1，防止下次事件找到了错误的点 mIsBeingDragged = false;//恢复默认值 if (mVelocityTracker != null) &#123;//清空速度计算帮助类 mVelocityTracker.recycle(); mVelocityTracker = null; &#125; &#125; break; case MotionEvent.ACTION_CANCEL: if (mIsBeingDragged &amp;&amp; getChildCount() &gt; 0) &#123;//判断条件，只有这2个条件成立，才会发生滚动事件，下面的值才会被改变，才需要恢复默认 mActivePointerId = INVALID_POINTER; mIsBeingDragged = false; if (mVelocityTracker != null) &#123; mVelocityTracker.recycle(); mVelocityTracker = null; &#125; &#125; break; case MotionEvent.ACTION_POINTER_UP://多点触摸时，不是最后一个点离开 onSecondaryPointerUp(ev); break; &#125; return true;&#125;//用于应对先按下1点，然后按下2点，1点离开后，2点仍能继续滑动的逻辑private void onSecondaryPointerUp(MotionEvent ev) &#123; final int pointerIndex = (ev.getAction() &amp; MotionEvent.ACTION_POINTER_INDEX_MASK) &gt;&gt; MotionEvent.ACTION_POINTER_INDEX_SHIFT;//首先对高位进行与操作，然后右移8位，获取其高位代表index的值 final int pointerId = ev.getPointerId(pointerIndex);//取出该点的id if (pointerId == mActivePointerId) &#123;//如果这个id对应的就是第一个按下的点 //理论上pointerIndex应该是0，所以用第二个按下的点，即1index的点代替 final int newPointerIndex = pointerIndex == 0 ? 1 : 0; mLastMotionY = ev.getY(newPointerIndex);//取出新点的y坐标 mActivePointerId = ev.getPointerId(newPointerIndex);//记录新点的id if (mVelocityTracker != null) &#123;//清空之前存入的MotionEvent，也就是说最后的速度只计算该点产生的 mVelocityTracker.clear(); &#125; &#125;&#125; 通过以上分析，我们得出以下知识： 在down事件的时候先判断触摸是否处于边缘，如果是，则不处理 在down事件中判断落点是否在子View中，如果不在，不处理 在down事件中判断是否仍在滑动，如果是，先停止 记录第一个按下点的索引值 每次事件都记录住当前的y值 在move事件中通过记录的索引值找到对应的点，获取y坐标 与上一次y坐标进行比对，scrollBy两次的差值 在up事件的时候计算最后一秒钟的速度，并且有最大速度进行限制，当计算的速度大于系统默认的最小速度时，只想fling up和cancel事件还原变量为默认值 如果为多点离开，进行多点离开的处理 该处理方式时：如果离开的是第一个按下的点，那么由第二个按下的点代替其进行y值偏移计算的基点，并清空速度计算的帮助类，重新记录MotionEvnet 8. Layout和Scroll的区别 Layout中设置的是自身在父View中的显示区域 Scroll是调整自己的显示区域 当父View滚动或者layout变化后，自身在屏幕上的位置会发生变化。当自身Scroll滚动后，在屏幕上的显示位置是不变的，变的只是自身的显示内容。 Scroll滚动不会影响Layout，只是在draw的时候影响画布偏移和触摸时的坐标计算。 window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{},"image":{"viewList":["fbook","twi","linkedin","qzone","tsina","douban","weixin","evernotecn"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?'];]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的消息机制]]></title>
    <url>%2F2017%2F04%2F30%2Fandroid%2FAndroid%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1. ANR异常Application No Response：应用程序无响应。在主线程中，是不允许执行耗时的操作的，如果主线程阻塞的时间大于6秒，就很有可能出现anr异常。主线程，要完成界面的更新，事件的处理，窗体显示的回调，所以如果主线程阻塞时间较长，就不能很好的处理以上比较重要的事情，那么Android有一个机制，就是如果他发现消息队列中有很多消息，主线程没办法响应的话，他就会抛出anr异常。所以，比较耗时的操作都必须要交给子线程。 解决办法：可以通过Handler来解决这个问题，将比较耗时的操作交给子线程，然后子线程通过Handler，发送消息给主线程，让主线程去更新界面。什么样的操作时比较耗时的？ 1、访问网络，2、大文件的拷贝，3、阻塞式的请求，socket 2. Handler、Looper、Message、MessageQueueAndroid 的Handler 机制（也有人叫消息机制）目的是为了跨线程通信，也就是多线程通信。之所以需要跨线程通信是因为在Android 中主线程通常只负责UI 的创建和修改，子线程负责网络访问和耗时操作，因此，主线程和子线程需要经常配合使用才能完成整个Android 功能。 在Android中，线程内部或者线程之间进行信息交互时经常会使用消息，这些基础的东西如果我们熟悉其内部的原理，将会使我们容易、更好地架构系统，避免一些低级的错误。在学习Android中消息机制之前，我们先了解与消息有关的几个类： Handler：消息处理器，发送消息和处理消息。你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里，或者接收Looper(从Message Queue取出)所送来的消息。 Looper：轮询器，从messagequeue取消息，分发给handler处理。一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列) Message 消息，数据的载体 MessageQueue 消息队列，存储消息 当我们的Android应用程序的进程一创建的时候，系统就给这个进程提供了一个Looper，Looper是一个死循环，它内部维护这个一个消息队列。Looper不停地从消息队列中取消息（Message），取到消息就发送给了Handler，最后Handler根据接收到的消息去修改UI。Handler的sendMessage方法就是将消息添加到消息队列中。 3. UI线程线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。 每一个线程里可含有一个Looper对象以及一个MessageQueue数据结构。在你的应用程序里，可以定义Handler的子类别来接收Looper所送出的消息。在你的Android程序里，新诞生一个线程，或执行 (Thread)时并不会自动建立其Message Looper。 Android里并没有Global的Message Queue数据结构，例如，不同APK里的对象不能透过Massage Queue来交换讯息(Message)。 例如：线程A的Handler对象可以传递消息给别的线程，让别的线程B或C等能送消息来给线程A(存于A的Message Queue里)。线程A的Message Queue里的消息，只有线程A所属的对象可以处理。使用Looper.myLooper()可以取得当前线程的Looper对象。可以自定义Handler类，只要继承Handler即可。使用new EventHandler(Looper.myLooper()); 可用来构造当前线程的Handler对象（其中EventHandler是自定义的Handler类）。 4. Activity.runOnUiThread()Activity中提供了一个runOnUiThread方法，用于进行消息处理。此方法是通过线程合并join来实现消息处理的。线程合并：主线程将子线程的任务拿到自己这里来执行并终止子线程。实例代码如下： 123456789101112131415/** * Runs the specified action on the UI thread. If thecurrent thread is * the UI thread, then the action is executedimmediately. If the * current thread is not the UI thread, the action is posted to the * event queue of the UI thread. * * 上面的意思为：在UI线程中运行我们的任务，如果当前线程是UI线程，则立即执行，如果 * 不是则该任务发送到UI线程的事件队列。 */runOnUiThread(new Runnable() &#123; @Override public void run() &#123; //自定义我们的业务代码 &#125;&#125;); 5. View.post()、View.postDelayed()6. Message消息消息对象，顾名思义就是记录消息信息的类。这个类有几个比较重要的字段： arg1和arg2：我们可以使用两个字段用来存放我们需要传递的整型值，在Service中，我们可以用来存放Service的ID。 obj：该字段是Object类型，我们可以让该字段传递某个多项到消息的接受者中。 what：这个字段可以说是消息的标志，在消息处理中，我们可以根据这个字段的不同的值进行不同的处理，类似于我们在处理Button事件时，通过switch(v.getId())判断是点击了哪个按钮。 在使用Message时，我们可以通过new Message()创建一个Message实例，但是Android更推荐我们通过Message.obtain()或者Handler.obtainMessage()获取Message对象。这并不一定是直接创建一个新的实例，而是先从消息池中看有没有可用的Message实例，存在则直接取出并返回这个实例。反之如果消息池中没有可用的Message实例，则根据给定的参数new一个新Message对象。通过分析源码可得知，Android系统默认情况下在消息池中实例化10个Message对象。 12345//创建或获取消息的几种方式Message msg = new Message();// 创建一个新的消息对象Message msg = handler.obtainMessage();// 获取一个消息，如果消息池存在消息，则复用消息池中的消息，否则新创建一个消息对象Message msg = Message.obtain();Message.obtain(handler, what, obj).sendToTarget(); 7. MessageQueue消息队列消息队列，用来存放Message对象的数据结构，按照“先进先出”的原则存放消息。存放并非实际意义的保存，而是将Message对象以链表的方式串联起来的。MessageQueue对象不需要我们自己创建，而是有Looper对象对其进行管理，一个线程最多只可以拥有一个MessageQueue。我们可以通过Looper.myQueue()获取当前线程中的MessageQueue。 MessageQueue的管理者，在一个线程中，如果存在Looper对象，则必定存在MessageQueue对象，并且只存在一个Looper对象和一个MessageQueue对象。 1234public class Looper &#123; MessageQueue mQueue;//Looper身上维持着一个消息队列 ...&#125; 在Android系统中，除了主线程有默认的Looper对象，其它线程默认是没有Looper对象。如果想让我们新创建的线程拥有Looper对象时，我们首先应调用Looper.prepare()方法，然后再调用Looper.loop()方法。典型的用法如下： 12345678910class LooperThread extends Thread&#123; public Handler mHandler; public void run() &#123; Looper.prepare(); //其它需要处理的操作 Looper.loop(); &#125;&#125; 倘若我们的线程中存在Looper对象，则我们可以通过Looper.myLooper()获取，此外我们还可以通过Looper.getMainLooper()获取当前应用系统中主线程的Looper对象。在这个地方有一点需要注意，假如Looper对象位于应用程序主线程中，则Looper.myLooper()和Looper.getMainLooper()获取的是同一个对象。 8. Handler消息处理器消息的处理者。通过Handler对象我们可以封装Message对象，然后通过sendMessage(msg)把Message对象添加到MessageQueue中；当MessageQueue循环到该Message时，就会调用该Message对象对应的handler对象的handleMessage()方法对其进行处理。由于是在handleMessage()方法中处理消息，因此我们应该编写一个类继承自Handler，然后在handleMessage()处理我们需要的操作。 下面我们通过跟踪代码分析在Android中是如何处理消息。首先贴上测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MessageService extends Service&#123; private static final String TAG = "MessageService"; private static final int KUKA = 0; private Looper looper; private ServiceHandler handler; /** * 由于处理消息是在Handler的handleMessage()方法中，因此我们需要自己编写类 * 继承自Handler类，然后在handleMessage()中编写我们所需要的功能代码 * @author coolszy */ private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; // 根据what字段判断是哪个消息 switch (msg.what) &#123; case KUKA: //获取msg的obj字段。我们可在此编写我们所需要的功能代码 Log.i(TAG, "The obj field of msg:" + msg.obj); break; // other cases default: break; &#125; // 如果我们Service已完成任务，则停止Service stopSelf(msg.arg1); &#125; &#125; @Override public void onCreate() &#123; Log.i(TAG, "MessageService--&gt;onCreate()"); // 默认情况下Service是运行在主线程中，而服务一般又十分耗费时间，如果 // 放在主线程中，将会影响程序与用户的交互，因此把Service // 放在一个单独的线程中执行 HandlerThread thread = new HandlerThread("MessageDemoThread", Process.THREAD_PRIORITY_BACKGROUND); thread.start(); // 获取当前线程中的looper对象 looper = thread.getLooper(); //创建Handler对象，把looper传递过来使得handler、 //looper和messageQueue三者建立联系 handler = new ServiceHandler(looper); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.i(TAG, "MessageService--&gt;onStartCommand()"); //从消息池中获取一个Message实例 Message msg = handler.obtainMessage(); // arg1保存线程的ID，在handleMessage()方法中 // 我们可以通过stopSelf(startId)方法，停止服务 msg.arg1 = startId; // msg的标志 msg.what = KUKA; // 在这里我创建一个date对象，赋值给obj字段 // 在实际中我们可以通过obj传递我们需要处理的对象 Date date = new Date(); msg.obj = date; // 把msg添加到MessageQueue中 handler.sendMessage(msg); return START_STICKY; &#125; @Override public void onDestroy() &#123; Log.i(TAG, "MessageService--&gt;onDestroy()"); &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 运行结果： 注：在测试代码中我们使用了HandlerThread类，该类是Thread的子类，该类运行时将会创建looper对象，使用该类省去了我们自己编写Thread子类并且创建Looper的麻烦。下面我们分析下程序的运行过程： 8.1 onCreate()首先启动服务时将会调用onCreate()方法，在该方法中我们new了一个HandlerThread对象，提供了线程的名字和优先级。紧接着我们调用了start()方法，执行该方法将会调用HandlerThread对象的run()方法： 123456789101112public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 在run()方法中，系统给线程添加的Looper，同时调用了Looper的loop()方法： 12345678910111213141516171819202122232425public static final void loop() &#123; Looper me = myLooper(); MessageQueue queue = me.mQueue; while (true) &#123; Message msg = queue.next(); // might block //if (!me.mRun) &#123; // break; //&#125; if (msg != null) &#123; if (msg.target == null) &#123; // No target is a magic identifier for the quit message. return; &#125; if (me.mLogging!= null) me.mLogging.println( "&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what ); msg.target.dispatchMessage(msg); if (me.mLogging!= null) me.mLogging.println( "&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); msg.recycle(); &#125; &#125;&#125; 通过源码我们可以看到loop()方法是个死循环，将会不停的从MessageQueue对象中获取Message对象，如果MessageQueue 对象中不存在Message对象，则结束本次循环，然后继续循环；如果存在Message对象，则执行 msg.target.dispatchMessage(msg)，但是这个msg的.target字段的值是什么呢？我们先暂时停止跟踪源码，返回到onCreate()方法中。线程执行完start()方法后，我们可以获取线程的Looper对象，然后new一个ServiceHandler对象，我们把Looper对象传到ServiceHandler构造函数中将使handler、looper和messageQueue三者建立联系。 8.2 onStartCommand()执行完onStart()方法后，将执行onStartCommand()方法。首先我们从消息池中获取一个Message实例，然后给Message对象的arg1、what、obj三个字段赋值。紧接着调用sendMessage(msg)方法，我们跟踪源代码，该方法将会调用sendMessageDelayed(msg, 0)方法，而sendMessageDelayed()方法又会调用sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)方法，在该方法中我们要注意该句代码msg.target = this，msg的target指向了this，而this就是ServiceHandler对象，因此msg的target字段指向了ServiceHandler对象，同时该方法又调用MessageQueue 的enqueueMessage(msg, uptimeMillis)方法： 12345678910111213141516171819202122232425262728293031323334353637final boolean enqueueMessage(Message msg, long when) &#123; if (msg.when != 0) &#123; throw new AndroidRuntimeException(msg + " This message is already in use."); &#125; if (msg.target == null &amp;&amp; !mQuitAllowed) &#123; throw new RuntimeException("Main thread not allowed to quit"); &#125; synchronized (this) &#123; if (mQuiting) &#123; RuntimeException e = new RuntimeException( msg.target + " sending message to a Handler on a dead thread"); Log.w("MessageQueue", e.getMessage(), e); return false; &#125; else if (msg.target == null) &#123; mQuiting = true; &#125; msg.when = when; //Log.d("MessageQueue", "Enqueing: " + msg); Message p = mMessages; if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; this.notify(); &#125; else &#123; Message prev = null; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; msg.next = prev.next; prev.next = msg; this.notify(); &#125; &#125; return true;&#125; 该方法主要的任务就是把Message对象的添加到MessageQueue中（数据结构最基础的东西，自己画图理解下）。 handler.sendMessage()–&gt;handler.sendMessageDelayed()–&gt;handler.sendMessageAtTime()–&gt;msg.target = this;queue.enqueueMessage==&gt;把msg添加到消息队列中 8.3 handleMessage(msg)onStartCommand()执行完毕后我们的Service中的方法就执行完毕了，那么handleMessage()是怎么调用的呢？在前面分析的loop()方法中，我们当时不知道msg的target字段代码什么，通过上面分析现在我们知道它代表ServiceHandler对象，msg.target.dispatchMessage(msg);则表示执行ServiceHandler对象中的dispatchMessage()方法： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 该方法首先判断callback是否为空，我们跟踪的过程中未见给其赋值，因此callback字段为空，所以最终将会执行handleMessage()方法，也就是我们ServiceHandler类中复写的方法。在该方法将根据what字段的值判断执行哪段代码。 至此，我们看到，一个Message经由Handler的发送，MessageQueue的入队，Looper的抽取，又再一次地回到Handler的怀抱中。而绕的这一圈，也正好帮助我们将同步操作变成了异步操作。 9. Handler的源码分析先看构造方法 123456789101112public class Handler &#123; private Looper mLooper; private MessageQueue mQueue; public Handler() &#123; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException("Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; &#125;&#125; 在Handler的构造方法中，调用Looper.myLooper()方法获取一个Looper对象，如果Looper对象为空，则会抛异常，没有Looper对象不能创建Handler对象。但是我们在主线程new Handler的时候，并没有调用Looper.prepare()和Looper.loop()方法初始化Looper，也不会出现异常，这是因为Android系统在主线程创建的时候帮我们把Looper初始化了 9.1 主线程设置Looper，在ActivityThread类里面1234567891011121314public static final void main(String[] args) &#123; .... // 1.主线程创建Looper Looper.prepareMainLooper(); if (sMainThreadHandler == null) &#123; sMainThreadHandler = new Handler(); &#125; ActivityThread thread = new ActivityThread(); thread.attach(false); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; Looper.loop();&#125; MainThread 是Android 系统创建并维护的，创建的时候系统执行了Looper.prepare();方法，该方法内部创建了MessageQueue 消息队列（也叫消息池），该消息队列是Message 消息的容器，用于存储通过handler发送过来的Message。MessageQueue 是Looper 对象的成员变量，Looper 对象通过ThreadLocal 绑定在MainThread 中。因此我们可以简单的这么认为：MainThread 拥有唯一的一个Looper 对象，该Looper 对象有用唯一的MessageQueue 对象，MessageQueue 对象可以存储多个Message。 MainThread 中需要程序员手动创建Handler 对象，并覆写Handler 中的handleMessage(Message msg)方法，该方法将来会在主线程中被调用，在该方法里一般会写与UI 修改相关的代码。 MainThread 创建好之后，系统自动执行了Looper.loop();方法，该方法内部开启了一个“死循环”不断的去之前创建好的MessageQueue 中取Message。如果一有消息进入MessageQueue，那么马上会被Looper.loop();取出来，取出来之后就会调用之前创建好的handler 对象的handleMessage（Message）方法。 newThread 线程是我们程序员自定new 出来的子线程。在该子线程中处理完我们的“耗时”或者网络访问任务后，调用主线程中的handler 对象的sendMessage（msg）方法，该方法一被执行，内部将就msg添加到了主线程中的MessageQueue 队列中，这样就成为了Looper.loop()的盘中餐了，等待着被消费。 上面的过程有点类似生产者和消费者的过程。newThread 属于生产者，负责生产Message，MainThread 属于消费者。这是一个很复杂的过程，但是Android 显然已经将这种模式给封装起来了，就叫Handler 机制。我们使用时只需要在主线程中创建Handler，并覆写handler 中的handleMessage 方法，然后在子线程中调用handler 的sendMessage（msg）方法即可。 获取Looper对象后，接着获取Looper身上的MessageQueue对象，Handler就是把消息发送到该消息队列 Handler对象创建后，就可以通过handler.sendXxx()发送消息，可以发送一个普通的消息，也可以发送一个空消息，可以发送一个延时消息，也可以发送一个定时消息 123456789101112131415161718192021222324252627282930313233343536public class Handler &#123; ... // 发送一个普通消息 public boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0) &#125; // 发送一个空消息 public boolean sendEmptyMessage(int what) &#123; return sendEmptyMessageDelayed(what, 0); &#125; // 发送一个空的延时消息 public boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, 0); &#125; // 发送一个延时消息 public boolean sendMessageDelayed(Message msg, long delayTime) &#123; if (delayTime &lt; 0) delayTime = 0; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayTime); &#125; // 发送一个定时消息 public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; return enqueueMessage(queue, msg, uptimeMillis); &#125; //发送消息几个方法sendXxx()，最终都是调用enqueueMessage()方法，消息入队 public boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; // 把Message的target置为当前发送的Handler，以便Looper取到message后根据target把message分发给正确的Handler msg.target = this; // 往队列里面添加消息Message return queue.enqueueMessage(msg, uptimeMillis); &#125; ...&#125; 发送消息几个方法sendXxx()，最终都是调用enqueueMessage()方法，在该方法内部调用的是消息队列MessageQueue的enqueueMessage()方法，把消息发送到消息队列 把this，也就是当前handler对象赋值给Message 的target属性，当多个Handler发送消息到消息队列的时候，可以通过该属性判断消息是哪个Handler发送的 9.2 MessageQueue.enqueueMessage12345678910111213141516171819202122232425262728293031323334353637boolean enqueueMessage(Message msg, long when) &#123; ... synchronized (this) &#123; ... msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 当前发送的message需要马上被处理调，needWake唤醒状态置true msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // 当前发送的message被排队到其他message的后面，needWake唤醒状态置false needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (; ; ) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; if (needWake) &#123; // 是否唤醒主线程 nativeWake(mPtr); &#125; &#125; return true; &#125; 9.3 Handler的post()、postAtTime()、postDelayed()123456789101112131415161718192021public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;public final boolean postAtTime(Runnable r, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis);&#125;public final boolean postDelayed(Runnable r, long delayMillis)&#123; return sendMessageDelayed(getPostMessage(r), delayMillis);&#125;// 把Runnable包装成一个消息Messageprivate static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain();// 获取消息对象 m.callback = r;// 把消息赋值给Message的callback属性 return m;&#125; 可以调用Handler的post()、postAtTime()、postDelayed()分别发送一个普通的、定时、延时的Runnable任务，Runnable会赋值给Message的callback属性，最终封装成一个消息发送出去 9.4 删除Callback和Message Handler.removeCallbacks() 从消息队列中删除所有回调 Handler.removeMessages() 从消息队列删除所有消息 Handler.removeCallbacksAndMessages() 从消息队列中删除所有Message和Callback 一般在Activity销毁的时候调用 12345public void onDestroy()&#123; handler.removeCallbacks(); handler.removeMessages(); handler.removeCallbacksAndMessages();&#125; 10. Looper 轮询器，从messagequeue取消息，分发给handler处理。创建Handler对象，必须有Looper对象，而Looper对象的初始化需要调用Looper.prepare()和Looper.loop()方法 10.1 Looper.prepare()123456789101112131415161718ThreadLocal&lt;Looper&gt; sThreadLocal;public static final void prepare() &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; // 3、在主线程中设置Looper， new Looper()里面创建了一个MessageQueue sThreadLocal.set(new Looper());&#125;public static final void prepareMainLooper() &#123; // 2、调用prepare prepare(); setMainLooper(myLooper()); if (Process.supportsProcesses()) &#123; myLooper().mQueue.mQuitAllowed = false; &#125;&#125; 先从ThreadLocal中获取一个Looper对象，如果该Looper对象不为空，则抛异常，这是因为一个线程仅能够绑定一个Looper对象。ThreadLocal是一个用于线程范围内共享数据的底层是一个map结构的类，key是当前线程，value是Looper。如果当前线程没有绑定Looper对象，则new Looper()创建一个Looper对象，并把该Looper对象设置sThreadLocal 10.2 Looper.loop()12345678910111213public static void loop() &#123; Looper me = myLooper(); // 获取当前线程的Looper对象，为空则抛异常 if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; MessageQueue queue = me.mQueue; // 获取Looper对象维持的消息队列 for (; ; ) &#123; // 开启死循环从消息队列获取消息 // 调用MessageQueue的next()取消息，如果没有消息，就阻塞 Message msg = queue.next(); // msg.target即Handler，获取消息后调用Handler的dispatchMessage()处理消息 msg.target.dispatchMessage(msg); &#125;&#125; 主线程调用Looper.loop()方法,主线程就会阻塞，是一个死循环，使用管道（Pipe），是Linux中的一种进程间通信方式，使用了特殊的文件，有两个文件描述符（一个是读取，一个是写入） 应用场景；主进程拿着读取描述符等待读取，没有内容时就阻塞，另一个进程拿写入描述符去写内容，唤醒主进程，主进程拿着读取描述符读取到内容，继续执行。 Handler应用场景：Handler在主线程中创建，Looper会在死循环里等待取消息，1、没取到，就阻塞，2、一旦被子线程唤醒，取到消息，就把Message交给Handler处理。子线程用Handler去发送消息，拿写入描述符去写消息，唤醒主线程。 12Looper.getMainLooper() == Looper.myLooper(); // 判断是否在主线程Handler mHandler = new Handler(Looper.getMainLooper()); 11. Handler.dispatchMessage12345678910111213public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; // 把Message交给Handler处理 handleMessage(msg); &#125;&#125; 调用Looper.loop()会开启一个死循环，从消息队列MessageQueue取消息，取到消息后调用msg.target.dispatchMessage(msg);即调用Handler的dispatchMessage()方法，在该方法内部调用的是handleMessage()，对，就是我们new Handler的时候实现的handleMessage()方法 所以Android的消息机制大概流程是：Handler把消息Message发送到消息队列MessageQueue，Looper从消息队列取消息，取到消息后回调Handler的handleMessage()方法 11.1 消息处理的优先级在dispatchMessage()方法中，如果msg.callback（一个Runnable）不为空，则先处理Message的Runnable；然后判断mCallback（通过Handler的构造方法传进来的Callback）是否为空，不为空，则执行Callback的handleMessage()方法，最后才是执行Handler的handleMessage() 所有消息处理的优先级是Message的callback –&gt; Handler的mCallback –&gt; Handler的handleMessage() 12. Handler机制的应用12.1 在主线程中给子线程发送消息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class MainActivity extends Activity &#123; private Handler subHandler;//是在子线程中创建的Handler对象 private Looper myLooper;//子线程中的Looper对象 private Handler handler = new Handler()&#123; @Override public void handleMessage(android.os.Message msg) &#123; switch (msg.what) &#123; case 1: Toast.makeText(MainActivity.this, msg.obj.toString(), Toast.LENGTH_SHORT).show(); break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /* * 匿名内部类对象对外部类有一个隐式的强引用 */ new Thread(new Runnable() &#123; @Override public void run() &#123; // 1. 创建了Looper对象，然后Looper对象中创建了MessageQueue // 2. 并将当前的Looper对象跟当前的线程（子线程）绑定ThreadLocal Looper.prepare(); // 1. 创建了handler对象，然后从当前线程中获取Looper对象，然后获取到MessageQueue对象 subHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; Toast.makeText(MainActivity.this, msg.obj.toString(), Toast.LENGTH_SHORT).show(); &#125; &#125;; myLooper = Looper.myLooper();//获取当前线程中的Looper对象 /* * 1. 从当前线程中找到之前创建的Looper对象，然后找到 MessageQueue * 2. 开启死循环，遍历消息池中的消息 * 3. 当获取到msg的时候，调用这个msg的handler的disPatchMsg方法，让msg执行起来 */ Looper.loop(); Log.d("tag", "loop()方法执行完了"); &#125; &#125;).start(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (myLooper!=null) &#123; myLooper.quit(); myLooper = null; &#125; &#125; public void sendMsg(View view)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; SystemClock.sleep(2000);//模拟一个耗时操作 Message msg = new Message(); msg.what = 1;//区分发送的消息 msg.obj = "来自子线程的问候"; handler.sendMessage(msg); &#125; &#125;).start(); &#125; public void sendMsg2(View view) &#123; //从消息池中获取一个旧的msg，如果没有重新创建消息 subHandler.obtainMessage(2, "我是主线程发送来的祝福").sendToTarget(); &#125;&#125; 12.2 同线程内不同组件间的消息传递Looper类用来管理特定线程内对象之间的消息交换(MessageExchange)。你的应用程序可以产生许多个线程。而一个线程可以有许多个组件，这些组件之间常常需要互相交换讯息。如果有这种需要，您可以替线程构造一个Looper对象，来担任讯息交换的管理工作。Looper对象会建立一个MessageQueue数据结构来存放各对象传来的消息(包括UI事件或System事件等)。每一个线程里可含有一个Looper对象以及一个MessageQueue数据结构。在你的应用程序里，可以定义Handler的子类别来接收Looper所送出的消息。 同线程不同组件之间的消息传递代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * ============================================================ * Copyright：$&#123;TODO&#125;有限公司版权所有 (c) 2017 * Author： AllenIverson * Email： 815712739@qq.com * GitHub： https://github.com/JackChen1999 * 博客： http://blog.csdn.net/axi295309066 * 微博： AndroidDeveloper * GitBook： https://www.gitbook.com/@alleniverson * &lt;p&gt; * Project_Name：HandlerDemo * Package_Name：com.github.handlerdemo.activity * Version：1.0 * time：2017/3/1 16:23 * des ： * gitVersion：2.12.0.windows.1 * updateAuthor：$Author$ * updateDate：$Date$ * updateDes：$&#123;TODO&#125; * ============================================================ */public classHandlerActivity extends Activity&#123; private Button sendBtn; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); sendBtn=(Button)findViewById(R.id.send); tv=(TextView)findViewById(R.id.textview); sendBtn.setOnClickListener(newMyOnClickListener()); &#125; class MyOnClickListener implements OnClickListener &#123; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send: // 取得当前线程的Looper，此时的线程为主线程（UI线程） Looper looper = Looper.myLooper(); // 构造一个Handler对象使之与Looper通信 MyHandler mHandler = newMyHandler(looper); // 产生一个消息通过Handler传递给Looper String msgStr = "main"; // 构造一个消息，这里what参数设为1，obj参数设为msgStr变量。 Message msg = mHandler.obtainMessage(1, 1, 1, msgStr); // 发送消息，调用Handler对象的handleMessage方法 mHandler.sendMessage(msg); break; &#125; &#125; &#125; // 自定义Handler类 class MyHandler extends Handler &#123; // 指定Looper对象来构造Handler对象，而我们平时直接使用的Handler无参构造方法实际上默认是本线程的looper，可通过查看SDk源代码了解。 public MyHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 1: tv.setText(String.valueOf(msg.obj)); break; &#125; &#125; &#125;&#125; 说明：此程序启动时，当前线程(即主线程, mainthread)已诞生了一个Looper对象，并且有了一个MessageQueue数据结构。 调用Looper类别的静态myLooper()函数，以取得目前线程里的Looper对象。looper = Looper.myLooper (); 构造一个MyHandler对象来与Looper沟通。Activity等对象可以藉由MyHandler对象来将消息传给Looper，然后放入MessageQueue里；MyHandler对象也扮演Listener的角色，可接收Looper对象所送来的消息。mHandler = new MyHandler (looper); 先构造一个Message对象，并将数据存入对象里。Message msg = mHandler.obtainMessage(1, 1, 1, msgStr);这里也可以这样写： 123Message msg = new Message();msg.what = 1;msg.obj = msgStr; 通过mHandler对象将消息m传给Looper，然后放入MessageQueue里。mHandler.sendMessage(msg); 此时，Looper对象看到MessageQueue里有消息m，就将它广播出去，mHandler对象接到此讯息时，会调用其handleMessage()函数来处理，于是让msgStr显示于TextView上（更新UI）。 12.3 子线程传递消息给主线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * ============================================================ * Copyright：$&#123;TODO&#125;有限公司版权所有 (c) 2017 * Author： AllenIverson * Email： 815712739@qq.com * GitHub： https://github.com/JackChen1999 * 博客： http://blog.csdn.net/axi295309066 * 微博： AndroidDeveloper * GitBook： https://www.gitbook.com/@alleniverson * &lt;p&gt; * Project_Name：HandlerDemo * Package_Name：com.github.handlerdemo.activity * Version：1.0 * time：2017/3/1 16:23 * des ： * gitVersion：2.12.0.windows.1 * updateAuthor：$Author$ * updateDate：$Date$ * updateDes：$&#123;TODO&#125; * ============================================================ */public classHandlerActivity extends Activity&#123; private Button sendBtn; private TextView tv; private MyHandler mHandler = null; Thread thread; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); sendBtn = (Button)findViewById(R.id.send); tv = (TextView)findViewById(R.id.textview); sendBtn.setOnClickListener(newMyOnClickListener()); &#125; class MyOnClickListener implements OnClickListener &#123; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.send: thread = new MyThread(); thread.start(); break; &#125; &#125; &#125; // 自定义Handler类 class MyHandler extends Handler &#123; // 指定Looper对象来构造Handler对象，而我们平时直接使用的Handler无参构造方法实际上默认是本线程的looper，可通过查看SDk源代码了解。 public MyHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg)&#123; switch (msg.what) &#123; case 1: tv.setText(String.valueOf(msg.obj)); break; &#125; &#125; &#125; private class MyThread extends Thread &#123; @Override public void run() &#123; // 获得当前线程的Looper对象 Looper curLooper =Looper.myLooper(); // 获得主线程（UI线程）的Looper对象 Looper mainLooper =Looper.getMainLooper(); String msgStr; if (curLooper == null) &#123; mHandler = newMyHandler(mainLooper); msgStr = "curLooper isnull"; &#125; else &#123; mHandler = newMyHandler(curLooper); msgStr = "This iscurLooper"; &#125; Message msg =mHandler.obtainMessage(1, 1, 1, msgStr); mHandler.sendMessage(msg); &#125; &#125;&#125; Android会自动替主线程建立MessageQueue。在这个子线程里并没有建立Message Queue。所以curLooper值为null，而mainLooper则指向主线程里的Looper。于是执行mHandler= new MyHandler (mainLooper);此mHandler属于主线程 mHandler.sendMessage(msg);就将msg消息存入到主线程的MessageQueue里 mainLooper看到Message Queue里有讯息，就会作出处理，于是由主线程执行到mHandler的handleMessage()来处理消息。 12.4 在子线程中直接更新View不抛异常的问题下面代码，我们在子线程中直接操作View，但是并不会抛出异常 12345678910111213public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); tv = (TextView) findViewById(R.id.tv); iv = (ImageView) findViewById(R.id.iv); //搞不懂为什么在子线程里可以修改ui new Thread()&#123; public void run() &#123; tv.setText("wwwwwwwww"); iv.setImageResource(R.drawable.ic_launcher); &#125; &#125;.start();&#125; 原因： 在更新ui界面时View会把要界面传给ViewRoot 自定义Handler它是Activity和WindowMangerImpl之间的桥梁，要修改界面上的数据的经过它，它把数据传递给WindowManagerImple或DecorView之前，会调用checkThread方法，判断当前线程是否是主线程，不是的话跑异常。 而上面的代码是在onCreate里面修改的view，那时候view还没有被真正的被放在ContentView里面，ViewRoot还没有被创建，mParent为null。mparent（放ContentView的容器类型ViewParent）为null时不调用checkThread方法，当执行到ActivityThread的handlerResumeActivity方法时ViewRoot方法才会被创建，该方法在Activity的onResume方法执行完以后的200到300毫秒以后得到执行，并且把界面传递给WidowManagerImpl进行显示，由于在viewRoot被创建前已经修改了控件的值，所以显示的是已经修改的值。 所以在onResume方法被执行完的200毫秒之前那是还没有ViewRoot和mparent是可以修改主线程UI界面的 只有当viewRoot被创建了以后 在子线程view被添加到了contentView上时，或已添加到ContentView上在修改显示内容时会调用View的requestLayout方法，requestLayout会调用ViewRoot的checkThread方法，才会抛异常。 如果修改一个view的内容不调用requestLayout方法时是可以子线程中修改的并且不抛异常。如给一个view设置监听事件，虽然设置监听是在子线程里设置的但是调用执行监听事件的代码是在主线程里调用的从而执行也将在主线程执行。又如post方法，它只是给主线程所在的handler发送消息，handler分发消息时执行具体任务，并没有执行checkThread。又如创建一个VIew，为VIEW设置内容，添加view到该view等等，因为还没被添加到ContentView上所以不会执行checkThread。 13. Handler的核心代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Handler &#123; private Looper mLooper; private MessageQueue mQueue; public Handler()&#123; mLooper = Looper.myLooper(); if (mLooper == null)&#123; throw new RuntimeException("Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; &#125; public void handleMessage()&#123; &#125; public void dispatchMessage(Message msg)&#123; handleMessage(); &#125; public boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg,0) &#125; public boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what,0); &#125; public boolean sendEmptyMessageDelayed(int what, long delayMillis)&#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg,0); &#125; public boolean sendMessageDelayed(Message msg, long delayTime)&#123; if (delayTime &lt; 0) delayTime = 0; return sendMessageAtTime(msg,SystemClock.uptimeMillis()+delayTime); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis)&#123; MessageQueue queue = mQueue; return enqueueMessage(queue,msg,uptimeMillis); &#125; public boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis)&#123; msg.target = this; return queue.enqueueMessage(msg, uptimeMillis); &#125; public void post(Runnable r)&#123; sendMessageDelayed(getPostMessage(r),0); &#125; public static Message getPostMessage(Runnable r)&#123; Message m = Message.obtain(); m.callback = r; return m; &#125; &#125; 14. Looper的核心代码1234567891011121314151617181920212223242526272829303132333435363738public class Looper &#123; static final ThreadLocal&lt;Looper&gt; mThreadLocal = new InheritableThreadLocal&lt;&gt;(); MessageQueue mQueue; Thread mCurrentThread; private static Looper sMainLooper; private Looper() &#123; mQueue = new MessageQueue(); mCurrentThread = Thread.currentThread(); &#125; public static void prepare() &#123; if (mThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; mThreadLocal.set(new Looper()); &#125; public void prepareMainLooper()&#123; prepare(); sMainLooper = myLooper(); &#125; public static void loop() &#123; Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");&#125; MessageQueue queue = me.mQueue; for(;;)&#123; Message msg = queue.next();//block msg.target.dispatchMessage(msg); &#125; &#125; public static Looper myLooper() &#123; return mThreadLocal.get(); &#125;&#125; window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{},"image":{"viewList":["fbook","twi","linkedin","qzone","tsina","douban","weixin","evernotecn"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?'];]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>消息机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程范围内共享数据]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E7%BA%BF%E7%A8%8B%E8%8C%83%E5%9B%B4%E5%86%85%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[笔记摘要所谓线程范围内共享数据，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据，API中为我们提供了一个操作线程范围内共享数据的类ThreadLocal，对于线程范围内共享数据的应用，在ThreadLocal的应用场景中进行了介绍，然后主要对它的使用进行讲解，演示了由单一数据的共享到将多个数据封装到一个对象中，然后进行共享。在开始先用一个Map集合简单实现线程范围内数据的共享 1. 使用Map实现线程范围内数据的共享原理：将线程对象作为map的键存入，这样就保证了map对象的唯一，也就保证了线程内数据的唯一 关键: 明确一点，把当前线程对象作为map集合的键存进去 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.HashMap; import java.util.Map; import java.util.Random; public class ThreadScopeShareData &#123; private static int data = 0; //定义一个全局的成员变量 private static Map&lt;Thread, Integer&gt; threadData = new HashMap&lt;Thread, Integer&gt;(); public static void main(String[] args) &#123; //启动两个线程 for(int i=0;i&lt;2;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; int data = new Random().nextInt(); //准备一个数据 System.out.println(Thread.currentThread().getName() + " has put data :" + data); //把当前线程对象作为键，就可以保证map对象的唯一，即保证线程内的数据唯一 threadData.put(Thread.currentThread(), data); new A().get(); new B().get(); &#125; &#125;).start(); &#125; &#125; //定义一个类模拟获取数据 static class A&#123; public void get()&#123; int data = threadData.get(Thread.currentThread()); System.out.println("A from " + Thread.currentThread().getName() + " get data :" + data); &#125; &#125; static class B&#123; public void get()&#123; int data = threadData.get(Thread.currentThread()); System.out.println("B from " + Thread.currentThread().getName() + " get data :" + data); &#125; &#125; &#125; 打印结果 123456Thread-0 has put data:-49248136Thread-1 has put data:311124475A from Thread-0 get data:-49248136A from Thread-1 get data:311124475B from Thread-0 get data:-49248136B from Thread-1 get data:311124475 2. ThreadLocal类ThreadLocal的作用和目的： 用于实现线程内的数据共享，即对于相同的程序代码，多个模块在同一个线程中运行时要共享一份数据，而在另外线程中运行时又共享另外一份数据。 每个线程调用全局ThreadLocal对象的set方法，就相当于往其内部的map中增加一条记录，key分别是各自的线程，value是各自的set方法传进去的值。在线程结束时可以调用ThreadLocal.clear()方法，这样会更快释放内存，不调用也可以，因为线程结束后也可以自动释放相关的ThreadLocal变量。 3. ThreadLocal的应用场景1、订单处理包含一系列操作：减少库存量、增加一条流水台账、修改总账，这几个操作要在同一个事务中完成，通常也即同一个线程中进行处理，如果累加公司应收款的操作失败了，则应该把前面的操作回滚，否则，提交所有操作，这要求这些操作使用相同的数据库连接对象，而这些操作的代码分别位于不同的模块类中。 2、 银行转账包含一系列操作：把转出帐户的余额减少，把转入帐户的余额增加，这两个操作要在同一个事务中完成，它们必须使用相同的数据库连接对象，转入和转出操作的代码分别是两个不同的帐户对象的方法。 3、例如Strut2的ActionContext，同一段代码被不同的线程调用运行时，该代码操作的数据是每个线程各自的状态和数据，对于不同的线程来说，getContext方法拿到的对象都不相同，对同一个线程来说，不管调用getContext方法多少次和在哪个模块中getContext方法，拿到的都是同一个。 线程范围内共享数据示意图 实现对ThreadLocal变量的封装， 让外界不要直接操作ThreadLocal变量由于对基本类型的数据的封装，这种应用相对很少见。而对对象类型的数据的封装，比较常见，即让某个类针对不同线程分别创建一个独立的实例对象。所以我们要对数据进行封装。 实现方式一示例说明： 1、 该示例包含了对基本类型数据的共享和对象类型数据的共享 2、定义一个全局共享的ThreadLocal变量，然后启动多个线程向该ThreadLocal变量中存储一个随机值，接着各个线程调用另外其他多个类的方法，这多个类的方法中读取这个ThreadLocal变量的值，就可以看到多个类在同一个线程中共享同一份数据。 3、但这里每次存储数据时，都是使用同一个ThreadLocal对象，只是重新赋值而已 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import java.util.HashMap; import java.util.Map; import java.util.Random; public class ThreadLocalTest &#123; private static ThreadLocal&lt;Integer&gt; x = new ThreadLocal&lt;Integer&gt;(); //创建一个存储封装类对象的ThreadLocal private static ThreadLocal&lt;MyThreadScopeData&gt; myThreadScopeData = new ThreadLocal&lt;MyThreadScopeData&gt;(); private static int data = 0; public static void main(String[] args)&#123; //产生两个线程 for(int i=0;i&lt;2;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; //共享单一的数据 int data = new Random().nextInt(); System.out.println(Thread.currentThread().getName()+"has put data : "+data); x.set(data); //共享多个数据 //将数据封装在myData对象中，并将myData作为myThreadScopeData的键 MyThreadScopeData myData = new MyThreadScopeData(); myData.setName("name "+data); myData.setAge(data); myThreadScopeData.set(myData); new A().get(); new B().get(); &#125; &#125;).start(); &#125; &#125; static class A&#123; public void get()&#123; int data = x.get(); System.out.println("A from "+Thread.currentThread().getName()+" get data :"+data); //从myData中取出数据，并获取当前线程名，数据 MyThreadScopeData myData = myThreadScopeData.get(); System.out.println("A from "+Thread.currentThread().getName()+" getMyData: " + myData.getName() + "," +myData.getAge()); &#125; &#125; static class B&#123; public void get()&#123; int data = x.get(); System.out.println("B from "+Thread.currentThread().getName()+" get data :"+data); MyThreadScopeData myData = myThreadScopeData.get(); System.out.println("B from "+Thread.currentThread().getName()+" getMyData: " + myData.getName() + "," +myData.getAge()); &#125; &#125; &#125; //封装数据的类 class MyThreadScopeData&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 输出结果 12345678910Thread-0has put data : 1317043235Thread-1has put data : -969579752A from Thread-0 get data :1317043235A from Thread-1 get data :-969579752A from Thread-0 getMyData: name 1317043235,1317043235A from Thread-1 getMyData: name -969579752,-969579752B from Thread-0 get data :1317043235B from Thread-1 get data :-969579752B from Thread-0 getMyData: name 1317043235,1317043235B from Thread-1 getMyData: name -969579752,-969579752 实现方式二 示例说明： 这里模拟原始的单例模式，它们的区别是：单例模式中只有唯一的一个实例，而这里是每个线程拥有自己唯一的实例，只要是已经创建，就直接返回，保证每个线程拥有自己的唯一一份实例 优点： 这里可以返回每个线程自己唯一的实例对象，所以不必在外面定义，当在代码中的任意地方想获取到一个可以存储自己数据的线程实例的时候直接去调用getThreadInstance方法即可，直接定义在数据对象的内部，和数据关系更紧密，而方式一，则每次想存入数据的时候都需要在外面创建一个ThreadLocal对象用于存储数据。所以方式二更具封装性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package cn.itcast.heima2; import java.util.HashMap; import java.util.Map; import java.util.Random; public class ThreadLocalTest &#123; //创建一个ThreadLocal对象 private static ThreadLocal&lt;Integer&gt; x = new ThreadLocal&lt;Integer&gt;(); public static void main(String[] args) &#123; for(int i=0;i&lt;2;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; int data = new Random().nextInt(); System.out.println(Thread.currentThread().getName() + " has put data :" + data); x.set(data); //往当前线程存入一条数据 //获取与当前线程绑定的实例并设置值 MyThreadScopeData.getThreadInstance().setName("name：" + data); MyThreadScopeData.getThreadInstance().setAge(data); new A().get(); new B().get(); &#125; &#125;).start(); &#125; &#125; static class A&#123; public void get()&#123; int data = x.get(); //获取当前线程中的数据 System.out.println("A from " + Thread.currentThread().getName() + " get data :" + data); //获取与当前线程绑定的实例 MyThreadScopeData myData = MyThreadScopeData.getThreadInstance(); System.out.println("A from " + Thread.currentThread().getName() + " getMyData: " + myData.getName() + "," + myData.getAge()); &#125; &#125; static class B&#123; public void get()&#123; int data = x.get(); System.out.println("B from " + Thread.currentThread().getName() + " get data :" + data); MyThreadScopeData myData = MyThreadScopeData.getThreadInstance(); System.out.println("B from " + Thread.currentThread().getName() + " getMyData: " + myData.getName() + ",age: " + myData.getAge()); &#125; &#125; &#125; //一个绑定当前线程的类 class MyThreadScopeData&#123; private MyThreadScopeData()&#123;&#125; //构造方法私有化 private static ThreadLocal&lt;MyThreadScopeData&gt; map = new ThreadLocal&lt;MyThreadScopeData&gt;(); //定义一个静态方法，返回各线程自己的实例 //这里不必用同步，因为每个线程都要创建自己的实例，所以没有线程安全问题。 public static /*synchronized*/ MyThreadScopeData getThreadInstance()&#123; MyThreadScopeData instance = map.get(); //获取当前线程绑定的实例 if(instance == null)&#123; instance = new MyThreadScopeData(); map.set(instance); //创建完之后，将实例对象存进去 &#125; return instance; &#125; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 输出结果 12345678910Thread-0 has put data :2105117242Thread-1 has put data :-368218341A from Thread-1 get data :-368218341A from Thread-1 getMyData: name：-368218341,-368218341A from Thread-0 get data :2105117242A from Thread-0 getMyData: name：2105117242,2105117242B from Thread-0 get data :2105117242B from Thread-1 get data :-368218341B from Thread-0 getMyData: name：2105117242,age: 2105117242B from Thread-1 getMyData: name：-368218341,age: -368218341 4. 总结一个ThreadLocal代表一个变量，故其中只能放一个数据，有两个变量都要线程范围内共享，则要定义两个ThreadLocal对象，如果数据更多就很麻烦，可以先定义一个对象封装变量，然后在ThreadLocal中存储这一个对象，而这些操作都在提供线程数据类中完成]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JDK5中同步技术的3个面试题]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E4%BD%BF%E7%94%A8JDK5%E4%B8%AD%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF%E7%9A%843%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一题现有的程序代码模拟产生了16个日志对象，并且需要运行16秒才能打印完这些日志，请在程序中增加4个线程去调用parseLog()方法来分头打印这16个日志对象，程序只需要运行4秒即可打印完这些日志对象。 123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args)&#123; System.out.println("begin:"+(System.currentTimeMillis()/1000)); /*模拟处理16行日志，下面的代码产生了16个日志对象，当前代码需要运行16秒才能打印完这些日志。 修改程序代码，开四个线程让这16个对象在4秒钟打完。 */ for(int i=0;i&lt;16;i++)&#123; //这行代码不能改动 final String log = ""+(i+1); //这行代码不能改动 &#123; Test.parseLog(log); &#125; &#125; &#125; //parseLog方法内部的代码不能改动 public static void parseLog(String log)&#123; System.out.println(log+":"+(System.currentTimeMillis()/1000)); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 实现：通过阻塞队列实现线程间的通信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue; //BlockingQueue public class Test &#123; public static void main(String[] args)&#123; //创建一个空间大小为16的阻塞队列，空间大小可以任意，因为每次打印都要1秒，在此期间， //4个线程足以不断去从队列中取数据，然后打印,即在1秒内打印4条日志信息 final BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;String&gt;(16); //开启4个线程打印 for(int i=0;i&lt;4;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; while(true)&#123; try &#123; //开始没有数据，阻塞，一旦有其中一个线程就去取数据，即不再阻塞，就开始打印 String log = queue.take(); parseLog(log); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125; //打印秒数 System.out.println("begin:"+(System.currentTimeMillis()/1000)); for(int i=0;i&lt;16;i++)&#123; // 这行代码不能改动 final String log = ""+(i+1); // 这行代码不能改动 &#123; try &#123; queue.put(log); // 向队列中存储数据 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //Test.parseLog(log); &#125; &#125; &#125; //parseLog方法内部的代码不能改动 public static void parseLog(String log)&#123; System.out.println(log+":"+(System.currentTimeMillis()/1000)); try &#123; Thread.sleep(1000); // 模拟每条日志打印需要1秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 第二题现成程序中的Test类中的代码在不断地产生数据，然后交给TestDo.doSome()方法去处理，就好像生产者在不断地产生数据，消费者在不断消费数据。 请将程序改造成有10个线程来消费生成者产生的数据，这些消费者都调用TestDo.doSome()方法去进行处理，故每个消费者都需要一秒才能处理完，程序应保证这些消费者线程依次有序地消费数据，只有上一个消费者消费完后，下一个消费者才能消费数据，下一个消费者是谁都可以，但要保证这些消费者线程拿到的数据是有顺序的。 1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) &#123; System.out.println("begin:"+(System.currentTimeMillis()/1000)); for(int i=0;i&lt;10;i++)&#123; //这行不能改动 String input = i+""; //这行不能改动 String output = TestDo.doSome(input); System.out.println(Thread.currentThread().getName()+ ":" + output); &#125; &#125; &#125; //不能改动此TestDo类 class TestDo &#123; public static String doSome(String input)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String output = input + ":"+ (System.currentTimeMillis() / 1000); return output; &#125; &#125; 在实现之前先介绍一个阻塞队列：SynchronousQuene，一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。 应用：它非常适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.concurrent.SynchronousQueue; /*Semaphore与SynchronousQueue的混合使用。 由于Semaphore只有1个许可权，所以谁先拿到谁执行，然后释放，保证依次执行, 用锁也行，只要保证一个线程执行即可 SynchronousQueue是必须有其他线程取的动作，这样一一对应 */ public class Test &#123; public static void main(String[] args) &#123; //定义一个许可权为1的信号灯 final Semaphore semaphore = new Semaphore(1); //产生的结果无序 final SynchronousQueue&lt;String&gt; queue = new SynchronousQueue&lt;String&gt;(); //产生10个线程 for(int i=0;i&lt;10;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; try &#123; semaphore.acquire(); //获取许可 String input = queue.take(); //获取并移除此队列的头 String output = TestDo.doSome(input); System.out.println(Thread.currentThread().getName()+ ":" + output); semaphore.release(); //释放许可 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; System.out.println("begin:"+(System.currentTimeMillis()/1000)); for(int i=0;i&lt;10;i++)&#123; //这行不能改动 String input = i+""; //这行不能改动 try &#123; queue.put(input); //将指定元素添加到此队列 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; //不能改动此TestDo类 class TestDo &#123; public static String doSome(String input)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String output = input + ":"+ (System.currentTimeMillis() / 1000); return output; &#125; &#125; 第三题现有程序同时启动了4个线程去调用TestDo.doSome(key, value)方法，由于TestDo.doSome(key, value)方法内的代码是先暂停1秒，然后再输出以秒为单位的当前时间值，所以，会打印出4个相同的时间值，如下所示： 12344:4:12581996151:1:12581996153:3:12581996151:2:1258199615 请修改代码，如果有几个线程调用TestDo.doSome(key, value)方法时，传递进去的key相等（equals比较为true），则这几个线程应互斥排队输出结果，即当有两个线程的key都是”1”时，它们中的一个要比另外其他线程晚1秒输出结果，如下所示： 12344:4:12581996151:1:12581996153:3:12581996151:2:1258199616 总之，当每个线程中指定的key相等时，这些相等key的线程应每隔一秒依次输出时间值（要用互斥），如果key不同，则并行执行（相互之间不互斥）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//不能改动此Test类 public class Test extends Thread&#123; private TestDo testDo; private String key; private String value; public Test(String key,String key2,String value)&#123; this.testDo = TestDo.getInstance(); /*常量"1"和"1"是同一个对象，下面这行代码就是要用"1"+""的方式产生新的对象， 以实现内容没有改变，仍然相等（都还为"1"），但对象却不再是同一个的效果*/ this.key = key+key2; this.value = value; &#125; public static void main(String[] args) throws InterruptedException&#123; Test a = new Test("1","","1"); Test b = new Test("1","","2"); Test c = new Test("3","","3"); Test d = new Test("4","","4"); System.out.println("begin:"+(System.currentTimeMillis()/1000)); a.start(); b.start(); c.start(); d.start(); &#125; public void run()&#123; testDo.doSome(key, value); &#125; &#125; class TestDo &#123; private TestDo() &#123;&#125; private static TestDo _instance = new TestDo(); public static TestDo getInstance() &#123; return _instance; &#125; public void doSome(Object key, String value) &#123; // 以大括号内的是需要局部同步的代码，不能改动! &#123; try &#123; Thread.sleep(1000); System.out.println(key+":"+value + ":" + (System.currentTimeMillis() / 1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 对于源代码中关于实现值相同而对象不同的效果进行解释：对于：12a = "1"+"";b = "1"+""; 编译器自动优化，所以a和b是同一个对象 而对于：key = key+key2; 由于是变量，编译器无法识别，这时a和b把“1”和“”赋值给key和key2时会得到两个不同的对象 思想：将集合中的对象作为同步代码块的锁，即this锁，每次将对象存入集合中的时候，就判断是否原集合中已经存在一个与将要存入集合的对象值相同的对象，即用equals比较，如果有，那么就获取原来的这个对象，把这个对象作为将要存入对象的锁，这样它们持有的就是同一把锁，即可实现互斥，这样就可以实现值相同的对象在不同的时刻打印的效果 代码中出现的问题：在遍历ArrayList集合查找与要存入值相同元素的时候，进行了添加的动作，所以会出现并发修改异常，因此使用并发的CopyOnWriteArrayList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.ArrayList; import java.util.Iterator; import java.util.concurrent.CopyOnWriteArrayList; //不能改动此Test类 public class Test extends Thread&#123; private TestDo testDo; private String key; private String value; public Test(String key,String key2,String value)&#123; this.testDo = TestDo.getInstance(); /*常量"1"和"1"是同一个对象，下面这行代码就是要用"1"+""的方式产生新的对象， 以实现内容没有改变，仍然相等（都还为"1"），但对象却不再是同一个的效果*/ this.key = key+key2; //这里是变量，所以不会优化 /* a = "1"+""; b = "1"+"" 编译器自动优化，所以a和b是同一个对象 */ this.value = value; &#125; public static void main(String[] args) throws InterruptedException&#123; Test a = new Test("1","","1"); Test b = new Test("1","","2"); Test c = new Test("3","","3"); Test d = new Test("4","","4"); System.out.println("begin:"+(System.currentTimeMillis()/1000)); a.start(); b.start(); c.start(); d.start(); &#125; public void run()&#123; testDo.doSome(key, value); &#125; &#125; class TestDo &#123; private TestDo() &#123;&#125; private static TestDo _instance = new TestDo(); public static TestDo getInstance() &#123; return _instance; &#125; //private ArrayList keys = new ArrayList(); //迭代的时候不能修改数据，所以使用同步的ArrayList private CopyOnWriteArrayList keys = new CopyOnWriteArrayList(); public void doSome(Object key, String value) &#123; Object o = key; if(!keys.contains(o))&#123; //比较是否已经存入了一个相同值的对象 keys.add(o); &#125;else&#123; //迭代，找出原集合里和传进来的值相同的对象 for(Iterator iter=keys.iterator();iter.hasNext();)&#123; try &#123; Thread.sleep(20); // 迭代的时候休息一会，在ArrayList下演示并发修改异常 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Object oo = iter.next(); if(oo.equals(o))&#123; //如果两个对象的值相同 //就让原集合中的那个相等值的对象作为锁对象，由于原对象之前做的就是锁 //这样两个锁就相同了，就可以实现互斥 o = oo; break; &#125; &#125; &#125; synchronized(o) // 以大括号内的是需要局部同步的代码，不能改动! &#123; try &#123; Thread.sleep(1000); System.out.println(key+":"+value + ":" + (System.currentTimeMillis() / 1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步工具类]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内容摘要这里主要介绍了java5中线程锁技术以外的其他同步工具，首先介绍Semaphore：一个计数信号量。用于控制同时访问资源的线程个数，CyclicBarrier同步辅助类：从字面意思看是路障，这里用于线程之间的相互等待，到达某点后，继续向下执行。CountDownLatch同步辅助类：在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。犹如倒计时计数器，然后是Exchanger：实现两个对象之间数据交换，可阻塞队列：ArrayBlockingQueue，通过阻塞队列间的通信来演示其作用，最后介绍了几个同步集合。 1. Semaphore实现信号灯Semaphore可以维护当前访问自身的线程个数，并提供了同步机制，使用Semaphore可以控制同时访问资源的线程个数，例如，实现一个文件允许的并发访问数。Semaphore 只对可用许可的号码进行计数，并采取相应的行动。 Semaphore实现的功能就像：银行办理业务，一共有5个窗口，但一共有10个客户，一次性最多有5个客户可以进行办理，其他的人必须等候，当5个客户中的任何一个离开后，在等待的客户中有一个人可以进行业务办理。 Semaphore提供了两种规则： 一种是公平的：获得资源的先后，按照排队的先后。在构造函数中设置true实现 一种是野蛮的：谁有本事抢到资源，谁就可以获得资源的使用权。 与传统的互斥锁的异同： 单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁“，再由另外一个线程释放”锁“，这可以应用于死锁恢复的一些场合。 应用场景：共享资源的争夺，例如游戏中选手进入房间的情况。 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Semaphore; public class SemaphoreTest &#123; public static void main(String[] args) &#123; //创建一个可根据需要创建新线程的线程池 ExecutorService service = Executors.newCachedThreadPool(); final Semaphore sp = new Semaphore(3); //创建10个线程 for(int i=0;i&lt;10;i++)&#123; Runnable runnable = new Runnable()&#123; public void run()&#123; try &#123; sp.acquire(); //获取灯，即许可权 &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; System.out.println("线程" + Thread.currentThread().getName() + "进入，当前已有" + (3-sp.availablePermits()) + "个并发"); try &#123; Thread.sleep((long)(Math.random()*10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("线程" + Thread.currentThread().getName() + "即将离开"); sp.release(); // 释放一个许可，将其返回给信号量 //下面代码有时候执行不准确，因为其没有和上面的代码合成原子单元 System.out.println("线程" + Thread.currentThread().getName() + "已离开，当前已有" + (3-sp.availablePermits()) + "个并发"); &#125; &#125;; service.execute(runnable); &#125; &#125; &#125; 输出结果 123456789101112131415161718192021222324252627282930线程pool-1-thread-3进入，当前已有3个并发线程pool-1-thread-2进入，当前已有3个并发线程pool-1-thread-1进入，当前已有3个并发线程pool-1-thread-2即将离开线程pool-1-thread-2已离开，当前已有2个并发线程pool-1-thread-5进入，当前已有3个并发线程pool-1-thread-1即将离开线程pool-1-thread-1已离开，当前已有2个并发线程pool-1-thread-4进入，当前已有3个并发线程pool-1-thread-4即将离开线程pool-1-thread-4已离开，当前已有2个并发线程pool-1-thread-8进入，当前已有3个并发线程pool-1-thread-3即将离开线程pool-1-thread-7进入，当前已有3个并发线程pool-1-thread-3已离开，当前已有3个并发线程pool-1-thread-8即将离开线程pool-1-thread-8已离开，当前已有2个并发线程pool-1-thread-9进入，当前已有3个并发线程pool-1-thread-7即将离开线程pool-1-thread-7已离开，当前已有2个并发线程pool-1-thread-6进入，当前已有3个并发线程pool-1-thread-9即将离开线程pool-1-thread-9已离开，当前已有2个并发线程pool-1-thread-10进入，当前已有3个并发线程pool-1-thread-5即将离开线程pool-1-thread-5已离开，当前已有2个并发线程pool-1-thread-6即将离开线程pool-1-thread-6已离开，当前已有1个并发线程pool-1-thread-10即将离开线程pool-1-thread-10已离开，当前已有0个并发 控制一个方法的并发量，比如同时只能有3个线程进来 12345678910111213141516171819202122232425262728293031323334353637383940public class ThreadPoolTest &#123; //信号量 private static Semaphore semaphore = new Semaphore(3);//允许个数，相当于放了3把锁 public static void main(String[] args) &#123; for(int i=0;i&lt;10;i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; method(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; &#125; //同时最多只允许3个线程过来 public static void method() throws InterruptedException&#123; semaphore.acquire();//获取一把锁 System.out.println("ThreadName="+Thread.currentThread().getName()+"过来了"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("ThreadName="+Thread.currentThread().getName()+"出去了"); semaphore.release();//释放一把锁 &#125;&#125; 输出结果 1234567891011121314151617181920ThreadName=Thread-1过来了ThreadName=Thread-4过来了ThreadName=Thread-0过来了ThreadName=Thread-1出去了ThreadName=Thread-4出去了ThreadName=Thread-2过来了ThreadName=Thread-3过来了ThreadName=Thread-0出去了ThreadName=Thread-5过来了ThreadName=Thread-3出去了ThreadName=Thread-2出去了ThreadName=Thread-6过来了ThreadName=Thread-7过来了ThreadName=Thread-5出去了ThreadName=Thread-9过来了ThreadName=Thread-7出去了ThreadName=Thread-6出去了ThreadName=Thread-8过来了ThreadName=Thread-9出去了ThreadName=Thread-8出去了 三个线程a、b、c 并发运行，b，c 需要a 线程的数据怎么实现 根据问题的描述，我将问题用以下代码演示，ThreadA、ThreadB、ThreadC，ThreadA 用于初始化数据num，只有当num 初始化完成之后再让ThreadB 和ThreadC 获取到初始化后的变量num。 分析过程如下： 考虑到多线程的不确定性，因此我们不能确保ThreadA 就一定先于ThreadB 和ThreadC 前执行，就算ThreadA先执行了，我们也无法保证ThreadA 什么时候才能将变量num 给初始化完成。因此我们必须让ThreadB 和ThreadC去等待ThreadA 完成任何后发出的消息。 现在需要解决两个难题，一是让ThreadB 和ThreadC 等待ThreadA 先执行完，二是ThreadA 执行完之后给ThreadB 和ThreadC 发送消息。 解决上面的难题我能想到的两种方案，一是使用纯Java API 的Semaphore 类来控制线程的等待和释放，二是使用Android 提供的Handler 消息机制 1234567891011121314151617181920212223242526272829303132333435363738394041public class ThreadCommunication &#123; private static int num;//定义一个变量作为数据 public static void main(String[] args) &#123; Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //模拟耗时操作之后初始化变量num Thread.sleep(1000); num = 1; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() +"获取到num 的值为："+num); &#125; &#125;); Thread threadC = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() +"获取到num 的值为："+num); &#125; &#125;); //同时开启3 个线程 threadA.start(); threadB.start(); threadC.start(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class ThreadCommunication &#123; private static int num; /** * 定义一个信号量，该类内部维持了多个线程锁，可以阻塞多个线程，释放多个线程， * 线程的阻塞和释放是通过permit 概念来实现的线程通过semaphore.acquire()方法获取permit， * 如果当前semaphore 有permit 则分配给该线程，如果没有则阻塞该线程直到semaphore * 调用release（）方法释放permit。构造函数中参数：permit（允许） 个数 */ private static Semaphore semaphore = new Semaphore(0); public static void main(String[] args) &#123; Thread threadA = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //模拟耗时操作之后初始化变量num Thread.sleep(1000); num = 1; //初始化完参数后释放两个permit semaphore.release(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); Thread threadB = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //获取permit，如果semaphore 没有可用的permit 则等待 // 如果有则消耗一个 semaphore.acquire(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() +"获取到num 的值为："+num); &#125; &#125;); Thread threadC = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //获取permit，如果semaphore 没有可用的permit 则等待 // 如果有则消耗一个 semaphore.acquire(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() +"获取到num 的值为："+num); &#125; &#125;); //同时开启3 个线程 threadA.start(); threadB.start(); threadC.start(); &#125;&#125; 2. CyclicBarrier一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 CyclicBarrier 支持一个可选的 Runnable 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作 很有用。 3个线程到达某个集合点后再向下执行,使用await方法实现 123456789101112131415161718192021222324252627282930313233343536import java.util.concurrent.CyclicBarrier; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); final CyclicBarrier cb = new CyclicBarrier(3); for(int i=0;i&lt;3;i++)&#123; Runnable runnable = new Runnable()&#123; public void run()&#123; try &#123; Thread.sleep((long)(Math.random()*10000)); System.out.println("线程" + Thread.currentThread().getName() + "即将到达集合地点1，当前已有" + (cb.getNumberWaiting()+1) + "个已经到达，" + (cb.getNumberWaiting()==2?"都到齐了，继续走啊":"正在等候")); cb.await();//在所有参与者都已经在此 barrier 上调用 await 方法之前，将一直等待。 Thread.sleep((long)(Math.random()*10000)); System.out.println("线程" + Thread.currentThread().getName() + "即将到达集合地点2，当前已有" + (cb.getNumberWaiting()+1) + "个已经到达，" + (cb.getNumberWaiting()==2?"都到齐了，继续走啊":"正在等候")); cb.await(); Thread.sleep((long)(Math.random()*10000)); System.out.println("线程" + Thread.currentThread().getName() + "即将到达集合地点3，当前已有" + (cb.getNumberWaiting() + 1) + "个已经到达，" + (cb.getNumberWaiting()==2?"都到齐了，继续走啊":"正在等候")); cb.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; service.execute(runnable); &#125; service.shutdown(); &#125; &#125; 输出结果 123456789线程pool-1-thread-3即将到达集合地点1，当前已有1个已经到达，正在等候线程pool-1-thread-1即将到达集合地点1，当前已有2个已经到达，正在等候线程pool-1-thread-2即将到达集合地点1，当前已有3个已经到达，都到齐了，继续走啊线程pool-1-thread-1即将到达集合地点2，当前已有1个已经到达，正在等候线程pool-1-thread-2即将到达集合地点2，当前已有2个已经到达，正在等候线程pool-1-thread-3即将到达集合地点2，当前已有3个已经到达，都到齐了，继续走啊线程pool-1-thread-3即将到达集合地点3，当前已有1个已经到达，正在等候线程pool-1-thread-1即将到达集合地点3，当前已有2个已经到达，正在等候线程pool-1-thread-2即将到达集合地点3，当前已有3个已经到达，都到齐了，继续走啊 3. CountDownLatch一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。犹如倒计时计数器，调用CountDownLatch对象的countDown方法就将计数器减1，当计数到达0时，则所有等待者或单个等待者开始执行。 可以实现一个人（也可以是多个人）等待其他所有人都来通知他，也可以实现一个人通知多个人的效果，类似裁判一声口令，运动员开始奔跑（一对多），或者所有运送员都跑到终点后裁判才可以公布结果（多对一）。 用指定的计数 初始化 CountDownLatch。在调用 countDown() 方法之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。 实现运动员比赛的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.concurrent.CountDownLatch; import java.util.concurrent.CyclicBarrier; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class CountdownLatchTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); //构造一个用给定计数初始化的 CountDownLatch,相当于裁判的口哨 final CountDownLatch cdOrder = new CountDownLatch(1); //相当于定义3个运行员 final CountDownLatch cdAnswer = new CountDownLatch(3); for (int i = 0; i &lt; 3; i++) &#123; Runnable runnable = new Runnable() &#123; public void run() &#123; try &#123; System.out.println("线程" + Thread.currentThread().getName() + "正准备接受命令"); // 等待发令枪 cdOrder.await();//使当前线程在锁存器倒计数至零之前一直等待 System.out.println("线程" + Thread.currentThread().getName() + "已接受命令"); Thread.sleep((long) (Math.random() * 10000)); System.out .println("线程" + Thread.currentThread().getName() + "回应命令处理结果"); // 各个运动员完报告成绩之后，通知裁判 cdAnswer.countDown();//递减锁存器的计数，如果计数到达零，则释放所有等待的线程 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; service.execute(runnable); &#125; try &#123; Thread.sleep((long) (Math.random() * 10000)); System.out.println("线程" + Thread.currentThread().getName() + "即将发布命令"); // 发令枪打响，比赛开始 cdOrder.countDown(); System.out.println("线程" + Thread.currentThread().getName() + "已发送命令，正在等待结果"); // 裁判等待各个运动员的结果 cdAnswer.await(); // 裁判公布获得所有运动员的成绩 System.out.println("线程" + Thread.currentThread().getName() + "已收到所有响应结果"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; service.shutdown(); &#125; &#125; 输出结果 123456789101112线程pool-1-thread-2正准备接受命令线程pool-1-thread-3正准备接受命令线程pool-1-thread-1正准备接受命令线程main即将发布命令线程main已发送命令，正在等待结果线程pool-1-thread-1已接受命令线程pool-1-thread-2已接受命令线程pool-1-thread-3已接受命令线程pool-1-thread-1回应命令处理结果线程pool-1-thread-3回应命令处理结果线程pool-1-thread-2回应命令处理结果线程main已收到所有响应结果 4. Exchanger用于实现两个对象之间的数据交换，每个对象在完成一定的事务后想与对方交换数据，第一个先拿出数据的对象将一直等待第二个对象拿着数据到来时，彼此才能交换数据。 方法：exchange（V x） 等待另一个线程到达此交换点（除非当前线程被中断），然后将给定的对象传送给该线程，并接收该线程的对象。 应用：使用 Exchanger 在线程间交换缓冲区 示例：模拟毒品交易情景 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.Exchanger; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ExchangerTest &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newCachedThreadPool(); final Exchanger exchanger = new Exchanger(); service.execute(new Runnable()&#123; public void run() &#123; try &#123; String data1 = "毒品"; System.out.println("线程" + Thread.currentThread().getName() + "正在把: " + data1 +" 交易出去"); Thread.sleep((long)(Math.random()*10000)); String data2 = (String)exchanger.exchange(data1); System.out.println("线程" + Thread.currentThread().getName() + "换得了: " + data2); &#125;catch(Exception e)&#123; &#125; &#125; &#125;); service.execute(new Runnable()&#123; public void run() &#123; try &#123; String data1 = "美金"; System.out.println("线程" + Thread.currentThread().getName() + "正在把: " + data1 +" 交易出去"); Thread.sleep((long)(Math.random()*10000)); String data2 = (String)exchanger.exchange(data1); System.out.println("线程" + Thread.currentThread().getName() + "换得了: " + data2); &#125;catch(Exception e)&#123; &#125; &#125; &#125;); &#125; &#125; 1234线程pool-1-thread-1正在把: 毒品 交易出去线程pool-1-thread-2正在把: 美金 交易出去线程pool-1-thread-1换得了: 美金线程pool-1-thread-2换得了: 毒品 5. ArrayBlockingQueue一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列包含固定长度的队列和不固定长度的队列。 这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。 通俗的讲：当指定队列大小，如果已经放满，其他存入数据的线程就阻塞，等着该队列中有空位，才能放进去。当取的比较快，队列中没有数据，取数据的线程阻塞，等队列中放入了数据，才可以取。 ArrayBlockingQueue中只有put和take方法才具有阻塞功能。方法类型如下 功能 抛出异常 特殊值 阻塞 超时 插入 add(e) offer(e) put(e) offer(e, time, unit) 移除 remove() poll() take() poll(time, unit) 检查 element() peek() 不可用 不可用 示例：用3个空间的队列来演示向阻塞队列中存取数据的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.xushuai.thread; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue; public class BlockingQueueTest &#123; public static void main(String[] args) &#123; final BlockingQueue queue = new ArrayBlockingQueue(3); for(int i=0;i&lt;2;i++)&#123; new Thread()&#123; public void run()&#123; while(true)&#123; try &#123; Thread.sleep((long)(Math.random()*1000)); System.out.println(Thread.currentThread().getName() + "准备放数据!"); queue.put(1); //放进去后，可能立即执行“准备取数据” System.out.println(Thread.currentThread().getName() + "已经放了数据，" + "队列目前有" + queue.size() + "个数据"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; new Thread()&#123; public void run()&#123; while(true)&#123; try &#123; //将此处的睡眠时间分别改为100和1000，观察运行结果 Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + "准备取数据!"); queue.take(); //取出后可能來不及执行下面的打印语句，就跑到了“准备放数据”， System.out.println(Thread.currentThread().getName() + "已经取走数据，" + "队列目前有" + queue.size() + "个数据"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; &#125; 输出结果1234567891011121314151617181920212223242526Thread-0准备放数据!Thread-0已经放了数据，队列目前有1个数据Thread-0准备放数据!Thread-0已经放了数据，队列目前有2个数据Thread-1准备放数据!Thread-1已经放了数据，队列目前有3个数据Thread-2准备取数据!Thread-2已经取走数据，队列目前有2个数据Thread-0准备放数据!Thread-0已经放了数据，队列目前有3个数据Thread-0准备放数据!Thread-1准备放数据!Thread-2准备取数据!Thread-2已经取走数据，队列目前有2个数据Thread-0已经放了数据，队列目前有3个数据Thread-0准备放数据!Thread-2准备取数据!Thread-2已经取走数据，队列目前有2个数据Thread-1已经放了数据，队列目前有3个数据Thread-1准备放数据!Thread-2准备取数据!Thread-2已经取走数据，队列目前有2个数据Thread-0已经放了数据，队列目前有3个数据Thread-0准备放数据!Thread-2准备取数据!... 6. 阻塞队列间的通信A队列向空间中存数据，B从空间里取数据，A存入后，通知B去取，B取过之后，通知A去放，依次循环 示例：子线程先循环10次，接着主线程循环100次，接着又回到子线程，循环10次，再回到主线程又循环100，如此循环50次。 说明：这里通过使 用两个具有1个空间的队列来实现同步通知的功能（实现了锁和condition的功能），以便实现队列间的通信，其中使用到了构造代码块为主队列先存入一个数据，以使其先阻塞，子队列先执行。 使用构造代码块的原因： 成员变量在创建类的实例对象时，才分配空间，才能有值，所以创建一个构造方法来给main_quene赋值，这里不可以使用静态代码块，因为静态在还没创建对象就存在， 而sub_quene和main_quene是对象创建以后的成员变量，所以这里用匿名构造方法，它的运行时期在任何构造方法之前，创建几个对象就执行几次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue; public class BlockingQueueCommunication &#123; public static void main(String[] args)&#123; final Business business = new Business(); new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=1;i&lt;=50;i++)&#123; business.sub(i); &#125; &#125; &#125;).start(); //主线程外部循环 for(int i=1;i&lt;=50;i++)&#123; business.main(i); &#125; &#125; //业务类 static class Business&#123; BlockingQueue&lt;Integer&gt; sub_quene = new ArrayBlockingQueue&lt;Integer&gt;(1); BlockingQueue&lt;Integer&gt; main_quene = new ArrayBlockingQueue&lt;Integer&gt;(1); &#123; //为了让子队列先走，所以在一开始就往主队列中存入一个对象，使其阻塞。 try &#123; main_quene.put(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; //子队列先走 public void sub(int i)&#123; try &#123; sub_quene.put(1); //子队列第一次存入，可以执行，但由于只有1个空间，已经存满，所以只有在执行后要等到take之后才能继续下次执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //子队列循环执行 for(int j=1;j&lt;=10;j++)&#123; System.out.println("sub thread sequence of"+i+",loop of "+j); &#125; try &#123; main_quene.take(); //让主队列从已经填满的队列中取出数据，使其开始第一次执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void main(int i)&#123; try &#123; main_quene.put(1); //主队列先前放过1个空间，现在处于阻塞状态，等待子队列通知，即子线程中的main_quene.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //主队列循环执行 for(int j=1;j&lt;=100;j++)&#123; System.out.println("main thread sequence of"+i+", loop of "+j); &#125; try &#123; sub_quene.take(); //让子队列从已经填满的队列中取出数据，使其执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 7. 同步集合类7.1 同步Map集合 java.util.concurrent.ConcurrentMap ConcurrentHashMap ConcurrentNavigableMap ConcurrentSkipListMap ConcurrentHashMap同步的HashMap，支持获取的完全并发和更新的所期望可调整并发的哈希表。此类遵守与 Hashtable 相同的功能规范，并且包括对应于 Hashtable 的每个方法的方法版本。 不过，尽管所有操作都是线程安全的，但获取操作不 必锁定，并且不 支持以某种防止所有访问的方式锁定整个表。此类可以通过程序完全与 Hashtable 进行互操作，这取决于其线程安全，而与其同步细节无关。 内部原理： 其实内部使用了代理模式，你给我一个HashMap，我就给你一个同步的HashMap。同步的HashMap在调用方法时，是去分配给原始的HashMap只是在去调用方法的同时加上了Synchronized，以此实现同步效果 ConcurrentHashMap是线程安全的HashMap的实现，默认构造同样有initialCapacity和loadFactor属性，不过还多了一个concurrencyLevel属性，三属性默认值分别为16、0.75及16。其内部使用锁分段技术，维持这锁Segment的数组，在Segment数组中又存放着Entity[]数组，内部hash算法将数据较均匀分布在不同锁中。 put(key , value) 并没有在此方法上加上synchronized，首先对key.hashcode进行hash操作，得到key的hash值。hash操作的算法和map也不同，根据此hash值计算并获取其对应的数组中的Segment对象(继承自ReentrantLock)，接着调用此Segment对象的put方法来完成当前操作。 ConcurrentHashMap基于concurrencyLevel划分出了多个Segment来对key-value进行存储，从而避免每次put操作都得锁住整个数组。在默认的情况下，最佳情况下可允许16个线程并发无阻塞的操作集合对象，尽可能地减少并发时的阻塞现象。 get(key) 首先对key.hashCode进行hash操作，基于其值找到对应的Segment对象，调用其get方法完成当前操作。而Segment的get操作首先通过hash值和对象数组大小减1的值进行按位与操作来获取数组上对应位置的HashEntry。在这个步骤中，可能会因为对象数组大小的改变，以及数组上对应位置的HashEntry产生不一致性，那么ConcurrentHashMap是如何保证的？ 对象数组大小的改变只有在put操作时有可能发生，由于HashEntry对象数组对应的变量是volatile类型的，因此可以保证如HashEntry对象数组大小发生改变，读操作可看到最新的对象数组大小。 在获取到了HashEntry对象后，怎么能保证它及其next属性构成的链表上的对象不会改变呢？这点ConcurrentHashMap采用了一个简单的方式，即HashEntry对象中的hash、key、next属性都是final的，这也就意味着没办法插入一个HashEntry对象到基于next属性构成的链表中间或末尾。这样就可以保证当获取到HashEntry对象后，其基于next属性构建的链表是不会发生变化的。 ConcurrentHashMap默认情况下采用将数据分为16个段进行存储，并且16个段分别持有各自不同的锁Segment，锁仅用于put和remove等改变集合对象的操作，基于volatile及HashEntry链表的不变性实现了读取的不加锁。这些方式使得ConcurrentHashMap能够保持极好的并发支持，尤其是对于读远比插入和删除频繁的Map而言，而它采用的这些方法也可谓是对于Java内存模型、并发机制深刻掌握的体现。 ConcurrentNavigableMapjava.util.concurrent.ConcurrentNavigableMap 是一个支持并发访问的 java.util.NavigableMap，它还能让它的子 map 具备并发访问的能力。所谓的 “子 map” 指的是诸如 headMap()，subMap()，tailMap() 之类的方法返回的 map。 NavigableMap 中的方法不再赘述，本小节我们来看一下 ConcurrentNavigableMap 添加的方法。 headMap()headMap(T toKey) 方法返回一个包含了小于给定 toKey 的 key 的子 map。如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素(译者注：map 集合持有的其实只是对象的引用)。 以下示例演示了对 headMap() 方法的使用： 1234567ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put("1", "one"); map.put("2", "two"); map.put("3", "three"); ConcurrentNavigableMap headMap = map.headMap("2"); headMap 将指向一个只含有键 “1” 的 ConcurrentNavigableMap，因为只有这一个键小于 “2”。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。 tailMap()tailMap(T fromKey) 方法返回一个包含了不小于给定 fromKey 的 key 的子 map。如果你对原始 map 里的元素做了改动，这些改动将影响到子 map 中的元素(译者注：map 集合持有的其实只是对象的引用)。 以下示例演示了对 tailMap() 方法的使用： 1234567ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put("1", "one"); map.put("2", "two"); map.put("3", "three"); ConcurrentNavigableMap tailMap = map.tailMap("2"); tailMap 将拥有键 “2” 和 “3”，因为它们不小于给定键 “2”。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。 subMap()subMap() 方法返回原始 map 中，键介于 from(包含) 和 to (不包含) 之间的子 map。示例如下： 1234567ConcurrentNavigableMap map = new ConcurrentSkipListMap(); map.put("1", "one"); map.put("2", "two"); map.put("3", "three"); ConcurrentNavigableMap subMap = map.subMap("2", "3"); 返回的 submap 只包含键 “2”，因为只有它满足不小于 “2”，比 “3” 小。 更多方法ConcurrentNavigableMap 接口还有其他一些方法可供使用，比如： descendingKeySet() descendingMap() navigableKeySet() 关于这些方法更多信息参考官方 Java 文档。 7.2 同步List集合 ConcurrentSkipListSet CopyOnWriteArraySet CopyOnWriteArrayList ConcurrentSkipListSet一个基于 ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现。类似于TreeSet，set 的元素可以根据它们的自然顺序进行排序，也可以根据创建 set 时所提供的Comparator 进行排序，具体取决于使用的构造方法。 CopyOnWriteArrayListArrayList 的一个线程安全的变体，可解决线程安全问题，在遍历的时候，同时进行添加操作。其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 CopyOnWriteArrayList是一个线程安全、并且在读操作时无锁的ArrayList，其具体实现方法如下。 CopyOnWriteArrayList() 和ArrayList不同，此步的做法为创建一个大小为0的数组。 add(E) add方法并没有加上synchronized关键字，它通过使用ReentrantLock来保证线程安全。此处和ArrayList的不同是每次都会创建一个新的Object数组，此数组的大小为当前数组大小加1，将之前数组中的内容复制到新的数组中，并将新增加的对象放入数组末尾，最后做引用切换将新创建的数组对象赋值给全局的数组对象。 remove(E) 和add方法一样，此方法也通过ReentrantLock来保证其线程安全，但它和ArrayList删除元素采用的方式并不一样。 首先创建一个比当前数组小1的数组，遍历新数组，如找到equals或均为null的元素，则将之后的元素全部赋值给新的数组对象，并做引用切换，返回true；如未找到，则将当前的元素赋值给新的数组对象，最后特殊处理数组中的最后一个元素，如最后一个元素等于要删除的元素，即将当前数组对象赋值为新创建的数组对象，完成删除操作，如最后一个元素也不等于要删除的元素，那么返回false。 此方法和ArrayList除了锁不同外，最大的不同在于其复制过程并没有调用System的arrayCopy来完成，理论上来说会导致性能有一定下降。 get(int) 此方法非常简单，直接获取当前数组对应位置的元素，这种方法是没有加锁保护的，因此可能会出现读到脏数据的现象。但相对而言，性能会非常高，对于写少读多且脏数据影响不大的场景而言是不错的选择。 iterator() 调用iterator方法后创建一个新的COWIterator对象实例，并保存了一个当前数组的快照，在调用next遍历时则仅对此快照数组进行遍历，因此遍历此list时不会抛出ConcurrentModificatiedException。 与ArrayList的性能对比，在读多写少的并发场景中，较之ArrayList是更好的选择，单线程以及多线程下增加元素及删除元素的性能不比ArrayList好 CopyOnWriteArraySet对其所有操作使用内部 CopyOnWriteArrayList 的 Set。因此，它共享以下相同的基本属性： 它最适合于 set 大小通常保持很小、只读操作远多于可变操作以及需要在遍历期间防止线程间冲突的应用程序。 它是线程安全的。 因为通常需要复制整个基础数组，所以可变操作（添加、设置、移除，等等）的开销巨大。 迭代器不支持可变移除操作。 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。 CopyOnWriteArraySet基于CopyOnWriteArrayList实现，其唯一的不同是在add时调用的是CopyOnWriteArrayList的addIfAbsent方法。保证了无重复元素，但在add时每次都要进行数组的遍历，因此性能会略低于上个。 7.3 ConcurrentLinkedQueueConcurrentLinkedQueue是一个基于链接节点的、无界的、线程安全的队列。此队列按照 FIFO（先进先出）原则对元素进行排序，队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列检索操作从队列头部获得元素。当许多线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择，此队列不允许 null 元素。 7.4 ConcurrentLinkedDeque一个基于链接节点的、无界的、线程安全的双端队列]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[这里首先介绍了java5中的并发的小工具包：java.util.concurrent.atomic，然后介绍了线程池的概念，对使用java5的方式创建不同形式的线程进行了演示，之后介绍了两个 对象：Callable和Future，用于获取线程执行后的结果，对于线程锁技术则在另外一篇文章中介绍。 Java5中的线程并发库都在java.util.concurrent包及子包中 1. Executor类的继承结构 Executor是线程池的顶级接口，只有一个执行任务的方法execute() ExecutorService是Executor的子接口，该接口中包含了线程池常用的一些方法 方法 功能描述 execute() 执行任务 shutdown() 调用后不再接收新任务，如果里面有任务，就执行完 shutdownNow() 调用后不再接受新任务，如果有等待任务，移出队列；有正在执行的，尝试停止之 isShutdown() 判断线程池是否关闭 isTerminated() 判断线程池中任务是否执行完成 submit() 提交任务 invokeAll() 执行一组任务 2. ThreadPoolExecutorExecutorService的默认实现，同时也是Executors的底层实现 2.1 构造方法123456789public ThreadPoolExecutor( int corePoolSize, //核心线程数 int maximumPoolSize, //最大线程数 long keepAliveTime, //保持时间 TimeUnit unit, //时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列 ThreadFactory threadFactory, //线程工厂 RejectedExecutionHandler handler //异常捕获器) 2.1.1 int corePoolSize核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中 2.1.2 int maximumPoolSize线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程 2.1.3 long keepAliveTime表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0 2.1.4 TimeUnit unit参数keepAliveTime的时间单位，有7种取值 TimeUnit.DAYS //天 TimeUnit.HOURS //小时 TimeUnit.MINUTES //分钟 TimeUnit.SECONDS //秒 TimeUnit.MILLISECONDS //毫秒 TimeUnit.MICROSECONDS //微妙 TimeUnit.NANOSECONDS //纳秒 2.1.5 RejectedExecutionHandler ThreadPoolExecutor.AbortPolicy当添加任务出错时的策略捕获器，丢弃任务并抛出RejectedExecutionException异常 ThreadPoolExecutor.DiscardPolicy也是丢弃任务，但是不抛出异常 ThreadPoolExecutor.DiscardOldestPolicy丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） ThreadPoolExecutor.CallerRunsPolicy由调用线程处理该任务 3. 任务提交给线程池之后的处理策略3.1 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建执行这个任务 3.2 如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中 3.2.1 若添加成功，则该任务会等待空闲线程将其取出去执行 3.2.2 若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务 3.3 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止 4. 阻塞队列的介绍4.1 BlockingQueue 阻塞队列 功能描述 BlockingQueue 阻塞队列的顶级接口，主要用于实现生产者消费者队列 BlockingDeque 双端队列 SynchronousQueue 同步队列，无界队列，直接提交策略，交替队列，在某次添加元素后必须等待其他线程取走后才能继续添加 LinkedBlockingQueue 无界队列，基于链表的阻塞队列，可以并发运行，FIFO ArrayBlockingQueue 基于数组的有界(固定大小的数组)阻塞队列，只有put方法和take方法才具有阻塞功能，公平性 fairness PriorityBlockingQueue 基于优先级的阻塞队列，依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序 DelayQueue 延时队列 4.2 排队策略直接提交工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 无界队列使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）使用无界队列将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列。例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性 有界队列当使用有限的 maximumPoolSizes 时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 4.3 BlockingQueue 方法 Throw exception 抛出异常 Special value 特殊值 Blocks 阻塞 Time out 超时 Insert add() offer() put() offer(e，time，unit) Remove remove() poll() take() poll(time，unit) Examine检查 element() peek() 不可用 不可用 BlockingQueue 不接受 null 元素。试图 add、put 或 offer 一个 null 元素时，某些实现会抛出 NullPointerException。null 被用作指示 poll 操作失败的警戒值。 BlockingQueue 可以是限定容量的。它在任意给定时间都可以有一个 remainingCapacity，超出此容量，便无法无阻塞地 put 附加元素。没有任何内部容量约束的 BlockingQueue 总是报告 Integer.MAX_VALUE 的剩余容量。 BlockingQueue 实现主要用于生产者-使用者队列，但它另外还支持 Collection 接口。因此，举例来说，使用 remove(x) 从队列中移除任意一个元素是有可能的。然而，这种操作通常不 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。 BlockingQueue 实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的 Collection 操作（addAll、containsAll、retainAll 和 removeAll）没有必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了 c 中的一些元素后，addAll(c) 有可能失败（抛出一个异常）。 BlockingQueue 实质上不支持使用任何一种“close”或“shutdown”操作来指示不再添加任何项。这种功能的需求和使用有依赖于实现的倾向。例如，一种常用的策略是：对于生产者，插入特殊的end-of-stream或poison对象，并根据使用者获取这些对象的时间来对它们进行解释。 4.4 BlockingDeque双端队列 4.5 ArrayBlockingQueue一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象必须明确大小，像数组一样。其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了(译者注：因为它是基于数组实现的，也就具有数组的特性：一旦初始化，大小就无法修改)。 实现互斥，你一下我一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BlockingQueueCondition &#123; public static void main(String[] args) &#123; ExecutorService service = Executors.newSingleThreadExecutor(); final Business3 business = new Business3(); service.execute(new Runnable()&#123; public void run() &#123; for(int i=0;i&lt;50;i++)&#123; business.sub(); &#125; &#125; &#125;); for(int i=0;i&lt;50;i++)&#123; business.main(); &#125; &#125;&#125;class Business3&#123; BlockingQueue subQueue = new ArrayBlockingQueue(1); BlockingQueue mainQueue = new ArrayBlockingQueue(1); &#123; try &#123; mainQueue.put(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void sub()&#123; try &#123; mainQueue.take(); for(int i=0;i&lt;10;i++)&#123; System.out.println(Thread.currentThread().getName() + " : " + i); &#125; subQueue.put(1); &#125;catch(Exception e)&#123; &#125; &#125; public void main()&#123; try &#123; subQueue.take(); for(int i=0;i&lt;5;i++)&#123; System.out.println(Thread.currentThread().getName() + " : " + i); &#125; mainQueue.put(1); &#125;catch(Exception e)&#123; &#125; &#125;&#125; 输出结果 1234567891011121314151617181920212223242526272829303132333435363738394041pool-1-thread-1 : 0pool-1-thread-1 : 1pool-1-thread-1 : 2pool-1-thread-1 : 3pool-1-thread-1 : 4pool-1-thread-1 : 5pool-1-thread-1 : 6pool-1-thread-1 : 7pool-1-thread-1 : 8pool-1-thread-1 : 9main : 0main : 1main : 2main : 3main : 4pool-1-thread-1 : 0pool-1-thread-1 : 1pool-1-thread-1 : 2pool-1-thread-1 : 3pool-1-thread-1 : 4pool-1-thread-1 : 5pool-1-thread-1 : 6pool-1-thread-1 : 7pool-1-thread-1 : 8pool-1-thread-1 : 9main : 0main : 1main : 2main : 3main : 4pool-1-thread-1 : 0pool-1-thread-1 : 1pool-1-thread-1 : 2pool-1-thread-1 : 3pool-1-thread-1 : 4pool-1-thread-1 : 5pool-1-thread-1 : 6pool-1-thread-1 : 7pool-1-thread-1 : 8pool-1-thread-1 : 9... 4.6 LinkedBlockingQueue一个可改变大小的阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。创建其对象如果没有明确大小，默认值是Integer.MAX_VALUE。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 4.7 SynchronousQueue同步队列。同步队列没有任何容量，每个插入必须等待另一个线程移除，反之亦然。是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。 4.8 DelayQueue延时队列，对元素进行持有直到一个特定的延迟到期，只有在延迟期满时才能从中提取元素。注入其中的元素必须实现 java.util.concurrent.Delayed 接口。 4.9 PriorityBlockingQueue基于优先级的阻塞队列，依据对象的自然排序顺序或者是构造函数所带的Comparator决定的顺序，应用：Volley 4.10 生产者消费者生产者生产任务，消费者消费任务，那么这时就需要一个任务队列，生产者向队列里插入任务，消费者从队列里提取任务执行 5. 线程池工具类Executorsjdk1.5之后的一个新类，提供了一些静态工厂，生成一些常用的线程池，ThreadPoolExecutor是Executors类的底层实现 方法 功能描述 newCachedThreadPool() 创建一个可缓存的线程池 newFixedThreadPool() 创建一个固定大小的线程池 newScheduledThreadPool() 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求 newSingleThreadExecutor() 创建单个线程的线程池，始终保证线程池中会有一个线程在。当某线程死去，会找继任者 defaultThreadFactory() 创建一个默认线程池工厂 6. 线程池在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程，这就是封装 记住：任务是提交给整个线程池，一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务。 示例： 创建固定大小的线程池 创建缓存线程池 用线程池创建定时器 创建单一线程池（始终保证线程池中会有一个线程在。当某线程死去，会找继任者） 注意： 定时器中总是相对时间，我们要想指定具体时间的方法：比如明天早上10点钟执行，则可以使用明天早上10点的时间减去当前的时间，得到时间间隔 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; public class ThreadPoolTest &#123; public static void main(String[] args)&#123; //创建固定大小的线程池，这里只能完成3个任务 //ExecutorService threadPool = Executors.newFixedThreadPool(3); //创建缓存线程池，根据任务来自动创建线程的数量，可以完成创建的所有任务 //ExecutorService threadPool = Executors.newCachedThreadPool(); //创建单一线程池（始终保持线程池中有一个线程存活。当唯一线程死去，会创建新的继任者、 ExecutorService threadPool = Executors.newSingleThreadExecutor(); for(int i=1;i&lt;=10;i++)&#123; //内部类不能访问外部类的局部变量，所以i要定义为final，又由于i++. //所以在循环内部定义一个变量接收i final int task = i; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; for(int j=1;j&lt;=10;j++)&#123; System.out.println(Thread.currentThread().getName() +" is looping of "+ j+" for task of " +task); &#125; &#125; &#125;); &#125; //验证10个任务都提交给了线程池 System.out.println("all of 10 tasks have committed! "); //threadPool.shutdown(); //等任务完成后，杀死线程、 //threadPool.shutdownNow(); //立即停止线程 //用线程池启动定时器 Executors.newScheduledThreadPool(3).schedule( new Runnable() &#123; //任务 @Override public void run() &#123; System.out.println("bombing!"); &#125; &#125;, 5, //5秒以后执行 TimeUnit.SECONDS); //单位 //在某个时间执行一次后，再指定后续的执行间隔时间 Executors.newScheduledThreadPool(3).scheduleAtFixedRate(new Runnable()&#123; @Override public void run() &#123; System.out.println("bombing!"); &#125; &#125;, 10, //第一次在10秒时爆炸 3, //以后每隔3秒爆炸一次。 TimeUnit.SECONDS); &#125; &#125; 7. 线程池的简单使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** * 一个简易的线程池管理类，提供三个线程池 */public class ThreadManager &#123; public static final String DEFAULT_SINGLE_POOL_NAME = "DEFAULT_SINGLE_POOL_NAME"; private static ThreadPoolProxy mLongPool = null; private static Object mLongLock = new Object(); private static ThreadPoolProxy mShortPool = null; private static Object mShortLock = new Object(); private static ThreadPoolProxy mDownloadPool = null; private static Object mDownloadLock = new Object(); private static Map&lt;String, ThreadPoolProxy&gt; mMap = new HashMap&lt;String, ThreadPoolProxy&gt;(); private static Object mSingleLock = new Object(); /** 获取下载线程 */ public static ThreadPoolProxy getDownloadPool() &#123; synchronized (mDownloadLock) &#123; if (mDownloadPool == null) &#123; mDownloadPool = new ThreadPoolProxy(3, 3, 5L); &#125; return mDownloadPool; &#125; &#125; /** 获取一个用于执行长耗时任务的线程池，避免和短耗时任务处在同一个队列而阻塞了重要的短耗时任务，通常用来联网操作 */ public static ThreadPoolProxy getLongPool() &#123; synchronized (mLongLock) &#123; if (mLongPool == null) &#123; mLongPool = new ThreadPoolProxy(5, 5, 5L); &#125; return mLongPool; &#125; &#125; /** 获取一个用于执行短耗时任务的线程池，避免因为和耗时长的任务处在同一个队列而长时间得不到执行，通常用来执行本地的IO/SQL */ public static ThreadPoolProxy getShortPool() &#123; synchronized (mShortLock) &#123; if (mShortPool == null) &#123; mShortPool = new ThreadPoolProxy(2, 2, 5L); &#125; return mShortPool; &#125; &#125; /** 获取一个单线程池，所有任务将会被按照加入的顺序执行，免除了同步开销的问题 */ public static ThreadPoolProxy getSinglePool() &#123; return getSinglePool(DEFAULT_SINGLE_POOL_NAME); &#125; /** 获取一个单线程池，所有任务将会被按照加入的顺序执行，免除了同步开销的问题 */ public static ThreadPoolProxy getSinglePool(String name) &#123; synchronized (mSingleLock) &#123; ThreadPoolProxy singlePool = mMap.get(name); if (singlePool == null) &#123; singlePool = new ThreadPoolProxy(1, 1, 5L); mMap.put(name, singlePool); &#125; return singlePool; &#125; &#125; public static class ThreadPoolProxy &#123; private ThreadPoolExecutor mPool; private int mCorePoolSize; private int mMaximumPoolSize; private long mKeepAliveTime; private ThreadPoolProxy(int corePoolSize, int maximumPoolSize, long keepAliveTime) &#123; mCorePoolSize = corePoolSize; mMaximumPoolSize = maximumPoolSize; mKeepAliveTime = keepAliveTime; &#125; /** 执行任务，当线程池处于关闭，将会重新创建新的线程池 */ public synchronized void execute(Runnable run) &#123; if (run == null) &#123; return; &#125; if (mPool == null || mPool.isShutdown()) &#123; //参数说明 //当线程池中的线程小于mCorePoolSize，直接创建新的线程加入线程池执行任务 //当线程池中的线程数目等于mCorePoolSize，将会把任务放入任务队列BlockingQueue中 //当BlockingQueue中的任务放满了，将会创建新的线程去执行， //但是当总线程数大于mMaximumPoolSize时，将会抛出异常，交给RejectedExecutionHandler处理 //mKeepAliveTime是线程执行完任务后，且队列中没有可以执行的任务，存活的时间，后面的参数是时间单位 //ThreadFactory是每次创建新的线程工厂 mPool = new ThreadPoolExecutor(mCorePoolSize, mMaximumPoolSize, mKeepAliveTime, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), Executors.defaultThreadFactory(), new AbortPolicy()); &#125; mPool.execute(run); &#125; /** 取消线程池中某个还未执行的任务 */ public synchronized void cancel(Runnable run) &#123; if (mPool != null &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123; mPool.getQueue().remove(run); &#125; &#125; /** 取消线程池中某个还未执行的任务 */ public synchronized boolean contains(Runnable run) &#123; if (mPool != null &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123; return mPool.getQueue().contains(run); &#125; else &#123; return false; &#125; &#125; /** 立刻关闭线程池，并且正在执行的任务也将会被中断 */ public void stop() &#123; if (mPool != null &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123; mPool.shutdownNow(); &#125; &#125; /** 平缓关闭单任务线程池，但是会确保所有已经加入的任务都将会被执行完毕才关闭 */ public synchronized void shutdown() &#123; if (mPool != null &amp;&amp; (!mPool.isShutdown() || mPool.isTerminating())) &#123; mPool.shutdownNow(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程锁技术]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E7%BA%BF%E7%A8%8B%E9%94%81%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[笔记摘要这里介绍了java5中的线程锁技术：Lock和Condition，实现线程间的通信，其中的读锁和写锁的使用通过一个缓存系统进行了演示，对于Condition的应用通过一个阻塞队列进行演示。 线程锁技术：Lock &amp; Condition 实现线程同步通信所属包：java.util.concurrent.locks 线程锁 说明 Synchronized 同步方法，锁对象是this；静态同步方法，锁对象是字节码.class；同步代码块，锁对象是任意对象，但必须是同一个对象 Lock 同步锁接口 ReentrantLock lock()，unlock()，newCondition() ReadWriteLock 读写锁接口 ReentrantReadWriteLock readLock()获取读锁，writeLock()获取写锁 Condition 线程间通信 await()等待 signal()唤醒 1. LockLock比传统线程模型中的synchronized方式更加面向对象，相对于synchronized 方法和语句它具有更广泛的锁定操作，此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的 Condition 对象。 于现实生活中类似，锁本身也是一个对象。两个线程执行的代码片段要实现同步互斥的结果，它们必须用同一个Lock对象，锁是上在代表要操作的资源的类的内部方法中，而不是线程代码中。 读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，写锁与写锁互斥，这是由JVM自己控制的。你只要上好相应的锁即可。如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁；如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！ 读写锁的使用情景： 如果代码只读数据，就可以很多人共同读取，但不能同时写。 如果代码修改数据，只能有一个人在写，且不能同时读数据。 API中ReentrantReadWriteLock类提供的一个读写锁缓存示例： 12345678910111213141516171819202122232425262728293031323334353637class CachedData &#123; Object data; volatile boolean cacheValid; ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); void processCachedData() &#123; rwl.readLock().lock(); if (!cacheValid) &#123; // Must release read lock before acquiring write lock rwl.readLock().unlock(); rwl.writeLock().lock(); // Recheck state because another thread might have acquired // write lock and changed state before we did. if (!cacheValid) &#123; data = ... cacheValid = true; &#125; // Downgrade by acquiring read lock before releasing write lock rwl.readLock().lock(); rwl.writeLock().unlock(); // Unlock write, still hold read &#125; use(data); rwl.readLock().unlock(); &#125; &#125; 读写锁的应用：编写一个缓存系统 注解：为了避免线程的安全问题，synchronized和ReadWriteLock都可以，synchronized也防止了并发读取，性能较低有一个线程先进去，开始读取数据，进行判断，发现没有数据，其他线程就没有必要进去了，就释放读锁，加上写锁，去查找数据写入，为了避免写入的其他对象等待，再做一次判断，数据写入完成后，释放写锁，上读锁，防止写入，还原原来的状态。 两次判断：第一次为了写入数据，所以释放读锁，上写锁。第二次为了防止阻塞的线程重复写入 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.HashMap; import java.util.Map; import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class CacheDemo &#123; //定义一个map用于缓存对象 private Map&lt;String, Object&gt; cache = new HashMap&lt;String, Object&gt;(); //获取一个读写锁对象 private ReadWriteLock rwl = new ReentrantReadWriteLock(); //带有缓存的获取指定值的方法 public Object getData(String key)&#123; rwl.readLock().lock(); //上读锁 Object value = null; try&#123; value = cache.get(key); //获取要查询的值 if(value == null)&#123; //线程出现安全问题的地方 rwl.readLock().unlock(); //没有数据，释放读锁，上写锁 // 多个线程去上写锁，第一个上成功后，其他线程阻塞，第一个线程开始执行下面的代码，最后 // 释放写锁后，后面的线程继续上写锁，为了避免后面的线程重复写入，进行二次判断 rwl.writeLock().lock(); try&#123; if(value==null)&#123; //二次判断，防止其他线程重复写数据 value = "aaaa"; //实际是去查询数据库 &#125; &#125;finally&#123; rwl.writeLock().unlock(); //写完数据，释放写锁 &#125; rwl.readLock().lock(); //恢复读锁 &#125; &#125;finally&#123; rwl.readLock().unlock(); //最终释放读锁 &#125; return value; //返回获取到的值 &#125; &#125; 虚假唤醒：用while代替if 1234567Lock lock = new ReentrantLock();try &#123; lock.lock(); //需要加锁的代码&#125;finally &#123; lock.unlock();&#125; 读写锁测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; final Queue3 q3 = new Queue3(); for(int i=0;i&lt;3;i++) &#123; new Thread()&#123; public void run()&#123; while(true)&#123; q3.get(); &#125; &#125; &#125;.start(); new Thread()&#123; public void run()&#123; while(true)&#123; q3.put(new Random().nextInt(10000)); &#125; &#125; &#125;.start(); &#125; &#125;&#125;class Queue3&#123; private Object data = null;ReadWriteLock rwl = new ReentrantReadWriteLock(); public void get()&#123; rwl.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + " be ready to read data!"); Thread.sleep((long)(Math.random()*1000)); System.out.println(Thread.currentThread().getName() + "have read data :" + data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; rwl.readLock().unlock(); &#125; &#125; public void put(Object data)&#123; rwl.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName() + " be ready to write data!"); Thread.sleep((long)(Math.random()*1000)); this.data = data; System.out.println(Thread.currentThread().getName() + " have write data: " + data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; rwl.writeLock().unlock(); &#125; &#125;&#125; 123456789101112131415161718Thread-0 be ready to read data!Thread-2 be ready to read data!Thread-4 be ready to read data!Thread-0have read data :nullThread-2have read data :nullThread-4have read data :nullThread-5 be ready to write data!Thread-5 have write data: 7975Thread-5 be ready to write data!Thread-5 have write data: 9832Thread-3 be ready to write data!Thread-3 have write data: 2813Thread-3 be ready to write data!Thread-3 have write data: 7998Thread-1 be ready to write data!Thread-1 have write data: 6737Thread-1 be ready to write data!... 2. ConditionCondition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法wait和notify的使用 一个锁内部可以有多个Condition，即有多路等待通知，传统的线程机制中一个监视器对象上只能有一路等待和通知，要想实现多路等待和通知，必须嵌套使用多个同步监视器对象。使用一个监视器往往会产生顾此失彼的情况。 在等待 Condition 时，允许发生“虚假唤醒”，这通常作为对基础平台语义的让步。对于大多数应用程序，这带来的实际影响很小，因为 Condition 应该总是在一个循环中被等待，并测试正被等待的状态声明。某个实现可以随意移除可能的虚假唤醒，但建议应用程序程序员总是假定这些虚假唤醒可能发生，因此总是在一个循环中等待。 Condition的应用：阻塞队列（使用了两个监视器） 说明：该应用是 java.util.concurrent.locks包中Condition接口中的示例代码。使用了两个Condition分别用于管理取数据的线程，和存数据的线程，这样就可以明确的唤醒需要的一类线程，如果使用一个Condition，当队列满了之后，唤醒的并不一定就是取数据的线程 1234567891011121314151617181920212223242526272829303132333435363738class BoundedBuffer &#123; final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) //循环判断队列是否已存满 notFull.await(); //如果队列存满了，则要存入数据的线程等待 items[putptr] = x; if (++putptr == items.length) putptr = 0;//当队列放满，指针回到0 ++count; //添加了一个数据 notEmpty.signal(); //队列中有数据了，所以就唤醒取数据的线程 &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) //循环判断，队列是否有空位 notEmpty.await(); //要取的线程等待 Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; //取走一个，说明队列有空闲的位置， notFull.signal(); //所以通知存入的线程 return x; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; Condition测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ConditionCommunication &#123; public static void main(String[] args) &#123; final Business business = new Business(); new Thread( new Runnable() &#123; @Override public void run() &#123; for(int i=1;i&lt;=5;i++)&#123; business.sub(i); &#125; &#125; &#125; ).start(); for(int i=1;i&lt;=5;i++)&#123; business.main(i); &#125; &#125; class Business &#123; Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); private boolean bShouldSub = true; public void sub(int i)&#123; lock.lock(); try&#123; while(!bShouldSub)&#123; try &#123; condition.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=2;j++)&#123; System.out.println("sub thread sequence of " + j + ",loop of " + i); &#125; bShouldSub = false; condition.signal(); &#125;finally&#123; lock.unlock(); &#125; &#125; public void main(int i)&#123; lock.lock(); try&#123; while(bShouldSub)&#123; try &#123; condition.await(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=4;j++)&#123; System.out.println("main thread sequence of " + j + ",loop of " + i); &#125; bShouldSub = true; condition.signal(); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125;&#125; 输出结果 123456789101112131415161718192021222324252627282930sub thread sequence of 1,loop of 1sub thread sequence of 2,loop of 1main thread sequence of 1,loop of 1main thread sequence of 2,loop of 1main thread sequence of 3,loop of 1main thread sequence of 4,loop of 1sub thread sequence of 1,loop of 2sub thread sequence of 2,loop of 2main thread sequence of 1,loop of 2main thread sequence of 2,loop of 2main thread sequence of 3,loop of 2main thread sequence of 4,loop of 2sub thread sequence of 1,loop of 3sub thread sequence of 2,loop of 3main thread sequence of 1,loop of 3main thread sequence of 2,loop of 3main thread sequence of 3,loop of 3main thread sequence of 4,loop of 3sub thread sequence of 1,loop of 4sub thread sequence of 2,loop of 4main thread sequence of 1,loop of 4main thread sequence of 2,loop of 4main thread sequence of 3,loop of 4main thread sequence of 4,loop of 4sub thread sequence of 1,loop of 5sub thread sequence of 2,loop of 5main thread sequence of 1,loop of 5main thread sequence of 2,loop of 5main thread sequence of 3,loop of 5main thread sequence of 4,loop of 5 3. Condition练习一共有3个线程，两个子线程先后循环2次，接着主线程循环3次，接着又回到两 个子线程先后循环2次，再回到主线程又循环3次，如此循环5次。 思路：老二先执行，执行完唤醒老三，老三执行完唤醒老大，老大执行完唤醒老二，以此循环，所以定义3个Condition对象和一个执行标识即可 示例出现的问题：两个文件中有同名类的情况 解决方案：可以将一个文件中的那个同名外部类放进类中，但是静态不能创建内部类的实例对象，所以需要加上static，这样两个类的名称就不一样了。 一个是原来的类名，一个是在自己类名前面加上外部类的类名。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class ThreeConditionCommunication &#123; public static void main(String[] args)&#123; final Business business = new Business(); //创建并启动子线程老二 new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=1;i&lt;=5;i++)&#123; business.sub2(i); &#125; &#125; &#125;).start(); //创建并启动子线程老三 new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=1;i&lt;=5;i++)&#123; business.sub3(i); &#125; &#125; &#125;).start(); //主线程 for(int i=1;i&lt;=5;i++)&#123; business.main(i); &#125; &#125; static class Business&#123; Lock lock = new ReentrantLock(); Condition condition1 = lock.newCondition(); Condition condition2 = lock.newCondition(); Condition condition3 = lock.newCondition(); //定义一个变量来决定线程的执行权 private int ShouldSub = 1; public void sub2(int i)&#123; //上锁，不让其他线程执行 lock.lock(); try&#123; if(ShouldSub != 2)&#123; //如果不该老二执行，就等待 try &#123; condition2.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=2;j++)&#123; System.out.println("sub thread sequence of"+i+",loop of "+j); &#125; ShouldSub = 3; //准备让老三执行 condition3.signal(); //唤醒老三 &#125;finally&#123; lock.unlock(); &#125; &#125; public void sub3(int i)&#123; lock.lock(); try&#123; if(ShouldSub != 3)&#123; try &#123; condition3.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=2;j++)&#123; System.out.println("sub2 thread sequence of"+i+",loop of "+j); &#125; ShouldSub = 1; //准备让老大执行 condition1.signal(); //唤醒老大 &#125;finally&#123; lock.unlock(); &#125; &#125; //主线程 public void main(int i)&#123; lock.lock(); try&#123; if(ShouldSub!=1)&#123; try &#123; condition1.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=3;j++)&#123; System.out.println("main thread sequence of"+i+", loop of "+j); &#125; ShouldSub = 2; //准备让老二执行 condition2.signal(); //唤醒老二 &#125;finally&#123; lock.unlock(); &#125; &#125; &#125; &#125; 输出结果1234567891011121314151617181920212223242526272829303132333435main thread sequence of1, loop of 1main thread sequence of1, loop of 2main thread sequence of1, loop of 3sub thread sequence of1,loop of 1sub thread sequence of1,loop of 2sub2 thread sequence of1,loop of 1sub2 thread sequence of1,loop of 2main thread sequence of2, loop of 1main thread sequence of2, loop of 2main thread sequence of2, loop of 3sub thread sequence of2,loop of 1sub thread sequence of2,loop of 2sub2 thread sequence of2,loop of 1sub2 thread sequence of2,loop of 2main thread sequence of3, loop of 1main thread sequence of3, loop of 2main thread sequence of3, loop of 3sub thread sequence of3,loop of 1sub thread sequence of3,loop of 2sub2 thread sequence of3,loop of 1sub2 thread sequence of3,loop of 2main thread sequence of4, loop of 1main thread sequence of4, loop of 2main thread sequence of4, loop of 3sub thread sequence of4,loop of 1sub thread sequence of4,loop of 2sub2 thread sequence of4,loop of 1sub2 thread sequence of4,loop of 2main thread sequence of5, loop of 1main thread sequence of5, loop of 2main thread sequence of5, loop of 3sub thread sequence of5,loop of 1sub thread sequence of5,loop of 2sub2 thread sequence of5,loop of 1sub2 thread sequence of5,loop of 2 多路等待和通知12345678910111213141516171819202122232425262728293031323334353637class BoundedBuffer &#123; final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) notEmpty.await(); Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; notFull.signal(); return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 多线程概述1.1 多线程引入 由上图中程序的调用流程可知，这个程序只有一个执行流程，所以这样的程序就是单线程程序。假如一个程序有多条执行流程，那么，该程序就是多线程程序。 1.2 多线程概述1.2.1 什么是进程？进程就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。 1.2.2 多进程有什么意义呢?单进程的计算机只能做一件事情，而我们现在的计算机都可以做多件事情。举例：一边玩游戏(游戏进程)，一边听音乐(音乐进程)。也就是说现在的计算机都是支持多进程的，可以在一个时间段内执行多个任务。并且呢，可以提高CPU的使用率，解决了多部分代码同时运行的问题。 其实，多个应用程序同时执行都是CPU在做着快速的切换完成的。这个切换是随机的。CPU的切换是需要花费时间的，从而导致了效率的降低。 1.2.3 什么是线程?线程是程序的执行单元，执行路径；是进程中的单个顺序控制流，是一条执行路径；一个进程如果只有一条执行路径，则称为单线程程序。一个进程如果有多条执行路径，则称为多线程程序。 1.2.4 多线程有什么意义呢?多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。程序的执行其实都是在抢CPU的资源，CPU的执行权。多个进程是在抢这个资源，而其中的某一个进程如果执行路径比较多，就会有更高的几率抢到CPU的执行权。我们是不敢保证哪一个线程能够在哪个时刻抢到，所以线程的执行有随机性。 1.2.5 什么是并行、并发呢？前者是逻辑上同时发生，指在某一个时间内同时运行多个程序；后者是物理上同时发生，指在某一个时间点同时运行多个程序。那么，我们能不能实现真正意义上的并发呢？答案是可以的，多个CPU就可以实现，不过你得知道如何调度和控制它们。 PS： 一个进程中可以有多个执行路径，称之为多线程。 一个进程中至少要有一个线程。 开启多个线程是为了同时运行多部分代码，每一个线程都有自己运行的内容，这个内容可以称为线程要执行的任务。 1.3 Java程序运行原理java 命令会启动 java 虚拟机，启动 JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。所以 main方法运行在主线程中。在此之前的所有程序都是单线程的。 思考：JVM虚拟机的启动是单线程的还是多线程的？ 答案：JVM启动时启动了多条线程，至少有两个线程可以分析的出来 执行main函数的线程，该线程的任务代码都定义在main函数中。 负责垃圾回收的线程。System类的gc方法告诉垃圾回收器调用finalize方法，但不一定立即执行。 2. 多线程的实现方案由于线程是依赖进程而存在的，所以我们应该先创建一个进程出来。而进程是由系统创建的，所以我们应该去调用系统功能创建一个进程。Java是不能直接调用系统功能的，所以，我们没有办法直接实现多线程程序。但是呢?Java可以去调用C/C++写好的程序来实现多线程程序。由C/C++去调用系统功能创建进程，然后由Java去调用这样的东西，然后提供一些类供我们使用。我们就可以实现多线程程序了。 2.1 多线程的实现方案一：继承Thread类，重写run()方法 定义一个类继承Thread类 覆盖Thread类中的run方法 直接创建Thread的子类对象创建线程 调用start方法开启线程并调用线程的任务run方法执行 12345678910111213141516171819202122232425262728293031323334package cn.itcast;//多线程的实现方案一：继承Thread类，重写run()方法//1、定义一个类继承Thread类。class MyThread extends Thread &#123; private String name; MyThread(String name) &#123; this.name = name; &#125; // 2、覆盖Thread类中的run方法。 public void run() &#123; for (int x = 0; x &lt; 5; x++) &#123; System.out.println(name + "...x=" + x + "...ThreadName=" + Thread.currentThread().getName()); &#125; &#125;&#125;class ThreadTest &#123; public static void main(String[] args) &#123; // 3、直接创建Thread的子类对象创建线程。 MyThread d1 = new MyThread("黑马程序员"); MyThread d2 = new MyThread("中关村在线"); // 4、调用start方法开启线程并调用线程的任务run方法执行。 d1.start(); d2.start(); for (int x = 0; x &lt; 5; x++) &#123; System.out.println("x = " + x + "...over..." + Thread.currentThread().getName()); &#125; &#125;&#125; 运行结果： 123456789101112131415黑马程序员...x=0...ThreadName=Thread-0中关村在线...x=0...ThreadName=Thread-1x = 0...over...main中关村在线...x=1...ThreadName=Thread-1黑马程序员...x=1...ThreadName=Thread-0中关村在线...x=2...ThreadName=Thread-1x = 1...over...main中关村在线...x=3...ThreadName=Thread-1黑马程序员...x=2...ThreadName=Thread-0中关村在线...x=4...ThreadName=Thread-1x = 2...over...mainx = 3...over...mainx = 4...over...main黑马程序员...x=3...ThreadName=Thread-0黑马程序员...x=4...ThreadName=Thread-0 2.1.2 为什么要重写run()方法？Thread类用于描述线程，线程是需要任务的。所以Thread类也有对任务的描述。这个任务就是通过Thread类中的run方法来体现。也就是说，run方法就是封装自定义线程运行任务的函数，run方法中定义的就是线程要运行的任务代码。所以只有继承Thread类，并复写run方法，将运行的代码定义在run方法中即可。 2.1.3 启动线程使用的是那个方法启动线程调用的是start()方法，不是run()方法，run()方法只是封装了被线程执行的代码，调用run()只是普通方法的调用，无法启动线程。 2.1.4 线程能不能多次启动不能，会出现IllegalThreadStateException非法的线程状态异常。 2.1.5 run()和start()方法的区别 run()：仅仅是封装了被线程执行的代码，直接调用就是普通方法 start()：首先是启动了线程，然后再由jvm去调用了该线程的run()方法 2.1.6 Thread类的基本获取和设置方法 public final String getName()：获取线程的名称 public final void setName(String name)：设置线程的名称 Thread(String name) ：通过构造方法给线程起名字 思考：如何获取main方法所在的线程名称呢? 1public static Thread currentThread() // 获取任意方法所在的线程名称 2.2 多线程的实现方案二：实现Runnable接口 定义类实现Runnable接口 覆盖接口中的run方法，将线程的任务代码封装到run方法中 通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。为什么？因为线程的任务都封装在Runnable接口子类对象的run方法中。所以要在线程对象创建时就必须明确要运行的任务 调用线程对象的start方法开启线程 12345678910111213141516171819202122232425262728package cn.itcast;//多线程的实现方案二：实现Runnable接口//1、定义类实现Runnable接口。class MyThread implements Runnable &#123; // 2、覆盖接口中的run方法，将线程的任务代码封装到run方法中。 public void run() &#123; show(); &#125; public void show() &#123; for (int x = 0; x &lt; 5; x++) &#123; System.out.println(Thread.currentThread().getName() + "..." + x); &#125; &#125;&#125;class ThreadTest &#123; public static void main(String[] args) &#123; MyThread d = new MyThread(); // 3、通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。 Thread t1 = new Thread(d); Thread t2 = new Thread(d); // 4、调用线程对象的start方法开启线程。 t1.start(); t2.start(); &#125;&#125; 运行结果： 12345678910Thread-0...0Thread-1...0Thread-0...1Thread-1...1Thread-0...2Thread-1...2Thread-0...3Thread-1...3Thread-0...4Thread-1...4 如何获取线程名称：Thread.currentThread().getName() 如何给线程设置名称：setName()、Thread(Runnable target, String name) 实现接口方式的好处： 可以避免由于Java单继承带来的局限性，所以，创建线程的第二种方式较为常用。 适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。 2.3 多线程程序实现方案三：实现Callable接口 创建一个线程池对象，控制要创建几个线程对象。 1public static ExecutorService newFixedThreadPool(int nThreads) 这种线程池的线程可以执行：可以执行Runnable对象或者Callable对象代表的线程。 调用如下方法即可 Future&lt;?&gt; submit(Runnable task)提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future Future submit(Callable task)提交一个Callable任务用于执行，返回一个表示任务的未决结果的 Future 结束线程：shutdown() 关闭线程池 123456789101112131415161718192021222324252627282930313233343536373839package cn.itcast;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Callable;//Callable:是带泛型的接口。//这里指定的泛型其实是call()方法的返回值类型。class MyCallable implements Callable &#123; public Object call() throws Exception &#123; for (int x = 0; x &lt; 100; x++) &#123; System.out.println(Thread.currentThread().getName() + ":" + x); &#125; return null; &#125;&#125;/* * 多线程实现的方式3： A:创建一个线程池对象，控制要创建几个线程对象。 public static ExecutorService * newFixedThreadPool(int nThreads) B:这种线程池的线程可以执行： * 可以执行Runnable对象或者Callable对象代表的线程 做一个类实现Runnable接口。 C:调用如下方法即可 Future&lt;?&gt; * submit(Runnable task) &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) D:我就要结束，可以吗? 可以。 */public class CallableDemo &#123; public static void main(String[] args) &#123; // 创建线程池对象 ExecutorService pool = Executors.newFixedThreadPool(2); // 可以执行Runnable对象或者Callable对象代表的线程 pool.submit(new MyCallable()); pool.submit(new MyCallable()); // 结束 pool.shutdown(); &#125;&#125; 运行结果： 实现Callable的优缺点 好处：可以有返回值；可以抛出异常。 弊端：代码比较复杂，所以一般不用 2.4 匿名内部类方式使用多线程12345678910111213141516//新创建一个线程，重写run()方法new Thread() &#123; @Override public void run() &#123; super.run(); // code &#125;&#125;.start();//新创建一个线程，传递一个Runnable对象new Thread(new Runnable() &#123; @Override public void run() &#123; // code &#125;&#125;).start(); 3. 线程调度和线程控制3.1 线程调度假如我们的计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到 CPU时间片，也就是使用权，才可以执行指令。那么Java是如何对线程进行调用的呢？ 3.1.1 线程有两种调度模型分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 Java使用的是抢占式调度模型。 3.1.2 如何设置和获取线程优先级12public final int getPriority(); //获取线程的优先级public final void setPriority(int newPriority); //设置线程的优先级 注意：线程默认的优先级是5；线程优先级的范围是：1-10；线程优先级高仅仅表示线程获取CPU的时间片的几率高，但是要在次数比较多，或者多次运行的时候才能卡到比较好的结果。 3.2 线程控制 方法声明 功能描述 sleep(long millis) 线程休眠，让当前线程暂停，进入休眠等待状态 join() 线程加入，调用该方法的线程会插入优先先执行 yield() 线程礼让，暂停当前正在执行的线程对象，并执行其他线程。 setDaemon(boolean on) 将该线程标记为守护线程（后台线程）或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 stop() 让线程停止，过时了，但是还可以使用 interrupt() 中断线程。 把线程的状态终止，并抛出一个InterruptedException。 setPriority(int newPriority) 更改线程的优先级 isInterrupted() 线程是否被中断 4. 线程的生命周期4.1 线程的状态 线程状态 状态说明 新建状态 等待状态，调用start()方法启动 就绪状态 有执行资格，但是没有执行权 运行状态 具有执行资格和执行权 阻塞状态 遇到sleep()方法和wait()方法时，失去执行资格和执行权，sleep()方法时间到或者调用notify()方法时，获取执行资格，变为临时状态 死亡状态 中断线程，或者run()方法结束 4.2 线程的生命周期图 5. 线程安全问题5.1 判断一个程序是否会有线程安全问题的标准 是否是多线程环境 是否有共享数据 是否有多条语句操作共享数据 5.2 如何解决多线程安全问题呢?基本思想：让程序没有安全问题的环境。解决办法：同步机制：同步代码块、同步方法。把多个语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可。 5.2.1 解决线程安全问题实现1：同步代码块，格式如下123synchronized(对象)&#123; 需要同步的代码;&#125; 123456789101112131415161718192021222324252627282930313233343536package cn.itcast;//卖票程序的同步代码块实现示例class Ticket implements Runnable &#123; private int num = 10; Object obj = new Object(); public void run() &#123; while (true) &#123; // 给可能出现问题的代码加锁 synchronized (obj) &#123; if (num &gt; 0) &#123; // 显示线程名及余票数 System.out.println(Thread.currentThread().getName() + "...sale..." + num--); &#125; &#125; &#125; &#125;&#125;class TicketDemo &#123; public static void main(String[] args) &#123; // 通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。 Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); // 调用线程对象的start方法开启线程。 t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 运行结果： 12345678910Thread-0...sale...10Thread-0...sale...9Thread-0...sale...8Thread-0...sale...7Thread-0...sale...6Thread-0...sale...5Thread-0...sale...4Thread-0...sale...3Thread-0...sale...2Thread-0...sale...1 同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。 同步代码块的对象可以是哪些呢? 可以是任意对象，但每个线程都必须是同一对象。 同步的前提：多个线程；多个线程使用的是同一个锁对象 同步的好处：同步的出现解决了多线程的安全问题。 同步的弊端：当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。 5.3 解决线程安全问题实现2：同步方法同步方法：就是把同步关键字加到方法上 12345678910111213141516171819202122232425262728293031323334353637383940414243package cn.itcast;//卖票程序的同步代码块实现示例class Ticket implements Runnable &#123; // 定义100张票 private static int tickets = 10; Object obj = new Object(); public void run() &#123; while (true) &#123; sellTicket(); &#125; &#125; private synchronized void sellTicket() &#123; if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票 "); &#125; &#125;&#125;class TicketDemo &#123; public static void main(String[] args) &#123; // 通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递。 Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); // 调用线程对象的start方法开启线程。 t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 运行结果： 12345678910Thread-0正在出售第10张票 Thread-0正在出售第9张票 Thread-0正在出售第8张票 Thread-3正在出售第7张票 Thread-3正在出售第6张票 Thread-3正在出售第5张票 Thread-3正在出售第4张票 Thread-3正在出售第3张票 Thread-3正在出售第2张票 Thread-3正在出售第1张票 PS： 同步方法的锁对象是什么呢?this对象 如果是静态方法，同步方法的锁对象又是什么呢?该类的字节码文件（类的class文件） 那么，我们到底使用同步方法还是同步代码块？ 如果锁对象是this，就可以考虑使用同步方法。否则能使用同步代码块的尽量使用同步代码块。 5.3.1 线程安全与非线程安全的类某些线程安全的类：StringBuffer、Vector、HashTable，虽然线程安全，但是效率较低，我们一般不用，而用Collections工具类解决线程安全的问题。 1List&lt;String&gt; list = Colletions.syncrinizedList(new ArrayList&lt;String&gt;()); // 获取线程安全的List集合 5.3.2 JDK5中Lock锁的使用虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock Lock接口：Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作，此实现允许更灵活的结构。 void lock()：获取锁 void unlock()：释放锁 ReentrantLock：Lock的实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.itcast;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class SellTicket implements Runnable &#123; // 定义票 private int tickets = 100; // 定义锁对象 private Lock lock = new ReentrantLock(); public void run() &#123; while (true) &#123; try &#123; // 加锁 lock.lock(); if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "正在出售第" + (tickets--) + "张票"); &#125; &#125; finally &#123; // 释放锁 lock.unlock(); &#125; &#125; &#125;&#125;/* * 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁， * 为了更清晰的表达如何加锁和释放锁,JDK5以后提供了一个新的锁对象Lock。 * * Lock： void lock()： 获取锁。 void unlock():释放锁。 ReentrantLock是Lock的实现类. */public class SellTicketDemo &#123; public static void main(String[] args) &#123; // 创建资源对象 SellTicket st = new SellTicket(); // 创建三个窗口 Thread t1 = new Thread(st, "窗口1"); Thread t2 = new Thread(st, "窗口2"); Thread t3 = new Thread(st, "窗口3"); // 启动线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果： 12345678910111213141516...窗口2正在出售第15张票窗口2正在出售第14张票窗口2正在出售第13张票窗口2正在出售第12张票窗口2正在出售第11张票窗口3正在出售第10张票窗口3正在出售第9张票窗口3正在出售第8张票窗口3正在出售第7张票窗口3正在出售第6张票窗口3正在出售第5张票窗口3正在出售第4张票窗口3正在出售第3张票窗口1正在出售第2张票窗口2正在出售第1张票 6. 死锁同步弊端：效率低，如果出现了同步嵌套，就容易产生死锁问题。死锁问题：是指两个或者两个以上的线程在执行的过程中，因争夺资源产生的一种互相等待现象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.itcast;class Ticket implements Runnable &#123; private static int num = 100; Object obj = new Object(); boolean flag = true; public void run() &#123; if (flag) &#123; while (true) &#123; synchronized (obj) &#123; show(); &#125; &#125; &#125; else while (true) show(); &#125; public synchronized void show() &#123; synchronized (obj) &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "...function..." + num--); &#125; &#125; &#125;&#125;class DeadLockDemo &#123; public static void main(String[] args) &#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t.flag = false; t2.start(); &#125;&#125; 运行结果： 原因分析： 由上图可以看到程序已经被锁死，无法向下执行。run方法中的同步代码块需要获取obj对象锁，才能执行代码块中的show方法。而执行show方法则必须获取this对象锁，然后才能执行其中的同步代码块。当线程t1获取到obj对象锁执行同步代码块，线程t2获取到this对象锁执行show方法。同步代码块中的show方法因无法获取到this对象锁无法执行，show方法中的同步代码块因无法获取到obj对象锁无法执行，就会产生死锁。 7. 线程间通信多个线程在处理统一资源，但是任务却不同，这时候就需要线程间通信。为了实现线程间的通信Java提供了等待唤醒机制。等待/唤醒机制涉及的方法： wait()：让线程处于冻结状态，被wait的线程会被存储到线程池中。 notify()：唤醒线程池中的一个线程（任何一个都有可能）。 notifyAll()：唤醒线程池中的所有线程。 PS： 这些方法都必须定义在同步中，因为这些方法是用于操作线程状态的方法。 必须要明确到底操作的是哪个锁上的线程！ wait和sleep区别？ 4、为什么操作线程的方法wait、notify、notifyAll定义在了object类中，因为这些方法是监视器的方法，监视器其实就是锁。锁可以是任意的对象，任意的对象调用的方式一定在object类中。 5、生产者-消费者问题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package cn.itcast;class Student &#123; String name; int age; boolean flag;&#125;class SetThread implements Runnable &#123; private Student s; private int x = 0; public SetThread(Student s) &#123; this.s = s; &#125; public void run() &#123; while (true) &#123; synchronized (s) &#123; // 判断有没有 if (s.flag) &#123; try &#123; s.wait(); // t1等着，释放锁 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (x % 2 == 0) &#123; s.name = "张三"; s.age = 15; &#125; else &#123; s.name = "李四"; s.age = 16; &#125; x++; // x=1 // 修改标记 s.flag = true; // 唤醒线程 s.notify(); // 唤醒t2,唤醒并不表示你立马可以执行，必须还得抢CPU的执行权。 &#125; // t1有，或者t2有 &#125; &#125;&#125;class GetThread implements Runnable &#123; private Student s; public GetThread(Student s) &#123; this.s = s; &#125; public void run() &#123; while (true) &#123; synchronized (s) &#123; if (!s.flag) &#123; try &#123; s.wait(); // t2就等待了。立即释放锁。将来醒过来的时候，是从这里醒过来的时候 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(s.name + "---" + s.age); // 林青霞---27 // 刘意---30 // 修改标记 s.flag = false; // 唤醒线程 s.notify(); // 唤醒t1 &#125; &#125; &#125;&#125;public class StudentDemo &#123; public static void main(String[] args) &#123; // 创建资源 Student s = new Student(); // 设置和获取的类 SetThread st = new SetThread(s); GetThread gt = new GetThread(s); // 线程类 Thread t1 = new Thread(st); Thread t2 = new Thread(gt); // 启动线程 t1.start(); t2.start(); &#125;&#125; 运行结果： 8. 线程组 Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。默认情况下，所有的线程都属于主线程组。 123public final ThreadGroup getThreadGroup() //返回该线程所属的线程组。Thread(ThreadGroup group,Runnable target, String name) // 给线程设置分组 9. 线程池程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。 线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。 在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池。JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法 返回值 方法声明 功能描述 ExecutorService newCachedThreadPool() 创建一个可缓存的线程池对象 ExecutorService newFixedThreadPool(int) 创建一个固定大小的线程池对象 ExecutorService newSingleThreadExecutor() 创建一个单线程的线程池对象 ExecutorService newScheduledThreadPool() 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法： Future&lt;?&gt; submit(Runnable task) 提交一个Runnable任务用于执行，并返回一个表示该任务的 Future &lt;T&gt;Future&lt;T&gt; submit(Callable&lt;T&gt; task) 提交一个Callable任务用于执行，返回一个表示任务的未决结果的Future 10. 定时器的使用定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行。在Java中，可以通过Timer和TimerTask类来实现定义调度的功能 Timer定时类一种工具，线程用其安排以后在后台线程中执行的任务。可安排任务执行一次，或者定期重复执行 方法声明 功能描述 public Timer() 构造方法 public void schedule(TimerTask task, long delay) 安排在指定延迟后执行指定的任务 public void schedule(TimerTask task,long delay,long period) 安排指定的任务从指定的延迟后开始进行重复的固定延迟执行 TimerTask任务类，有Timer安排为一次执行或重复执行的任务 方法声明 功能描述 public abstract void run() 此计时器任务要执行的操作 public boolean cancel() 取消此计时器任务 实际开发中使用的是Quartz：一个完全由java编写的开源调度框架。 11. 多线程总结11.1 三种多选实现方案 继承Thread类，重写run()方法。 实现Runnable接口，new Thread(new Runnable(){…}){…}; 实现Callable接口。和线程池结合。 11.2 实现Runnable好处 将线程的任务从线程的子类中分离出来，进行了单独的封装，实现数据和程序分离，按照面向对象的思想将任务封装成对象 避免了Java单继承的局限性。所以，创建线程的第二种方式较为常用 11.3 线程间的通信 多个线程在处理同一资源，但是任务却不同，这时候就需要线程间通信。 等待/唤醒机制涉及的方法 wait()：让线程处于冻结状态，被wait的线程会被存储到线程池中。 notify()：唤醒线程池中的一个线程（任何一个都有可能）。 notifyAll()：唤醒线程池中的所有线程。 11.4 wait、sleep区别 wait可以指定时间也可以不指定。sleep必须指定时间。 在同步中时，对CPU的执行权和锁的处理不同。 wait：释放CPU执行权，释放锁。Object中的方法。 sleep：释放CPU执行权，不释放锁。Thread中的方法。 sleep必需捕获异常，wait，notify，notifyAll不需要捕获异常 11.5 常用方法 方法声明 功能描述 String getName() 获取线程的名称 void setName(String name) 设置线程的名称 static Thread currentThread() 获取当前正在执行的线程 int getPriority() 获取线程优先级 void setPriority(int newPriority) 设置线程优先级（1-10） static void sleep(long millis) 线程休眠 void join() 线程加入，该线程执行完毕其他线程才可以执行 static void yield() 线程礼让 setDaemon(boolean on) 后台线程/守护线程 void stop( ) 已过时，不建议使用 interrupt( ) 中断线程 isInterrupted() 线程是否被中断 11.6 线程的生命周期 新建，就绪，运行，阻塞（同步阻塞，等待阻塞，其他阻塞），死亡]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时器、互斥、同步通信技术]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E5%AE%9A%E6%97%B6%E5%99%A8%E3%80%81%E4%BA%92%E6%96%A5%E3%80%81%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[笔记摘要这里分析了多线程的一些细节问题，并介绍了传统定时器的创建，同时实现了根据自己的调度计划的自定义定时器，对于传统互斥技术中发现的内部类问题，进行了分析，最后对于同步通信技术，是重点，分析了如何处理类似的问题，如何设计能够更加清晰简单，体现了高内聚和程序的健壮性 1. 多线程的几个知识点1.1 为何使用实现Runnable的方式创建线程更普遍？new Runnable()的方式，更加体现面向对象的思想 通过 new Thread()创建一个线程，代码封装在runnable对象中，代码和线程独立分开来，但最终将它们组合在一起。 1234567Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; // code &#125;&#125;); 1.2 获取线程名的时候，应使用currentThread().getName()方式因为this.getName()方式，只有在当前对象是Thread的时候可以，当我们使用runnable方式时，this代表的是runnable对象，它仅是要运行代码的宿主，而不是线程，当然编译也无法通过（没有此方法）。 1.3 创建线程的两种传统方式的run方法执行问题查看Thread类的run()方法的源代码，可以看到其实这两种方式都是在调用Thread对象的run()方法，如果Thread类的run()方法没有被覆盖，并且为该Thread对象设置了一个Runnable对象，该run方法会调用Runnable对象的run()方法。 下面是Thread类的run()方法的源码，可以看到runnable对象也是调用了Thread的run()方法。 当runnable对象不为null，并且有自己的run()方法，则执行自己的，如果target为null，则Thread类的run()方法什么也不执行，所以我们在创建线程的时候不直接创建Thread对象，而是创建其子类对象，目的是为了复写run方法，把要执行的代码放进去，否则该线程没有意义 123456Private Runnable target; public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 1.4 多线程的运行问题1：如果在Thread子类覆盖的run()方法中编写了运行代码，也为Thread子类对象传递了一个Runnable对象，那么，线程运行时的执行代码？ 是子类的run方法的代码？还是Runnable对象的run()方法的代码？如： 123456789101112// 匿名内部类的方式实现的一个子类，并在构造方法中传入了一个Runnable对象new Thread(new Runnable() &#123; public void run() &#123; // code &#125;&#125;) &#123; @Override public void run() &#123; super.run(); // code &#125;&#125;.start(); 会运行子类的run方法。因为当某个对象调用start方法之后，就会去找自己对象的run方法，如果没有就会找父类的run方法，父类的run方法会找runnable运行。 其实就是多态的一种体现，覆盖了父类的就执行自己的，没有覆盖就去找父类的执行 问题2：多线程机制是否会提高程序的运行效率？ 多线程机制并不会提高程序的运行效率，反而性能更低，因为CPU需要在不同线程之间频繁切换。 1.5 多线程下载的误解？多线程下载其实是抢了服务器的带宽，一个线程代表一个用户，每个线程分配的带宽是相等的，开启的线程多，就会分配更多的带宽，是在抢资源，而不是自己更快。 2. 传统定时器：Timer类定时器有两种：一种在指定时间只执行一次，另一种先在指定时间执行一次，之后每隔指定时间循环执行。 该示例说明了定时器的创建方式，并通过自定义定时器的方式，在一个定时器内部通过不同切换秒数，来实现在不同的间隔时间实现循环爆炸，另外还通过两个类之间的互相实现相同的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Date; import java.util.Timer; import java.util.TimerTask; public class TraditionalTimerTest &#123; private static int count = 0; public static void main(String[] args) &#123; //创建一个定时器并调度任务 /* new Timer().schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println("bombing!"); &#125; &#125;, 3000);//3秒以后爆炸 */ //&#125;, 10000,3000); //10秒以后爆炸，以后每隔3秒炸一次 //自定义一个定时器 class MyTimerTask extends TimerTask&#123; @Override public void run() &#123; count = (count+1)%2; //在0和1之间切换 System.out.println("bombing!"); new Timer().schedule(/*new TimerTask() &#123; @Override public void run() &#123; System.out.println("bombing!"); &#125; &#125;*/new MyTimerTask(),2000+2000*count); //实现循环，不能用this，因为是匿名，所以只能执行一次， //就像炸弹一样，炸完后就没有了，必须布置新的炸弹 //所以创建一个类，每次在最后new一个新的炸弹 &#125; &#125; //开启定时器，每隔2秒调用一次MyTimerTask new Timer().schedule(new MyTimerTask(), 2000); //为了观察定时器任务的执行：每隔1秒打印一次当前秒数 while(true)&#123; System.out.println(new Date().getSeconds()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; 使用互相调用的方式实现间隔2秒和4秒的连环爆炸123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Date; import java.util.Timer; import java.util.TimerTask; public class MyTraditionalTimer &#123; public static void main(String[] args)&#123; new Timer().schedule(new MyTimerTask(), 4000); //打印当前秒数 while(true)&#123; System.out.println(new Date().getSeconds()); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; //每隔2秒调用MyTimerTask2 class MyTimerTask extends TimerTask&#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println("boomping!!!"); new Timer().schedule(new MyTimerTask2(),2000); &#125; &#125; //每隔4秒调用MyTimerTask2 class MyTimerTask2 extends TimerTask&#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println("boomping!!!"); new Timer().schedule(new MyTimerTask(), 4000); &#125; &#125; 3. 调度框架：quartsQuartz是一个开源的作业调度框架，它完全由Java写成，并设计用于J2SE和J2EE应用中。它提供了巨大的灵活性而不牺牲简单性。你能够用它来为执行一个作业而创建简单的或复杂的调度。它有很多特征，如：数据库支持，集群，插件，EJB作业预构建，JavaMail及其它，支持cron-like表达式等等。 对于定时器中不能很好实现的需求，我们可以想到quarts,这里并没有介绍其使用方式，以后开发用到，能够记起，去查资料 4. 传统线程互斥技术发现的问题：在主函数内部不能创建内部类的实例对象 内部类的一个重要特点就是可以访问外部类的成员变量，成员变量是对象身上的，对象创建完后，成员变量才分配空间，所以内部类访问外部类的成员变量需要外部类的实例对象。而静态方法先存在，所以不可以。 解决方式： 可以将内部类定义为静态的，或者将创建内部类的实例对象的语句封装在一个外部类的成员方法中，这里定义了一个init方法，因为方法调用需要对象，这个对象就是将来调用该方法的对象 示例说明： 本示例主要是对上面的问题进行了展示，另外对过去的互斥技术中的锁所使用的对象进行了分析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class TraditionalThreadSychronized &#123; public static void main(String[] args) &#123; //无法创建，必须关联一个外部类的实例对象，可以定义一个方法， //或者将外部类定义为静态 //final Outputer outputer = new Outputer(); //编译错误 new TraditionalThreadSychronized().init(); &#125; //方法需要对象调用，所以就关联了一个外部类的对象 private void init() &#123; final Outputer outputer = new Outputer(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; outputer.output("11111"); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // outputer.output("are you happy?"); outputer.output2("22222"); &#125; &#125; &#125;).start(); &#125; static class Outputer &#123; // public void output(String name) &#123; // String lock = ""; int len = name.length(); // synchronized(lock)&#123; 使用同一把锁，任意对象都可以 // synchronized(this)&#123; 同步函数使用的是锁是this，即outputer对象 synchronized (Outputer.class) &#123; // 静态方法的锁只能是class字节码对象 for (int i = 0; i &lt; len; i++) &#123; System.out.print(name.charAt(i)); &#125; System.out.println(); &#125; &#125; // 同步函数使用的是锁是this /* public synchronized void output2(String name)&#123; int len = name.length(); for(int i=0;i&lt;len;i++)&#123; System.out.print(name.charAt(i)); &#125; System.out.println(); &#125; &#125; */ //定义同步的静态方法 public static synchronized void output2(String name) &#123; int len = name.length(); for (int i = 0; i &lt; len; i++) &#123; System.out.print(name.charAt(i)); &#125; System.out.println(); &#125; &#125; &#125; 5. 传统线程同步通信技术这里通过一道面试题进行讲解 需求：子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着再回到主线程又循环100次，如此循环50次 1、思路： 使用面向对象的方式思考，子线程的任务是循环10次，子线程的任务是循环100次，所以可以将它们各自的任务封装起来，在封装内部实现各自的同步（锁是放在代表要操作的资源的类的内部方法中），最后别的对象来调用，循环50次即可 2、Eclipse小技巧： 这里打印结果过长，我们可以使用eclipse将打印结果输出到文件中：Run As → Run Configurations → Common → File前打勾 → 指定路径 3、锁对象的定义 两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个锁对象，锁是放在代表要操作的资源的类的内部方法中，而不是在线程代码中。 4、实现按指定的顺序执行 需要用到wait，Notify，当轮到自己要执行的时候，让对象去唤醒自己，可以定义一个标识，来决定谁可以执行 5、wait方法必须放在synchronized的里面，而且调用它的对象必须和synchronized的对象是同一个。 6、While比if更严谨，因为会循环判断执行条件，所以可以防止伪唤醒，（并不是期望的对象来唤醒自己）。 经验：要用到共同数据（包括同步锁）或共同算法的若干个方法应该归于同一个类上，在这个类的内部去管理各个方法的状态，这种设计正好体现了高类聚和程序的健壮性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class TraditionalThreadCommunication &#123; public static void main(String[] args)&#123; //获取一个业务对象 final Business business = new Business(); //子线程 new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=1;i&lt;=50;i++)&#123; /*for(int j=0;j&lt;10;j++)&#123; System.out.println("sub thread sequence of"+i+",loop of "+j); &#125;*/ business.sub(i); &#125; &#125; &#125;).start(); //主线程 for(int i=1;i&lt;=50;i++)&#123; /* for(int j=0;j&lt;100;j++)&#123; System.out.println("main thread sequence of"+i+", loop of "+j); &#125; */ business.main(i); &#125; &#125; &#125; //定义一个业务类 class Business&#123; //定义一个boolean型变量来决定子线程和主线程的执行权 private boolean bShouldSub = true; //子线程 public synchronized void sub(int i)&#123;//把同步的鎖放在资源身上 //不该子线程执行，等待 if(!bShouldSub)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=10;j++)&#123; System.out.println("sub thread sequence of"+i+",loop of "+j); &#125; bShouldSub = false; this.notify(); //唤醒主线程 &#125; //主线程 public synchronized void main(int i)&#123; //若是子线程执行，主线程等待 if(bShouldSub)&#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; for(int j=1;j&lt;=100;j++)&#123; System.out.println("main thread sequence of"+i+", loop of "+j); &#125; bShouldSub = true; this.notify(); //唤醒子线程 &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个线程之间共享数据的方式探讨]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[内容摘要多个线程之间共享数据，按照每个线程执行代码是否相同，我们可以采取不同的处理方式，这里通过简单的卖票示例说明了当每个线程执行相同代码的情况，对于多个线程执行不同代码的情况，处理方式比较灵活，这里主要介绍了2种方式，通过2种方式的对比和归纳，我们可以总结出在多个线程执行不同的代码情况下，如何进行代码的设计 1. 如果每个线程执行的代码相同可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如：卖票系统 1.1 简单的卖票系统示例12345678910111213141516171819202122232425262728293031323334class Ticket implements Runnable&#123; private int tick = 20; Object obj = new Object(); public void run()&#123; while(true)&#123; synchronized(obj)&#123; if(tick&gt;0)&#123; //只能try，因为run是复写了Runnable接口的run,接口的run没有抛 //try&#123;Thread.sleep(10);&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"....sale : "+ tick--); &#125; &#125; &#125; &#125; &#125; class TicketDemo &#123; public static void main(String[] args) &#123; //只建立了一个Ticket对象，内存中只有一个tick成员变量，所以是共享数据 Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; 1234567891011121314151617181920Thread-0....sale : 20Thread-0....sale : 19Thread-0....sale : 18Thread-0....sale : 17Thread-0....sale : 16Thread-0....sale : 15Thread-0....sale : 14Thread-0....sale : 13Thread-0....sale : 12Thread-3....sale : 11Thread-3....sale : 10Thread-3....sale : 9Thread-3....sale : 8Thread-3....sale : 7Thread-3....sale : 6Thread-3....sale : 5Thread-3....sale : 4Thread-3....sale : 3Thread-3....sale : 2Thread-3....sale : 1 2. 如果每个线程执行的代码不同 这时候不需要用不同的Runnable对象，有如下两种方式来实现这些Runnable对象之间的数据共享。 2.1 方式1将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样容易实现针对该数据进行的各个操作的互斥和通信。 思想：一个类提供数据和操作数据的同步方法，另外定义两个线程通过构造函数接收并操作数据，在主函数中直接创建线程对象，即可完成操作 2.2 方式2将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方式也分配给外部类，以便实现对共享数据进行的各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。 思想：一个外部类里面有两个内部类，为了让这两个内部类共享数据，让它们都操作外部类的同一个成员，方法和数据都在这个成员身上，直接调用方法即可完成 数据的操作 2.3 方式3：将上面两种方式的组合将共享数据封装在另外一个对象中，每个线程对共享数据的操作方法也分配到那个对象身上去完成，对象作为这个外部类中的成员变量或方法中的局部变量，每个线程的Runnable的对象作为外部类中的成员内部类或局部外部类。 2.4 技巧总结要同步互斥的几段代码最好是分别放在几个独立的方法中，这些方法再放在同一个类中，这样比较容易实现它们之间的同步互斥或通信。极端且简单的方式，即在任意一个类中定义一个static的变量，这将被所有线程共享。 2.5 对于每个线程执行的代码不同下的3种方式，通过一个面试题来说明需求：设计4个线程，其中两个线程每次对j增加1，另外两个线程每次对j减少1，写出程序 使用方式1实现将数据和操作共享数据的方法封装在一个类中，定义两个Runnable实现类，让两个Runnable都持有共享数据的引用，在Runnable的构造函数中，直接传入去操作，在实现类的run方法中调用封装类的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MultyThreadShareMethod1 &#123; public static void main(String[] args)&#123; //将数据封装到一个对象上， ShareData2 data1 = new ShareData2(); //在runnable的构造函数中直接传入去操作 for(int i=0;i&lt;2;i++)&#123; new Thread(new MyRunnable1(data1)).start(); new Thread(new MyRunnable2(data1)).start(); &#125; &#125; &#125; //封装共享数据和操作共享数据方法的类 class ShareData2&#123; private int j = 10; public synchronized void increment() &#123; j++; System.out.println(Thread.currentThread().getName()+" inc : "+j); &#125; public synchronized void decrement() &#123; j--; System.out.println(Thread.currentThread().getName()+" dec : "+j); &#125; &#125; //增加的线程，需要传入一个共享数据 class MyRunnable1 implements Runnable &#123; private ShareData2 data; public MyRunnable1(ShareData2 data) &#123; this.data = data; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; data.increment(); &#125; &#125; &#125; //减少的线程，需要传入一个共享数据 class MyRunnable2 implements Runnable &#123; private ShareData2 data; public MyRunnable2(ShareData2 data) &#123; this.data = data; &#125; @Override public void run() &#123; for(int i=0;i&lt;10;i++)&#123; data.decrement(); &#125; &#125; &#125; 输出结果 12345678910111213141516171819202122232425262728293031323334353637383940Thread-0 inc : 11Thread-0 inc : 12Thread-0 inc : 13Thread-0 inc : 14Thread-0 inc : 15Thread-0 inc : 16Thread-0 inc : 17Thread-0 inc : 18Thread-0 inc : 19Thread-0 inc : 20Thread-1 dec : 19Thread-3 dec : 18Thread-3 dec : 17Thread-3 dec : 16Thread-3 dec : 15Thread-3 dec : 14Thread-3 dec : 13Thread-3 dec : 12Thread-3 dec : 11Thread-3 dec : 10Thread-3 dec : 9Thread-2 inc : 10Thread-2 inc : 11Thread-1 dec : 10Thread-1 dec : 9Thread-1 dec : 8Thread-1 dec : 7Thread-1 dec : 6Thread-1 dec : 5Thread-1 dec : 4Thread-1 dec : 3Thread-1 dec : 2Thread-2 inc : 3Thread-2 inc : 4Thread-2 inc : 5Thread-2 inc : 6Thread-2 inc : 7Thread-2 inc : 8Thread-2 inc : 9Thread-2 inc : 10 使用方式2实现将数据和操作共享数据的方法封装在一个类中 两个Runnable作为它的内部类，相对于方式1，这里没有将数据传给Runnable，而是让它们自己去取，在自己的run方法中调用操作数据的方法 这里的共享变量可以定义为静态类型的成员变量，也可以定义为final类型的局部变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MultyThreadShareData &#123; //共享数据作为外部类的成员变量 //private static ShareData data = new ShareData(); public static void main(String[] args)&#123; //也可以定义为final类型的局部变量 final ShareData data = new ShareData(); //开启4条线程 for(int i=0;i&lt;2;i++)&#123; //增加的线程 new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=0;i&lt;100;i++)&#123; data.increment(); &#125; &#125; &#125;).start(); //减少的线程 new Thread(new Runnable()&#123; @Override public void run() &#123; for(int i=0;i&lt;100;i++)&#123; data.decrement(); &#125; &#125; &#125;).start(); &#125; &#125; &#125; //封装共享数据和操作共享数据方法的类 class ShareData&#123; private int j = 0; public synchronized void increment() &#123; j++; System.out.println(Thread.currentThread().getName()+" inc : "+j); &#125; public synchronized void decrement() &#123; j--; System.out.println(Thread.currentThread().getName()+" dec : "+j); &#125; &#125; 两种方式的组合实现1234567891011121314151617181920212223242526272829303132333435363738394041public class MultyThreadShareDataTest &#123; private int j; public static void main(String args[])&#123; MultyThreadShareDataTest tt = new MultyThreadShareDataTest(); Inc inc=tt.new Inc(); Dec dec=tt.new Dec(); for(int i=0;i&lt;2;i++)&#123; Thread t=new Thread(inc); t.start(); t=new Thread(dec); t.start(); &#125; &#125; private synchronized void inc()&#123; j++; System.out.println(Thread.currentThread().getName()+"-inc:"+j); &#125; private synchronized void dec()&#123; j--; System.out.println(Thread.currentThread().getName()+"-dec:"+j); &#125; class Inc implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;100;i++)&#123; inc(); &#125; &#125; &#125; class Dec implements Runnable&#123; public void run()&#123; for(int i=0;i&lt;100;i++)&#123; dec(); &#125; &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字解析]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.cnblogs.com/dolphin0520/p/3920373.html volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。 volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。 目录大纲 内存模型的相关概念 并发编程中的三个概念 Java内存模型 深入剖析volatile关键字 使用volatile关键字的场景 1. 内存模型的相关概念大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。 也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码： 1i = i + 1; 当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。 这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。 比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。 最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 通过在总线加LOCK锁的方式 通过缓存一致性协议 这2种方式都是硬件层面上提供的方式。 在早期的CPU当中，是通过在总线上加LOCK锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。 所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 2. 并发编程中的三个概念在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念： 2.1 原子性原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？ 1i = 9; 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。 2.2 可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 举个简单的例子，看下面这段代码： 123456//线程1执行的代码int i = 0;i = 10; //线程2执行的代码j = i; 假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 2.3 有序性有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码： 1234int i = 0; boolean flag = false;i = 1; //语句1 flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子： 1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4 这段代码有4个语句，那么可能的一个执行顺序是： 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 3. Java内存模型在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。 在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。 Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。 举个简单的例子：在java中，执行下面这个语句： 1i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？ 4. 原子性在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i： 请分析以下哪些操作是原子性操作： 1234x = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 5. 可见性对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 6. 有序性在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 下面就来具体介绍下happens-before原则（先行发生原则）： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 这8条原则摘自《深入理解Java虚拟机》。这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。下面我们来解释一下前4条规则： 对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则具备传递性。 7. 深入剖析volatile关键字在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。 7.1 volatile关键字的两层语义一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行： 12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125; //线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值。 7.2 volatile保证原子性吗？从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？ 下面看一个例子： 1234567891011121314151617181920212223public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。 这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 把上面的代码改成以下任何一种都可以达到效果： 采用synchronized： 1234567891011121314151617181920212223public class Test &#123; public int inc = 0; public synchronized void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用Lock：1234567891011121314151617181920212223242526272829public class Test &#123; public int inc = 0; Lock lock = new ReentrantLock(); public void increase() &#123; lock.lock(); try &#123; inc++; &#125; finally&#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用AtomicInteger：1234567891011121314151617181920212223public class Test &#123; public AtomicInteger inc = new AtomicInteger(); public void increase() &#123; inc.getAndIncrement(); &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 7.3 volatile能保证有序性吗？在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子： 12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 7.4 volatile的原理和实现机制前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。下面这段话摘自《深入理解Java虚拟机》： “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 它会强制将对缓存的修改操作立即写入主存； 如果是写操作，它会导致其他CPU中对应的缓存行无效。 7.5 使用volatile关键字的场景synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 对变量的写操作不依赖于当前值 该变量没有包含在具有其他变量的不变式中 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 下面列举几个Java中使用volatile的几个场景。 状态标记量 1234567891011121314151617181920volatile boolean flag = false; while(!flag)&#123; doSomething();&#125; public void setFlag() &#123; flag = true;&#125;volatile boolean inited = false;//线程1:context = loadContext(); inited = true; //线程2:while(!inited )&#123;sleep()&#125;doSomethingwithconfig(context); double check 1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 至于为何需要这么写请参考： Java 中的双重检查（Double-Check） 单例模式与双重检测 8. 参考资料《Java编程思想》 《深入理解Java虚拟机》 http://jiangzhengjun.iteye.com/blog/652532 http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html http://ifeve.com/volatile/ http://blog.csdn.net/ccit0519/article/details/11241403 http://blog.csdn.net/ns_code/article/details/17101369 http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html http://www.cppblog.com/elva/archive/2011/01/21/139019.html http://ifeve.com/volatile-array-visiblity/ http://www.bdqn.cn/news/201312/12579.shtml http://exploer.blog.51cto.com/7123589/1193399 http://www.cnblogs.com/Mainz/p/3556430.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. 泛型概述泛型（Generic type 或者 generics）是对 Java 语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。可以把类型参数看作是使用参数化类型时指定的类型的一个占位符，就像方法的形式参数是运行时传递的值的占位符一样。 泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。 Java语言引入泛型的好处是安全简单。 在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。 泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。 可以在集合框架（Collection framework）中看到泛型的动机。例如，Map 类允许您向一个 Map添加任意类的对象，即使最常见的情况是在给定映射（map）中保存某个特定类型（比如 String）的对象。 因为 Map.get() 被定义为返回 Object，所以一般必须将 Map.get() 的结果强制类型转换为期望的类型，如下面的代码所示： 123Map m = new HashMap();m.put("key", "blarg");String s = (String) m.get("key"); 要让程序通过编译，必须将 get() 的结果强制类型转换为 String，并且希望结果真的是一个 String。但是有可能某人已经在该映射中保存了不是 String 的东西，这样的话，上面的代码将会抛出 ClassCastException。 理想情况下，您可能会得出这样一个观点，即 m 是一个 Map，它将 String 键映射到 String 值。这可以让您消除代码中的强制类型转换，同时获得一个附加的类型检查层，该检查层可以防止有人将错误类型的键或值保存在集合中。这就是泛型所做的工作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.itcast_01;import java.util.ArrayList;import java.util.Iterator;/* * ArrayList存储字符串并遍历 * * 我们按照正常的写法来写这个程序， 结果确出错了。 * 为什么呢? * 因为我们开始存储的时候，存储了String和Integer两种类型的数据。 * 而在遍历的时候，我们把它们都当作String类型处理的，做了转换，所以就报错了。 * 但是呢，它在编译期间却没有告诉我们。 * 所以，我就觉得这个设计的不好。 * 回想一下，我们的数组 * String[] strArray = new String[3]; * strArray[0] = "hello"; * strArray[1] = "world"; * strArray[2] = 10; * 集合也模仿着数组的这种做法，在创建对象的时候明确元素的数据类型。这样就不会在有问题了。 * 而这种技术被称为：泛型。 * * 泛型：是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。参数化类型，把类型当作参数一样的传递。 * 格式： * &lt;数据类型&gt; * 此处的数据类型只能是引用类型。 * 好处： * A:把运行时期的问题提前到了编译期间 * B:避免了强制类型转换 * C:优化了程序设计，解决了黄色警告线 */public class GenericDemo &#123; public static void main(String[] args) &#123; // 创建 ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(); // 添加元素 array.add("hello"); array.add("world"); array.add("java"); // array.add(new Integer(100)); //array.add(10); // JDK5以后的自动装箱 // 等价于：array.add(Integer.valueOf(10)); // 遍历 Iterator&lt;String&gt; it = array.iterator(); while (it.hasNext()) &#123; // ClassCastException // String s = (String) it.next(); String s = it.next(); System.out.println(s); &#125; // 看下面这个代码 // String[] strArray = new String[3]; // strArray[0] = "hello"; // strArray[1] = "world"; // strArray[2] = 10; &#125;&#125; 2. 泛型的好处Java 语言中引入泛型是一个较大的功能增强。不仅语言、类型系统和编译器有了较大的变化，以支持泛型，而且类库也进行了大翻修，所以许多重要的类，比如集合框架，都已经成为泛型化的了。这带来了很多好处： 2.1 类型安全泛型的主要目标是提高 Java 程序的类型安全。通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中（或者如果幸运的话，还存在于代码注释中）。 Java 程序中的一种流行技术是定义这样的集合，即它的元素或键是公共类型的，比如“String 列表”或者“String 到 String 的映射”。通过在变量声明中捕获这一附加的类型信息，泛型允许编译器实施这些附加的类型约束。类型错误现在就可以在编译时被捕获了，而不是在运行时当作 ClassCastException 展示出来。将类型检查从运行时挪到编译时有助于您更容易找到错误，并可提高程序的可靠性。 2.2 消除强制类型转换泛型的一个附带好处是，消除源代码中的许多强制类型转换。这使得代码更加可读，并且减少了出错机会。尽管减少强制类型转换可以降低使用泛型类的代码的罗嗦程度，但是声明泛型变量会带来相应的罗嗦。 2.3 优化了程序设计，解决了黄色警告线3. 泛型的应用3.1 泛型的内部原理泛型是提供给javac编译器使用的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入。但是，编译器编译带类型说明的集合时会去除掉“类型”信息，目的就是使程序运行效率不受影响。因此，对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样。 12345678910111213package com.itheima.day2;import java.util.ArrayList;public class GenericTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; collection1 = new ArrayList&lt;String&gt;(); ArrayList collection2 = new ArrayList(); System. out.println(collection1.getClass() == collection2.getClass()); //结果：true &#125;&#125; 由于编译生成的字节码会去掉泛型的类型信息，只要能跳过编译器，就可以往某个泛型集合中加入其它类型的数据，例如，用反射得到集合，再调用其add方法即可。 123456789101112package com.itheima.day2;import java.util.ArrayList;public class GenericTest &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; collection1 = new ArrayList&lt;Integer&gt;(); collection1.getClass().getMethod( "add",Object.class).invoke(collection1, "abc"); System. out.println(collection1.get(0)); &#125;&#125; ArrayList类定义和ArrayList类引用中涉及如下术语： 整个称为ArrayList&lt;E&gt;泛型类型 ArrayList&lt;E&gt;中的E称为类型变量或类型参数 整个ArrayList&lt;Integer&gt;称为参数化的类型 ArrayList&lt;Integer&gt;中的Integer称为类型参数的实例或实际类型参数 ArrayList&lt;Integer&gt;中的&lt;&gt;念着typeof ArrayList称为原始类型 参数化类型与原始类型的兼容性：参数化类型可以引用一个原始类型的对象，编译报告警告，例如 1Collection&lt;String&gt; c = new Vector();//考虑到对以前代码的兼容性，编译器是可以通过的 原始类型可以引用一个参数化类型的对象，编译报告警告，例如1Collection c = new Vector&lt;String&gt;();//原来的方法接受一个集合参数，新的类型也要能传进去 参数化类型不考虑类型参数的继承关系： 12Vector&lt;String&gt; v = new Vector&lt;Object&gt;(); //错误!不写&lt;Object&gt;没错，写了就是明知故犯Vector&lt;Object&gt; v = new Vector&lt;String&gt;(); //也错误! 注意： 假设Vector&lt;String&gt; v = new Vector&lt;Object&gt;();可以的话，那么以后从v中取出的对象当作String用，而v实际指向的对象中可以加入任意的类型对象； 假设Vector&lt;Object&gt; v = new Vector&lt;String&gt;();可以的话，那么以后可以向v中加入任意的类型对象，而v实际指向的集合中只能装String类型的对象。 编译器不允许创建泛型变量的数组。即在创建数组实例时，数组的元素不能使用参数化的类型。 例如，下面语句有错误： 1Vector&lt;Integer&gt; vectorList[] = new Vector&lt;Integer&gt;[10]; 思考题： 下面的代码会报错误吗？ 12Vector v1 = new Vector&lt;String&gt;();Vector&lt;Object&gt; v = v1; 答案：编译的时候是不会报错的，因为编译器是一行一行按照语法检查代码的，因此不会出错。 4. 泛型类把泛型定义在类上，格式:public class 类名&lt;泛型类型1,…&gt;，注意:泛型类型必须是引用类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.itcast_04;/* * 泛型类的测试 */public class ObjectToolDemo &#123; public static void main(String[] args) &#123; // ObjectTool ot = new ObjectTool(); // // ot.setObj(new String("风清扬")); // String s = (String) ot.getObj(); // System.out.println("姓名是：" + s); // // ot.setObj(new Integer(30)); // Integer i = (Integer) ot.getObj(); // System.out.println("年龄是：" + i); // ot.setObj(new String("林青霞")); // // ClassCastException // Integer ii = (Integer) ot.getObj(); // System.out.println("姓名是：" + ii); System.out.println("-------------"); ObjectTool&lt;String&gt; ot = new ObjectTool&lt;String&gt;(); // ot.setObj(new Integer(27)); //这个时候编译期间就过不去 ot.setObj(new String("林青霞")); String s = ot.getObj(); System.out.println("姓名是：" + s); ObjectTool&lt;Integer&gt; ot2 = new ObjectTool&lt;Integer&gt;(); // ot2.setObj(new String("风清扬"));//这个时候编译期间就过不去 ot2.setObj(new Integer(27)); Integer i = ot2.getObj(); System.out.println("年龄是：" + i); &#125;&#125;//泛型类：把泛型定义在类上class ObjectTool&lt;T&gt; &#123; private T obj; public T getObj() &#123; return obj; &#125; public void setObj(T obj) &#123; this.obj = obj; &#125;&#125; 5. 泛型方法把泛型定义在方法上，格式:public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 .) 12345678910111213141516171819202122232425262728293031package cn.itcast_05;public class ObjectToolDemo &#123; public static void main(String[] args) &#123; // ObjectTool ot = new ObjectTool(); // ot.show("hello"); // ot.show(100); // ot.show(true); // ObjectTool&lt;String&gt; ot = new ObjectTool&lt;String&gt;(); // ot.show("hello"); // // ObjectTool&lt;Integer&gt; ot2 = new ObjectTool&lt;Integer&gt;(); // ot2.show(100); // // ObjectTool&lt;Boolean&gt; ot3 = new ObjectTool&lt;Boolean&gt;(); // ot3.show(true); // 定义泛型方法后 ObjectTool ot = new ObjectTool(); ot.show("hello"); ot.show(100); ot.show(true); &#125;&#125;//泛型方法：把泛型定义在方法上class ObjectTool &#123; public &lt;T&gt; void show(T t) &#123; System.out.println(t); &#125;&#125; 6. 泛型接口把泛型定义在接口上，格式:public interface 接口名&lt;泛型类型1…&gt; 123456789101112131415161718192021222324252627282930313233343536373839package cn.itcast_06;public class InterDemo &#123; public static void main(String[] args) &#123; // 第一种情况的测试 // Inter&lt;String&gt; i = new InterImpl(); // i.show("hello"); // // 第二种情况的测试 Inter&lt;String&gt; i = new InterImpl&lt;String&gt;(); i.show("hello"); Inter&lt;Integer&gt; ii = new InterImpl&lt;Integer&gt;(); ii.show(100); &#125;&#125;//泛型接口：把泛型定义在接口上 interface Inter&lt;T&gt; &#123; public abstract void show(T t);&#125;// 实现类在实现接口的时候// 第一种情况：已经知道该是什么类型的了//public class InterImpl implements Inter&lt;String&gt; &#123;//// @Override// public void show(String t) &#123;// System.out.println(t);// &#125;// &#125;// 第二种情况：还不知道是什么类型的class InterImpl&lt;T&gt; implements Inter&lt;T&gt; &#123; @Override public void show(T t) &#123; System.out.println(t); &#125;&#125; 7. 泛型高级(通配符)为了解决类型被限制死了不能动态根据实例来确定的缺点，引入了“通配符泛型”，针对上面的例子，使用通配泛型格式为&lt;? extends Collection&gt;，“？”代表未知类型，这个类型是实现Collection接口。? extends E：向下限定，E及其子类，限定通配符的上边界。? super E：向上限定，E及其父类，限定通配符的下边界。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.itcast_07;import java.util.ArrayList;import java.util.Collection;/* * 泛型高级(通配符) * ?:任意类型，如果没有明确，那么就是Object以及任意的Java类了 * ? extends E:向下限定，E及其子类 * ? super E:向上限定，E极其父类 */public class GenericDemo &#123; public static void main(String[] args) &#123; // 泛型如果明确的写的时候，前后必须一致 Collection&lt;Object&gt; c1 = new ArrayList&lt;Object&gt;(); // Collection&lt;Object&gt; c2 = new ArrayList&lt;Animal&gt;(); // Collection&lt;Object&gt; c3 = new ArrayList&lt;Dog&gt;(); // Collection&lt;Object&gt; c4 = new ArrayList&lt;Cat&gt;(); // ?表示任意的类型都是可以的 Collection&lt;?&gt; c5 = new ArrayList&lt;Object&gt;(); Collection&lt;?&gt; c6 = new ArrayList&lt;Animal&gt;(); Collection&lt;?&gt; c7 = new ArrayList&lt;Dog&gt;(); Collection&lt;?&gt; c8 = new ArrayList&lt;Cat&gt;(); // ? extends E:向下限定，E及其子类 // Collection&lt;? extends Animal&gt; c9 = new ArrayList&lt;Object&gt;(); Collection&lt;? extends Animal&gt; c10 = new ArrayList&lt;Animal&gt;(); Collection&lt;? extends Animal&gt; c11 = new ArrayList&lt;Dog&gt;(); Collection&lt;? extends Animal&gt; c12 = new ArrayList&lt;Cat&gt;(); // ? super E:向上限定，E极其父类 Collection&lt;? super Animal&gt; c13 = new ArrayList&lt;Object&gt;(); Collection&lt;? super Animal&gt; c14 = new ArrayList&lt;Animal&gt;(); // Collection&lt;? super Animal&gt; c15 = new ArrayList&lt;Dog&gt;(); // Collection&lt;? super Animal&gt; c16 = new ArrayList&lt;Cat&gt;(); &#125;&#125;class Animal &#123;&#125;class Dog extends Animal &#123;&#125;class Cat extends Animal &#123;&#125; 泛型泛型是提供给javac编译器使用的，可以限定集合中的输入类型，让编译器挡住源程序中的非法输入，编译器编译带类型说明的集合时会去除掉“类型”信息，使程序运行效率不受影响，对于参数化的泛型类型，getClass()方法的返回值和原始类型完全一样。由于编译生成的字节码会去掉泛型的类型信息，只要能跳过编译器，就可以往某个泛型集合中加入其它类型的数据，例如，用反射得到集合，再调用其add方法即可。 泛型引用和创建两端，给出的泛型变量必须相同 泛型类12A&lt;T&gt;Class&lt;T&gt; type 泛型类中使用泛型 成员类型 返回值和参数类型 局部变量的引用上 12345678class A&lt;T&gt; &#123; private T bean;//泛型可在成员变量上使用 public T fun(T t) &#123;&#125;//泛型可以在类中的方法上（返回值和参数类型）使用！ public void fun2() &#123;//泛型还可以在局部变量的引用类型上使用 T b = ... new T();//不行的！ &#125;&#125; 泛型方法12public &lt;T&gt; T add(T x, T y)&#123; &#125; 泛型方法与泛型类没有什么关系，泛型方法不一定非要在泛型类中！ 泛型的继承和实现1234567class A&lt;T&gt; &#123;&#125;// AA不是泛型类，只是它爸爸是泛型类！class AA extends A&lt;String&gt; &#123; &#125; 继承泛型类 子类不是泛型类：需要给父类传递类型常量 当给父类传递的类型常量为String时，那么在父类中所有T都会被String替换！ 123class AA1 extends A&lt;String&gt; &#123; &#125; 子类是泛型类：可以给父类传递类型常量，也可以传递类型变量 123class AA3&lt;E&gt; extends A&lt;E&gt; &#123; &#125; 通配符 无限通配符&lt;?&gt; 向下通配符&lt;? extends T&gt; 向上通配符&lt;? super T&gt; 类型推断 通过反射的方式获取泛型的实际类型 泛型只能是引用类型，不能是基本数据类型 泛型擦除泛型会在编译时擦除，List和List这两个的字节码文件那一个都是List.class Gson泛型封装在你真的会用Gson吗?Gson使用指南（一） 的第三节我介绍了在Gson中如何使用泛型来简化我们的类设计，但随之而来引入了一个新的问题：封装。不知道各位有没有想过这样一个问题：每次都要用 new TypeToken&lt;XXX&gt;(){}; 好麻烦，有没有更好的办法? 有更好的办法么?当然有！相信也有不少人自己作了尝试，只是有人欢喜有人愁了，不过没关系，今天我们就来解决这个问题。 约定1、本文涉及到的json格式 1234// data 为 object 的情况&#123;"code":"0","message":"success","data":&#123;&#125;&#125;// data 为 array 的情况&#123;"code":"0","message":"success","data":[]&#125; 2、假定第一种的对应的Java类型为 Result&lt;XXX&gt; ，第二种为 Result&lt;List&lt;XXX&gt;&gt; 为何封装，如何封装1. 为何封装： 写new TypeToken&lt;XXX&gt;(){} 麻烦，IDE格式化后还不好看 不同的地方每进行一次 new TypeToken&lt;XXX&gt;(){} 操作都会生成一个新的类 对于任意类XXX都只有两种情况new TypeToken&lt;Result&lt;XXX&gt;&gt;(){}和new TypeToken&lt;Result&lt;List&lt;XXX&gt;&gt;&gt;(){} 方便统一管理 2. 如何封装从上面的我们可以知道，最简单的方法就是提供两个方法分别对应data为Array和Object的情况并接收一个参数，即告知XXX的类型，自动将完成new TypeToken&lt;XXX&gt;(){}与new TypeToken&lt;Result&lt;List&lt;XXX&gt;&gt;&gt;(){}的过程。 方法原型： 1234// 处理 data 为 object 的情况public static &lt;T&gt; Result&lt;T&gt; fromJsonObject(Reader reader, Class&lt;T&gt; clazz) &#123;&#125;// 处理 data 为 array 的情况public static &lt;T&gt; Result&lt;List&lt;T&gt;&gt; fromJsonArray(Reader reader, Class&lt;T&gt; clazz)&#123;&#125; 为何失败?对于那些尝试着封装过的人可能都这么写过： 1234public static &lt;T&gt; Result&lt;List&lt;T&gt;&gt; fromJsonArray(Reader reader) &#123; Type type = new TypeToken&lt;Result&lt;List&lt;T&gt;&gt;&gt;()&#123;&#125;.getType(); return GSON.fromJson(reader, type);&#125; 当然上面的写法肯定是没有办法完成的，虽然代码不会报错，但运行结果肯定是不对的，因为这里的T 其实是一个 TypeVariable，他在运行时并不会变成我们想要的XXX，所以通过TypeToken 得到的 泛型信息只是 &quot;Result&lt;List&lt;T&gt;&gt;&quot;。 如何解决?既然TypeToken的作用是用于获取泛型的类，返回的类型为Type，真正的泛型信息就是放在这个Type里面，既然用TypeToken生成会有问题,那我们自己生成Type就行了嘛。 Type是Java中所有类型的父接口，在1.8以前是一个空接口，自1.8起多了个getTypeName()方法，下面有ParameterizedType、 GenericArrayType、 WildcardType、 TypeVariable 几个接口，以及Class类。这几个接口在本次封装过程中只会用到 ParameterizedType ，所以简单说一下： ParameterizedType 简单说来就是形如“ 类型&lt;&gt; ”的类型，如:Map&lt;String,User&gt;。下面就以 Map&lt;String,User&gt; 为例讲一下里面各个方法的作用。 12345678public interface ParameterizedType extends Type &#123; // 返回Map&lt;String,User&gt;里的String和User，所以这里返回[String.class,User.clas] Type[] getActualTypeArguments(); // Map&lt;String,User&gt;里的Map,所以返回值是Map.class Type getRawType(); // 用于这个泛型上中包含了内部类的情况,一般返回null Type getOwnerType(); &#125; 所以，知道了这里需要的泛型是怎么回事，一切都好说了，下面我们来完成之前留下的空方法。 1. 实现一个简易的 ParameterizedType123456789101112131415161718public class ParameterizedTypeImpl implements ParameterizedType &#123; private final Class raw; private final Type[] args; public ParameterizedTypeImpl(Class raw, Type[] args) &#123; this.raw = raw; this.args = args != null ? args : new Type[0]; &#125; @Override public Type[] getActualTypeArguments() &#123; return args; &#125; @Override public Type getRawType() &#123; return raw; &#125; @Override public Type getOwnerType() &#123;return null;&#125;&#125; 2. 生成Gson需要的泛型2.1 解析data是object的情况1234public static &lt;T&gt; Result&lt;T&gt; fromJsonObject(Reader reader, Class&lt;T&gt; clazz) &#123; Type type = new ParameterizedTypeImpl(Result.class, new Class[]&#123;clazz&#125;); return GSON.fromJson(reader, type);&#125; 2.2 解析data是array的情况是Array的情况要比是Object的情况多那么一步。 1234567public static &lt;T&gt; Result&lt;List&lt;T&gt;&gt; fromJsonArray(Reader reader, Class&lt;T&gt; clazz) &#123; // 生成List&lt;T&gt; 中的 List&lt;T&gt; Type listType = new ParameterizedTypeImpl(List.class, new Class[]&#123;clazz&#125;); // 根据List&lt;T&gt;生成完整的Result&lt;List&lt;T&gt;&gt; Type type = new ParameterizedTypeImpl(Result.class, new Type[]&#123;listType&#125;); return GSON.fromJson(reader, type);&#125; 本次代码较少，不提供源码 虽然这篇博客是以Gson为例，但从上面的内容可以看出实际上和Gson关系不大，主要的内容还是Java的泛型基础，所以这种封装的方法同样适用于其它的框架。 最后借这次机会给安利一个简易的泛型生成库 TypeBuilder ，其最初实现的目的就是让大家快速的生成泛型信息，同时也会作一些参数检查，保证正确性。 用上面的代码给大家举个例子 1234567891011121314151617public static &lt;T&gt; Result&lt;List&lt;T&gt;&gt; fromJsonArray(Reader reader, Class&lt;T&gt; clazz) &#123; Type type = TypeBuilder .newInstance(Result.class) .beginSubType(List.class) .addTypeParam(clazz) .endSubType() .build(); return GSON.fromJson(reader, type);&#125;public static &lt;T&gt; Result&lt;T&gt; fromJsonObject(Reader reader, Class&lt;T&gt; clazz) &#123; Type type = TypeBuilder .newInstance(Result.class) .addTypeParam(clazz) .build(); return GSON.fromJson(reader, type);&#125; TypeType 是 Java 编程语言中所有类型的公共高级接口。它们包括原始类型、参数化类型、数组类型、类型变量和基本类型 ParameterizedTypeParameterizedType 表示参数化类型，如 Collection 方法 说明 Type[ ] getActualTypeArguments() 获取真实参数 12345678910public abstract class BaseProtocol&lt;T&gt; &#123; ... // 泛型解析 protected T parsejson(String jsonString)&#123; ParameterizedType genericSuperclass = (ParameterizedType) getClass().getGenericSuperclass(); Type[] args = genericSuperclass.getActualTypeArguments(); Type type = args[0]; return GsonUtil.changeGsonToBean(jsonString,type); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射注解动态代理相关阅读 Java基础：类加载器 Java基础：反射 Java基础：注解 Java基础：动态代理 1. 反射概述Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 Java 反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。 Java中，反射是一种强大的工具。它使您能够创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码链接。反射允许我们在编写于执行时，使我们的程序代码能够接入装载到JVM中的类的内部信息，而不是源代码中选定的类协作的代码。这使反射成为构建灵活的应用的主要工具。但需注意的是：如果使用不当，反射的成本很高。 2. 反射的应用场景反射是Java中的高级特性，在各种Java框架中都需要使用反射。所以，就算你将来很长一段时间不使用反射，但你使用的框架都大量使用了反射，所以想深入学习框架，那么就一定要学习反射。 框架通常通过反射来识别一个对象的“类型信息”。当你传递给框架一个对象时，框架会通过反射来了解对象的真实类型（对象实体的类型，而不是引用的类型），这个类型有几个构造器，有什么样的属性，有什么样的方法。还可以通过反射调用构造器，调用方法，对属性进行读写操作。 你可能觉得这没有什么神奇的，那是你还没了解我说的是什么！你需要再想一想，写一个方法，参数是Object obj，然后你的方法需要创建一个与参数类型相同的对象出来，还要调用这个对象上的方法。需要注意，参数是Object类型，但用户调用这个方法时，可能传递的不是Object实体对象，它的真实类型有可能是任何类型。 目前好多框架都会用到java的反射机制。比如struts2，sping，hibernate。 如果我们不用struts2，自己写一个类似的功能也是可以实现的，比如浏览器通过HTTP发送数据，而这些数据都是字符串，我们接受到这些字符串时， 可以通过反射去构造一个对象(通过拦截器做成框架的功能)，这样就可以用对象的get和set方法了，而不用原始的getPeremter()方法。事实上， 在struts2出来之前，我们又不想用struts1的ActionForm就做过这样项目。 Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法 生成动态代理 3. 反射JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 要想解剖一个类，必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。 一句话概括：反射就是把java类中的各种成分映射成相应的java类（Class，Field，Method，Constructor），在程序运行的过程中，动态的访问java类中的成分，反射还可以实现框架的功能 例如：一个Java类中用一个Class类的对象来表示，一个类中的组成部分：成员变量，方法，构造方法，包等信息也用一个个的Java类来表示，就像汽车是一个类，汽车中的发动机，变速箱等等也是一个个的类。表示java类的Class类显然要提供一系列的方法，来获得其中的变量，方法，构造方法，修饰符，包等信息，这些信息就是用相应类的实例对象来表示，它们是Field、Method、Contructor、Package等。 3.1 反射的主要作用 运行时取得类的方法和字段的相关信息。 创建某个类的新实例(newInstance()) 取得字段引用直接获取和设置对象字段，无论访问修饰符是什么 观察或操作应用程序的运行时行为 调试或测试程序，因为可以直接访问方法、构造函数和成员字段 通过名字调用不知道的方法并使用该信息来创建对象和调用方法 4. 反射从Class类开始要想使用反射，首先你需要得到Class对象，然后才能通过Class对象获取Constructor、Field、Method等对象。所有的反射对象都不可能自己来new，说白一点，这些反射对象对应的是class文件上的信息，你怎么可能自己去new呢？如果可以自己去new一个Class类的对象，那么是不是就不用我们再去编写.java文件，然后再通过编译器去编译成.class文件了呢？当然这是不可能的！ 我们需要思考，Class除了可以返回当前对应类型的所有属性、方法、构造器的反射对象外，还有什么功能呢？例如对应类型的类名是什么？对应类型的父类是谁？对应类型是不是public类，是不是final类。对应类型有没有可能是个数组类型？有没有可能是接口类型？有没有可能是基本类型等等！如果你学会了这样思考，那么你今后学习新类是就方便多了！ 4.1 三种获取Class对象的方式 Object类的getClass()方法 12Person p = new Person();Class c = p.getClass(); 数据类型的静态属性class 1Class c2 =Person.class; 任意数据类型都具备一个class静态属性，看上去要比第一种方式简单 将类名作为字符串传递给Class类中的静态方法forName即可 1Class c3 = Class.forName("Person"); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package cn.itcast;class Person &#123; private String name; int age; public String address; public Person() &#123; &#125; private Person(String name) &#123; this.name = name; &#125; Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public Person(String name, int age, String address) &#123; this.name = name; this.age = age; this.address = address; &#125; public void show() &#123; System.out.println("show"); &#125; public void method(String s) &#123; System.out.println("method " + s); &#125; public String getString(String s, int i) &#123; return s + "---" + i; &#125; private void function() &#123; System.out.println("function"); &#125; public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", address=" + address + "]"; &#125;&#125;/* * 反射：就是通过class文件对象，去使用该文件中的成员变量，构造方法，成员方法。 * * Person p = new Person(); p.使用 * * 要想这样使用，首先你必须得到class文件对象，其实也就是得到Class类的对象。 Class类： 成员变量 Field 构造方法 Constructor * 成员方法 Method * * 获取class文件对象的方式： A:Object类的getClass()方法 B:数据类型的静态属性class C:Class类中的静态方法 public * static Class forName(String className) * * 一般我们到底使用谁呢? 第三种：因为第三种是一个字符串，而不是一个具体的类名。这样我们就可以把这样的字符串配置到配置文件中。 */public class ReflectDemo &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 方式1 Person p = new Person(); Class c = p.getClass(); Person p2 = new Person(); Class c2 = p2.getClass(); System.out.println(p == p2);// false System.out.println(c == c2);// true // 方式2 Class c3 = Person.class; // int.class; // String.class; System.out.println(c == c3); // 方式3 // ClassNotFoundException Class c4 = Class.forName("cn.itcast_01.Person"); System.out.println(c == c4); &#125;&#125; 4.2 第三种和前两种的区别前两种你必须明确Person类型；后面是你我这种类型的字符串就行.这种扩展更强.我不需要知道你的类.我只提供字符串,按照配置文件加载就可以了。 PS：所谓的框架就是对外提供一些接口，也就是功能扩展的标准，由实现类按照这个接口标准去实现。框架内部如果需要操纵这些实现类的对象完成某些操作，那么只需要把这些实现类的全名（包名+类名）写在某个配置文件中，框架代码只需要读取这个配置文件，就可以获取这个实现类的字节码文件，然后利用反射技术创建这个实现类的对象并且调用相应的方法完成一些操作。 用于描述字节码的类就是Class类，创建对象，可以提取字节码文件中的内容，如字段、构造函数、一般函数。该类就可以获取字节码文件中的所有内容，那么反射就是依靠该类完成的。想要对一个类文件进行解剖，只要获取到该类的字节码文件对象即可。 5. 加载类我们已经知道，main()方法是程序的入口。那是不是在main()方法开始执行之前，所有的class文件都已经加载到方法区中了呢？答案是：NO！通常只有需要执行到使用某个类的代码时，才会去CLASSPATH中加载class文件，如果程序从头到尾都没有使用某个类，那么这个类对应的class文件就不会被加载到内存。 可以导致一个类被加载可能有： 使用一个类的静态方法； 使用一个类的静态属性； 创建这个类的对象； 使用Class.forName()方法加载类； 反序列化一个类的对象； 加载一个类的子类时，也会加载其父类； 加载一个类时，也会加载与该类相关的类。 上面给出的几个可能也只是可能而已，如果当前类没有被加载过，才会去加载，如果已经加载到方法区中了，那么就不可能再去加载。 6. Class 字节码Class 类的实例表示正在运行的 Java 应用程序中的类和接口 方法 说明 forName() 通过类名获取类的字节码 getClassLoader() 获取该类的类加载器 getInterfaces() 获取所实现的接口 getSuperclass() 获取父类 getGenericSuperclass() 获取传递给父类参数化类型 newInstance() 创建实例 getName() 获取类名，接口名 getPackage() 获取包名 isPrimitive() 判定指定的 Class 对象是否表示一个基本类型 isArray() 判定此 Class 对象是否表示一个数组类 getResourceAsStream() 查找具有给定名称的资源 6.1 获取注解 方法 说明 getAnnotation() 获取指定类型的注解 getAnnotations() 获取所有的注解 getDeclaredAnnotations() 获取除了继承得到的所有注解 6.2 获取构造方法 方法 说明 getConstructor() 获取指定的非私有的构造方法 getDeclaredConstructor() 获取指定的构造方法 getConstructors() 获取公有的构造方法 getDeclaredConstructors() 获取所有的构造方法 6.3 获取成员方法 方法 说明 getMethod() 获取指定的非私有方法 getDeclaredMethod() 获取指定的方法 getMethods() 获取公有的方法 getDeclaredMethods() 获取所有的方法 6.4 获取成员变量 方法 说明 getField() 获取指定名称的字段 getFields() 获取公有的字段 getDeclaredField(String name) 获取指定名称的字段 getDeclaredFields() 获取所有的字段 7. AccessibleObjectAccessibleObject 类是 Field、Method 和 Constructor 对象的基类 方法 说明 getAnnotation() 获取指定类型的注解 getAnnotations() 获取所有的注解 getDeclaredAnnotations() 获取除了继承得到的所有注解 setAccessible(true) 暴力反射，取消访问检查 8. ConstructorConstructor 提供关于类的单个构造方法的信息以及对它的访问权限 方法 说明 newInstance() 通过构造方法创建实例 getParameterTypes() 获取构造器的所有参数的类型 getExceptionTypes() 获取构造器上声明的所有异常类型 getDeclaringClass() 获取构造器所属的类型 getModifiers() 获取构造器上的所有修饰符信息 9. Method表示一个类中的成员方法 方法 说明 invoke(Object obj, Object… args) 通过方法反射对象调用方法，如果当前方法是实例方法，那么当前对象就是obj，如果当前方法是static方法，那么可以给obj传递null。args表示是方法的参数 setAccessible(true) 暴力反射，取消访问检查 getAnnotation() 获取方法上指定类型的注解 getAnnotations() 获取所有的注解 getDeclaredAnnotations() 获取方法上说所有的注解 getGenericParameterTypes() 获取泛型的参数化类型 getModifiers() 获取方法的权限修饰符，Modifier.PUBLIC，Modifier.ABSTRACT，Modifier.STATIC getParameterTypes() 获取方法参数 10. Field表示一个类中的成员变量 方法 说明 getAnnotation() 获取字段上指定类型的注解 getAnnotations() 获取所有的注解 getDeclaredAnnotations() 获取字段所有的注解 set() 给指定字段设置新值 get() 获取字段值 setAccessible(true) 暴力反射，取消访问检查 getType() 获取字段的类型 getXXX(Object obj) 如果当前属性为基本类型，可以使用getXXX()系列方法获取基本类型属性值 setXXX(Object obj, XXX value) 如果当前属性为基本类型，可以使用setXXX()系统方法基本类型属性值 11. TypeType 是 Java 编程语言中所有类型的公共高级接口 11.1 ParameterizedTypeParameterizedType 表示参数化类型，如 Collection 方法 说明 Type[ ] getActualTypeArguments() 获取真实参数 123456789101112public abstract class BaseProtocol&lt;T&gt; &#123; ... /**泛型解析*/ protected T parsejson(String jsonString)&#123; ParameterizedType genericSuperclass = (ParameterizedType) getClass().getGenericSuperclass(); Type[] args = genericSuperclass.getActualTypeArguments(); Type type = args[0]; return GsonUtil.changeGsonToBean(jsonString,type); &#125;&#125; 12. ArrayArray 类提供了动态创建和访问 Java 数组的方法 方法 说明 Array.getLenght() 获取数组的长度 Array.get() 获取数组中指定索引的值 13. ModifierModifier类有一系列的static方法用来解析其他getModifiers()方法返回的int值 12345Method m = …int m = m.getModifiers();boolean b1 = Modifier.isAbstract(m);//解析m中是否包含abstract修饰boolean b2 = Modifier.isStatic(m);//解析m中是否包含static修饰String s = Modifiers.toString(m);//把所有修饰都转换成字符串 14. 反射的应用通过反射获取构造方法并使用 123456789101112131415161718192021222324252627282930package cn.itcast_02;import java.lang.reflect.Constructor;/* * 需求：通过反射获取私有构造方法并使用 * private Person(String name)&#123;&#125; * * Person p = new Person("风清扬"); * System.out.println(p); */public class ReflectDemo3 &#123; public static void main(String[] args) throws Exception &#123; // 获取字节码文件对象 Class c = Class.forName("cn.itcast_01.Person"); // 获取私有构造方法对象 // NoSuchMethodException：每个这个方法异常 // 原因是一开始我们使用的方法只能获取公共的，下面这种方式就可以了。 Constructor con = c.getDeclaredConstructor(String.class); // 用该私有构造方法创建对象 // IllegalAccessException:非法的访问异常。 // 暴力访问 con.setAccessible(true);// 值为true则指示反射的对象在使用时应该取消Java语言访问检查。 Object obj = con.newInstance("风清扬"); System.out.println(obj); &#125;&#125; 通过反射获取成员变量并使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package cn.itcast_03;import java.lang.reflect.Constructor;import java.lang.reflect.Field;/* * 通过发生获取成员变量并使用 */public class ReflectDemo &#123; public static void main(String[] args) throws Exception &#123; // 获取字节码文件对象 Class c = Class.forName("cn.itcast_01.Person"); // 获取所有的成员变量 // Field[] fields = c.getFields(); // Field[] fields = c.getDeclaredFields(); // for (Field field : fields) &#123; // System.out.println(field); // &#125; /* * Person p = new Person(); p.address = "北京"; System.out.println(p); */ // 通过无参构造方法创建对象 Constructor con = c.getConstructor(); Object obj = con.newInstance(); System.out.println(obj); // 获取单个的成员变量 // 获取address并对其赋值 Field addressField = c.getField("address"); // public void set(Object obj,Object value) // 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 addressField.set(obj, "北京"); // 给obj对象的addressField字段设置值为"北京" System.out.println(obj); // 获取name并对其赋值 // NoSuchFieldException Field nameField = c.getDeclaredField("name"); // IllegalAccessException nameField.setAccessible(true); nameField.set(obj, "林青霞"); System.out.println(obj); // 获取age并对其赋值 Field ageField = c.getDeclaredField("age"); ageField.setAccessible(true); ageField.set(obj, 27); System.out.println(obj); &#125;&#125; 通过反射获取成员方法并使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package cn.itcast_04;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class ReflectDemo &#123; public static void main(String[] args) throws Exception &#123; // 获取字节码文件对象 Class c = Class.forName("cn.itcast_01.Person"); // 获取所有的方法 // Method[] methods = c.getMethods(); // 获取自己的包括父亲的公共方法 // Method[] methods = c.getDeclaredMethods(); // 获取自己的所有的方法 // for (Method method : methods) &#123; // System.out.println(method); // &#125; Constructor con = c.getConstructor(); Object obj = con.newInstance(); /* * Person p = new Person(); p.show(); */ // 获取单个方法并使用 // public void show() // public Method getMethod(String name,Class&lt;?&gt;... parameterTypes) // 第一个参数表示的方法名，第二个参数表示的是方法的参数的class类型 Method m1 = c.getMethod("show"); // obj.m1(); // 错误 // public Object invoke(Object obj,Object... args) // 返回值是Object接收,第一个参数表示对象是谁，第二参数表示调用该方法的实际参数 m1.invoke(obj); // 调用obj对象的m1方法 System.out.println("----------"); // public void method(String s) Method m2 = c.getMethod("method", String.class); m2.invoke(obj, "hello"); System.out.println("----------"); // public String getString(String s, int i) Method m3 = c.getMethod("getString", String.class, int.class); Object objString = m3.invoke(obj, "hello", 100); System.out.println(objString); // String s = (String)m3.invoke(obj, "hello",100); // System.out.println(s); System.out.println("----------"); // private void function() Method m4 = c.getDeclaredMethod("function"); m4.setAccessible(true); m4.invoke(obj); &#125;&#125; 14.1 反射应用举例给ArrayList&lt;Integer&gt;的一个对象，在这个集合中添加一个字符串数据，如何实现呢？ 1234567891011121314151617181920212223242526272829package cn.itcast.test;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;/* * 我给你ArrayList&lt;Integer&gt;的一个对象，我想在这个集合中添加一个字符串数据，如何实现呢？ */public class ArrayListDemo &#123; public static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException &#123; // 创建集合对象 ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); // array.add("hello"); // array.add(10); Class c = array.getClass(); // 集合ArrayList的class文件对象 Method m = c.getMethod("add", Object.class); m.invoke(array, "hello"); // 调用array的add方法，传入的值是hello m.invoke(array, "world"); m.invoke(array, "java"); System.out.println(array); &#125;&#125; 通过配置文件运行类中的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.itcast.test;import java.io.FileReader;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.Properties;/* * 通过配置文件运行类中的方法 * * 反射： * 需要有配置文件配合使用。 * 用class.txt代替。 * 并且你知道有两个键。 * className * methodName */public class Test &#123; public static void main(String[] args) throws Exception &#123; // 反射前的做法 // Student s = new Student(); // s.love(); // Teacher t = new Teacher(); // t.love(); // Worker w = new Worker(); // w.love(); // 反射后的做法 // 加载键值对数据 Properties prop = new Properties(); FileReader fr = new FileReader("class.txt"); prop.load(fr); fr.close(); // 获取数据 String className = prop.getProperty("className"); String methodName = prop.getProperty("methodName"); // 反射 Class c = Class.forName(className); Constructor con = c.getConstructor(); Object obj = con.newInstance(); // 调用方法 Method m = c.getMethod(methodName); m.invoke(obj); &#125;&#125; 写一个方法：public void setProperty(Object obj, String propertyName, Object value){}，此方法可将obj对象中名为propertyName的属性的值设置为value12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.itcast.test;import java.lang.reflect.Field;public class Tool &#123; public void setProperty(Object obj, String propertyName, Object value) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123; // 根据对象获取字节码文件对象 Class c = obj.getClass(); // 获取该对象的propertyName成员变量 Field field = c.getDeclaredField(propertyName); // 取消访问检查 field.setAccessible(true); // 给对象的成员变量赋值为指定的值 field.set(obj, value); &#125;&#125;package cn.itcast.test;public class ToolDemo &#123; public static void main(String[] args) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException &#123; Person p = new Person(); Tool t = new Tool(); t.setProperty(p, "name", "林青霞"); t.setProperty(p, "age", 27); System.out.println(p); System.out.println("-----------"); Dog d = new Dog(); t.setProperty(d, "sex", '男'); t.setProperty(d, "price", 12.34f); System.out.println(d); &#125;&#125;class Dog &#123; char sex; float price; @Override public String toString() &#123; return sex + "---" + price; &#125;&#125;class Person &#123; private String name; public int age; @Override public String toString() &#123; return name + "---" + age; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载器]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[系列阅读 Java基础：类加载器 Java基础：反射 Java基础：注解 Java基础：动态代理 1. 什么是类加载器类加载器就是用来加载类的东西！类加载器也是一个类：ClassLoader 类加载器可以被加载到内存，是通过类加载器完成的！Java虚拟机中可以安装多个类加载器，系统默认三个主要类加载器，每个类负责加载特定位置的类： BootStrap：引导类加载器，加载rt.jar中的类 ExtClassLoader：扩展类加载器，加载lib/ext目录下的类 AppClassLoader：系统类加载器，加载CLASSPATH下的类，即我们写的类，以及第三方提供的类 类加载器之间存在上下级关系，系统类加载器的上级是扩展类加载器，而扩展类加载器的上级是引导类加载器 类加载器也是Java类，因为其它java类的类加载器本身也要被类加载器加载，显然必须有第一个类加载器不是java类，这正是BootStrap。 Java虚拟机中的所有类装载器采用具有父子关系的树形结构进行组织，在实例化每个类装载器对象时，需要为其指定一个父级类装载器对象或者默认采用系统类装载器为其父级类加载 2. 类的加载当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。 2.1 加载就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。 2.2 连接 验证：是否有正确的内部结构，并和其他类协调一致 准备：负责为类的静态成员分配内存，并设置默认初始化值 解析：将类的二进制数据中的符号引用替换为直接引用 2.3 初始化类会在首次被“主动使用”时执行初始化，为类（静态）变量赋予正确的初始值。在Java代码中，一个正确的初始值是通过类变量初始化语句或者静态初始化块给出的。 初始化一个类包括两个步骤： 如果类存在直接父类的话，且直接父类还没有被初始化，则先初始化其直接父类 如果类存在一个初始化方法，就执行此方法 注：初始化接口并不需要初始化它的父接口。 3. 类初始化时机 创建类的实例 访问类的静态变量，或者为静态变量赋值 调用类的静态方法 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 4. 类加载器负责将.class文件加载到内在中，并为之生成对应的Class对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。 4.1 类加载器的组成 BootstrapClassLoader 根类加载器 ExtensionClassLoader 扩展类加载器 SysetmClassLoader 系统类加载器 4.2类加载器的作用1、Bootstrap ClassLoader 根类加载器 也被称为引导类加载器，负责Java核心类的加载，比如System，String等。在JDK中JRE的lib目录下rt.jar文件中。 2、Extension ClassLoader 扩展类加载器 负责JRE的扩展目录中jar包的加载。在JDK中JRE的lib目录下ext目录 3、Sysetm ClassLoader 系统类加载器 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径。通过这些描述我们就可以知道我们常用的东西的加载都是由谁来完成的。到目前为止我们已经知道把class文件加载到内存了，那么，如果我们仅仅站在这些class文件的角度，我们如何来使用这些class文件中的内容呢?这就是我们反射要研究的内容。 5. JVM眼中的相同的类在JVM中，不可能存在一个类被加载两次的事情！一个类如果已经被加载了，当再次试图加载这个类时，类加载器会先去查找这个类是否已经被加载过了，如果已经被加载过了，就不会再去加载了。 但是，如果一个类使用不同的类加载器去加载是可以出现多次加载的情况的！也就是说，在JVM眼中，相同的类需要有相同的class文件，以及相同的类加载器。当一个class文件，被不同的类加载器加载了，JVM会认识这是两个不同的类，这会在JVM中出现两个相同的Class对象！甚至会出现类型转换异常！ 6. 类加载器的委托机制首先委托类加载器的父类去加载，如果父类无法加载则自己加载 当系统类加载器去加载一个类时，它首先会让上级去加载，即让扩展类加载器去加载类，扩展类加载器也会让它的上级引导类加载器去加载类。如果上级没有加载成功，那么再由自己去加载！ 例如我们自己写的Person类，一定是存放到CLASSPATH中，那么一定是由系统类加载器来加载。当系统类加载器来加载类时，它首先把加载的任务交给扩展类加载去，如果扩展类加载器加载成功了，那么系统类加载器就不会再去加载。这就是代理模式了！ 相同的道理，扩展类加载器也会把加载类的任务交给它的“上级”，即引导类加载器，引导类加载器加载成功，那么扩展类加载器也就不会再去加载了。引导类加载器是用C语言写的，是JVM的一部分，它是最上层的类加载器了，所以它就没有“上级了”。它只负责去加载“内部人”，即JDK中的类，但我们知道Person类不是我们自己写的类，所以它加载失败。 当扩展类加载器发现“上级”不能加载类，它就开始加载工作了，它加载的是lib\ext目录下的jar文件，当然，它也会加载失败，所以最终还是由系统类加载器在CLASSPATH中去加载Person，最终由系统类加载器加载到了Person类。 代理模式保证了JDK中的类一定是由引导类加载加载的！这就不会出现多个版本的类，这也是代理模式的好处。 6.1 类加载器之间的父子关系和管辖范围图 7. 自定义类加载器我们也可以通过继承ClassLoader类来完成自定义类加载器，自定义类加载器的目的一般是为了加载网络上的类，因为这会让class在网络中传输，为了安全，那么class一定是需要加密的，所以需要自定义的类加载器来加载（自定义的类加载器需要做解密工作）。 ClassLoader加载类都是通过loadClass()方法来完成的，loadClass()方法的工作流程如下： 调用findLoadedClass()方法查看该类是否已经被加载过了，如果该没有加载过，那么这个方法返回null 判断findLoadedClass()方法返回的是否为null，如果不是null那么直接返回，这可以避免同一个类被加载两次 如果findLoadedClass()返回的是null，那么就启动代理模式（委托机制），即调用上级的loadClass()方法，获取上级的方法是getParent()，当然上级可能还有上级，这个动作就一直向上走 如果getParent().loadClass()返回的不是null，这说明上级加载成功了，那么就加载结果 如果上级返回的是null，这说明需要自己出手了，这时loadClass()方法会调用本类的findClass()方法来加载类 这说明我们只需要重写ClassLoader的findClass()方法，这就可以了！如果重写了loadClass()方法覆盖了代理模式！ OK，通过上面的分析，我们知道要自定义一个类加载器，只需要继承ClassLoader类，然后重写它的findClass()方法即可。那么在findClass()方法中我们要完成哪些工作呢？ 找到class文件，把它加载到一个byte[]中； 调用defineClass()方法，把byte[]传递给这个方法即可。 loadClass()方法的实现代码12345678910111213141516171819202122protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = findLoadedClass(className); if (clazz == null) &#123; ClassNotFoundException suppressed = null; try &#123; clazz = parent.loadClass(className, false); &#125; catch (ClassNotFoundException e) &#123; suppressed = e; &#125; if (clazz == null) &#123; try &#123; clazz = findClass(className); &#125; catch (ClassNotFoundException e) &#123; e.addSuppressed(suppressed); throw e; &#125; &#125; &#125; return clazz;&#125; 自定义类加载器FileSystemClassLoader1234567891011121314151617181920212223242526272829public class FileSystemClassLoader extends ClassLoader &#123; private String classpath; public FileSystemClassLoader() &#123;&#125; public FileSystemClassLoader(String classpath) &#123; this.classpath = classpath; &#125; @Override public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; try &#123; byte[] datas = getClassData(name); if(datas == null) &#123; throw new ClassNotFoundException("类没有找到：" + name); &#125; return this.defineClass(name, datas, 0, datas.length); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new ClassNotFoundException("类找不到：" + name); &#125; &#125; private byte[] getClassData(String name) throws IOException &#123; name = name.replace(".", "\\") + ".class"; File classFile = new File(classpath, name); return FileUtils.readFileToByteArray(classFile); &#125;&#125; 12345ClassLoader loader = new FileSystemClassLoader("F:\\classpath");Class clazz = loader.loadClass("cn.itcast.utils.CommonUtils");Method method = clazz.getMethod("md5", String.class);String result = (String) method.invoke(null, "qdmmy6");System.out.println(result); 8. ClassLoader 方法 说明 getParent() 获取上级类加载器 loadClass() 实现了类加载的加载流程，也就是算法框架 findLoadedClass() 查看该类是否被加载过 findClass() 真正去加载类，自定义类加载器需要重写的方法 defineClass() 把Class的字节数组byte[]转成Class]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[系列阅读 Java基础：类加载器 Java基础：反射 Java基础：注解 Java基础：动态代理 1. 概述注解相当于一种标记，在程序中加了注解就等于为程序打上了某种标记，没加，则等于没有某种标记，以后，javac编译器，开发工具和其他程序可以用反射来了解你的类及各种元素上有无何种标记，看你有什么标记，就去干相应的事。标记可以加在包，类，字段，方法，方法的参数以及局部变量上 开发中常见注解： @Override：作用在方法上的注解。当方法不是重写父类的方法时会报错 @Deprecated：作用在方法上。标记该方法为作废方法（已过时） @SuppressWarnings：作用在方法上，压制警告 应用 标记一些信息 运行时动态处理 编译时动态处理 2. 注解类型8种基本数据类型，String，Class，enum，annotation，以上类型的数组类型 3. 定义注解123456@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface ViewInject &#123; int value();//当使用注解时，如果只给名为value的属性赋值时，可以省略“value=” String name() default "zhangsan";//默认值&#125; @interface使用@interface声明一个注解类 @Target表示注解的作用目标，是一个枚举值 作用目标 说明 ElementType.FIELD 作用于成员变量 ElementType.METHOD 作用于方法 ElementType.CONSTRUCTOR 作用于构造方法 ElementType.PARAMETER 作用于方法的参数 ElementType.TYPE 作用于类，接口，enum， Annotation @Retention表示注解的保存策略，也是一个枚举值 注解的保留策略是指，注解是只保留在源代码上，还是保留到class文件上，再或者是类在运行时，可以被类加载器加载到内存中。 如果希望注解被反射，那么注解就要保留到运行时，而不是源代码或类文件上。 指定注解的保留策略需要使用元注解@Retention，它有一个value属性，类型为RetentionPolicy类型，RetentionPolicy是枚举类型 保存策略 说明 RetentionPolicy.SOURCE 注解只保存在源代码中，即.java文件 RetentionPolicy.CLASS 注解保存在字节码中,即.class文件 RetentionPolicy.RUNTIME 注解保存在内存中的字节码，可用于反射 注解的属性1String name() default "zhangsan";//默认值 定义注解的属性，有点像java类中的方法，上面的代码定义了一个类型为String类型，注解名为name的属性，default是给注解设置默认值 value属性1String value() default "xxx"; 如果注解中有一个名称为value的属性，且你只想设置value属性（即其他属性都采用默认值或者你只有一个value属性），那么可以省略value=部分，例如：@MyAnnotation(“AllenIverson”) 数组类型的属性12int [] arrayAttr() default &#123;1,2,3&#125;;//定义@MyAnnotation(arrayAttr=&#123;2,3,4&#125;)//使用 如果数组属性中只有一个元素，这时候属性值部分可以省略大括 4. Annotation4.1 注解的应用结构图 Annotation 方法声明 功能描述 annotationType() 获取注解类型 4.2 反射注解类上的注解：使用Class获取 Class.getAnnotation()：获取指定类型的注解 Class.getAnnotations()：获取所有的注解 Class.getDeclaredAnnotations()：获取除了继承得到的所有注解 方法上的注解：使用Method获取 Method.getAnnotation() ：获取方法上指定类型的注解 Method.getAnnotations()：获取所有的注解 Method.getDeclaredAnnotations()：获取除了继承得到的所有注解 构造方法上的注解：使用Constructor获取 Constructor.getAnnotation()获取指定类型的注解 Constructor.getAnnotations()获取所有的注解 Constructor.getDeclaredAnnotations() 获取除了继承得到的所有注解 属性上的注解：使用Field获取 Field.getAnnotation()：获取字段上指定类型的注解 Field.getAnnotations()：获取所有的注解 Field.getDeclaredAnnotations()：获取字段所有的注解 定义注解123456@Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface MyAnn &#123; String value() default "hello"; int value1() default 100;&#125; 使用注解 1234567@MyAnn(value="hello world", value1=200)public class MyClass &#123; private int a; @MyAnn("myMethod") public void fun() &#123;&#125;&#125; 通过反射读取注解 12345678910111213public class Demo1 &#123; public static void main(String[] args) throws Exception &#123; Class clazz = MyClass.class; MyAnn myAnn = (MyAnn) clazz.getAnnotation(MyAnn.class); System.out.println(myAnn.value()); System.out.println(myAnn.value1()); Method method = clazz.getMethod("fun"); MyAnn myAnn1 = method.getAnnotation(MyAnn.class); System.out.println(myAnn1.value()); System.out.println(myAnn1.value1()); &#125;&#125; 4.3 实现注解小框架123456789101112131415161718192021222324252627282930313233343536373839404142public class ViewUtils &#123; public static void inject(Activity activity) throws IllegalAccessException &#123; bindView(activity); &#125; private static void bindView(Activity activity) throws IllegalAccessException &#123; Field[] fields = activity.getClass().getDeclaredFields(); for (Field field : fields)&#123; ViewInject viewInject = field.getAnnotation(ViewInject.class); if (viewInject != null)&#123; int resId = viewInject.value(); View view = activity.findViewById(resId); field.setAccessible(true); field.set(activity,view); &#125; &#125; &#125; public static void onClick(final Activity activity)&#123; Method[] methods = activity.getClass().getDeclaredMethods(); for (final Method method : methods)&#123; Onclick onclick = method.getAnnotation(Onclick.class); if (onclick != null)&#123; int resId = onclick.value(); final View view = activity.findViewById(resId); view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; method.setAccessible(true); try &#123; method.invoke(activity,view); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; &#125;&#125; 5. Annotation Processing Tool编译时注解在项目编译的时候生成新的Java文件，这样可以减少手动的代码输入，而且可以不用使用反射，对程序不会造成性能影响。 AbstractProcessor注解处理器，javac 自带的一个工具，用来在编译时期扫描处理注解信息 process() init() Filer Elements Messager Android 如何编写基于编译时注解的项目 Android 打造编译时注解解析框架 这只是一个开始 Android公共技术点之二-Annotation Processing Tool Annotation-Processing-Tool详解 Java 生成器源代码集合 6. javapoet动态生成Java代码，ButterKnife使用了该框架，实现了编译时注解 javapoet——让你从重复无聊的代码中解放出来 7. 注解框架 Dagger1 Dagger2 Guice Butterknife androidannotations]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[系列阅读 Java基础：类加载器 Java基础：反射 Java基础：注解 Java基础：动态代理 1. 概述在运行时，动态创建一组指定的接口的实现类对象（代理对象）！ 代理是实现AOP（面向切面编程）的核心和关键技术，动态代理的用途与装饰模式很相似，就是为了对某个对象进行增强。所有使用装饰者模式的案例都可以使用动态代理来替换。 代理：本来应该自己做的事情，却请了别人来做，被请的人就是代理对象。 举例：春季回家买票让人代买 动态代理：在程序运行过程中产生的这个对象 而程序运行过程中产生对象其实就是我们刚才反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理 2. 工作原理 client调用代理 代理的构造方法接收一个invocationhandler参数 client调用代理的各个方法，代理的各个方法会把调用请求转发给invocationhandler invocationhandler通过invoke()方法把调用请求分发给目标对象的各个方法 1、在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib。 2、Proxy类中的方法创建动态代理类对象 1234public static Object newProxyInstance( ClassLoader loader, Class&lt;?&gt;[]interfaces, InvocationHandler h) 返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。最终会调用InvocationHandler的方法 3、InvocationHandler 1Object invoke(Object proxy,Method method,Object[] args) 在代理实例上处理方法调用并返回结果。 4、Proxy类中创建动态代理对象的方法的三个参数 ClassLoader对象定义了由哪个ClassLoader对象来对生成的代理对象进行加载 Interface对象的数组表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了 InvocationHandler对象表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的invoke 方法来进行调用。 5、InvocationHandler接口中invoke()方法的三个参数： Object proxy：代表动态代理对象 Method method：代表正在执行的方法 Object[] args：代表调用目标方法时传入的实参 6、Proxy.newProxyInstance() 创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号 3. 动态代理的实现1234567891011package cn.itcast_06;/* * 用户操作接口 */public interface UserDao &#123; public abstract void add(); public abstract void delete(); public abstract void update(); public abstract void find();&#125; 1234567package cn.itcast_06;public interface StudentDao &#123; public abstract void login(); public abstract void regist();&#125; 12345678910111213141516171819202122package cn.itcast_06;public class UserDaoImpl implements UserDao &#123; @Override public void add() &#123; System.out.println("添加功能"); &#125; @Override public void delete() &#123; System.out.println("删除功能"); &#125; @Override public void update() &#123; System.out.println("修改功能"); &#125; @Override public void find() &#123; System.out.println("查找功能"); &#125;&#125; 1234567891011121314package cn.itcast_06;public class StudentDaoImpl implements StudentDao &#123; @Override public void login() &#123; System.out.println("登录功能"); &#125; @Override public void regist() &#123; System.out.println("注册功能"); &#125;&#125; 123456789101112131415161718192021package cn.itcast_06;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler &#123; private Object target; // 目标对象 public MyInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("权限校验"); Object result = method.invoke(target, args); System.out.println("日志记录"); return result; // 返回的是代理对象 &#125;&#125; 12345678910111213141516171819202122232425262728293031323334package cn.itcast_06;import java.lang.reflect.Proxy;public class Test &#123; public static void main(String[] args) &#123; UserDao ud = new UserDaoImpl(); ud.add(); ud.delete(); ud.update(); ud.find(); System.out.println("-----------"); // 我们要创建一个动态代理对象 // Proxy类中有一个方法可以创建动态代理对象 // public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] // interfaces,InvocationHandler h) // 我准备对ud对象做一个代理对象 MyInvocationHandler handler = new MyInvocationHandler(ud); UserDao proxy = (UserDao) Proxy.newProxyInstance(ud.getClass() .getClassLoader(), ud.getClass().getInterfaces(), handler); proxy.add(); proxy.delete(); proxy.update(); proxy.find(); System.out.println("-----------"); StudentDao sd = new StudentDaoImpl(); MyInvocationHandler handler2 = new MyInvocationHandler(sd); StudentDao proxy2 = (StudentDao) Proxy.newProxyInstance(sd.getClass() .getClassLoader(), sd.getClass().getInterfaces(), handler2); proxy2.login(); proxy2.regist(); &#125;&#125; 4. Spring原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class ProxyFactoryBean &#123; private Object mTarget; private Advice mAdvice; public Object getProxy()&#123; Object proxy = Proxy.newProxyInstance( mTarget.getClass().getClassLoader(), mTarget.getClass().getInterfaces(), mHandler ); return proxy; &#125; private InvocationHandler mHandler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; mAdvice.beforeMethod(method); Object result = method.invoke(mTarget, args); mAdvice.afterMethod(method); return result; &#125; &#125;; public void setTarget(Object target) &#123; mTarget = target; &#125; public void setAdvice(Advice advice) &#123; mAdvice = advice; &#125; public Object getTarget() &#123; return mTarget; &#125; public Advice getAdvice() &#123; return mAdvice; &#125;&#125;public class BeanFactory &#123; Properties mProperties = new Properties(); public BeanFactory(InputStream in)&#123; try &#123; mProperties.load(in); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public Object getBean(String name)&#123; String classname = mProperties.getProperty(name); Object bean = null; try &#123; Class clazz = Class.forName(classname); bean = clazz.newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (bean instanceof ProxyFactoryBean)&#123; Object proxy = null; ProxyFactoryBean factoryBean = (ProxyFactoryBean) bean; Advice advice = null; try &#123; advice = (Advice) Class.forName(mProperties.getProperty(name+".advice")).newInstance(); Object target = Class.forName(mProperties.getProperty(name+".target")).newInstance(); factoryBean.setAdvice(advice); factoryBean.setTarget(target); proxy = factoryBean.getProxy(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return proxy; &#125; return bean; &#125;&#125; 1234public interface Advice &#123; void beforeMethod(Method method); void afterMethod(Method method);&#125; 123456789public class AopFrameworkTest &#123; public static void main(String[] args) throws Exception &#123; InputStream ips = AopFrameworkTest.class.getResourceAsStream("config.properties"); Object bean = new BeanFactory(ips).getBean("xxx"); System.out.println(bean.getClass().getName()); ((Collection)bean).clear(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给那些让我糊里糊涂的HTTP、TCP、UDP、Socket]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E5%86%99%E7%BB%99%E9%82%A3%E4%BA%9B%E8%AE%A9%E6%88%91%E7%B3%8A%E9%87%8C%E7%B3%8A%E6%B6%82%E7%9A%84HTTP%E3%80%81TCP%E3%80%81UDP%E3%80%81Socket%2F</url>
    <content type="text"><![CDATA[写给那些让我糊里糊涂的HTTP、TCP、UDP、Socket先来一个讲TCP、UDP和HTTP关系的，注意红色mark的部分 1. TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。在传输层中有TCP协议与UDP协议。在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。 2. HTTP协议是建立在请求/响应模型上的。首先由客户建立一条与服务器的TCP链接，并发送一个请求到服务器，请求中包含请求方法、URI、协议版本以及相关的MIME样式的消息。服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的MIME式样的消息。 HTTP/1.0为每一次HTTP的请求/响应建立一条新的TCP链接，因此一个包含HTML内容和图片的页面将需要建立多次的短期的TCP链接。一次TCP链接的建立将需要3次握手。 另外，为了获得适当的传输速度，则需要TCP花费额外的回路链接时间（RTT）。每一次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只是保证链接的可靠性，因此HTTP/1.1提出了可持续链接的实现方法。HTTP/1.1将只建立一次TCP的链接而重复地使用它传输一系列的请求/响应消息，因此减少了链接建立的次数和经常性的链接开销。 3. 结论虽然HTTP本身是一个协议，但其最终还是基于TCP的。不过，目前，有人正在研究基于TCP+UDP混合的HTTP协议。 4. Socket是什么呢？Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 socket、tcp、udp、http 的认识及区别1. 先来一个讲TCP、UDP和HTTP关系的1.1 TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议与UDP协议。在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。 1.2 HTTP协议是建立在请求/响应模型上的。首先由客户建立一条与服务器的TCP链接，并发送一个请求到服务器， 请求中包含请求方法、URI、协议版本以及相关的MIME样式的消息。 服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的MIME式样的消息。 HTTP/1.0为每一次HTTP的请求/响应建立一条新的TCP链接， 因此一个包含HTML内容和图片的页面将需要建立多次的短期的TCP链接。 一次TCP链接的建立将需要3次握手。 另外，为了获得适当的传输速度，则需要TCP花费额外的回路链接时间（RTT）。 每一次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只是保证链接的可靠性，因此HTTP/1.1提出了可持续链接的实现方法。 HTTP/1.1将只建立一次TCP的链接而重复地使用它传输一系列的请求/响应消息，因此减少了链接建立的次数和经常性的链接开销。 1.3 结论虽然HTTP本身是一个协议，但其最终还是基于TCP的。不过，目前，有人正在研究基于TCP+UDP混合的HTTP协议。 Socket是什么呢？Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中， Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面， 对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 2. TCP、UDP、HTTP、SOCKET之间的区别TCP和UDP：传输层协议； HTTP：应用层协议； SOCKET：TCP/IP网络的API。 TCP/IP代表传输控制协议/网际协议，指的是一系列协议。 TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。 TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。 TCP和UDP是FTP、HTTP和SMTP之类使用的传输层协议。 虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。 这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。 HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。 客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。 记住，需要IP协议来连接网络;TCP是一种允许我们安全传输数据的机制，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的特殊协议。 Socket 接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，用以开发TCP/IP网络上的应用程序。 3. socket、tcp、udp、http 的认识及区别网络由下往上分为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 IP 协议对应于网络层，TCP协议对应于传输层，HTTP协议对应于应用层，三者从本质上来说没有可比性，socket则是对TCP/IP协议的封装和应用。 可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据；socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。 实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、 listen、connect、accept、send、read和write等等 实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口 4. TCP连接的三次握手第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据 断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手” TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上（实际上也很大程度上保证了）保证了连接的可靠性； 而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号， 发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议 也正由于上面的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。 所以采用TCP传输协议的MSN比采用UDP的QQ传输文件慢，但并不能说QQ的通信是不安全的，因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，即使是这样，UDP因为在底层协议的封装上没有采用类似 TCP的“三次握手”而实现了TCP所无法达到的传输效率。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 网络编程概述1.1 计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。 1.2 网络编程就是用来实现网络互连的不同计算机上运行的程序间可以进行数据交换。 1.3 网络模型计算机网络之间以何种规则进行通信，就是网络模型研究问题。 网络模型一般是指OSI（Open System Interconnection开放系统互连）参考模型或者TCP/IP参考模型。 应用层：http、https、ftp，传输层：TCP、UDP，网络层：IP，物理层，数据链路层 1.4 网络模型7层概述 物理层 主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 数据链路层 主要将从物理层接收的数据进行MAC地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。 网络层 主要将从下层接收到的数据进行IP地址（例192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。 传输层 定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 会话层 通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） 表示层 主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。 应用层 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西．就是终端应用）。 PS： 每个网卡的MAC地址都是全球唯一的。 路由器实现将数据包发送到指定的地点。 应用软件之间通信的过程就是层与层之间封包、解封包的过程。 OSI参考模型虽然设计精细，但过于麻烦，效率不高，因此才产生了简化版的TCP/IP参考模型。 1.5 封包、解封包的过程 2. 网络编程三要素网络模型说完了,我们要进行通讯,需要哪些要素呢? 比如说：我要跟你说话第一个条件：我要先找到你 (IP)第二个条件：你得有接收数据的地方，耳朵 (端口)第三个条件：我跟你说话,你能接收到,咱按什么方式接收啊,我说英文你懂吗,说韩文你懂吗,不懂是吧,所以我还是说中文把(协议) 2.1 IP地址网络中计算机的唯一标识，不易记忆，可用主机名。本地回环地址：127.0.0.1，主机名：localhost。计算机只能识别二进制的数据，所以我们的IP地址应该是一个二进制的数据。为了方便表示IP地址，我们就把IP地址的每一个字节上的数据换算成十进制，然后用.分开来表示：”点分十进制”。 所谓IP地址就是给每个连接在Internet上的主机分配的一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，比特换算成字节，就是4个字节。例如一个采用二进制形式的IP地址是“00001010000000000000000000000001”，这么长的地址，人们处理起来也太费劲了。为了方便人们的使用，IP地址经常被写成十进制的形式，中间使用符号“.”分开不同的字节。于是，上面的IP地址可以表示为“10.0.0.1”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多。 通过ping 127.0.0.1可以测试网络是不是通，如果不通，可能是网卡出问题了 通过ping命令还可以获取到url对应的IP地址，例如获取网易新闻url（c.m.163.com）的IP地址 查看本机IP地址ipconfig IP地址分类IP地址的组成：IP地址 = 网络号码+主机地址 IPV4数量已经不够分配，所以产生了IPV6。 InetAddress类的使用此类表示互联网协议 (IP) 地址 返回值 方法 说明 InetAddress getByName(String host) 根据主机名或者IP地址的字符串表示得到IP地址对象 String getHostName() 获取此 IP 地址的主机名 String getHostAddress() 返回 IP 地址字符串 代码示例：123456789101112131415161718package cn.itcast_01;import java.net.InetAddress;import java.net.UnknownHostException;public class InetAddressDemo &#123; public static void main(String[] args) throws UnknownHostException &#123; // public static InetAddress getByName(String host) // InetAddress address = InetAddress.getByName("liuyi"); // InetAddress address = InetAddress.getByName("192.168.12.92"); InetAddress address = InetAddress.getByName("192.168.12.63"); // 获取两个东西：主机名，IP地址 // public String getHostName() String name = address.getHostName(); // public String getHostAddress() String ip = address.getHostAddress(); System.out.println(name + "---" + ip); &#125;&#125; 运行结果： 2.2 端口号正在运行的程序的标识，用于标识进程的逻辑地址，不同进程的标识。有效端口：0~65535，其中0~1024系统使用或保留端口。 端口分为：物理端口，网卡口；逻辑端口，我们指的就是逻辑端口。 A：每个网络程序都会至少有一个逻辑端口 B：用于标识进程的逻辑地址，不同进程的标识 C：有效端口：0~65535，其中0~1024系统使用或保留端口。 D：所谓防火墙，其功能就是将发送到某程序端口的数据屏蔽掉以及将从该程序端口发出的数据也屏蔽掉。 2.3 传输协议传输协议就是通讯的规则，常见协议：TCP，UDP。 UDP将数据源和目的封装成数据包中，不需要建立连接；每个数据报的大小在限制在64k；因无连接，是不可靠协议；不需要建立连接，速度快 TCP建立连接，形成传输数据的通道；在连接中进行大数据量传输；通过三次握手完成连接，是可靠协议；必须建立连接，效率会稍低 UDP和TCP的特点 UDP：面向无连接；不可靠；速度快；将数据封包传输，数据包最大64k举例：聊天留言，在线视频，视频会议，发短信，邮局包裹。 TCP：面向连接；安全可靠效率稍低；通过三次握手确保连接的建立。举例：下载，打电话，QQ聊天(你在线吗,在线,就回应下,就开始聊天了) 2.4 域名解析在浏览器中输入新浪的域名，DNS解析域名成IP，然后计算机再通过获取到的IP访问新浪服务器。 域名解析，最先走是本地的hosts（C:\WINDOWS\system32\drivers\etc\hosts）文件，解析失败了，才去访问DNS服务器解析、获取IP地址。 123456789101112131415import java.net.InetAddress;import java.net.UnknownHostException;public class IPDemo&#123; public static void main(String[] args) throws UnknownHostException &#123; InetAddress ip = InetAddress.getLocalHost(); ip = InetAddress.getByName("192.168.1.110"); System.out.println(ip.getHostAddress()); System.out.println(ip.getHostName()); &#125;&#125; 运行结果 应用：通过hosts文件可以屏蔽游戏网站内容弹出，例如：在hosts文件中添加，127.0.0.1 www.game18.com 3. Socket套接字3.1 Socket套接字网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。 3.2 Socket原理机制 通信的两端都有Socket 网络通信其实就是Socket间的通信 数据在两个Socket间通过IO传输 3.3 Socket机制图解 4. UDP编程UDP：UDP 协议全称是用户数据报协议，在网络中它与TCP 协议一样用于处理数据包，是一种无连接的协议。在OSI 模型中，在第四层——传输层，处于IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。UDP 协议从问世至今已经被使用了很多年，虽然其最初的光彩已经被一些类似协议所掩盖，但是即使是在今天UDP 仍然不失为一项非常实用和可行的网络传输层协议。 4.1 UDP传输 DatagramSocket与DatagramPacket 建立发送端，接收端 建立数据包 调用Socket的发送接收方法 关闭Socket 发送端与接收端是两个独立的运行程序 4.2 DatagramSocket此类表示用来发送和接收数据报包的套接字 数据报套接字是包投递服务的发送或接收点。每个在数据报套接字上发送或接收的包都是单独编址和路由的。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达 在 DatagramSocket 上总是启用 UDP 广播发送。为了接收广播包，应该将 DatagramSocket 绑定到通配符地址。在某些实现中，将 DatagramSocket 绑定到一个更加具体的地址时广播包也可以被接收。 构造方法 12DatagramSocket(int port) // 创建数据报套接字并将其绑定到本地主机上的指定端口DatagramSocket(int port, InetAddress laddr) // 创建数据报套接字，将其绑定到指定的本地地址 UDP传输-发送端思路 建立udp的socket服务 将要发送的数据封装成数据包 通过udp的socket服务,将数据包发送出 关闭资源 123456789101112131415161718192021222324252627282930313233343536373839package cn.itcast_02;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;/* * UDP协议发送数据： * A:创建发送端Socket对象 * B:创建数据，并把数据打包 * C:调用Socket对象的发送方法发送数据包 * D:释放资源 */public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建发送端Socket对象 // DatagramSocket() DatagramSocket ds = new DatagramSocket(); // 创建数据，并把数据打包 // DatagramPacket(byte[] buf, int length, InetAddress address, int port) // 创建数据 byte[] bys = "hello,udp,我来了".getBytes(); // 长度 int length = bys.length; // IP地址对象 InetAddress address = InetAddress.getByName("192.168.12.92"); // 端口 int port = 10086; DatagramPacket dp = new DatagramPacket(bys, length, address, port); // 调用Socket对象的发送方法发送数据包 // public void send(DatagramPacket p) ds.send(dp); // 释放资源 ds.close(); &#125;&#125; 4.3 DatagramPacket此类表示数据报包。数据报包用来实现无连接包投递服务。每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。不对包投递做出保证。 构造方法 DatagramPacket(byte[] buf, int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 DatagramPacket(byte[] buf, int length, InetAddress address, int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。 DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port)构造数据报包，用来将长度为 length 偏移量为 offset 的包发送到指定主机上的指定端口号。 UDP传输-接收端思路 建立udp的socket服务. 通过receive方法接收数据 将收到的数据存储到数据包对象中 通过数据包对象的功能来完成对接收到数据进行解析 可以对资源进行关闭 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.itcast_02;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;/* * UDP协议接收数据： * A:创建接收端Socket对象 * B:创建一个数据包(接收容器) * C:调用Socket对象的接收方法接收数据 * D:解析数据包，并显示在控制台 * E:释放资源 */public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建接收端Socket对象 // DatagramSocket(int port) DatagramSocket ds = new DatagramSocket(10086); // 创建一个数据包(接收容器) // DatagramPacket(byte[] buf, int length) byte[] bys = new byte[1024]; int length = bys.length; DatagramPacket dp = new DatagramPacket(bys, length); // 调用Socket对象的接收方法接收数据 // public void receive(DatagramPacket p) ds.receive(dp); // 阻塞式 // 解析数据包，并显示在控制台 // 获取对方的ip // public InetAddress getAddress() InetAddress address = dp.getAddress(); String ip = address.getHostAddress(); // public byte[] getData():获取数据缓冲区 // public int getLength():获取数据的实际长度 byte[] bys2 = dp.getData(); int len = dp.getLength(); String s = new String(bys2, 0, len); System.out.println(ip + "传递的数据是:" + s); // 释放资源 ds.close(); &#125;&#125; 运行结果： 4.4 UDP案例从键盘录入数据进行发送，如果输入的是886那么客户端就结束输入数据。 发送端 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.itcast_04;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;/* * 数据来自于键盘录入 * 键盘录入数据要自己控制录入结束。 */public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建发送端的Socket对象 DatagramSocket ds = new DatagramSocket(); // 封装键盘录入数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String line = null; while ((line = br.readLine()) != null) &#123; if ("886".equals(line)) &#123; break; &#125; // 创建数据并打包 byte[] bys = line.getBytes(); // DatagramPacket dp = new DatagramPacket(bys, bys.length, // InetAddress.getByName("192.168.12.92"), 12345); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName("192.168.12.255"), 12345); // 发送数据 ds.send(dp); &#125; // 释放资源 ds.close(); &#125;&#125; 运行结果： 接收端 1234567891011121314151617181920212223242526272829303132333435package cn.itcast_04;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;/* * 多次启动接收端： * java.net.BindException: Address already in use: Cannot bind * 端口被占用。 */public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建接收端的Socket对象 DatagramSocket ds = new DatagramSocket(12345); while (true) &#123; // 创建一个包裹 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); // 接收数据 ds.receive(dp); // 解析数据 String ip = dp.getAddress().getHostAddress(); String s = new String(dp.getData(), 0, dp.getLength()); System.out.println("from " + ip + " data is : " + s); &#125; // 释放资源 // 接收端应该一直开着等待接收数据，是不需要关闭 // ds.close(); &#125;&#125; 运行结果： 5. TCP编程TCP/IP：Transmission Control Protocol/Internet Protocol 的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet 最基本的协议、Internet 国际互联网络的基础，由网络层的IP 协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。协议采用了4 层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。通俗而言：TCP 负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP 是给因特网的每一台联网设备规定一个地址。 TCP/IP 协议栈主要分为四层:应用层、传输层、网络层、数据链路层,每层都有相应的协议，如下图： 所谓的协议就是双方进行数据传输的一种格式。 5.1 TCP传输 Socket和ServerSocket 建立客户端和服务器端 建立连接后，通过Socket中的IO流进行数据的传输 关闭socket 同样，客户端与服务器端是两个独立的应用程序。 5.2 Socket此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。 构造方法 Socket(String host, int port) ：创建一个流套接字并将其连接到指定主机上的指定端口号。 Socket(InetAddress address, int port) ：创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 TCP传输-客户端思路 建立客户端的Socket服务,并明确要连接的服务器。 如果连接建立成功,就表明,已经建立了数据传输的通道.就可以在该通道通过IO进行数据的读取和写入.该通道称为Socket流,Socket流中既有读取流,也有写入流. 通过Socket对象的方法,可以获取这两个流 通过流的对象可以对数据进行传输 如果传输数据完毕,关闭资源 123456789101112131415161718192021222324252627282930313233package cn.itcast_06;import java.io.IOException;import java.io.OutputStream;import java.net.Socket;/* * TCP协议发送数据： * A:创建发送端的Socket对象 * 这一步如果成功，就说明连接已经建立成功了。 * B:获取输出流，写数据 * C:释放资源 * * 连接被拒绝。TCP协议一定要先看服务器。 * java.net.ConnectException: Connection refused: connect */public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建发送端的Socket对象 // Socket(InetAddress address, int port) // Socket(String host, int port) // Socket s = new Socket(InetAddress.getByName("192.168.12.92"), 8888); Socket s = new Socket("192.168.12.92", 8888); // 获取输出流，写数据 // public OutputStream getOutputStream() OutputStream os = s.getOutputStream(); os.write("hello,tcp,我来了".getBytes()); // 释放资源 s.close(); &#125;&#125; 5.3 ServerSocket此类实现服务器套接字。服务器套接字等待请求通过网络传入。它基于该请求执行某些操作，然后可能向请求者返回结果。 构造方法1ServerSocket(int port) // 创建绑定到特定端口的服务器套接字 TCP传输-服务器端思路 建立服务器端的socket服务，需要一个端口 服务端没有直接流的操作,而是通过accept方法获取客户端对象，在通过获取到的客户端对象的流和客户端进行通信 通过客户端的获取流对象的方法,读取数据或者写入数据 如果服务完成,需要关闭客户端,然后关闭服务器，但是,一般会关闭客户端,不会关闭服务器,因为服务端是一直提供服务的 12345678910111213141516171819202122232425262728293031323334353637383940package cn.itcast_06;import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;/* * TCP协议接收数据： * A:创建接收端的Socket对象 * B:监听客户端连接。返回一个对应的Socket对象 * C:获取输入流，读取数据显示在控制台 * D:释放资源 */public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建接收端的Socket对象 // ServerSocket(int port) ServerSocket ss = new ServerSocket(8888); // 监听客户端连接。返回一个对应的Socket对象 // public Socket accept() Socket s = ss.accept(); // 侦听并接受到此套接字的连接。此方法在连接传入之前一直阻塞。 // 获取输入流，读取数据显示在控制台 InputStream is = s.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); // 阻塞式方法 String str = new String(bys, 0, len); String ip = s.getInetAddress().getHostAddress(); System.out.println(ip + "---" + str); // 释放资源 s.close(); // ss.close(); //这个不应该关闭 &#125;&#125; 5.4 TCP传输案例客户端键盘录入，服务器输出到控制台 客户端： 12345678910111213141516171819202122232425262728293031323334353637383940package cn.itcast_08;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;/* * 客户端键盘录入，服务器输出到控制台 */public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建客户端Socket对象 Socket s = new Socket("192.168.12.92", 22222); // 键盘录入数据 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // 把通道内的流给包装一下 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter( s.getOutputStream())); String line = null; while ((line = br.readLine()) != null) &#123; // 键盘录入数据要自定义结束标记 if ("886".equals(line)) &#123; break; &#125; bw.write(line); bw.newLine(); bw.flush(); &#125; // 释放资源 // bw.close(); // br.close(); s.close(); &#125;&#125; 运行结果： 服务器端： 1234567891011121314151617181920212223242526272829package cn.itcast_08;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; // 创建服务器Socket对象 ServerSocket ss = new ServerSocket(22222); // 监听客户端连接 Socket s = ss.accept(); // 包装通道内容的流 BufferedReader br = new BufferedReader(new InputStreamReader( s.getInputStream())); String line = null; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; // br.close(); s.close(); // ss.close(); &#125;&#125; 运行结果： 5.5 上传图片案例客户端： 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.itcast_13;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.net.Socket;public class UploadClient &#123; public static void main(String[] args) throws IOException &#123; // 创建客户端Socket对象 Socket s = new Socket("192.168.12.92", 19191); // 封装图片文件 BufferedInputStream bis = new BufferedInputStream(new FileInputStream( "林青霞.jpg")); // 封装通道内的流 BufferedOutputStream bos = new BufferedOutputStream(s.getOutputStream()); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); bos.flush(); &#125; s.shutdownOutput(); // 读取反馈 InputStream is = s.getInputStream(); byte[] bys2 = new byte[1024]; int len2 = is.read(bys2); String client = new String(bys2, 0, len2); System.out.println(client); // 释放资源 bis.close(); s.close(); &#125;&#125; 服务器端： 123456789101112131415161718192021222324252627282930313233343536373839package cn.itcast_13;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;public class UploadServer &#123; public static void main(String[] args) throws IOException &#123; // 创建服务器Socket对象 ServerSocket ss = new ServerSocket(19191); // 监听客户端连接 Socket s = ss.accept(); // 封装通道内流 BufferedInputStream bis = new BufferedInputStream(s.getInputStream()); // 封装图片文件 BufferedOutputStream bos = new BufferedOutputStream( new FileOutputStream("mn.jpg")); byte[] bys = new byte[1024]; int len = 0; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); bos.flush(); &#125; // 给一个反馈 OutputStream os = s.getOutputStream(); os.write("图片上传成功".getBytes()); bos.close(); s.close(); &#125;&#125; 运行结果： 5.6 TCP传输容易出现的问题 客户端连接上服务端，两端都在等待，没有任何数据传输 通过例程分析：因为read方法或者readLine方法是阻塞式 解决办法：自定义结束标记，使用shutdownInput，shutdownOutput方法 6. TCP、UDP 特点对比TCP 协议是面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达)传输层协议。UDP 协议也是传输层协议，它是无连接，不保证可靠的传输层协议。 TCP UDP 面向连接 面向非连接 可靠的连接 不可靠的连接 速度慢 速度快 大文件、重要的数据等 适合小数据、不重要 7. TCP 三次握手过程1、请求端(通常称为客户)发送一个SYN 段指明客户打算连接的服务器的端口，以及初始序号(ISN) 2、服务器发回包含服务器的初始序号的SYN 报文段(报文段2)作为应答。同时，将确认序号设置为客户的ISN加1 以对客户的SYN 报文段进行确认。 3、客户必须将确认序号设置为服务器的ISN 加1 以对服务器的SYN 报文段进行确认(报文段3)这三个报文段完成连接的建立。这个过程也称为三次握手(three-way handshake)。 上面的过程如下图所示： #8. 客户端和服务器端原理 8.1 常见的客户端、服务器端最常见的客户端：浏览器，IE/chrome最常见的服务端：服务器，Tomcat 8.2 常见网络结构 8.3 URL和URIURI：统一资源标识符URI是统一资源标识符，是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。URI由包括确定语法和相关协议的方案所定义。由是三个组成部分：访问资源的命名机制、存放资源的主机名、资源自身的名称，由路径表示。 URL：统一资源定位符也就是说根据URL能够定位到网络上的某个资源，它是指向互联网“资源”的指针。 每个URL都是URI，但不一定每个URI都是URL。这是因为URI还包括一个子类，即统一资源名称（URN），它命名资源但不指定如何定位资源。 URL是统一资源定位，是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 比如百度URL即是http://www.baidu.com。 9. TCP的三次握手/四次挥手TCP是面向连接的运输层协议，TCP协议提供可靠的连接服务，所以用了建立链接的三次握手和关闭连接的四次挥手来保证可靠服务。通过TCP通信就像是两个应用在打电话一样，打电话前得先拨号建立连接，通话结束后要挂机释放连接。 9.1 建立TCP连接的三次握手TCP连接的三次握手分别为： 客户端发送一个带SYN标志的TCP报文到服务器，表示告诉服务器我想建立一个连接。 服务器收到客户端的带SYN标志的文后，就给客户端回复一个带ACK标志和带SYN标志的报文，ACK表示回复客户端：OK，我准备好了建立连接；然后SYN表示服务器又问客户端：你准备好建立连接了么？ 然后客户端又要发送一个带ACK标志的TCP报文，回答服务器说：我准备好了。然后一个TCP连接就建立起来了。 SYN相当于询问的标志，ACK相当于回复的标志。 这里有一个问题：为什么最后客户端还要发送一次确认呢？这主要是防止已经失效了的请求报文段突然又传到了服务器，因而产生错误。“已经失效了的请求报文段”大致是这样产生的:A发出第一个连接请求报文段并没有丢失，在一些网络结点上面长时间滞留，以致延误到连接释放以后的某个时间才到达B。本来这是一个早已失效的报文段。但B收到这个失效的报文段后，就误以为是A发出的又一次新的连接请求，于是就向A发出确认报文段，同意建立连接，如果不采用三次握手，那么只要B发出确认后，新的连接就建立了。 9.2 释放TCP连接的四次挥手由于TCP是全双工的，所以在释放TCP连接时，要双方都得单独关闭。意思就是服务器和客户端都要释放连接。原则是某一方主动关闭时，先发一个FIN报文来表示终止这个方向的连接，收到一个FIN报文就意味着这个方向不再有数据流动，但另一个方向仍可以有数据流动，当这一个方向也发送了FIN报文后，那么这一方的连接也可以关闭了。释放TCP连接相对于要复杂点，具体释放TCP连接的四次挥手流程如下： A发送一个FIN给B，说：我这边要传给你的数据已经传完了，我要关闭连接了。A进入FIN-WAIT-1状态，等待B确认。 B收到了上面的FIN报文后，回复一个ACK报文说：OK。A就关闭了A-&gt;B的连接。但是此时B还能给A发送数据，A也能接收B发来的数据。（此时A收到确认后进入FIN-WAIT-2状态。TCP处于半关闭状态） 当B也发送完数据后，就给A发送一个FIN报文说：我这边要传给你的数据也已经传完了，我也要关闭连接了。（B进入LAST-ACK状态，等待A确认） A收到了上面的报文后，回复一个ACK报文说：OK。A进入TIME-WAIT状态。现在TCP连接还没有释放掉，然后经过等待计时器(TIME-WAIT timer)设置的时间2MSL后，A才进入CLOSE状态。 然后，当A撤销相应的传输控制块TCB后，一个TCP连接就关闭了。 10. Http、Tcp、Udp、Socket的区别IP，网络层协议；TCP和UDP，传输层协议；HTTP，应用层协议；SOCKET：TCP/IP网络的API。 TCP/IP代表传输控制协议/网际协议，指的是一系列协议。 TCP和UDP使用IP协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。 TCP和UDP是FTP，HTTP和SMTP之类使用的传输层协议。虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。 HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。 记住，需要IP协议来连接网络;TCP是一种允许我们安全传输数据的机制，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的特殊协议。 Socket 接口是TCP/IP网络的API，Socket接口定义了许多函数或例程，用以开发TCP/IP网络上的应用程序。 本节原文链接：http://www.jianshu.com/p/1f512687ea19 11. URLURI：统一资源标示符。 URL：统一资源定位符，也就是说根据URL能够定位到网络上的某个资源，它是指向互联网“资源”的指针。 每个URL都是URI，但不一定每个URI都是URL。这是因为URI还包括一个子类，即统一资源名称（URN），它命名资源但不指定如何定位资源。 12345678910111213141516171819public class URLDemo&#123; public static void main(String[] args) throws MalformedURLException,IOException &#123; String str_url = "http://192.168.1.100:8080/myweb/1.html?name=lisi"; URL url = new URL(str_url); System.out.println("getProtocol：" + url.getProtocol()); System.out.println("getHost：" + url.getHost()); System.out.println("getPort：" + url.getPort()); System.out.println("getFile：" + url.getFile()); System.out.println("getPath：" + url.getPath()); System.out.println("getQuery：" + url.getQuery()); InputStream in = url.openStream();//相当于 url.openConnection().getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String text = new String(buf,0,len); System.out.println(text); in.close(); &#125;&#125; 运行结果 之所以运行结果中响应头不见了，只能看到主体数据的原因在于：URLConnection对象已经把响应头给解析了 12. URLConnection123456789101112131415public class URLDemo&#123; public static void main(String[] args) throws MalformedURLException,IOException &#123; String str_url = "http://192.168.1.100:8080/myweb/1.html?name=lisi"; URL url = new URL(str_url); //获取url对象的Url连接器对象。将连接封装成了对象： // java中内置的可以解析的具体协议对象+socket。 URLConnection conn = url.openConnection(); System.out.println(conn); //由于URLConnection对象已经把响应头给解析了，所以， // 可以通过URLConnection对象获取响应头某属性名对应的属性值。 String value = conn.getHeaderField("Content-Type"); System.out.println(value); &#125;&#125; 运行结果 13. HttpURLConnection12345678910URL newURL = new URL(url);URLConnection urlConnection = newURL.openConnection();urlConnection.setConnectTimeout(mConfig.connTimeOut);urlConnection.setReadTimeout(mConfig.soTimeOut);urlConnection.setDoInput(true);urlConnection.setUseCaches(false);// HttpsURLConnectionHttpsURLConnection.setDefaultSSLSocketFactory(sslFactory);HttpsURLConnection.setDefaultHostnameVerifier(); HttpURLConnection常用方法 方法声明 功能描述 addRequestProperty() 添加请求属性 setRequestMethod() 设置请求方式 connect() 连接网络 disconnect() 断开连接 setDoOutput() 设置打开连接对象输出流，把要提交的数据写入流中 setDoInput() 设置打开连接对象输入流 setConnectTimeout() 设置连接超时 setReadTimeout() 设置读取超时 setUseCaches() 设置是否使用缓存 getResponseCode() 获取响应码 getOutputStream() 获取输出流 getInputStream() 获取输入流 getErrorStream() 获取错误流 getResponseMessage() 获取响应信息 getContentLength() 获取内容长度 getContentEncoding() 获取内容编码 getContentType() 获取内容类型 getHeaderFields() 获取所有的头字段 setRequestProperty和addRequestProperty的区别setRequestProperty和addRequestProperty的区别就是，setRequestProperty会覆盖已经存在的key的所有values，有清零重新赋值的作用。而addRequestProperty则是在原来key的基础上继续添加其他value。 1234567/** * Adds the given property to the request header. Existing properties with * the same name will not be overwritten by this method. */ public void addRequestProperty(String field, String newValue) &#123; ... &#125; 字节流转换为字符123456789101112131415161718public class Tools &#123; public static String getTextFromStream(InputStream is) &#123; try &#123; byte[] b = new byte[1024]; int len; ByteArrayOutputStream bos = new ByteArrayOutputStream(); while ((len = is.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; //把输出流里的内容转换成字节数组 String text = new String(bos.toByteArray()); return text; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 14. URLEncoder和URLDecoder12URLEncoder.encode();URLDecoder.decode();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2FString%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[相关阅读 Java基础：String类 Java字符串格式化 Java基础：正则表达式 1. 概述字符串是由多个字符组成的一串数据(字符序列)，字符串可以看成是字符数组。 在实际开发中，字符串的操作是最常见的操作，没有之一。而Java没有内置的字符串类型，所以，就在Java类库中提供了一个类String 供我们来使用。String 类代表字符串。 2. String类的特点 字符串是常量,它的值在创建之后不能更改 Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。 字符串如果是变量相加，先开空间，在拼接。 字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。 1234567891011package cn.itcast_02; /* * 字符串的特点：一旦被赋值，就不能改变。 */ public class StringDemo &#123; public static void main(String[] args) &#123; String s = "hello"; s += "world"; System.out.println("s:" + s); // helloworld &#125; &#125; 字符串在内存中1 字符串在内存中2 String s1 = new String(“hello”);和String s2 = “hello”;有什么区别？ 前者创建了2个或1个对象，后者创建了1个或0个对象。 123456789String s1 = new String(“hello”);String s2 = “hello”;s1 == s2; // false s1.equals(s2); // trueString s3 = “hello”; String s4 = “world”; String s5 = “helloworld”;S5== s3 + s4 ; //fale s5 == “hello” + ”world”; //true 字符串如果是变量相加，先开空间，再拼接。 字符串如果是常量相加，是先加，然后到字符串常量池中找，如果有就直接返回，否则就创建。 3. 常见操作方法3.1 构造方法 方法 说明 String() 创建一个内容为空的字符串 String(byte[]) 根据指定的字节数组创建对象 String(byte[]，int，int) 根据字节数组的一部分创建对象 String(char[]) 根据指定的字符数组创建对象 String(char[]，int，int) 根据字符数组的一部分创建对象 String(String) 根据指定的字符串内容创建对象 String(byte[] bytes, Charset charset) 使用指定的编码构造字符串对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.itcast_01; /* * 字符串：就是由多个字符组成的一串数据。也可以看成是一个字符数组。 * 通过查看API，我们可以知道 * A:字符串字面值"abc"也可以看成是一个字符串对象。 * B:字符串是常量，一旦被赋值，就不能被改变。 * * 构造方法： * public String():空构造 * public String(byte[] bytes):把字节数组转成字符串 * public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串 * public String(char[] value):把字符数组转成字符串 * public String(char[] value,int index,int count):把字符数组的一部分转成字符串 * public String(String original):把字符串常量值转成字符串 * * 字符串的方法： * public int length()：返回此字符串的长度。 */ public class StringDemo &#123; public static void main(String[] args) &#123; // public String():空构造 String s1 = new String(); System.out.println("s1:" + s1); System.out.println("s1.length():" + s1.length()); System.out.println("--------------------------"); // public String(byte[] bytes):把字节数组转成字符串 byte[] bys = &#123; 97, 98, 99, 100, 101 &#125;; String s2 = new String(bys); System.out.println("s2:" + s2); System.out.println("s2.length():" + s2.length()); System.out.println("--------------------------"); // public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串 // 我想得到字符串"bcd" String s3 = new String(bys, 1, 3); System.out.println("s3:" + s3); System.out.println("s3.length():" + s3.length()); System.out.println("--------------------------"); // public String(char[] value):把字符数组转成字符串 char[] chs = &#123; 'a', 'b', 'c', 'd', 'e', '爱', '林', '亲' &#125;; String s4 = new String(chs); System.out.println("s4:" + s4); System.out.println("s4.length():" + s4.length()); System.out.println("--------------------------"); // public String(char[] value,int index,int count):把字符数组的一部分转成字符串 String s5 = new String(chs, 2, 4); System.out.println("s5:" + s5); System.out.println("s5.length():" + s5.length()); System.out.println("--------------------------"); //public String(String original):把字符串常量值转成字符串 String s6 = new String("abcde"); System.out.println("s6:" + s6); System.out.println("s6.length():" + s6.length()); System.out.println("--------------------------"); //字符串字面值"abc"也可以看成是一个字符串对象。 String s7 = "abcde"; System.out.println("s7:"+s7); System.out.println("s7.length():"+s7.length()); &#125; &#125; 运行结果： 1234567891011121314151617181920s1:s1.length():0--------------------------s2:abcdes2.length():5--------------------------s3:bcds3.length():3--------------------------s4:abcde爱林亲s4.length():8--------------------------s5:cde爱s5.length():4--------------------------s6:abcdes6.length():5--------------------------s7:abcdes7.length():5 3.2 判断功能 方法 说明 equals() 比较字符串的内容是否相等，区分大小写 equalsIgnoreCase() 比较字符串的内容是否相等，忽略大小写 contains(String str) 判断大字符串中是否包含小字符串 startsWith() 判断字符串是否以某个字符串开头 endsWith() 判断字符串是否以某个字符串结尾 isEmpty() 判断字符串是否为空 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package cn.itcast_03; /* * String类的判断功能： * boolean equals(Object obj):比较字符串的内容是否相同,区分大小写 * boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 * boolean contains(String str):判断大字符串中是否包含小字符串 * boolean startsWith(String str):判断字符串是否以某个指定的字符串开头 * boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾 * boolean isEmpty():判断字符串是否为空。 * * 注意： * 字符串内容为空和字符串对象为空。 * String s = ""; * String s = null; */ public class StringDemo &#123; public static void main(String[] args) &#123; // 创建字符串对象 String s1 = "helloworld"; String s2 = "helloworld"; String s3 = "HelloWorld"; // boolean equals(Object obj):比较字符串的内容是否相同,区分大小写 System.out.println("equals:" + s1.equals(s2)); System.out.println("equals:" + s1.equals(s3)); System.out.println("-----------------------"); // boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 System.out.println("equals:" + s1.equalsIgnoreCase(s2)); System.out.println("equals:" + s1.equalsIgnoreCase(s3)); System.out.println("-----------------------"); // boolean contains(String str):判断大字符串中是否包含小字符串 System.out.println("contains:" + s1.contains("hello")); System.out.println("contains:" + s1.contains("hw")); System.out.println("-----------------------"); // boolean startsWith(String str):判断字符串是否以某个指定的字符串开头 System.out.println("startsWith:" + s1.startsWith("h")); System.out.println("startsWith:" + s1.startsWith("hello")); System.out.println("startsWith:" + s1.startsWith("world")); System.out.println("-----------------------"); // 练习：boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾这个自己玩 // boolean isEmpty():判断字符串是否为空。 System.out.println("isEmpty:" + s1.isEmpty()); String s4 = ""; String s5 = null; System.out.println("isEmpty:" + s4.isEmpty()); // NullPointerException // s5对象都不存在，所以不能调用方法，空指针异常 System.out.println("isEmpty:" + s5.isEmpty()); &#125; &#125; 运行结果： 1234567891011121314151617equals:trueequals:false-----------------------equals:trueequals:true-----------------------contains:truecontains:false-----------------------startsWith:truestartsWith:truestartsWith:false-----------------------isEmpty:falseisEmpty:trueException in thread &quot;main&quot; java.lang.NullPointerException at Test.main(Test.java:43) 3.3 获取功能 方法 说明 length() 获取字符串长度 charAt(int index) 获取指定位置的字符 indexOf(int ch) 字符第一次出现的索引 indexOf(String str) 字符串第一次出现的索引 indexOf(int ch,int fromIndex) 字符从指定位置后第一次出现的索引 indexOf(String str,int from) 字符串从指定位置后第一次出现的索引 lastIndexOf() 字符串最后一次出现的索引 subString(int start) 从指定位置开始截取字符串 subString(int start,int end) 截取字符串，包左不包右 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.itcast_04; /* * String类的获取功能 * int length():获取字符串的长度。 * char charAt(int index):获取指定索引位置的字符 * int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 * 为什么这里是int类型，而不是char类型? * 原因是：'a'和97其实都可以代表'a' * int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。 * int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现处的索引。 * int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现处的索引。 * String substring(int start):从指定位置开始截取字符串,默认到末尾。 * String substring(int start,int end):从指定位置开始到指定位置结束截取字符串。 */ public class StringDemo &#123; public static void main(String[] args) &#123; // 定义一个字符串对象 String s = "helloworld"; // int length():获取字符串的长度。 System.out.println("s.length:" + s.length()); System.out.println("----------------------"); // char charAt(int index):获取指定索引位置的字符 System.out.println("charAt:" + s.charAt(7)); System.out.println("----------------------"); // int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 System.out.println("indexOf:" + s.indexOf('l')); System.out.println("----------------------"); // int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。 System.out.println("indexOf:" + s.indexOf("owo")); System.out.println("----------------------"); // int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现处的索引。 System.out.println("indexOf:" + s.indexOf('l', 4)); System.out.println("indexOf:" + s.indexOf('k', 4)); // -1 System.out.println("indexOf:" + s.indexOf('l', 40)); // -1 System.out.println("----------------------"); // 自己练习：int indexOf(String str,int // fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现处的索引。 // String substring(int start):从指定位置开始截取字符串,默认到末尾。包含start这个索引 System.out.println("substring:" + s.substring(5)); System.out.println("substring:" + s.substring(0)); System.out.println("----------------------"); // String substring(int start,int // end):从指定位置开始到指定位置结束截取字符串。包括start索引但是不包end索引 System.out.println("substring:" + s.substring(3, 8)); System.out.println("substring:" + s.substring(0, s.length())); &#125; &#125; 运行结果： 1234567891011121314151617s.length:10----------------------charAt:r----------------------indexOf:2----------------------indexOf:4----------------------indexOf:8indexOf:-1indexOf:-1----------------------substring:worldsubstring:helloworld----------------------substring:loworsubstring:helloworld 3.4 转换功能 方法 说明 getBytes() 把字符串转成字节数组 getCharArray() 把字符串转成字符数组 valueOf(char[] chs) 把字符数组转成字符串 valueOf(int i) 把int类型的数据转成字符串 toLowerCase() 把字符串转成小写 toUpperCase() 把字符串转成大写 concat(String str) 字符串拼接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.itcast_05; /* * String的转换功能： * byte[] getBytes():把字符串转换为字节数组。 * char[] toCharArray():把字符串转换为字符数组。 * static String valueOf(char[] chs):把字符数组转成字符串。 * static String valueOf(int i):把int类型的数据转成字符串。 * 注意：String类的valueOf方法可以把任意类型的数据转成字符串。 * String toLowerCase():把字符串转成小写。 * String toUpperCase():把字符串转成大写。 * String concat(String str):把字符串拼接。 */ public class StringDemo &#123; public static void main(String[] args) &#123; // 定义一个字符串对象 String s = "JavaSE"; // byte[] getBytes():把字符串转换为字节数组。 byte[] bys = s.getBytes(); for (int x = 0; x &lt; bys.length; x++) &#123; System.out.println(bys[x]); &#125; System.out.println("----------------"); // char[] toCharArray():把字符串转换为字符数组。 char[] chs = s.toCharArray(); for (int x = 0; x &lt; chs.length; x++) &#123; System.out.println(chs[x]); &#125; System.out.println("----------------"); // static String valueOf(char[] chs):把字符数组转成字符串。 String ss = String.valueOf(chs); System.out.println(ss); System.out.println("----------------"); // static String valueOf(int i):把int类型的数据转成字符串。 int i = 100; String sss = String.valueOf(i); System.out.println(sss); System.out.println("----------------"); // String toLowerCase():把字符串转成小写。 System.out.println("toLowerCase:" + s.toLowerCase()); System.out.println("s:" + s); // System.out.println("----------------"); // String toUpperCase():把字符串转成大写。 System.out.println("toUpperCase:" + s.toUpperCase()); System.out.println("----------------"); // String concat(String str):把字符串拼接。 String s1 = "hello"; String s2 = "world"; String s3 = s1 + s2; String s4 = s1.concat(s2); System.out.println("s3:"+s3); System.out.println("s4:"+s4); &#125; &#125; 运行结果： 1234567891011121314151617181920212223247497118978369----------------JavaSE----------------JavaSE----------------100----------------toLowerCase:javases:JavaSEtoUpperCase:JAVASE----------------s3:helloworlds4:helloworld 3.5 其他功能 方法 说明 replace(char old,char new) 替换字符 replace(String old,String new) 替换字符串 trim() 去掉字符串两端空格 compareTo() 按字典顺序比较字符串 compareToIngnoreCase() 按字典顺序比较字符串，忽略大小写 format() 格式化字符串 1String.format(Locale.CHINA，"第%03d条数据%s"，10，"str") 更多关于字符串格式化的内容，请看 Java字符串格式化String.format()的使用123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast_06; /* * String类的其他功能： * * 替换功能： * String replace(char old,char new) * String replace(String old,String new) * * 去除字符串两空格 * String trim() * * 按字典顺序比较两个字符串 * int compareTo(String str) * int compareToIgnoreCase(String str) */ public class StringDemo &#123; public static void main(String[] args) &#123; // 替换功能 String s1 = "helloworld"; String s2 = s1.replace('l', 'k'); String s3 = s1.replace("owo", "ak47"); System.out.println("s1:" + s1); System.out.println("s2:" + s2); System.out.println("s3:" + s3); System.out.println("---------------"); // 去除字符串两空格 String s4 = " hello world "; String s5 = s4.trim(); System.out.println("s4:" + s4 + "---"); System.out.println("s5:" + s5 + "---"); // 按字典顺序比较两个字符串 String s6 = "hello"; String s7 = "hello"; String s8 = "abc"; String s9 = "xyz"; System.out.println(s6.compareTo(s7));// 0 System.out.println(s6.compareTo(s8));// 7 System.out.println(s6.compareTo(s9));// -16 &#125; &#125; 运行结果： 123456789s1:helloworlds2:hekkoworkds3:hellak47rld---------------s4: hello world ---s5:hello world---07-16 4. String类练习4.1 把数组中的数据按照指定个格式拼接成一个字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.itcast_07; /* * 需求：把数组中的数据按照指定个格式拼接成一个字符串 * 举例： * int[] arr = &#123;1,2,3&#125;; * 输出结果： * "[1, 2, 3]" * 分析： * A:定义一个字符串对象，只不过内容为空 * B:先把字符串拼接一个"[" * C:遍历int数组，得到每一个元素 * D:先判断该元素是否为最后一个 * 是：就直接拼接元素和"]" * 不是：就拼接元素和逗号以及空格 * E:输出拼接后的字符串 * * 把代码用功能实现。 */ public class StringTest2 &#123; public static void main(String[] args) &#123; // 前提是数组已经存在 int[] arr = &#123; 1, 2, 3 &#125;; // 写一个功能，实现结果 String result = arrayToString(arr); System.out.println("最终结果是：" + result); &#125; /* * 两个明确： 返回值类型：String 参数列表：int[] arr */ public static String arrayToString(int[] arr) &#123; // 定义一个字符串 String s = ""; // 先把字符串拼接一个"[" s += "["; // 遍历int数组，得到每一个元素 for (int x = 0; x &lt; arr.length; x++) &#123; // 先判断该元素是否为最后一个 if (x == arr.length - 1) &#123; // 就直接拼接元素和"]" s += arr[x]; s += "]"; &#125; else &#123; // 就拼接元素和逗号以及空格 s += arr[x]; s += ", "; &#125; &#125; return s; &#125; &#125; 4.2 字符串反转1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.itcast_07; import java.util.Scanner; /* * 字符串反转 * 举例：键盘录入”abc” * 输出结果：”cba” * * 分析： * A:键盘录入一个字符串 * B:定义一个新字符串 * C:倒着遍历字符串，得到每一个字符 * a:length()和charAt()结合 * b:把字符串转成字符数组 * D:用新字符串把每一个字符拼接起来 * E:输出新串 */ public class StringTest3 &#123; public static void main(String[] args) &#123; // 键盘录入一个字符串 Scanner sc = new Scanner(System.in); System.out.println("请输入一个字符串："); String line = sc.nextLine(); /* // 定义一个新字符串 String result = ""; // 把字符串转成字符数组 char[] chs = line.toCharArray(); // 倒着遍历字符串，得到每一个字符 for (int x = chs.length - 1; x &gt;= 0; x--) &#123; // 用新字符串把每一个字符拼接起来 result += chs[x]; &#125; // 输出新串 System.out.println("反转后的结果是：" + result); */ // 改进为功能实现 String s = myReverse(line); System.out.println("实现功能后的结果是：" + s); &#125; /* * 两个明确： 返回值类型：String 参数列表：String */ public static String myReverse(String s) &#123; // 定义一个新字符串 String result = ""; // 把字符串转成字符数组 char[] chs = s.toCharArray(); // 倒着遍历字符串，得到每一个字符 for (int x = chs.length - 1; x &gt;= 0; x--) &#123; // 用新字符串把每一个字符拼接起来 result += chs[x]; &#125; return result; &#125; &#125; 4.3 统计大串中小串出现的次数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package cn.itcast_07; /* * 统计大串中小串出现的次数 * 举例： * 在字符串"woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun" * 结果： * java出现了5次 * * 分析： * 前提：是已经知道了大串和小串。 * * A:定义一个统计变量，初始化值是0 * B:先在大串中查找一次小串第一次出现的位置 * a:索引是-1，说明不存在了，就返回统计变量 * b:索引不是-1，说明存在，统计变量++ * C:把刚才的索引+小串的长度作为开始位置截取上一次的大串，返回一个新的字符串，并把该字符串的值重新赋值给大串 * D:回到B */ public class StringTest5 &#123; public static void main(String[] args) &#123; // 定义大串 String maxString = "woaijavawozhenaijavawozhendeaijavawozhendehenaijavaxinbuxinwoaijavagun"; // 定义小串 String minString = "java"; // 写功能实现 int count = getCount(maxString, minString); System.out.println("Java在大串中出现了：" + count + "次"); &#125; /* * 两个明确： 返回值类型：int 参数列表：两个字符串 */ public static int getCount(String maxString, String minString) &#123; // 定义一个统计变量，初始化值是0 int count = 0; /* // 先在大串中查找一次小串第一次出现的位置 int index = maxString.indexOf(minString); // 索引不是-1，说明存在，统计变量++ while (index != -1) &#123; count++; // 把刚才的索引+小串的长度作为开始位置截取上一次的大串，返回一个新的字符串，并把该字符串的值重新赋值给大串 // int startIndex = index + minString.length(); // maxString = maxString.substring(startIndex); maxString = maxString.substring(index + minString.length()); // 继续查 index = maxString.indexOf(minString); &#125; */ int index; //先查，赋值，判断 while((index=maxString.indexOf(minString))!=-1)&#123; count++; maxString = maxString.substring(index + minString.length()); &#125; return count; &#125; &#125; 5. StringBuffer我们如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。而StringBuffer就可以解决这个问题 StringBuffer是线程安全的可变字符序列。 StringBuffer和String的区别? 前者长度和内容可变，后者不可变。如果使用前者做字符串的拼接，不会浪费太多的资源。 6. 常见操作方法 6.1 构造方法和获取方法123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast_01; /* * StringBuffer: * 线程安全的可变字符串。 * * StringBuffer和String的区别? * 前者长度和内容可变，后者不可变。 * 如果使用前者做字符串的拼接，不会浪费太多的资源。 * * StringBuffer的构造方法： * public StringBuffer():无参构造方法 * public StringBuffer(int capacity):指定容量的字符串缓冲区对象 * public StringBuffer(String str):指定字符串内容的字符串缓冲区对象 * * StringBuffer的获取方法： * public int capacity()：返回当前容量。 理论值 * public int length():返回长度（字符数）。 实际值 */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // public StringBuffer():无参构造方法 StringBuffer sb = new StringBuffer(); System.out.println("sb:" + sb); System.out.println("sb.capacity():" + sb.capacity()); System.out.println("sb.length():" + sb.length()); System.out.println("--------------------------"); // public StringBuffer(int capacity):指定容量的字符串缓冲区对象 StringBuffer sb2 = new StringBuffer(50); System.out.println("sb2:" + sb2); System.out.println("sb2.capacity():" + sb2.capacity()); System.out.println("sb2.length():" + sb2.length()); System.out.println("--------------------------"); // public StringBuffer(String str):指定字符串内容的字符串缓冲区对象 StringBuffer sb3 = new StringBuffer("hello"); System.out.println("sb3:" + sb3); System.out.println("sb3.capacity():" + sb3.capacity()); System.out.println("sb3.length():" + sb3.length()); &#125; &#125; 6.2 添加功能1234567891011121314151617181920212223242526272829303132333435package cn.itcast_02; /* * StringBuffer的添加功能： * public StringBuffer append(String str):可以把任意类型数据添加到字符串缓冲区里面,并返回字符串缓冲区本身 * * public StringBuffer insert(int offset,String str):在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身 */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // public StringBuffer append(String str) // StringBuffer sb2 = sb.append("hello"); // System.out.println("sb:" + sb); // System.out.println("sb2:" + sb2); // System.out.println(sb == sb2); // true // 一步一步的添加数据 // sb.append("hello"); // sb.append(true); // sb.append(12); // sb.append(34.56); // 链式编程 sb.append("hello").append(true).append(12).append(34.56); System.out.println("sb:" + sb); // public StringBuffer insert(int offset,String // str):在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身 sb.insert(5, "world"); System.out.println("sb:" + sb); &#125; &#125; 运行结果： 12sb:hellotrue1234.56sb:helloworldtrue1234.56 6.3 删除功能123456789101112131415161718192021222324252627282930313233package cn.itcast_03; /* * StringBuffer的删除功能 * public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身 * public StringBuffer delete(int start,int end):删除从指定位置开始指定位置结束的内容，并返回本身 */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // 创建对象 StringBuffer sb = new StringBuffer(); // 添加功能 sb.append("hello").append("world").append("java"); System.out.println("sb:" + sb); // public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身 // 需求：我要删除e这个字符，肿么办? // sb.deleteCharAt(1); // 需求:我要删除第一个l这个字符，肿么办? // sb.deleteCharAt(1); // public StringBuffer delete(int start,int // end):删除从指定位置开始指定位置结束的内容，并返回本身 // 需求：我要删除world这个字符串，肿么办? // sb.delete(5, 10); // 需求:我要删除所有的数据 sb.delete(0, sb.length()); System.out.println("sb:" + sb); &#125; &#125; 运行结果： 12sb:helloworldjavasb: 6.4 替换功能123456789101112131415161718192021222324package cn.itcast_04; /* * StringBuffer的替换功能： * public StringBuffer replace(int start,int end,String str):从start开始到end用str替换 */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // 添加数据 sb.append("hello"); sb.append("world"); sb.append("java"); System.out.println("sb:" + sb); // public StringBuffer replace(int start,int end,String // str):从start开始到end用str替换 // 需求：我要把world这个数据替换为"节日快乐" sb.replace(5, 10, "节日快乐"); System.out.println("sb:" + sb); &#125; &#125; 运行结果： 12sb:helloworldjavasb:hello节日快乐java 6.5 反转功能1234567891011121314151617181920package cn.itcast_05; /* * StringBuffer的反转功能： * public StringBuffer reverse() */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // 添加数据 sb.append("霞青林爱我"); System.out.println("sb:" + sb); // public StringBuffer reverse() sb.reverse(); System.out.println("sb:" + sb); &#125; &#125; 运行结果： 12sb:霞青林爱我sb:我爱林青霞 6.6 截取功能12345678910111213141516171819202122232425262728package cn.itcast_06; /* * StringBuffer的截取功能:注意返回值类型不再是StringBuffer本身了 * public String substring(int start) * public String substring(int start,int end) */ public class StringBufferDemo &#123; public static void main(String[] args) &#123; // 创建字符串缓冲区对象 StringBuffer sb = new StringBuffer(); // 添加元素 sb.append("hello").append("world").append("java"); System.out.println("sb:" + sb); // 截取功能 // public String substring(int start) String s = sb.substring(5); System.out.println("s:" + s); System.out.println("sb:" + sb); // public String substring(int start,int end) String ss = sb.substring(5, 10); System.out.println("ss:" + ss); System.out.println("sb:" + sb); &#125; &#125; 运行结果： 12345sb:helloworldjavas:worldjavasb:helloworldjavass:worldsb:helloworldjava 7. StringBuffer类练习7.1 String和StringBuffer的相互转换1234567891011121314151617181920212223242526272829303132333435363738package cn.itcast_07; /* * 为什么我们要讲解类之间的转换： * A -- B的转换 * 我们把A转换为B，其实是为了使用B的功能。 * B -- A的转换 * 我们可能要的结果是A类型，所以还得转回来。 * * String和StringBuffer的相互转换? */ public class StringBufferTest &#123; public static void main(String[] args) &#123; // String -- StringBuffer String s = "hello"; // 注意：不能把字符串的值直接赋值给StringBuffer // StringBuffer sb = "hello"; // StringBuffer sb = s; // 方式1:通过构造方法 StringBuffer sb = new StringBuffer(s); // 方式2：通过append()方法 StringBuffer sb2 = new StringBuffer(); sb2.append(s); System.out.println("sb:" + sb); System.out.println("sb2:" + sb2); System.out.println("---------------"); // StringBuffer -- String StringBuffer buffer = new StringBuffer("java"); // String(StringBuffer buffer) // 方式1:通过构造方法 String str = new String(buffer); // 方式2：通过toString()方法 String str2 = buffer.toString(); System.out.println("str:" + str); System.out.println("str2:" + str2); &#125; &#125; 运行结果： 12345sb:hellosb2:hello---------------str:javastr2:java 7.2 把数组拼接成一个字符串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.itcast_07; /* * 把数组拼接成一个字符串 */ public class StringBufferTest2 &#123; public static void main(String[] args) &#123; // 定义一个数组 int[] arr = &#123; 44, 33, 55, 11, 22 &#125;; // 定义功能 // 方式1：用String做拼接的方式 String s1 = arrayToString(arr); System.out.println("s1:" + s1); // 方式2:用StringBuffer做拼接的方式 String s2 = arrayToString2(arr); System.out.println("s2:" + s2); &#125; // 用StringBuffer做拼接的方式 public static String arrayToString2(int[] arr) &#123; StringBuffer sb = new StringBuffer(); sb.append("["); for (int x = 0; x &lt; arr.length; x++) &#123; if (x == arr.length - 1) &#123; sb.append(arr[x]); &#125; else &#123; sb.append(arr[x]).append(", "); &#125; &#125; sb.append("]"); return sb.toString(); &#125; // 用String做拼接的方式 public static String arrayToString(int[] arr) &#123; String s = ""; s += "["; for (int x = 0; x &lt; arr.length; x++) &#123; if (x == arr.length - 1) &#123; s += arr[x]; &#125; else &#123; s += arr[x]; s += ", "; &#125; &#125; s += "]"; return s; &#125; &#125; 运行结果： 12s1:[44, 33, 55, 11, 22]s2:[44, 33, 55, 11, 22] 7.3 把字符串反转12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.itcast_07; import java.util.Scanner; /* * 把字符串反转 */ public class StringBufferTest3 &#123; public static void main(String[] args) &#123; // 键盘录入数据 Scanner sc = new Scanner(System.in); System.out.println("请输入数据："); String s = sc.nextLine(); // 方式1：用String做拼接 String s1 = myReverse(s); System.out.println("s1:" + s1); // 方式2：用StringBuffer的reverse()功能 String s2 = myReverse2(s); System.out.println("s2:" + s2); &#125; // 用StringBuffer的reverse()功能 public static String myReverse2(String s) &#123; // StringBuffer sb = new StringBuffer(); // sb.append(s); // StringBuffer sb = new StringBuffer(s); // sb.reverse(); // return sb.toString(); // 简易版 return new StringBuffer(s).reverse().toString(); &#125; // 用String做拼接 public static String myReverse(String s) &#123; String result = ""; char[] chs = s.toCharArray(); for (int x = chs.length - 1; x &gt;= 0; x--) &#123; // char ch = chs[x]; // result += ch; result += chs[x]; &#125; return result; &#125; &#125; 运行结果： 1234请输入数据：hello worlds1:dlrow ollehs2:dlrow olleh 7.4 判断一个字符串是否是对称字符串1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.itcast_07; import java.util.Scanner; /* * 判断一个字符串是否是对称字符串 * 例如"abc"不是对称字符串，"aba"、"abba"、"aaa"、"mnanm"是对称字符串 * * 分析： * 判断一个字符串是否是对称的字符串，我只需要把 * 第一个和最后一个比较 * 第二个和倒数第二个比较 * ... * 比较的次数是长度除以2。 */ public class StringBufferTest4 &#123; public static void main(String[] args) &#123; // 创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println("请输入一个字符串："); String s = sc.nextLine(); // 一个一个的比较 boolean b = isSame(s); System.out.println("b:" + b); //用字符串缓冲区的反转功能 boolean b2 = isSame2(s); System.out.println("b2:"+b2); &#125; public static boolean isSame2(String s) &#123; return new StringBuffer(s).reverse().toString().equals(s); &#125; // public static boolean isSame(String s) &#123; // // 把字符串转成字符数组 // char[] chs = s.toCharArray(); // // for (int start = 0, end = chs.length - 1; start &lt;= end; start++, end--) &#123; // if (chs[start] != chs[end]) &#123; // return false; // &#125; // &#125; // // return true; // &#125; public static boolean isSame(String s) &#123; boolean flag = true; // 把字符串转成字符数组 char[] chs = s.toCharArray(); for (int start = 0, end = chs.length - 1; start &lt;= end; start++, end--) &#123; if (chs[start] != chs[end]) &#123; flag = false; break; &#125; &#125; return flag; &#125; &#125; 运行结果： 1234请输入一个字符串：abcbab:trueb2:true 8. String常见问题8.1 Strings = new String(“xyz”)；创建了几个String Object？二者之间有什么区别？ 两个或一个，”xyz”对应一个对象，这个对象放在字符串常量缓冲区，常量”xyz”不管出现多少遍，都是缓冲区中的那一个。new String()每写一遍，就创建一个新的对象，它一句那个常量”xyz”对象的内容来创建出一个新String对象。如果以前就用过”xyz”，这句代表就不会创建”xyz”自己了，直接从缓冲区拿。 8.2 String和StringBuffer的区别？ String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。String类表示内容不可改变的字符串，而StringBuffer类表示内容可以被修改的字符串。String重写了equals()方法和hashCode()方法，而StringBuffer没有重写equals方法和hashCode方法，所以，将StringBuffer对象存储进Java集合类中时会出现问题。StringBuffer更加高效。 8.3 StringBuffer与StringBuilder的区别？ StringBuffer和StringBuilder类都表示内容可以被修改的字符串，StringBuilder是线程不安全的，运行效率高，如果一个字符串变量是在方法里面定义，这种情况只可能有一个线程访问它，不存在不安全的因素了，则用StringBuilder。如果要在类里面定义成员变量，并且这个类的实例对象会在多线程环境下使用，那么最好用StringBuffer。 8.4 如何把一段逗号分割的字符串转换成一个数组? 用正则表达式：String [ ] result = Str.split(“, ”) ; 8.5 Strings=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;+&quot;d&quot;; 一共创建了多少个对象？ 一个，相当于直接定义了一个”abcd”的字符串。Javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。 8.6 编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。 8.7 有一个字符串，其中包含中文字符、英文字符和数字字符，请统计和打印出各个字符的个数 思路：取出字符串的每一个字符到HashMap中去找，如果不存在，则把该字符和1分别作为键和值添加到集合中，如果存在，则把该字符和值加1作为键和值添加到集合中。最后遍历集合即可得到字符的个数 8.8 如果一串字符如”aaaabbc中国1512”要分别统计英文字符的数量，中文字符的数量，和数字字符的数量，假设字符中没有中文字符、英文字符、数字字符之外的其他特殊字符。 123456789// 字符串反转Public static String Reverce(String str)&#123; return new StringBuffer(str).reverce().toString();&#125;// 判断字符串是否对称Public static boolean isSame(String str)&#123; return new StringBuffer(str).reverce().toString().equals(str);&#125; 8.9 把数组拼接成指定格式的字符串 8.10 把字符串中的字符进行排序]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[相关阅读 Java基础：String类 Java字符串格式化 Java基础：正则表达式 1. 正则表达式概述正则表达式，又称正规表示法、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本 许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有regexp、regex，复数有regexps、regexes、regexen 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑 1.1 给定一个正则表达式和另一个字符串，我们可以达到如下的目的 给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”） 可以通过正则表达式，从字符串中获取我们想要的特定部分 1.2 正则表达式的特点是 灵活性、逻辑性和功能性非常的强； 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。 由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容 2. 正则表达式基础知识2.1 规则字符在java.util.regex Pattern类中2.2 常见符号2.2.1 字符 符号 说明 X 字符X \\ 反斜线 \t 制表符 (‘\u0009’) \n 回车 \r 换行 \f 换页符 (‘\u000C’) \a 报警 (bell) 符 (‘\u0007’) 2.2.2 字符类 符号 说明 [abc] a、b或c [^abc] 任何字符，除了a、b或c [a-zA-Z] a到z,或A到Z [0-9] 0到9的字符 [a-d[m-p]] a到 d或 m 到 p：[a-dm-p]（并集） [a-z&amp;&amp;[def]] d、e或 f（交集） [a-z&amp;&amp;[^bc]] a到 z，除了 b和 c：[ad-z]（减去） [a-z&amp;&amp;[^m-p]] a到 z，而非 m到 p：[a-lq-z]（减去） 2.2.3 预定义字符 符号 说明 . 任何字符 \d 数字：[0-9] \D 非数字： [^0-9] \s 空白字符：[ \t\n\x0B\f\r] \S 非空白字符：[^\s] \w 单词字符：[a-zA-Z_0-9] \W 非单词字符：[^\w] 2.3 边界匹配器 符号 说明 ^ 行开头 $ 行结尾 \b 单词边界 \B 非单词边界 \A 输入的开头 \G 上一个匹配的结尾 \Z 输入的结尾，仅用于最后的结束符（如果有的话） \z 输入的结尾 2.3.1 Greedy数量词 符号 说明 X？ 0次或1次 X* 0次以上 X+ 1次以上 X{n} 恰好n次 X{n,} 至少n次 X{n,m} n-m次 2.3.2 组和捕获捕获组可以通过从左到右计算其开括号来编号。例如，在表达式 ((A)(B(C)))中，存在四个这样的组： ((A)(B(C))) \A (B(C)) (C) 组零始终代表整个表达式。在替换中常用$匹配组的内容。 3. 正则表达式的应用3.1 判断功能1public boolean matches(String regex)：编译给定正则表达式并尝试将给定输入与其匹配。 3.2 分割功能1public String[] split(String regex)：根据指定的正则表达式分割字符串 3.3 替换功能1public String replaceAll(String regex,String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 ##3.4 获取功能Pattern和Matcher类的使用 123456789101112131415161718192021222324252627package cn.itcast_05;import java.util.regex.Matcher;import java.util.regex.Pattern;/* * 获取功能 * Pattern和Matcher类的使用 * * 模式和匹配器的基本使用顺序 */public class RegexDemo &#123; public static void main(String[] args) &#123; // 模式和匹配器的典型调用顺序 // 把正则表达式编译成模式对象 Pattern p = Pattern.compile("a*b"); // 通过模式对象得到匹配器对象，这个时候需要的是被匹配的字符串 Matcher m = p.matcher("aaaaab"); // 调用匹配器对象的功能 boolean b = m.matches(); System.out.println(b); //这个是判断功能，但是如果做判断，这样做就有点麻烦了，我们直接用字符串的方法做 String s = "aaaaab"; String regex = "a*b"; boolean bb = s.matches(regex); System.out.println(bb); &#125;&#125; 3.4 注意事项Pattern类为正则表达式的编译表示形式。指定为字符串的正则表达式必须首先被编译为此类的实例。然后，可将得到的模式用于创建Matcher对象，依照正则表达式，该对象可以与任意字符序列匹配。执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式 4. 正则表达式的练习4.1 判断功能：校验邮箱12345678910111213141516171819202122232425262728293031323334package cn.itcast_02;import java.util.Scanner;/* * 校验邮箱 * * 分析： * A:键盘录入邮箱 * B:定义邮箱的规则 * 1517806580@qq.com * liuyi@163.com * linqingxia@126.com * fengqingyang@sina.com.cn * fqy@itcast.cn * C:调用功能，判断即可 * D:输出结果 */public class RegexTest &#123; public static void main(String[] args) &#123; //键盘录入邮箱 Scanner sc = new Scanner(System.in); System.out.println("请输入邮箱："); String email = sc.nextLine(); //定义邮箱的规则 //String regex = "[a-zA-Z_0-9]+@[a-zA-Z_0-9]&#123;2,6&#125;(\\.[a-zA-Z_0-9]&#123;2,3&#125;)+"; String regex = "\\w+@\\w&#123;2,6&#125;(\\.\\w&#123;2,3&#125;)+"; //调用功能，判断即可 boolean flag = email.matches(regex); //输出结果 System.out.println("flag:"+flag); &#125;&#125; 4.2 分割功能代码示例：我有如下一个字符串:”91 27 46 3850”，请写代码实现最终输出结果是：”27 3846 50 91” 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.itcast_03;import java.util.Arrays;/* * 我有如下一个字符串:"91 27 46 38 50" * 请写代码实现最终输出结果是："27 38 46 50 91" * * 分析： * A:定义一个字符串 * B:把字符串进行分割，得到一个字符串数组 * C:把字符串数组变换成int数组 * D:对int数组排序 * E:把排序后的int数组在组装成一个字符串 * F:输出字符串 */public class RegexTest &#123; public static void main(String[] args) &#123; // 定义一个字符串 String s = "91 27 46 38 50"; // 把字符串进行分割，得到一个字符串数组 String[] strArray = s.split(" "); // 把字符串数组变换成int数组 int[] arr = new int[strArray.length]; for (int x = 0; x &lt; arr.length; x++) &#123; arr[x] = Integer.parseInt(strArray[x]); &#125; // 对int数组排序 Arrays.sort(arr); // 把排序后的int数组在组装成一个字符串 StringBuilder sb = new StringBuilder(); for (int x = 0; x &lt; arr.length; x++) &#123; sb.append(arr[x]).append(" "); &#125; //转化为字符串 String result = sb.toString().trim(); //输出字符串 System.out.println("result:"+result); &#125;&#125; 4.3 替换功能：论坛中不能出现数字字符，用*替换12345678910111213141516171819202122232425package cn.itcast_04;/* * 替换功能 * String类的public String replaceAll(String regex,String replacement) * 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 */public class RegexDemo &#123; public static void main(String[] args) &#123; // 定义一个字符串 String s = "helloqq12345worldkh622112345678java"; // 我要去除所有的数字,用*给替换掉 // String regex = "\\d+"; // String regex = "\\d"; //String ss = "*"; // 直接把数字干掉 String regex = "\\d+"; String ss = ""; String result = s.replaceAll(regex, ss); System.out.println(result); &#125;&#125; 4.4 获取功能：获取由三个字符组成的单词123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.itcast_05;import java.util.regex.Matcher;import java.util.regex.Pattern;/* * 获取功能： * 获取下面这个字符串中由三个字符组成的单词 * da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu? */public class RegexDemo2 &#123; public static void main(String[] args) &#123; // 定义字符串 String s = "da jia ting wo shuo,jin tian yao xia yu,bu shang wan zi xi,gao xing bu?"; // 规则 String regex = "\\b\\w&#123;3&#125;\\b"; // 把规则编译成模式对象 Pattern p = Pattern.compile(regex); // 通过模式对象得到匹配器对象 Matcher m = p.matcher(s); // 调用匹配器对象的功能 // 通过find方法就是查找有没有满足条件的子串 // public boolean find() // boolean flag = m.find(); // System.out.println(flag); // // 如何得到值呢? // // public String group() // String ss = m.group(); // System.out.println(ss); // // // 再来一次 // flag = m.find(); // System.out.println(flag); // ss = m.group(); // System.out.println(ss); while (m.find()) &#123; System.out.println(m.group()); &#125; // 注意：一定要先find()，然后才能group() // IllegalStateException: No match found // String ss = m.group(); // System.out.println(ss); &#125;&#125; 5. 正则表达式工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 正则工具类 提供验证邮箱、手机号、电话号码、身份证号码、数字等方法 */public final class RegexUtils &#123; /** * 验证Email * * @param email * email地址，格式：zhangsan@sina.com，zhangsan@xxx.com.cn，xxx代表邮件服务商 * @return 验证成功返回true，验证失败返回false ^ ：匹配输入的开始位置。 \：将下一个字符标记为特殊字符或字面值。 * ：匹配前一个字符零次或几次。 + ：匹配前一个字符一次或多次。 (pattern) 与模式匹配并记住匹配。 x|y：匹配 x 或 * y。 [a-z] ：表示某个范围内的字符。与指定区间内的任何字符匹配。 \w ：与任何单词字符匹配，包括下划线。 * * &#123;n,m&#125; 最少匹配 n 次且最多匹配 m 次 $ ：匹配输入的结尾。 */ public static boolean checkEmail(String email) &#123; String regex = "^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w&#123;2,3&#125;)&#123;1,3&#125;)$"; return Pattern.matches(regex, email); &#125; /** * 验证身份证号码 * * @param idCard * 居民身份证号码15位或18位，最后一位可能是数字或字母 * @return 验证成功返回true，验证失败返回false */ public static boolean checkIdCard(String idCard) &#123; String regex = "[1-9]\\d&#123;13,16&#125;[a-zA-Z0-9]&#123;1&#125;"; return Pattern.matches(regex, idCard); &#125; /** * 验证手机号码（支持国际格式，+86135xxxx...（中国内地），+00852137xxxx...（中国香港）） * * @param mobile * 移动、联通、电信运营商的号码段 * &lt;p&gt; * 移动的号段：134(0-8)、135、136、137、138、139、147（预计用于TD上网卡） * 、150、151、152、157（TD专用）、158、159、187（未启用）、188（TD专用） * &lt;/p&gt; * &lt;p&gt; * 联通的号段：130、131、132、155、156（世界风专用）、185（未启用）、186（3g） * &lt;/p&gt; * &lt;p&gt; * 电信的号段：133、153、180（未启用）、189 * &lt;/p&gt; * &lt;p&gt; * 虚拟运营商的号段：170 * &lt;/p&gt; * @return 验证成功返回true，验证失败返回false */ public static boolean checkMobile(String mobile) &#123; String regex = "(\\+\\d+)?1[34578]\\d&#123;9&#125;$"; return Pattern.matches(regex, mobile); &#125; /** * 验证固定电话号码 * * @param phone * 电话号码，格式：国家（地区）电话代码 + 区号（城市代码） + 电话号码，如：+8602085588447 * &lt;p&gt; * &lt;b&gt;国家（地区） 代码 ：&lt;/b&gt;标识电话号码的国家（地区）的标准国家（地区）代码。它包含从 0 到 9 * 的一位或多位数字， 数字之后是空格分隔的国家（地区）代码。 * &lt;/p&gt; * &lt;p&gt; * &lt;b&gt;区号（城市代码）：&lt;/b&gt;这可能包含一个或多个从 0 到 9 的数字，地区或城市代码放在圆括号—— * 对不使用地区或城市代码的国家（地区），则省略该组件。 * &lt;/p&gt; * &lt;p&gt; * &lt;b&gt;电话号码：&lt;/b&gt;这包含从 0 到 9 的一个或多个数字 * &lt;/p&gt; * @return 验证成功返回true，验证失败返回false */ public static boolean checkPhone(String phone) &#123; // String regex = "(\\+\\d+)?(\\d&#123;3,4&#125;\\-?)?\\d&#123;7,8&#125;$"; String regex = "^1\\d&#123;10&#125;$"; return Pattern.matches(regex, phone); &#125; /** * 验证整数（正整数和负整数） * * @param digit * 一位或多位0-9之间的整数 * @return 验证成功返回true，验证失败返回false */ public static boolean checkDigit(String digit) &#123; String regex = "\\-?[1-9]\\d+"; return Pattern.matches(regex, digit); &#125; /** * 验证整数和浮点数（正负整数和正负浮点数） * * @param decimals * 一位或多位0-9之间的浮点数，如：1.23，233.30 * @return 验证成功返回true，验证失败返回false */ public static boolean checkDecimals(String decimals) &#123; String regex = "\\-?[1-9]\\d+(\\.\\d+)?"; return Pattern.matches(regex, decimals); &#125; /** * 验证空白字符 * * @param blankSpace * 空白字符，包括：空格、\t、\n、\r、\f、\x0B * @return 验证成功返回true，验证失败返回false */ public static boolean checkBlankSpace(String blankSpace) &#123; String regex = "\\s+"; return Pattern.matches(regex, blankSpace); &#125; /** * 验证中文 * * @param chinese * 中文字符 * @return 验证成功返回true，验证失败返回false */ public static boolean checkChinese(String chinese) &#123; String regex = "^[\u4E00-\u9FA5]+$"; return Pattern.matches(regex, chinese); &#125; /** * 验证日期（年月日） * * @param birthday * 日期，格式：1992-09-03，或1992.09.03 * @return 验证成功返回true，验证失败返回false */ public static boolean checkBirthday(String birthday) &#123; String regex = "[1-9]&#123;4&#125;([-./])\\d&#123;1,2&#125;\\1\\d&#123;1,2&#125;"; return Pattern.matches(regex, birthday); &#125; /** * 验证URL地址 * * @param url * 格式：http://blog.csdn.net:80/xyang81/article/details/7705960? 或 * http://www.csdn.net:80 * @return 验证成功返回true，验证失败返回false */ public static boolean checkURL(String url) &#123; String regex = "(https?://(w&#123;3&#125;\\.)?)?\\w+\\.\\w+(\\.[a-zA-Z]+)*(:\\d&#123;1,5&#125;)?(/\\w*)*(\\??(.+=.*)?(&amp;.+=.*)?)?"; return Pattern.matches(regex, url); &#125; /** * 匹配中国邮政编码 * * @param postcode * 邮政编码 * @return 验证成功返回true，验证失败返回false */ public static boolean checkPostcode(String postcode) &#123; String regex = "[1-9]\\d&#123;5&#125;"; return Pattern.matches(regex, postcode); &#125; /** * 匹配IP地址(简单匹配，格式，如：192.168.1.1，127.0.0.1，没有匹配IP段的大小) * * @param ipAddress * IPv4标准地址 * @return 验证成功返回true，验证失败返回false */ public static boolean checkIpAddress(String ipAddress) &#123; String regex = "[1-9](\\d&#123;1,2&#125;)?\\.(0|([1-9](\\d&#123;1,2&#125;)?))\\.(0|([1-9](\\d&#123;1,2&#125;)?))\\.(0|([1-9](\\d&#123;1,2&#125;)?))"; return Pattern.matches(regex, ipAddress); &#125; public static boolean checkNickname(String nickname) &#123; String regex = "^[a-zA-Z0-9\u4E00-\u9FA5_]+$"; return Pattern.matches(regex, nickname); &#125; public static boolean hasCrossSciptRiskInAddress(String str) &#123; String regx = "[`~!@#$%^&amp;*+=|&#123;&#125;':;',\\[\\].&lt;&gt;~！@#￥%……&amp;*——+|&#123;&#125;【】‘；：”“’。，、？-]"; if (str != null) &#123; str = str.trim(); Pattern p = Pattern.compile(regx, Pattern.CASE_INSENSITIVE); Matcher m = p.matcher(str); return m.find(); &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串格式化]]></title>
    <url>%2F2017%2F04%2F30%2Fjava%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[原文出处：http://blog.csdn.net/lonely_fireworks/article/details/7962171/ 相关阅读 Java基础：String类 Java字符串格式化 Java基础：正则表达式 1. 常规类型的格式化String类的format()方法用于创建格式化的字符串以及连接多个字符串对象。熟悉C语言的同学应该记得C语言的sprintf()方法，两者有类似之处。 format()方法有两种重载形式 format(String format, Object… args) 新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。 format(Locale locale, String format, Object… args)使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。 显示不同转换符实现不同数据类型到字符串的转换，如图所示。 转换符 说明 示例 %s 字符串类型 “mingrisoft” %c 字符类型 ‘m’ %b 布尔类型 true %d 整数类型（十进制） 99 %x 整数类型（十六进制） FF %o 整数类型（八进制） 77 %f 浮点类型 99.99 %a 十六进制浮点类型 FF.35AE %e 指数类型 9.38e+5 %g 通用浮点类型（f和e类型中较短的） %h 散列码，Integer.toHexString(arg.hashCode()) %% 百分比类型 ％ %n 换行符 %tx 日期与时间类型（x代表不同的日期与时间转换符 2. 测试用例123456789101112131415161718public static void main(String[] args) &#123; String str=null; str=String.format("Hi,%s", "王力"); System.out.println(str); str=String.format("Hi,%s:%s.%s", "王南","王力","王张"); System.out.println(str); System.out.printf("字母a的大写是：%c %n", 'A'); System.out.printf("3&gt;7的结果是：%b %n", 3&gt;7); System.out.printf("100的一半是：%d %n", 100/2); System.out.printf("100的16进制数是：%x %n", 100); System.out.printf("100的8进制数是：%o %n", 100); System.out.printf("50元的书打8.5折扣是：%f 元%n", 50*0.85); System.out.printf("上面价格的16进制数是：%a %n", 50*0.85); System.out.printf("上面价格的指数表示：%e %n", 50*0.85); System.out.printf("上面价格的指数和浮点数结果的长度较短的是：%g %n", 50*0.85); System.out.printf("上面的折扣是%d%% %n", 85); System.out.printf("字母A的散列码是：%h %n", 'A'); &#125; 输出结果 12345678910111213Hi,王力 Hi,王南:王力.王张 字母a的大写是：A 3&gt;7的结果是：false 100的一半是：50 100的16进制数是：64 100的8进制数是：144 50元的书打8.5折扣是：42.500000 元 上面价格的16进制数是：0x1.54p5 上面价格的指数表示：4.250000e+01 上面价格的指数和浮点数结果的长度较短的是：42.5000 上面的折扣是85% 字母A的散列码是：41 3. 搭配转换符的标志 4. 测试用例12345678910111213141516public static void main(String[] args) &#123; String str=null; //$使用 str=String.format("格式参数$的使用：%1$d,%2$s", 99,"abc"); System.out.println(str); //+使用 System.out.printf("显示正负数的符号：%+d与%d%n", 99,-99); //补O使用 System.out.printf("最牛的编号是：%03d%n", 7); //空格使用 System.out.printf("Tab键的效果是：% 8d%n", 7); //.使用 System.out.printf("整数分组的效果是：%,d%n", 9989997); //空格和小数点后面个数 System.out.printf("一本书的价格是：% 50.5f元%n", 49.8); &#125; 输出结果 123456格式参数$的使用：99,abc 显示正负数的符号：+99与-99 最牛的编号是：007 Tab键的效果是：7 整数分组的效果是：9,989,997 一本书的价格是：49.80000元 5. 日期和事件字符串格式化在程序界面中经常需要显示时间和日期，但是其显示的 格式经常不尽人意，需要编写大量的代码经过各种算法才得到理想的日期与时间格式。字符串格式中还有%tx转换符没有详细介绍，它是专门用来格式化日期和时 间的。%tx转换符中的x代表另外的处理日期和时间格式的转换符，它们的组合能够将日期和时间格式化成多种格式。 常见日期和时间组合的格式，如图所示。| 转换符 | 说明 | 示例 || :— | :——————– | :————————– || c | 包括全部日期和时间信息 | 星期六 十月 27 14:21:20 CST 2007 || F | “年-月-日”格式 | 2007-10-27 || D | “月/日/年”格式 | 10/27/07 || r | “HH:MM:SS PM”格式（12时制） | 02:25:51 下午 || T | “HH:MM:SS”格式（24时制） | 14:28:16 || R | “HH:MM”格式（24时制） | 14:28 | 6. 测试用例123456789101112131415public static void main(String[] args) &#123; Date date=new Date(); //c的使用 System.out.printf("全部日期和时间信息：%tc%n",date); //f的使用 System.out.printf("年-月-日格式：%tF%n",date); //d的使用 System.out.printf("月/日/年格式：%tD%n",date); //r的使用 System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date); //t的使用 System.out.printf("HH:MM:SS格式（24时制）：%tT%n",date); //R的使用 System.out.printf("HH:MM格式（24时制）：%tR",date); &#125; 输出结果123456全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012 年-月-日格式：2012-09-10 月/日/年格式：09/10/12 HH:MM:SS PM格式（12时制）：10:43:36 上午 HH:MM:SS格式（24时制）：10:43:36 HH:MM格式（24时制）：10:43 定义日期格式的转换符可以使日期通过指定的转换符生成新字符串。这些日期转换符如图所示。12345678910111213141516171819202122232425262728public static void main(String[] args) &#123; Date date=new Date(); //b的使用，月份简称 String str=String.format(Locale.US,"英文月份简称：%tb",date); System.out.println(str); System.out.printf("本地月份简称：%tb%n",date); //B的使用，月份全称 str=String.format(Locale.US,"英文月份全称：%tB",date); System.out.println(str); System.out.printf("本地月份全称：%tB%n",date); //a的使用，星期简称 str=String.format(Locale.US,"英文星期的简称：%ta",date); System.out.println(str); //A的使用，星期全称 System.out.printf("本地星期的简称：%tA%n",date); //C的使用，年前两位 System.out.printf("年的前两位数字（不足两位前面补0）：%tC%n",date); //y的使用，年后两位 System.out.printf("年的后两位数字（不足两位前面补0）：%ty%n",date); //j的使用，一年的天数 System.out.printf("一年中的天数（即年的第几天）：%tj%n",date); //m的使用，月份 System.out.printf("两位数字的月份（不足两位前面补0）：%tm%n",date); //d的使用，日（二位，不够补零） System.out.printf("两位数字的日（不足两位前面补0）：%td%n",date); //e的使用，日（一位不补零） System.out.printf("月份的日（前面不补0）：%te",date); &#125; 输出结果 123456789101112英文月份简称：Sep 本地月份简称：九月 英文月份全称：September 本地月份全称：九月 英文星期的简称：Mon 本地星期的简称：星期一 年的前两位数字（不足两位前面补0）：20 年的后两位数字（不足两位前面补0）：12 一年中的天数（即年的第几天）：254 两位数字的月份（不足两位前面补0）：09 两位数字的日（不足两位前面补0）：10 月份的日（前面不补0）：10 和日期格式转换符相比，时间格式的转换符要更多、更精确。它可以将时间格式化成时、分、秒甚至时毫秒等单位。格式化时间字符串的转换符如图所示。 转换符 说明 示例 H 2位数字24时制的小时（不足2位前面补0） 15 I 2位数字12时制的小时（不足2位前面补0） 03 K 2位数字24时制的小时（前面不补0） 15 L 2位数字12时制的小时（前面不补0） 3 M 2位数字的分钟（不足2位前面补0） 03 S 2位数字的秒（不足2位前面补0） 09 L 3位数字的毫秒（不足3位前面补0） 015 N 9位数字的毫秒数（不足9位前面补0） 562000000 p 小写字母的上午或下午标记 中：下午,英：pm z 相对于GMT的RFC822时区的偏移量 +0800 Z 时区缩写字符串 CST S 1970-1-1 00:00:00 到现在所经过的秒数 1193468128 Q 1970-1-1 00:00:00 到现在所经过的毫秒数 1193468128984 7. 测试代码12345678910111213141516171819202122232425262728293031public static void main(String[] args) &#123; Date date = new Date(); //H的使用 System.out.printf("2位数字24时制的小时（不足2位前面补0）:%tH%n", date); //I的使用 System.out.printf("2位数字12时制的小时（不足2位前面补0）:%tI%n", date); //k的使用 System.out.printf("2位数字24时制的小时（前面不补0）:%tk%n", date); //l的使用 System.out.printf("2位数字12时制的小时（前面不补0）:%tl%n", date); //M的使用 System.out.printf("2位数字的分钟（不足2位前面补0）:%tM%n", date); //S的使用 System.out.printf("2位数字的秒（不足2位前面补0）:%tS%n", date); //L的使用 System.out.printf("3位数字的毫秒（不足3位前面补0）:%tL%n", date); //N的使用 System.out.printf("9位数字的毫秒数（不足9位前面补0）:%tN%n", date); //p的使用 String str = String.format(Locale.US, "小写字母的上午或下午标记(英)：%tp", date); System.out.println(str); System.out.printf("小写字母的上午或下午标记（中）：%tp%n", date); //z的使用 System.out.printf("相对于GMT的RFC822时区的偏移量:%tz%n", date); //Z的使用 System.out.printf("时区缩写字符串:%tZ%n", date); //s的使用 System.out.printf("1970-1-1 00:00:00 到现在所经过的秒数：%ts%n", date); //Q的使用 System.out.printf("1970-1-1 00:00:00 到现在所经过的毫秒数：%tQ%n", date); &#125; 输出结果 12345678910111213142位数字24时制的小时（不足2位前面补0）:11 2位数字12时制的小时（不足2位前面补0）:11 2位数字24时制的小时（前面不补0）:11 2位数字12时制的小时（前面不补0）:11 2位数字的分钟（不足2位前面补0）:03 2位数字的秒（不足2位前面补0）:52 3位数字的毫秒（不足3位前面补0）:773 9位数字的毫秒数（不足9位前面补0）:773000000 小写字母的上午或下午标记(英)：am 小写字母的上午或下午标记（中）：上午 相对于GMT的RFC822时区的偏移量:+0800 时区缩写字符串:CST 1970-1-1 00:00:00 到现在所经过的秒数：1347246232 1970-1-1 00:00:00 到现在所经过的毫秒数：1347246232773 8. 在android String resource中使用&amp;#1601&lt;string name="downloaded"&gt;&amp;#160;%s %%&lt;/string&gt; 在显示文本信息时，一句话结束之后需要用空格来分隔两个句子，但是在string.xml中当内容没有在双引号内时空格是没有用的。 要想让string.xml中的字符串显示空格可以用 &amp;#160 ; 来代替空格，但是 &amp;#160 ; 来代替空格时他只是被当做了一个字符并且会和其他的单词组合在一起变成一个新的字符串， 也就是说它是没用分隔符的功能的。 9. Formatterprintf 风格的格式字符串的解释程序。此类提供了对布局对齐和排列的支持，以及对数值、字符串和日期/时间数据的常规格式和特定于语言环境的输出的支持 1234567891011121314151617181920StringBuilder sb = new StringBuilder(); // Send all output to the Appendable object sb Formatter formatter = new Formatter(sb, Locale.US); // Explicit argument indices may be used to re-order output. formatter.format("%4$2s %3$2s %2$2s %1$2s", "a", "b", "c", "d") // -&gt; " d c b a" // Optional locale as the first argument can be used to get // locale-specific formatting of numbers. The precision and width can be // given to round and align the value. formatter.format(Locale.FRANCE, "e = %+10.4f", Math.E); // -&gt; "e = +2,7183" // The '(' numeric flag may be used to format negative numbers with // parentheses rather than a minus sign. Group separators are // automatically inserted. formatter.format("Amount gained or lost since last statement: $ %(,.2f", balanceDelta); // -&gt; "Amount gained or lost since last statement: $ (6,217.58)" 12345678// Writes a formatted string to System.out. System.out.format("Local time: %tT", Calendar.getInstance()); // -&gt; "Local time: 13:34:18" // Writes formatted output to System.err. System.err.printf("Unable to open file '%1$s': %2$s", fileName, exception.getMessage()); // -&gt; "Unable to open file 'food': No such file or directory" 10. 格式字符串语法产生格式化输出的每个方法都需要格式字符串 和参数列表。格式字符串是一个 String，它可以包含固定文本以及一个或多个嵌入的格式说明符 10.1 常规类型、字符类型和数值类型的格式说明符的语法如下1%[argument_index$][flags][width][.precision]conversion 格式说明符 描述 argument_index 可选的argument_index是一个十进制整数，用于表明参数在参数列表中的位置。第一个参数由 “1$” 引用，第二个参数由 “2$” 引用，依此类推 flags 可选 flags 是修改输出格式的字符集。有效标志集取决于转换类型 width 可选 width 是一个非负十进制整数，表明要向输出中写入的最少字符数 precision 可选 precision 是一个非负十进制整数，通常用来限制字符数。特定行为取决于转换类型 conversion 所需 conversion 是一个表明应该如何格式化参数的字符。给定参数的有效转换集取决于参数的数据类型 10.2 转换conversion10.3 日期和时间格式化1%[argument_index$][flags][width]conversion 11. NumberFormat12. MessageFormat1234567/* * 包含了点位符的字符串就是模板！ * 点位符：&#123;0&#125;、&#123;1&#125;、&#123;2&#125; * 可变参数，需要指定模板中的点位符的值！有几个点位符就要提供几个参数 */String s = MessageFormat.format("&#123;0&#125;或&#123;1&#125;错误！", "用户名", "密码");System.out.println(s);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
</search>